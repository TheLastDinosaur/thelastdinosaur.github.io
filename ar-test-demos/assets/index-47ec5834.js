(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const r of i)if(r.type==="childList")for(const a of r.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&s(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const r={};return i.integrity&&(r.integrity=i.integrity),i.referrerPolicy&&(r.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?r.credentials="include":i.crossOrigin==="anonymous"?r.credentials="omit":r.credentials="same-origin",r}function s(i){if(i.ep)return;i.ep=!0;const r=t(i);fetch(i.href,r)}})();/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const Bx="158",GL=0,bT=1,zL=2,o2=1,VL=2,Er=3,Wr=0,Ws=1,Pi=2,Sa=0,Vl=1,xT=2,vT=3,wT=4,WL=5,fo=100,UL=101,BL=102,ST=103,TT=104,$L=200,XL=201,HL=202,KL=203,R0=204,A0=205,ZL=206,YL=207,jL=208,QL=209,JL=210,qL=211,e3=212,t3=213,n3=214,s3=0,i3=1,r3=2,Ff=3,a3=4,o3=5,l3=6,c3=7,l2=0,u3=1,h3=2,Ta=0,d3=1,p3=2,f3=3,m3=4,g3=5,_T="attached",y3="detached",c2=300,Yl=301,jl=302,Of=303,L0=304,Cm=306,Na=1e3,Os=1001,Gf=1002,$n=1003,P0=1004,Nf=1005,An=1006,u2=1007,Ra=1008,_a=1009,b3=1010,x3=1011,$x=1012,h2=1013,ga=1014,yi=1015,Dr=1016,d2=1017,p2=1018,So=1020,v3=1021,mi=1023,w3=1024,S3=1025,To=1026,Ql=1027,T3=1028,f2=1029,_3=1030,m2=1031,g2=1033,cb=33776,ub=33777,hb=33778,db=33779,IT=35840,MT=35841,CT=35842,ET=35843,I3=36196,kT=37492,NT=37496,RT=37808,AT=37809,LT=37810,PT=37811,DT=37812,FT=37813,OT=37814,GT=37815,zT=37816,VT=37817,WT=37818,UT=37819,BT=37820,$T=37821,pb=36492,XT=36494,HT=36495,M3=36283,KT=36284,ZT=36285,YT=36286,C3=2200,y2=2201,E3=2202,wh=2300,Jl=2301,fb=2302,Dl=2400,Fl=2401,zf=2402,Xx=2500,k3=2501,N3=0,b2=1,D0=2,x2=3e3,Ia=3001,R3=3200,A3=3201,v2=0,L3=1,gi="",an="srgb",Kn="srgb-linear",Hx="display-p3",Em="display-p3-linear",Vf="linear",qt="srgb",Wf="rec709",Uf="p3",dl=7680,jT=519,P3=512,D3=513,F3=514,O3=515,G3=516,z3=517,V3=518,W3=519,F0=35044,QT="300 es",O0=1035,Fr=2e3,Bf=2001;class Zo{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const s=this._listeners;s[e]===void 0&&(s[e]=[]),s[e].indexOf(t)===-1&&s[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const s=this._listeners;return s[e]!==void 0&&s[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const r=i.indexOf(t);r!==-1&&i.splice(r,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const s=this._listeners[e.type];if(s!==void 0){e.target=this;const i=s.slice(0);for(let r=0,a=i.length;r<a;r++)i[r].call(this,e);e.target=null}}}const as=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let JT=1234567;const gh=Math.PI/180,ql=180/Math.PI;function Fi(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,s=Math.random()*4294967295|0;return(as[n&255]+as[n>>8&255]+as[n>>16&255]+as[n>>24&255]+"-"+as[e&255]+as[e>>8&255]+"-"+as[e>>16&15|64]+as[e>>24&255]+"-"+as[t&63|128]+as[t>>8&255]+"-"+as[t>>16&255]+as[t>>24&255]+as[s&255]+as[s>>8&255]+as[s>>16&255]+as[s>>24&255]).toLowerCase()}function ts(n,e,t){return Math.max(e,Math.min(t,n))}function Kx(n,e){return(n%e+e)%e}function U3(n,e,t,s,i){return s+(n-e)*(i-s)/(t-e)}function B3(n,e,t){return n!==e?(t-n)/(e-n):0}function yh(n,e,t){return(1-t)*n+t*e}function $3(n,e,t,s){return yh(n,e,1-Math.exp(-t*s))}function X3(n,e=1){return e-Math.abs(Kx(n,e*2)-e)}function H3(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function K3(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function Z3(n,e){return n+Math.floor(Math.random()*(e-n+1))}function Y3(n,e){return n+Math.random()*(e-n)}function j3(n){return n*(.5-Math.random())}function Q3(n){n!==void 0&&(JT=n);let e=JT+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function J3(n){return n*gh}function q3(n){return n*ql}function G0(n){return(n&n-1)===0&&n!==0}function w2(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function $f(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function eP(n,e,t,s,i){const r=Math.cos,a=Math.sin,o=r(t/2),l=a(t/2),c=r((e+s)/2),u=a((e+s)/2),h=r((e-s)/2),d=a((e-s)/2),p=r((s-e)/2),f=a((s-e)/2);switch(i){case"XYX":n.set(o*u,l*h,l*d,o*c);break;case"YZY":n.set(l*d,o*u,l*h,o*c);break;case"ZXZ":n.set(l*h,l*d,o*u,o*c);break;case"XZX":n.set(o*u,l*f,l*p,o*c);break;case"YXY":n.set(l*p,o*u,l*f,o*c);break;case"ZYZ":n.set(l*f,l*p,o*u,o*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function sr(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Wt(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const tP={DEG2RAD:gh,RAD2DEG:ql,generateUUID:Fi,clamp:ts,euclideanModulo:Kx,mapLinear:U3,inverseLerp:B3,lerp:yh,damp:$3,pingpong:X3,smoothstep:H3,smootherstep:K3,randInt:Z3,randFloat:Y3,randFloatSpread:j3,seededRandom:Q3,degToRad:J3,radToDeg:q3,isPowerOfTwo:G0,ceilPowerOfTwo:w2,floorPowerOfTwo:$f,setQuaternionFromProperEuler:eP,normalize:Wt,denormalize:sr};class Rt{constructor(e=0,t=0){Rt.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,s=this.y,i=e.elements;return this.x=i[0]*t+i[3]*s+i[6],this.y=i[1]*t+i[4]*s+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(ts(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y;return t*t+s*s}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const s=Math.cos(t),i=Math.sin(t),r=this.x-e.x,a=this.y-e.y;return this.x=r*s-a*i+e.x,this.y=r*i+a*s+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class wt{constructor(e,t,s,i,r,a,o,l,c){wt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,a,o,l,c)}set(e,t,s,i,r,a,o,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=o,u[3]=t,u[4]=r,u[5]=l,u[6]=s,u[7]=a,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],this}extractBasis(e,t,s){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),s.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,a=s[0],o=s[3],l=s[6],c=s[1],u=s[4],h=s[7],d=s[2],p=s[5],f=s[8],y=i[0],m=i[3],g=i[6],b=i[1],x=i[4],v=i[7],w=i[2],_=i[5],I=i[8];return r[0]=a*y+o*b+l*w,r[3]=a*m+o*x+l*_,r[6]=a*g+o*v+l*I,r[1]=c*y+u*b+h*w,r[4]=c*m+u*x+h*_,r[7]=c*g+u*v+h*I,r[2]=d*y+p*b+f*w,r[5]=d*m+p*x+f*_,r[8]=d*g+p*v+f*I,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8];return t*a*u-t*o*c-s*r*u+s*o*l+i*r*c-i*a*l}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=u*a-o*c,d=o*l-u*r,p=c*r-a*l,f=t*h+s*d+i*p;if(f===0)return this.set(0,0,0,0,0,0,0,0,0);const y=1/f;return e[0]=h*y,e[1]=(i*c-u*s)*y,e[2]=(o*s-i*a)*y,e[3]=d*y,e[4]=(u*t-i*l)*y,e[5]=(i*r-o*t)*y,e[6]=p*y,e[7]=(s*l-c*t)*y,e[8]=(a*t-s*r)*y,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,s,i,r,a,o){const l=Math.cos(r),c=Math.sin(r);return this.set(s*l,s*c,-s*(l*a+c*o)+a+e,-i*c,i*l,-i*(-c*a+l*o)+o+t,0,0,1),this}scale(e,t){return this.premultiply(mb.makeScale(e,t)),this}rotate(e){return this.premultiply(mb.makeRotation(-e)),this}translate(e,t){return this.premultiply(mb.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,s,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<9;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<9;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const mb=new wt;function S2(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function Sh(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function nP(){const n=Sh("canvas");return n.style.display="block",n}const qT={};function bh(n){n in qT||(qT[n]=!0,console.warn(n))}const e_=new wt().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),t_=new wt().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Lp={[Kn]:{transfer:Vf,primaries:Wf,toReference:n=>n,fromReference:n=>n},[an]:{transfer:qt,primaries:Wf,toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[Em]:{transfer:Vf,primaries:Uf,toReference:n=>n.applyMatrix3(t_),fromReference:n=>n.applyMatrix3(e_)},[Hx]:{transfer:qt,primaries:Uf,toReference:n=>n.convertSRGBToLinear().applyMatrix3(t_),fromReference:n=>n.applyMatrix3(e_).convertLinearToSRGB()}},sP=new Set([Kn,Em]),Pt={enabled:!0,_workingColorSpace:Kn,get legacyMode(){return console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),!this.enabled},set legacyMode(n){console.warn("THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."),this.enabled=!n},get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!sP.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const s=Lp[e].toReference,i=Lp[t].fromReference;return i(s(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return Lp[n].primaries},getTransfer:function(n){return n===gi?Vf:Lp[n].transfer}};function Wl(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function gb(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let pl;class T2{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{pl===void 0&&(pl=Sh("canvas")),pl.width=e.width,pl.height=e.height;const s=pl.getContext("2d");e instanceof ImageData?s.putImageData(e,0,0):s.drawImage(e,0,0,e.width,e.height),t=pl}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=Sh("canvas");t.width=e.width,t.height=e.height;const s=t.getContext("2d");s.drawImage(e,0,0,e.width,e.height);const i=s.getImageData(0,0,e.width,e.height),r=i.data;for(let a=0;a<r.length;a++)r[a]=Wl(r[a]/255)*255;return s.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let s=0;s<t.length;s++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[s]=Math.floor(Wl(t[s]/255)*255):t[s]=Wl(t[s]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let iP=0;class _2{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:iP++}),this.uuid=Fi(),this.data=e,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const s={uuid:this.uuid,url:""},i=this.data;if(i!==null){let r;if(Array.isArray(i)){r=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?r.push(yb(i[a].image)):r.push(yb(i[a]))}else r=yb(i);s.url=r}return t||(e.images[this.uuid]=s),s}}function yb(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?T2.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let rP=0;class is extends Zo{constructor(e=is.DEFAULT_IMAGE,t=is.DEFAULT_MAPPING,s=Os,i=Os,r=An,a=Ra,o=mi,l=_a,c=is.DEFAULT_ANISOTROPY,u=gi){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:rP++}),this.uuid=Fi(),this.name="",this.source=new _2(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=s,this.wrapT=i,this.magFilter=r,this.minFilter=a,this.anisotropy=c,this.format=o,this.internalFormat=null,this.type=l,this.offset=new Rt(0,0),this.repeat=new Rt(1,1),this.center=new Rt(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new wt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,typeof u=="string"?this.colorSpace=u:(bh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=u===Ia?an:gi),this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.needsPMREMUpdate=!1}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const s={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(s.userData=this.userData),t||(e.textures[this.uuid]=s),s}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==c2)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Na:e.x=e.x-Math.floor(e.x);break;case Os:e.x=e.x<0?0:1;break;case Gf:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Na:e.y=e.y-Math.floor(e.y);break;case Os:e.y=e.y<0?0:1;break;case Gf:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}get encoding(){return bh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace===an?Ia:x2}set encoding(e){bh("THREE.Texture: Property .encoding has been replaced by .colorSpace."),this.colorSpace=e===Ia?an:gi}}is.DEFAULT_IMAGE=null;is.DEFAULT_MAPPING=c2;is.DEFAULT_ANISOTROPY=1;class Xt{constructor(e=0,t=0,s=0,i=1){Xt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=s,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=this.w,a=e.elements;return this.x=a[0]*t+a[4]*s+a[8]*i+a[12]*r,this.y=a[1]*t+a[5]*s+a[9]*i+a[13]*r,this.z=a[2]*t+a[6]*s+a[10]*i+a[14]*r,this.w=a[3]*t+a[7]*s+a[11]*i+a[15]*r,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,s,i,r;const l=e.elements,c=l[0],u=l[4],h=l[8],d=l[1],p=l[5],f=l[9],y=l[2],m=l[6],g=l[10];if(Math.abs(u-d)<.01&&Math.abs(h-y)<.01&&Math.abs(f-m)<.01){if(Math.abs(u+d)<.1&&Math.abs(h+y)<.1&&Math.abs(f+m)<.1&&Math.abs(c+p+g-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const x=(c+1)/2,v=(p+1)/2,w=(g+1)/2,_=(u+d)/4,I=(h+y)/4,C=(f+m)/4;return x>v&&x>w?x<.01?(s=0,i=.707106781,r=.707106781):(s=Math.sqrt(x),i=_/s,r=I/s):v>w?v<.01?(s=.707106781,i=0,r=.707106781):(i=Math.sqrt(v),s=_/i,r=C/i):w<.01?(s=.707106781,i=.707106781,r=0):(r=Math.sqrt(w),s=I/r,i=C/r),this.set(s,i,r,t),this}let b=Math.sqrt((m-f)*(m-f)+(h-y)*(h-y)+(d-u)*(d-u));return Math.abs(b)<.001&&(b=1),this.x=(m-f)/b,this.y=(h-y)/b,this.z=(d-u)/b,this.w=Math.acos((c+p+g-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this.w=e.w+(t.w-e.w)*s,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class aP extends Zo{constructor(e=1,t=1,s={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Xt(0,0,e,t),this.scissorTest=!1,this.viewport=new Xt(0,0,e,t);const i={width:e,height:t,depth:1};s.encoding!==void 0&&(bh("THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."),s.colorSpace=s.encoding===Ia?an:gi),s=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:An,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0},s),this.texture=new is(i,s.mapping,s.wrapS,s.wrapT,s.magFilter,s.minFilter,s.format,s.type,s.anisotropy,s.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.flipY=!1,this.texture.generateMipmaps=s.generateMipmaps,this.texture.internalFormat=s.internalFormat,this.depthBuffer=s.depthBuffer,this.stencilBuffer=s.stencilBuffer,this.depthTexture=s.depthTexture,this.samples=s.samples}setSize(e,t,s=1){(this.width!==e||this.height!==t||this.depth!==s)&&(this.width=e,this.height=t,this.depth=s,this.texture.image.width=e,this.texture.image.height=t,this.texture.image.depth=s,this.dispose()),this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.texture=e.texture.clone(),this.texture.isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new _2(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class ko extends aP{constructor(e=1,t=1,s={}){super(e,t,s),this.isWebGLRenderTarget=!0}}class I2 extends is{constructor(e=null,t=1,s=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=$n,this.minFilter=$n,this.wrapR=Os,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class oP extends is{constructor(e=null,t=1,s=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:s,depth:i},this.magFilter=$n,this.minFilter=$n,this.wrapR=Os,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Is{constructor(e=0,t=0,s=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=s,this._w=i}static slerpFlat(e,t,s,i,r,a,o){let l=s[i+0],c=s[i+1],u=s[i+2],h=s[i+3];const d=r[a+0],p=r[a+1],f=r[a+2],y=r[a+3];if(o===0){e[t+0]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h;return}if(o===1){e[t+0]=d,e[t+1]=p,e[t+2]=f,e[t+3]=y;return}if(h!==y||l!==d||c!==p||u!==f){let m=1-o;const g=l*d+c*p+u*f+h*y,b=g>=0?1:-1,x=1-g*g;if(x>Number.EPSILON){const w=Math.sqrt(x),_=Math.atan2(w,g*b);m=Math.sin(m*_)/w,o=Math.sin(o*_)/w}const v=o*b;if(l=l*m+d*v,c=c*m+p*v,u=u*m+f*v,h=h*m+y*v,m===1-o){const w=1/Math.sqrt(l*l+c*c+u*u+h*h);l*=w,c*=w,u*=w,h*=w}}e[t]=l,e[t+1]=c,e[t+2]=u,e[t+3]=h}static multiplyQuaternionsFlat(e,t,s,i,r,a){const o=s[i],l=s[i+1],c=s[i+2],u=s[i+3],h=r[a],d=r[a+1],p=r[a+2],f=r[a+3];return e[t]=o*f+u*h+l*p-c*d,e[t+1]=l*f+u*d+c*h-o*p,e[t+2]=c*f+u*p+o*d-l*h,e[t+3]=u*f-o*h-l*d-c*p,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,s,i){return this._x=e,this._y=t,this._z=s,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t){const s=e._x,i=e._y,r=e._z,a=e._order,o=Math.cos,l=Math.sin,c=o(s/2),u=o(i/2),h=o(r/2),d=l(s/2),p=l(i/2),f=l(r/2);switch(a){case"XYZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"YXZ":this._x=d*u*h+c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"ZXY":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h-d*p*f;break;case"ZYX":this._x=d*u*h-c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h+d*p*f;break;case"YZX":this._x=d*u*h+c*p*f,this._y=c*p*h+d*u*f,this._z=c*u*f-d*p*h,this._w=c*u*h-d*p*f;break;case"XZY":this._x=d*u*h-c*p*f,this._y=c*p*h-d*u*f,this._z=c*u*f+d*p*h,this._w=c*u*h+d*p*f;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t!==!1&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const s=t/2,i=Math.sin(s);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(s),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,s=t[0],i=t[4],r=t[8],a=t[1],o=t[5],l=t[9],c=t[2],u=t[6],h=t[10],d=s+o+h;if(d>0){const p=.5/Math.sqrt(d+1);this._w=.25/p,this._x=(u-l)*p,this._y=(r-c)*p,this._z=(a-i)*p}else if(s>o&&s>h){const p=2*Math.sqrt(1+s-o-h);this._w=(u-l)/p,this._x=.25*p,this._y=(i+a)/p,this._z=(r+c)/p}else if(o>h){const p=2*Math.sqrt(1+o-s-h);this._w=(r-c)/p,this._x=(i+a)/p,this._y=.25*p,this._z=(l+u)/p}else{const p=2*Math.sqrt(1+h-s-o);this._w=(a-i)/p,this._x=(r+c)/p,this._y=(l+u)/p,this._z=.25*p}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let s=e.dot(t)+1;return s<Number.EPSILON?(s=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=s):(this._x=0,this._y=-e.z,this._z=e.y,this._w=s)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=s),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(ts(this.dot(e),-1,1)))}rotateTowards(e,t){const s=this.angleTo(e);if(s===0)return this;const i=Math.min(1,t/s);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const s=e._x,i=e._y,r=e._z,a=e._w,o=t._x,l=t._y,c=t._z,u=t._w;return this._x=s*u+a*o+i*c-r*l,this._y=i*u+a*l+r*o-s*c,this._z=r*u+a*c+s*l-i*o,this._w=a*u-s*o-i*l-r*c,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const s=this._x,i=this._y,r=this._z,a=this._w;let o=a*e._w+s*e._x+i*e._y+r*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=s,this._y=i,this._z=r,this;const l=1-o*o;if(l<=Number.EPSILON){const p=1-t;return this._w=p*a+t*this._w,this._x=p*s+t*this._x,this._y=p*i+t*this._y,this._z=p*r+t*this._z,this.normalize(),this._onChangeCallback(),this}const c=Math.sqrt(l),u=Math.atan2(c,o),h=Math.sin((1-t)*u)/c,d=Math.sin(t*u)/c;return this._w=a*h+this._w*d,this._x=s*h+this._x*d,this._y=i*h+this._y*d,this._z=r*h+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,s){return this.copy(e).slerp(t,s)}random(){const e=Math.random(),t=Math.sqrt(1-e),s=Math.sqrt(e),i=2*Math.PI*Math.random(),r=2*Math.PI*Math.random();return this.set(t*Math.cos(i),s*Math.sin(r),s*Math.cos(r),t*Math.sin(i))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class J{constructor(e=0,t=0,s=0){J.prototype.isVector3=!0,this.x=e,this.y=t,this.z=s}set(e,t,s){return s===void 0&&(s=this.z),this.x=e,this.y=t,this.z=s,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(n_.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(n_.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[3]*s+r[6]*i,this.y=r[1]*t+r[4]*s+r[7]*i,this.z=r[2]*t+r[5]*s+r[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,s=this.y,i=this.z,r=e.elements,a=1/(r[3]*t+r[7]*s+r[11]*i+r[15]);return this.x=(r[0]*t+r[4]*s+r[8]*i+r[12])*a,this.y=(r[1]*t+r[5]*s+r[9]*i+r[13])*a,this.z=(r[2]*t+r[6]*s+r[10]*i+r[14])*a,this}applyQuaternion(e){const t=this.x,s=this.y,i=this.z,r=e.x,a=e.y,o=e.z,l=e.w,c=2*(a*i-o*s),u=2*(o*t-r*i),h=2*(r*s-a*t);return this.x=t+l*c+a*h-o*u,this.y=s+l*u+o*c-r*h,this.z=i+l*h+r*u-a*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,s=this.y,i=this.z,r=e.elements;return this.x=r[0]*t+r[4]*s+r[8]*i,this.y=r[1]*t+r[5]*s+r[9]*i,this.z=r[2]*t+r[6]*s+r[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const s=this.length();return this.divideScalar(s||1).multiplyScalar(Math.max(e,Math.min(t,s)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,s){return this.x=e.x+(t.x-e.x)*s,this.y=e.y+(t.y-e.y)*s,this.z=e.z+(t.z-e.z)*s,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const s=e.x,i=e.y,r=e.z,a=t.x,o=t.y,l=t.z;return this.x=i*l-r*o,this.y=r*a-s*l,this.z=s*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const s=e.dot(this)/t;return this.copy(e).multiplyScalar(s)}projectOnPlane(e){return bb.copy(this).projectOnVector(e),this.sub(bb)}reflect(e){return this.sub(bb.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const s=this.dot(e)/t;return Math.acos(ts(s,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,s=this.y-e.y,i=this.z-e.z;return t*t+s*s+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,s){const i=Math.sin(t)*e;return this.x=i*Math.sin(s),this.y=Math.cos(t)*e,this.z=i*Math.cos(s),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,s){return this.x=e*Math.sin(t),this.y=s,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),s=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=s,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=(Math.random()-.5)*2,t=Math.random()*Math.PI*2,s=Math.sqrt(1-e**2);return this.x=s*Math.cos(t),this.y=s*Math.sin(t),this.z=e,this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const bb=new J,n_=new Is;class jr{constructor(e=new J(1/0,1/0,1/0),t=new J(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t+=3)this.expandByPoint(Ci.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,s=e.count;t<s;t++)this.expandByPoint(Ci.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,s=e.length;t<s;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const s=Ci.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(s),this.max.copy(e).add(s),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const s=e.geometry;if(s!==void 0){const r=s.getAttribute("position");if(t===!0&&r!==void 0&&e.isInstancedMesh!==!0)for(let a=0,o=r.count;a<o;a++)e.isMesh===!0?e.getVertexPosition(a,Ci):Ci.fromBufferAttribute(r,a),Ci.applyMatrix4(e.matrixWorld),this.expandByPoint(Ci);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),Pp.copy(e.boundingBox)):(s.boundingBox===null&&s.computeBoundingBox(),Pp.copy(s.boundingBox)),Pp.applyMatrix4(e.matrixWorld),this.union(Pp)}const i=e.children;for(let r=0,a=i.length;r<a;r++)this.expandByObject(i[r],t);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Ci),Ci.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,s;return e.normal.x>0?(t=e.normal.x*this.min.x,s=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,s=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,s+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,s+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,s+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,s+=e.normal.z*this.min.z),t<=-e.constant&&s>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Ku),Dp.subVectors(this.max,Ku),fl.subVectors(e.a,Ku),ml.subVectors(e.b,Ku),gl.subVectors(e.c,Ku),aa.subVectors(ml,fl),oa.subVectors(gl,ml),qa.subVectors(fl,gl);let t=[0,-aa.z,aa.y,0,-oa.z,oa.y,0,-qa.z,qa.y,aa.z,0,-aa.x,oa.z,0,-oa.x,qa.z,0,-qa.x,-aa.y,aa.x,0,-oa.y,oa.x,0,-qa.y,qa.x,0];return!xb(t,fl,ml,gl,Dp)||(t=[1,0,0,0,1,0,0,0,1],!xb(t,fl,ml,gl,Dp))?!1:(Fp.crossVectors(aa,oa),t=[Fp.x,Fp.y,Fp.z],xb(t,fl,ml,gl,Dp))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Ci).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Ci).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Sr[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Sr[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Sr[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Sr[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Sr[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Sr[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Sr[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Sr[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Sr),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Sr=[new J,new J,new J,new J,new J,new J,new J,new J],Ci=new J,Pp=new jr,fl=new J,ml=new J,gl=new J,aa=new J,oa=new J,qa=new J,Ku=new J,Dp=new J,Fp=new J,eo=new J;function xb(n,e,t,s,i){for(let r=0,a=n.length-3;r<=a;r+=3){eo.fromArray(n,r);const o=i.x*Math.abs(eo.x)+i.y*Math.abs(eo.y)+i.z*Math.abs(eo.z),l=e.dot(eo),c=t.dot(eo),u=s.dot(eo);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>o)return!1}return!0}const lP=new jr,Zu=new J,vb=new J;class yr{constructor(e=new J,t=-1){this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const s=this.center;t!==void 0?s.copy(t):lP.setFromPoints(e).getCenter(s);let i=0;for(let r=0,a=e.length;r<a;r++)i=Math.max(i,s.distanceToSquared(e[r]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const s=this.center.distanceToSquared(e);return t.copy(e),s>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;Zu.subVectors(e,this.center);const t=Zu.lengthSq();if(t>this.radius*this.radius){const s=Math.sqrt(t),i=(s-this.radius)*.5;this.center.addScaledVector(Zu,i/s),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(vb.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(Zu.copy(e.center).add(vb)),this.expandByPoint(Zu.copy(e.center).sub(vb))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Tr=new J,wb=new J,Op=new J,la=new J,Sb=new J,Gp=new J,Tb=new J;class km{constructor(e=new J,t=new J(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Tr)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const s=t.dot(this.direction);return s<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,s)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Tr.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Tr.copy(this.origin).addScaledVector(this.direction,t),Tr.distanceToSquared(e))}distanceSqToSegment(e,t,s,i){wb.copy(e).add(t).multiplyScalar(.5),Op.copy(t).sub(e).normalize(),la.copy(this.origin).sub(wb);const r=e.distanceTo(t)*.5,a=-this.direction.dot(Op),o=la.dot(this.direction),l=-la.dot(Op),c=la.lengthSq(),u=Math.abs(1-a*a);let h,d,p,f;if(u>0)if(h=a*l-o,d=a*o-l,f=r*u,h>=0)if(d>=-f)if(d<=f){const y=1/u;h*=y,d*=y,p=h*(h+a*d+2*o)+d*(a*h+d+2*l)+c}else d=r,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*l)+c;else d=-r,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*l)+c;else d<=-f?(h=Math.max(0,-(-a*r+o)),d=h>0?-r:Math.min(Math.max(-r,-l),r),p=-h*h+d*(d+2*l)+c):d<=f?(h=0,d=Math.min(Math.max(-r,-l),r),p=d*(d+2*l)+c):(h=Math.max(0,-(a*r+o)),d=h>0?r:Math.min(Math.max(-r,-l),r),p=-h*h+d*(d+2*l)+c);else d=a>0?-r:r,h=Math.max(0,-(a*d+o)),p=-h*h+d*(d+2*l)+c;return s&&s.copy(this.origin).addScaledVector(this.direction,h),i&&i.copy(wb).addScaledVector(Op,d),p}intersectSphere(e,t){Tr.subVectors(e.center,this.origin);const s=Tr.dot(this.direction),i=Tr.dot(Tr)-s*s,r=e.radius*e.radius;if(i>r)return null;const a=Math.sqrt(r-i),o=s-a,l=s+a;return l<0?null:o<0?this.at(l,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const s=-(this.origin.dot(e.normal)+e.constant)/t;return s>=0?s:null}intersectPlane(e,t){const s=this.distanceToPlane(e);return s===null?null:this.at(s,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let s,i,r,a,o,l;const c=1/this.direction.x,u=1/this.direction.y,h=1/this.direction.z,d=this.origin;return c>=0?(s=(e.min.x-d.x)*c,i=(e.max.x-d.x)*c):(s=(e.max.x-d.x)*c,i=(e.min.x-d.x)*c),u>=0?(r=(e.min.y-d.y)*u,a=(e.max.y-d.y)*u):(r=(e.max.y-d.y)*u,a=(e.min.y-d.y)*u),s>a||r>i||((r>s||isNaN(s))&&(s=r),(a<i||isNaN(i))&&(i=a),h>=0?(o=(e.min.z-d.z)*h,l=(e.max.z-d.z)*h):(o=(e.max.z-d.z)*h,l=(e.min.z-d.z)*h),s>l||o>i)||((o>s||s!==s)&&(s=o),(l<i||i!==i)&&(i=l),i<0)?null:this.at(s>=0?s:i,t)}intersectsBox(e){return this.intersectBox(e,Tr)!==null}intersectTriangle(e,t,s,i,r){Sb.subVectors(t,e),Gp.subVectors(s,e),Tb.crossVectors(Sb,Gp);let a=this.direction.dot(Tb),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;la.subVectors(this.origin,e);const l=o*this.direction.dot(Gp.crossVectors(la,Gp));if(l<0)return null;const c=o*this.direction.dot(Sb.cross(la));if(c<0||l+c>a)return null;const u=-o*la.dot(Tb);return u<0?null:this.at(u/a,r)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class ot{constructor(e,t,s,i,r,a,o,l,c,u,h,d,p,f,y,m){ot.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,s,i,r,a,o,l,c,u,h,d,p,f,y,m)}set(e,t,s,i,r,a,o,l,c,u,h,d,p,f,y,m){const g=this.elements;return g[0]=e,g[4]=t,g[8]=s,g[12]=i,g[1]=r,g[5]=a,g[9]=o,g[13]=l,g[2]=c,g[6]=u,g[10]=h,g[14]=d,g[3]=p,g[7]=f,g[11]=y,g[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new ot().fromArray(this.elements)}copy(e){const t=this.elements,s=e.elements;return t[0]=s[0],t[1]=s[1],t[2]=s[2],t[3]=s[3],t[4]=s[4],t[5]=s[5],t[6]=s[6],t[7]=s[7],t[8]=s[8],t[9]=s[9],t[10]=s[10],t[11]=s[11],t[12]=s[12],t[13]=s[13],t[14]=s[14],t[15]=s[15],this}copyPosition(e){const t=this.elements,s=e.elements;return t[12]=s[12],t[13]=s[13],t[14]=s[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,s){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),s.setFromMatrixColumn(this,2),this}makeBasis(e,t,s){return this.set(e.x,t.x,s.x,0,e.y,t.y,s.y,0,e.z,t.z,s.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,s=e.elements,i=1/yl.setFromMatrixColumn(e,0).length(),r=1/yl.setFromMatrixColumn(e,1).length(),a=1/yl.setFromMatrixColumn(e,2).length();return t[0]=s[0]*i,t[1]=s[1]*i,t[2]=s[2]*i,t[3]=0,t[4]=s[4]*r,t[5]=s[5]*r,t[6]=s[6]*r,t[7]=0,t[8]=s[8]*a,t[9]=s[9]*a,t[10]=s[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,s=e.x,i=e.y,r=e.z,a=Math.cos(s),o=Math.sin(s),l=Math.cos(i),c=Math.sin(i),u=Math.cos(r),h=Math.sin(r);if(e.order==="XYZ"){const d=a*u,p=a*h,f=o*u,y=o*h;t[0]=l*u,t[4]=-l*h,t[8]=c,t[1]=p+f*c,t[5]=d-y*c,t[9]=-o*l,t[2]=y-d*c,t[6]=f+p*c,t[10]=a*l}else if(e.order==="YXZ"){const d=l*u,p=l*h,f=c*u,y=c*h;t[0]=d+y*o,t[4]=f*o-p,t[8]=a*c,t[1]=a*h,t[5]=a*u,t[9]=-o,t[2]=p*o-f,t[6]=y+d*o,t[10]=a*l}else if(e.order==="ZXY"){const d=l*u,p=l*h,f=c*u,y=c*h;t[0]=d-y*o,t[4]=-a*h,t[8]=f+p*o,t[1]=p+f*o,t[5]=a*u,t[9]=y-d*o,t[2]=-a*c,t[6]=o,t[10]=a*l}else if(e.order==="ZYX"){const d=a*u,p=a*h,f=o*u,y=o*h;t[0]=l*u,t[4]=f*c-p,t[8]=d*c+y,t[1]=l*h,t[5]=y*c+d,t[9]=p*c-f,t[2]=-c,t[6]=o*l,t[10]=a*l}else if(e.order==="YZX"){const d=a*l,p=a*c,f=o*l,y=o*c;t[0]=l*u,t[4]=y-d*h,t[8]=f*h+p,t[1]=h,t[5]=a*u,t[9]=-o*u,t[2]=-c*u,t[6]=p*h+f,t[10]=d-y*h}else if(e.order==="XZY"){const d=a*l,p=a*c,f=o*l,y=o*c;t[0]=l*u,t[4]=-h,t[8]=c*u,t[1]=d*h+y,t[5]=a*u,t[9]=p*h-f,t[2]=f*h-p,t[6]=o*u,t[10]=y*h+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(cP,e,uP)}lookAt(e,t,s){const i=this.elements;return Qs.subVectors(e,t),Qs.lengthSq()===0&&(Qs.z=1),Qs.normalize(),ca.crossVectors(s,Qs),ca.lengthSq()===0&&(Math.abs(s.z)===1?Qs.x+=1e-4:Qs.z+=1e-4,Qs.normalize(),ca.crossVectors(s,Qs)),ca.normalize(),zp.crossVectors(Qs,ca),i[0]=ca.x,i[4]=zp.x,i[8]=Qs.x,i[1]=ca.y,i[5]=zp.y,i[9]=Qs.y,i[2]=ca.z,i[6]=zp.z,i[10]=Qs.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const s=e.elements,i=t.elements,r=this.elements,a=s[0],o=s[4],l=s[8],c=s[12],u=s[1],h=s[5],d=s[9],p=s[13],f=s[2],y=s[6],m=s[10],g=s[14],b=s[3],x=s[7],v=s[11],w=s[15],_=i[0],I=i[4],C=i[8],S=i[12],M=i[1],A=i[5],D=i[9],F=i[13],k=i[2],P=i[6],O=i[10],V=i[14],$=i[3],H=i[7],Y=i[11],G=i[15];return r[0]=a*_+o*M+l*k+c*$,r[4]=a*I+o*A+l*P+c*H,r[8]=a*C+o*D+l*O+c*Y,r[12]=a*S+o*F+l*V+c*G,r[1]=u*_+h*M+d*k+p*$,r[5]=u*I+h*A+d*P+p*H,r[9]=u*C+h*D+d*O+p*Y,r[13]=u*S+h*F+d*V+p*G,r[2]=f*_+y*M+m*k+g*$,r[6]=f*I+y*A+m*P+g*H,r[10]=f*C+y*D+m*O+g*Y,r[14]=f*S+y*F+m*V+g*G,r[3]=b*_+x*M+v*k+w*$,r[7]=b*I+x*A+v*P+w*H,r[11]=b*C+x*D+v*O+w*Y,r[15]=b*S+x*F+v*V+w*G,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],s=e[4],i=e[8],r=e[12],a=e[1],o=e[5],l=e[9],c=e[13],u=e[2],h=e[6],d=e[10],p=e[14],f=e[3],y=e[7],m=e[11],g=e[15];return f*(+r*l*h-i*c*h-r*o*d+s*c*d+i*o*p-s*l*p)+y*(+t*l*p-t*c*d+r*a*d-i*a*p+i*c*u-r*l*u)+m*(+t*c*h-t*o*p-r*a*h+s*a*p+r*o*u-s*c*u)+g*(-i*o*u-t*l*h+t*o*d+i*a*h-s*a*d+s*l*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,s){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=s),this}invert(){const e=this.elements,t=e[0],s=e[1],i=e[2],r=e[3],a=e[4],o=e[5],l=e[6],c=e[7],u=e[8],h=e[9],d=e[10],p=e[11],f=e[12],y=e[13],m=e[14],g=e[15],b=h*m*c-y*d*c+y*l*p-o*m*p-h*l*g+o*d*g,x=f*d*c-u*m*c-f*l*p+a*m*p+u*l*g-a*d*g,v=u*y*c-f*h*c+f*o*p-a*y*p-u*o*g+a*h*g,w=f*h*l-u*y*l-f*o*d+a*y*d+u*o*m-a*h*m,_=t*b+s*x+i*v+r*w;if(_===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const I=1/_;return e[0]=b*I,e[1]=(y*d*r-h*m*r-y*i*p+s*m*p+h*i*g-s*d*g)*I,e[2]=(o*m*r-y*l*r+y*i*c-s*m*c-o*i*g+s*l*g)*I,e[3]=(h*l*r-o*d*r-h*i*c+s*d*c+o*i*p-s*l*p)*I,e[4]=x*I,e[5]=(u*m*r-f*d*r+f*i*p-t*m*p-u*i*g+t*d*g)*I,e[6]=(f*l*r-a*m*r-f*i*c+t*m*c+a*i*g-t*l*g)*I,e[7]=(a*d*r-u*l*r+u*i*c-t*d*c-a*i*p+t*l*p)*I,e[8]=v*I,e[9]=(f*h*r-u*y*r-f*s*p+t*y*p+u*s*g-t*h*g)*I,e[10]=(a*y*r-f*o*r+f*s*c-t*y*c-a*s*g+t*o*g)*I,e[11]=(u*o*r-a*h*r-u*s*c+t*h*c+a*s*p-t*o*p)*I,e[12]=w*I,e[13]=(u*y*i-f*h*i+f*s*d-t*y*d-u*s*m+t*h*m)*I,e[14]=(f*o*i-a*y*i-f*s*l+t*y*l+a*s*m-t*o*m)*I,e[15]=(a*h*i-u*o*i+u*s*l-t*h*l-a*s*d+t*o*d)*I,this}scale(e){const t=this.elements,s=e.x,i=e.y,r=e.z;return t[0]*=s,t[4]*=i,t[8]*=r,t[1]*=s,t[5]*=i,t[9]*=r,t[2]*=s,t[6]*=i,t[10]*=r,t[3]*=s,t[7]*=i,t[11]*=r,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],s=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,s,i))}makeTranslation(e,t,s){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,s,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),s=Math.sin(e);return this.set(1,0,0,0,0,t,-s,0,0,s,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,0,s,0,0,1,0,0,-s,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),s=Math.sin(e);return this.set(t,-s,0,0,s,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const s=Math.cos(t),i=Math.sin(t),r=1-s,a=e.x,o=e.y,l=e.z,c=r*a,u=r*o;return this.set(c*a+s,c*o-i*l,c*l+i*o,0,c*o+i*l,u*o+s,u*l-i*a,0,c*l-i*o,u*l+i*a,r*l*l+s,0,0,0,0,1),this}makeScale(e,t,s){return this.set(e,0,0,0,0,t,0,0,0,0,s,0,0,0,0,1),this}makeShear(e,t,s,i,r,a){return this.set(1,s,r,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,s){const i=this.elements,r=t._x,a=t._y,o=t._z,l=t._w,c=r+r,u=a+a,h=o+o,d=r*c,p=r*u,f=r*h,y=a*u,m=a*h,g=o*h,b=l*c,x=l*u,v=l*h,w=s.x,_=s.y,I=s.z;return i[0]=(1-(y+g))*w,i[1]=(p+v)*w,i[2]=(f-x)*w,i[3]=0,i[4]=(p-v)*_,i[5]=(1-(d+g))*_,i[6]=(m+b)*_,i[7]=0,i[8]=(f+x)*I,i[9]=(m-b)*I,i[10]=(1-(d+y))*I,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,s){const i=this.elements;let r=yl.set(i[0],i[1],i[2]).length();const a=yl.set(i[4],i[5],i[6]).length(),o=yl.set(i[8],i[9],i[10]).length();this.determinant()<0&&(r=-r),e.x=i[12],e.y=i[13],e.z=i[14],Ei.copy(this);const c=1/r,u=1/a,h=1/o;return Ei.elements[0]*=c,Ei.elements[1]*=c,Ei.elements[2]*=c,Ei.elements[4]*=u,Ei.elements[5]*=u,Ei.elements[6]*=u,Ei.elements[8]*=h,Ei.elements[9]*=h,Ei.elements[10]*=h,t.setFromRotationMatrix(Ei),s.x=r,s.y=a,s.z=o,this}makePerspective(e,t,s,i,r,a,o=Fr){const l=this.elements,c=2*r/(t-e),u=2*r/(s-i),h=(t+e)/(t-e),d=(s+i)/(s-i);let p,f;if(o===Fr)p=-(a+r)/(a-r),f=-2*a*r/(a-r);else if(o===Bf)p=-a/(a-r),f=-a*r/(a-r);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return l[0]=c,l[4]=0,l[8]=h,l[12]=0,l[1]=0,l[5]=u,l[9]=d,l[13]=0,l[2]=0,l[6]=0,l[10]=p,l[14]=f,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,t,s,i,r,a,o=Fr){const l=this.elements,c=1/(t-e),u=1/(s-i),h=1/(a-r),d=(t+e)*c,p=(s+i)*u;let f,y;if(o===Fr)f=(a+r)*h,y=-2*h;else if(o===Bf)f=r*h,y=-1*h;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-d,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-p,l[2]=0,l[6]=0,l[10]=y,l[14]=-f,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const t=this.elements,s=e.elements;for(let i=0;i<16;i++)if(t[i]!==s[i])return!1;return!0}fromArray(e,t=0){for(let s=0;s<16;s++)this.elements[s]=e[s+t];return this}toArray(e=[],t=0){const s=this.elements;return e[t]=s[0],e[t+1]=s[1],e[t+2]=s[2],e[t+3]=s[3],e[t+4]=s[4],e[t+5]=s[5],e[t+6]=s[6],e[t+7]=s[7],e[t+8]=s[8],e[t+9]=s[9],e[t+10]=s[10],e[t+11]=s[11],e[t+12]=s[12],e[t+13]=s[13],e[t+14]=s[14],e[t+15]=s[15],e}}const yl=new J,Ei=new ot,cP=new J(0,0,0),uP=new J(1,1,1),ca=new J,zp=new J,Qs=new J,s_=new ot,i_=new Is;class Nm{constructor(e=0,t=0,s=0,i=Nm.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=s,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,s,i=this._order){return this._x=e,this._y=t,this._z=s,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,s=!0){const i=e.elements,r=i[0],a=i[4],o=i[8],l=i[1],c=i[5],u=i[9],h=i[2],d=i[6],p=i[10];switch(t){case"XYZ":this._y=Math.asin(ts(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,p),this._z=Math.atan2(-a,r)):(this._x=Math.atan2(d,c),this._z=0);break;case"YXZ":this._x=Math.asin(-ts(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,p),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-h,r),this._z=0);break;case"ZXY":this._x=Math.asin(ts(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-h,p),this._z=Math.atan2(-a,c)):(this._y=0,this._z=Math.atan2(l,r));break;case"ZYX":this._y=Math.asin(-ts(h,-1,1)),Math.abs(h)<.9999999?(this._x=Math.atan2(d,p),this._z=Math.atan2(l,r)):(this._x=0,this._z=Math.atan2(-a,c));break;case"YZX":this._z=Math.asin(ts(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-h,r)):(this._x=0,this._y=Math.atan2(o,p));break;case"XZY":this._z=Math.asin(-ts(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,c),this._y=Math.atan2(o,r)):(this._x=Math.atan2(-u,p),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,s===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,s){return s_.makeRotationFromQuaternion(e),this.setFromRotationMatrix(s_,t,s)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return i_.setFromEuler(this),this.setFromQuaternion(i_,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Nm.DEFAULT_ORDER="XYZ";class M2{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let hP=0;const r_=new J,bl=new Is,_r=new ot,Vp=new J,Yu=new J,dP=new J,pP=new Is,a_=new J(1,0,0),o_=new J(0,1,0),l_=new J(0,0,1),fP={type:"added"},mP={type:"removed"};class nn extends Zo{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:hP++}),this.uuid=Fi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=nn.DEFAULT_UP.clone();const e=new J,t=new Nm,s=new Is,i=new J(1,1,1);function r(){s.setFromEuler(t,!1)}function a(){t.setFromQuaternion(s,void 0,!1)}t._onChange(r),s._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:s},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new ot},normalMatrix:{value:new wt}}),this.matrix=new ot,this.matrixWorld=new ot,this.matrixAutoUpdate=nn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.matrixWorldAutoUpdate=nn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.layers=new M2,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return bl.setFromAxisAngle(e,t),this.quaternion.multiply(bl),this}rotateOnWorldAxis(e,t){return bl.setFromAxisAngle(e,t),this.quaternion.premultiply(bl),this}rotateX(e){return this.rotateOnAxis(a_,e)}rotateY(e){return this.rotateOnAxis(o_,e)}rotateZ(e){return this.rotateOnAxis(l_,e)}translateOnAxis(e,t){return r_.copy(e).applyQuaternion(this.quaternion),this.position.add(r_.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(a_,e)}translateY(e){return this.translateOnAxis(o_,e)}translateZ(e){return this.translateOnAxis(l_,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(_r.copy(this.matrixWorld).invert())}lookAt(e,t,s){e.isVector3?Vp.copy(e):Vp.set(e,t,s);const i=this.parent;this.updateWorldMatrix(!0,!1),Yu.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_r.lookAt(Yu,Vp,this.up):_r.lookAt(Vp,Yu,this.up),this.quaternion.setFromRotationMatrix(_r),i&&(_r.extractRotation(i.matrixWorld),bl.setFromRotationMatrix(_r),this.quaternion.premultiply(bl.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.parent!==null&&e.parent.remove(e),e.parent=this,this.children.push(e),e.dispatchEvent(fP)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let s=0;s<arguments.length;s++)this.remove(arguments[s]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(mP)),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),_r.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),_r.multiply(e.parent.matrixWorld)),e.applyMatrix4(_r),this.add(e),e.updateWorldMatrix(!1,!0),this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let s=0,i=this.children.length;s<i;s++){const a=this.children[s].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t){let s=[];this[e]===t&&s.push(this);for(let i=0,r=this.children.length;i<r;i++){const a=this.children[i].getObjectsByProperty(e,t);a.length>0&&(s=s.concat(a))}return s}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yu,e,dP),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yu,pP,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let s=0,i=t.length;s<i;s++)t[s].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let s=0,i=t.length;s<i;s++){const r=t[s];(r.matrixWorldAutoUpdate===!0||e===!0)&&r.updateMatrixWorld(e)}}updateWorldMatrix(e,t){const s=this.parent;if(e===!0&&s!==null&&s.matrixWorldAutoUpdate===!0&&s.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),t===!0){const i=this.children;for(let r=0,a=i.length;r<a;r++){const o=i[r];o.matrixWorldAutoUpdate===!0&&o.updateWorldMatrix(!1,!0)}}}toJSON(e){const t=e===void 0||typeof e=="string",s={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},s.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON()));function r(o,l){return o[l.uuid]===void 0&&(o[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=r(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const l=o.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const h=l[c];r(e.shapes,h)}else r(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(r(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let l=0,c=this.material.length;l<c;l++)o.push(r(e.materials,this.material[l]));i.material=o}else i.material=r(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const l=this.animations[o];i.animations.push(r(e.animations,l))}}if(t){const o=a(e.geometries),l=a(e.materials),c=a(e.textures),u=a(e.images),h=a(e.shapes),d=a(e.skeletons),p=a(e.animations),f=a(e.nodes);o.length>0&&(s.geometries=o),l.length>0&&(s.materials=l),c.length>0&&(s.textures=c),u.length>0&&(s.images=u),h.length>0&&(s.shapes=h),d.length>0&&(s.skeletons=d),p.length>0&&(s.animations=p),f.length>0&&(s.nodes=f)}return s.object=i,s;function a(o){const l=[];for(const c in o){const u=o[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let s=0;s<e.children.length;s++){const i=e.children[s];this.add(i.clone())}return this}}nn.DEFAULT_UP=new J(0,1,0);nn.DEFAULT_MATRIX_AUTO_UPDATE=!0;nn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const ki=new J,Ir=new J,_b=new J,Mr=new J,xl=new J,vl=new J,c_=new J,Ib=new J,Mb=new J,Cb=new J;let Wp=!1;class Ri{constructor(e=new J,t=new J,s=new J){this.a=e,this.b=t,this.c=s}static getNormal(e,t,s,i){i.subVectors(s,t),ki.subVectors(e,t),i.cross(ki);const r=i.lengthSq();return r>0?i.multiplyScalar(1/Math.sqrt(r)):i.set(0,0,0)}static getBarycoord(e,t,s,i,r){ki.subVectors(i,t),Ir.subVectors(s,t),_b.subVectors(e,t);const a=ki.dot(ki),o=ki.dot(Ir),l=ki.dot(_b),c=Ir.dot(Ir),u=Ir.dot(_b),h=a*c-o*o;if(h===0)return r.set(-2,-1,-1);const d=1/h,p=(c*l-o*u)*d,f=(a*u-o*l)*d;return r.set(1-p-f,f,p)}static containsPoint(e,t,s,i){return this.getBarycoord(e,t,s,i,Mr),Mr.x>=0&&Mr.y>=0&&Mr.x+Mr.y<=1}static getUV(e,t,s,i,r,a,o,l){return Wp===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Wp=!0),this.getInterpolation(e,t,s,i,r,a,o,l)}static getInterpolation(e,t,s,i,r,a,o,l){return this.getBarycoord(e,t,s,i,Mr),l.setScalar(0),l.addScaledVector(r,Mr.x),l.addScaledVector(a,Mr.y),l.addScaledVector(o,Mr.z),l}static isFrontFacing(e,t,s,i){return ki.subVectors(s,t),Ir.subVectors(e,t),ki.cross(Ir).dot(i)<0}set(e,t,s){return this.a.copy(e),this.b.copy(t),this.c.copy(s),this}setFromPointsAndIndices(e,t,s,i){return this.a.copy(e[t]),this.b.copy(e[s]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,s,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,s),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return ki.subVectors(this.c,this.b),Ir.subVectors(this.a,this.b),ki.cross(Ir).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ri.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Ri.getBarycoord(e,this.a,this.b,this.c,t)}getUV(e,t,s,i,r){return Wp===!1&&(console.warn("THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."),Wp=!0),Ri.getInterpolation(e,this.a,this.b,this.c,t,s,i,r)}getInterpolation(e,t,s,i,r){return Ri.getInterpolation(e,this.a,this.b,this.c,t,s,i,r)}containsPoint(e){return Ri.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ri.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const s=this.a,i=this.b,r=this.c;let a,o;xl.subVectors(i,s),vl.subVectors(r,s),Ib.subVectors(e,s);const l=xl.dot(Ib),c=vl.dot(Ib);if(l<=0&&c<=0)return t.copy(s);Mb.subVectors(e,i);const u=xl.dot(Mb),h=vl.dot(Mb);if(u>=0&&h<=u)return t.copy(i);const d=l*h-u*c;if(d<=0&&l>=0&&u<=0)return a=l/(l-u),t.copy(s).addScaledVector(xl,a);Cb.subVectors(e,r);const p=xl.dot(Cb),f=vl.dot(Cb);if(f>=0&&p<=f)return t.copy(r);const y=p*c-l*f;if(y<=0&&c>=0&&f<=0)return o=c/(c-f),t.copy(s).addScaledVector(vl,o);const m=u*f-p*h;if(m<=0&&h-u>=0&&p-f>=0)return c_.subVectors(r,i),o=(h-u)/(h-u+(p-f)),t.copy(i).addScaledVector(c_,o);const g=1/(m+y+d);return a=y*g,o=d*g,t.copy(s).addScaledVector(xl,a).addScaledVector(vl,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const C2={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ua={h:0,s:0,l:0},Up={h:0,s:0,l:0};function Eb(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class lt{constructor(e,t,s){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,s)}set(e,t,s){if(t===void 0&&s===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,s);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=an){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Pt.toWorkingColorSpace(this,t),this}setRGB(e,t,s,i=Pt.workingColorSpace){return this.r=e,this.g=t,this.b=s,Pt.toWorkingColorSpace(this,i),this}setHSL(e,t,s,i=Pt.workingColorSpace){if(e=Kx(e,1),t=ts(t,0,1),s=ts(s,0,1),t===0)this.r=this.g=this.b=s;else{const r=s<=.5?s*(1+t):s+t-s*t,a=2*s-r;this.r=Eb(a,r,e+1/3),this.g=Eb(a,r,e),this.b=Eb(a,r,e-1/3)}return Pt.toWorkingColorSpace(this,i),this}setStyle(e,t=an){function s(r){r!==void 0&&parseFloat(r)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let r;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(r=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setRGB(Math.min(255,parseInt(r[1],10))/255,Math.min(255,parseInt(r[2],10))/255,Math.min(255,parseInt(r[3],10))/255,t);if(r=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setRGB(Math.min(100,parseInt(r[1],10))/100,Math.min(100,parseInt(r[2],10))/100,Math.min(100,parseInt(r[3],10))/100,t);break;case"hsl":case"hsla":if(r=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return s(r[4]),this.setHSL(parseFloat(r[1])/360,parseFloat(r[2])/100,parseFloat(r[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const r=i[1],a=r.length;if(a===3)return this.setRGB(parseInt(r.charAt(0),16)/15,parseInt(r.charAt(1),16)/15,parseInt(r.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(r,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=an){const s=C2[e.toLowerCase()];return s!==void 0?this.setHex(s,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=Wl(e.r),this.g=Wl(e.g),this.b=Wl(e.b),this}copyLinearToSRGB(e){return this.r=gb(e.r),this.g=gb(e.g),this.b=gb(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=an){return Pt.fromWorkingColorSpace(os.copy(this),e),Math.round(ts(os.r*255,0,255))*65536+Math.round(ts(os.g*255,0,255))*256+Math.round(ts(os.b*255,0,255))}getHexString(e=an){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Pt.workingColorSpace){Pt.fromWorkingColorSpace(os.copy(this),t);const s=os.r,i=os.g,r=os.b,a=Math.max(s,i,r),o=Math.min(s,i,r);let l,c;const u=(o+a)/2;if(o===a)l=0,c=0;else{const h=a-o;switch(c=u<=.5?h/(a+o):h/(2-a-o),a){case s:l=(i-r)/h+(i<r?6:0);break;case i:l=(r-s)/h+2;break;case r:l=(s-i)/h+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,t=Pt.workingColorSpace){return Pt.fromWorkingColorSpace(os.copy(this),t),e.r=os.r,e.g=os.g,e.b=os.b,e}getStyle(e=an){Pt.fromWorkingColorSpace(os.copy(this),e);const t=os.r,s=os.g,i=os.b;return e!==an?`color(${e} ${t.toFixed(3)} ${s.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(s*255)},${Math.round(i*255)})`}offsetHSL(e,t,s){return this.getHSL(ua),this.setHSL(ua.h+e,ua.s+t,ua.l+s)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,s){return this.r=e.r+(t.r-e.r)*s,this.g=e.g+(t.g-e.g)*s,this.b=e.b+(t.b-e.b)*s,this}lerpHSL(e,t){this.getHSL(ua),e.getHSL(Up);const s=yh(ua.h,Up.h,t),i=yh(ua.s,Up.s,t),r=yh(ua.l,Up.l,t);return this.setHSL(s,i,r),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,s=this.g,i=this.b,r=e.elements;return this.r=r[0]*t+r[3]*s+r[6]*i,this.g=r[1]*t+r[4]*s+r[7]*i,this.b=r[2]*t+r[5]*s+r[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const os=new lt;lt.NAMES=C2;let gP=0;class lr extends Zo{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:gP++}),this.uuid=Fi(),this.name="",this.type="Material",this.blending=Vl,this.side=Wr,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=R0,this.blendDst=A0,this.blendEquation=fo,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new lt(0,0,0),this.blendAlpha=0,this.depthFunc=Ff,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=jT,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=dl,this.stencilZFail=dl,this.stencilZPass=dl,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const s=e[t];if(s===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(s):i&&i.isVector3&&s&&s.isVector3?i.copy(s):this[t]=s}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const s={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};s.uuid=this.uuid,s.type=this.type,this.name!==""&&(s.name=this.name),this.color&&this.color.isColor&&(s.color=this.color.getHex()),this.roughness!==void 0&&(s.roughness=this.roughness),this.metalness!==void 0&&(s.metalness=this.metalness),this.sheen!==void 0&&(s.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(s.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(s.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(s.emissive=this.emissive.getHex()),this.emissiveIntensity&&this.emissiveIntensity!==1&&(s.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(s.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(s.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(s.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(s.shininess=this.shininess),this.clearcoat!==void 0&&(s.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(s.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(s.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(s.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(s.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,s.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(s.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(s.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(s.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(s.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(s.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(s.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(s.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(s.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(s.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(s.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(s.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(s.lightMap=this.lightMap.toJSON(e).uuid,s.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(s.aoMap=this.aoMap.toJSON(e).uuid,s.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(s.bumpMap=this.bumpMap.toJSON(e).uuid,s.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(s.normalMap=this.normalMap.toJSON(e).uuid,s.normalMapType=this.normalMapType,s.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(s.displacementMap=this.displacementMap.toJSON(e).uuid,s.displacementScale=this.displacementScale,s.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(s.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(s.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(s.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(s.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(s.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(s.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(s.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(s.combine=this.combine)),this.envMapIntensity!==void 0&&(s.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(s.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(s.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(s.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(s.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(s.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(s.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(s.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(s.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(s.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(s.size=this.size),this.shadowSide!==null&&(s.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(s.sizeAttenuation=this.sizeAttenuation),this.blending!==Vl&&(s.blending=this.blending),this.side!==Wr&&(s.side=this.side),this.vertexColors===!0&&(s.vertexColors=!0),this.opacity<1&&(s.opacity=this.opacity),this.transparent===!0&&(s.transparent=!0),this.blendSrc!==R0&&(s.blendSrc=this.blendSrc),this.blendDst!==A0&&(s.blendDst=this.blendDst),this.blendEquation!==fo&&(s.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(s.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(s.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(s.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(s.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(s.blendAlpha=this.blendAlpha),this.depthFunc!==Ff&&(s.depthFunc=this.depthFunc),this.depthTest===!1&&(s.depthTest=this.depthTest),this.depthWrite===!1&&(s.depthWrite=this.depthWrite),this.colorWrite===!1&&(s.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(s.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==jT&&(s.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(s.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(s.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==dl&&(s.stencilFail=this.stencilFail),this.stencilZFail!==dl&&(s.stencilZFail=this.stencilZFail),this.stencilZPass!==dl&&(s.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(s.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(s.rotation=this.rotation),this.polygonOffset===!0&&(s.polygonOffset=!0),this.polygonOffsetFactor!==0&&(s.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(s.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(s.linewidth=this.linewidth),this.dashSize!==void 0&&(s.dashSize=this.dashSize),this.gapSize!==void 0&&(s.gapSize=this.gapSize),this.scale!==void 0&&(s.scale=this.scale),this.dithering===!0&&(s.dithering=!0),this.alphaTest>0&&(s.alphaTest=this.alphaTest),this.alphaHash===!0&&(s.alphaHash=!0),this.alphaToCoverage===!0&&(s.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(s.premultipliedAlpha=!0),this.forceSinglePass===!0&&(s.forceSinglePass=!0),this.wireframe===!0&&(s.wireframe=!0),this.wireframeLinewidth>1&&(s.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(s.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(s.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(s.flatShading=!0),this.visible===!1&&(s.visible=!1),this.toneMapped===!1&&(s.toneMapped=!1),this.fog===!1&&(s.fog=!1),Object.keys(this.userData).length>0&&(s.userData=this.userData);function i(r){const a=[];for(const o in r){const l=r[o];delete l.metadata,a.push(l)}return a}if(t){const r=i(e.textures),a=i(e.images);r.length>0&&(s.textures=r),a.length>0&&(s.images=a)}return s}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let s=null;if(t!==null){const i=t.length;s=new Array(i);for(let r=0;r!==i;++r)s[r]=t[r].clone()}return this.clippingPlanes=s,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class ya extends lr{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new lt(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.combine=l2,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Ar=yP();function yP(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),s=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(s[l]=0,s[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(s[l]=1024>>-c-14,s[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(s[l]=c+15<<10,s[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(s[l]=31744,s[l|256]=64512,i[l]=24,i[l|256]=24):(s[l]=31744,s[l|256]=64512,i[l]=13,i[l|256]=13)}const r=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,u=0;for(;!(c&8388608);)c<<=1,u-=8388608;c&=-8388609,u+=947912704,r[l]=c|u}for(let l=1024;l<2048;++l)r[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)a[l]=l<<23;a[31]=1199570944,a[32]=2147483648;for(let l=33;l<63;++l)a[l]=2147483648+(l-32<<23);a[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(o[l]=1024);return{floatView:e,uint32View:t,baseTable:s,shiftTable:i,mantissaTable:r,exponentTable:a,offsetTable:o}}function bP(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=ts(n,-65504,65504),Ar.floatView[0]=n;const e=Ar.uint32View[0],t=e>>23&511;return Ar.baseTable[t]+((e&8388607)>>Ar.shiftTable[t])}function xP(n){const e=n>>10;return Ar.uint32View[0]=Ar.mantissaTable[Ar.offsetTable[e]+(n&1023)]+Ar.exponentTable[e],Ar.floatView[0]}const Bp={toHalfFloat:bP,fromHalfFloat:xP},Mn=new J,$p=new Rt;class Ms{constructor(e,t,s=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=s,this.usage=F0,this.updateRange={offset:0,count:-1},this.gpuType=yi,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,s){e*=this.itemSize,s*=t.itemSize;for(let i=0,r=this.itemSize;i<r;i++)this.array[e+i]=t.array[s+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,s=this.count;t<s;t++)$p.fromBufferAttribute(this,t),$p.applyMatrix3(e),this.setXY(t,$p.x,$p.y);else if(this.itemSize===3)for(let t=0,s=this.count;t<s;t++)Mn.fromBufferAttribute(this,t),Mn.applyMatrix3(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}applyMatrix4(e){for(let t=0,s=this.count;t<s;t++)Mn.fromBufferAttribute(this,t),Mn.applyMatrix4(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)Mn.fromBufferAttribute(this,t),Mn.applyNormalMatrix(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)Mn.fromBufferAttribute(this,t),Mn.transformDirection(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let s=this.array[e*this.itemSize+t];return this.normalized&&(s=sr(s,this.array)),s}setComponent(e,t,s){return this.normalized&&(s=Wt(s,this.array)),this.array[e*this.itemSize+t]=s,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=sr(t,this.array)),t}setX(e,t){return this.normalized&&(t=Wt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=sr(t,this.array)),t}setY(e,t){return this.normalized&&(t=Wt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=sr(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Wt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=sr(t,this.array)),t}setW(e,t){return this.normalized&&(t=Wt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,s){return e*=this.itemSize,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array)),this.array[e+0]=t,this.array[e+1]=s,this}setXYZ(e,t,s,i){return e*=this.itemSize,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array),i=Wt(i,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e*=this.itemSize,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array),i=Wt(i,this.array),r=Wt(r,this.array)),this.array[e+0]=t,this.array[e+1]=s,this.array[e+2]=i,this.array[e+3]=r,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==F0&&(e.usage=this.usage),(this.updateRange.offset!==0||this.updateRange.count!==-1)&&(e.updateRange=this.updateRange),e}}class E2 extends Ms{constructor(e,t,s){super(new Uint16Array(e),t,s)}}class k2 extends Ms{constructor(e,t,s){super(new Uint32Array(e),t,s)}}class zr extends Ms{constructor(e,t,s){super(new Float32Array(e),t,s)}}let vP=0;const ci=new ot,kb=new nn,wl=new J,Js=new jr,ju=new jr,Bn=new J;class br extends Zo{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:vP++}),this.uuid=Fi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(S2(e)?k2:E2)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,s=0){this.groups.push({start:e,count:t,materialIndex:s})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const s=this.attributes.normal;if(s!==void 0){const r=new wt().getNormalMatrix(e);s.applyNormalMatrix(r),s.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return ci.makeRotationFromQuaternion(e),this.applyMatrix4(ci),this}rotateX(e){return ci.makeRotationX(e),this.applyMatrix4(ci),this}rotateY(e){return ci.makeRotationY(e),this.applyMatrix4(ci),this}rotateZ(e){return ci.makeRotationZ(e),this.applyMatrix4(ci),this}translate(e,t,s){return ci.makeTranslation(e,t,s),this.applyMatrix4(ci),this}scale(e,t,s){return ci.makeScale(e,t,s),this.applyMatrix4(ci),this}lookAt(e){return kb.lookAt(e),kb.updateMatrix(),this.applyMatrix4(kb.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(wl).negate(),this.translate(wl.x,wl.y,wl.z),this}setFromPoints(e){const t=[];for(let s=0,i=e.length;s<i;s++){const r=e[s];t.push(r.x,r.y,r.z||0)}return this.setAttribute("position",new zr(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new jr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new J(-1/0,-1/0,-1/0),new J(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let s=0,i=t.length;s<i;s++){const r=t[s];Js.setFromBufferAttribute(r),this.morphTargetsRelative?(Bn.addVectors(this.boundingBox.min,Js.min),this.boundingBox.expandByPoint(Bn),Bn.addVectors(this.boundingBox.max,Js.max),this.boundingBox.expandByPoint(Bn)):(this.boundingBox.expandByPoint(Js.min),this.boundingBox.expandByPoint(Js.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new yr);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new J,1/0);return}if(e){const s=this.boundingSphere.center;if(Js.setFromBufferAttribute(e),t)for(let r=0,a=t.length;r<a;r++){const o=t[r];ju.setFromBufferAttribute(o),this.morphTargetsRelative?(Bn.addVectors(Js.min,ju.min),Js.expandByPoint(Bn),Bn.addVectors(Js.max,ju.max),Js.expandByPoint(Bn)):(Js.expandByPoint(ju.min),Js.expandByPoint(ju.max))}Js.getCenter(s);let i=0;for(let r=0,a=e.count;r<a;r++)Bn.fromBufferAttribute(e,r),i=Math.max(i,s.distanceToSquared(Bn));if(t)for(let r=0,a=t.length;r<a;r++){const o=t[r],l=this.morphTargetsRelative;for(let c=0,u=o.count;c<u;c++)Bn.fromBufferAttribute(o,c),l&&(wl.fromBufferAttribute(e,c),Bn.add(wl)),i=Math.max(i,s.distanceToSquared(Bn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const s=e.array,i=t.position.array,r=t.normal.array,a=t.uv.array,o=i.length/3;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Ms(new Float32Array(4*o),4));const l=this.getAttribute("tangent").array,c=[],u=[];for(let M=0;M<o;M++)c[M]=new J,u[M]=new J;const h=new J,d=new J,p=new J,f=new Rt,y=new Rt,m=new Rt,g=new J,b=new J;function x(M,A,D){h.fromArray(i,M*3),d.fromArray(i,A*3),p.fromArray(i,D*3),f.fromArray(a,M*2),y.fromArray(a,A*2),m.fromArray(a,D*2),d.sub(h),p.sub(h),y.sub(f),m.sub(f);const F=1/(y.x*m.y-m.x*y.y);isFinite(F)&&(g.copy(d).multiplyScalar(m.y).addScaledVector(p,-y.y).multiplyScalar(F),b.copy(p).multiplyScalar(y.x).addScaledVector(d,-m.x).multiplyScalar(F),c[M].add(g),c[A].add(g),c[D].add(g),u[M].add(b),u[A].add(b),u[D].add(b))}let v=this.groups;v.length===0&&(v=[{start:0,count:s.length}]);for(let M=0,A=v.length;M<A;++M){const D=v[M],F=D.start,k=D.count;for(let P=F,O=F+k;P<O;P+=3)x(s[P+0],s[P+1],s[P+2])}const w=new J,_=new J,I=new J,C=new J;function S(M){I.fromArray(r,M*3),C.copy(I);const A=c[M];w.copy(A),w.sub(I.multiplyScalar(I.dot(A))).normalize(),_.crossVectors(C,A);const F=_.dot(u[M])<0?-1:1;l[M*4]=w.x,l[M*4+1]=w.y,l[M*4+2]=w.z,l[M*4+3]=F}for(let M=0,A=v.length;M<A;++M){const D=v[M],F=D.start,k=D.count;for(let P=F,O=F+k;P<O;P+=3)S(s[P+0]),S(s[P+1]),S(s[P+2])}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let s=this.getAttribute("normal");if(s===void 0)s=new Ms(new Float32Array(t.count*3),3),this.setAttribute("normal",s);else for(let d=0,p=s.count;d<p;d++)s.setXYZ(d,0,0,0);const i=new J,r=new J,a=new J,o=new J,l=new J,c=new J,u=new J,h=new J;if(e)for(let d=0,p=e.count;d<p;d+=3){const f=e.getX(d+0),y=e.getX(d+1),m=e.getX(d+2);i.fromBufferAttribute(t,f),r.fromBufferAttribute(t,y),a.fromBufferAttribute(t,m),u.subVectors(a,r),h.subVectors(i,r),u.cross(h),o.fromBufferAttribute(s,f),l.fromBufferAttribute(s,y),c.fromBufferAttribute(s,m),o.add(u),l.add(u),c.add(u),s.setXYZ(f,o.x,o.y,o.z),s.setXYZ(y,l.x,l.y,l.z),s.setXYZ(m,c.x,c.y,c.z)}else for(let d=0,p=t.count;d<p;d+=3)i.fromBufferAttribute(t,d+0),r.fromBufferAttribute(t,d+1),a.fromBufferAttribute(t,d+2),u.subVectors(a,r),h.subVectors(i,r),u.cross(h),s.setXYZ(d+0,u.x,u.y,u.z),s.setXYZ(d+1,u.x,u.y,u.z),s.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),s.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,s=e.count;t<s;t++)Bn.fromBufferAttribute(e,t),Bn.normalize(),e.setXYZ(t,Bn.x,Bn.y,Bn.z)}toNonIndexed(){function e(o,l){const c=o.array,u=o.itemSize,h=o.normalized,d=new c.constructor(l.length*u);let p=0,f=0;for(let y=0,m=l.length;y<m;y++){o.isInterleavedBufferAttribute?p=l[y]*o.data.stride+o.offset:p=l[y]*u;for(let g=0;g<u;g++)d[f++]=c[p++]}return new Ms(d,u,h)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new br,s=this.index.array,i=this.attributes;for(const o in i){const l=i[o],c=e(l,s);t.setAttribute(o,c)}const r=this.morphAttributes;for(const o in r){const l=[],c=r[o];for(let u=0,h=c.length;u<h;u++){const d=c[u],p=e(d,s);l.push(p)}t.morphAttributes[o]=l}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,l=a.length;o<l;o++){const c=a[o];t.addGroup(c.start,c.count,c.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const s=this.attributes;for(const l in s){const c=s[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let r=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let h=0,d=c.length;h<d;h++){const p=c[h];u.push(p.toJSON(e.data))}u.length>0&&(i[l]=u,r=!0)}r&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const s=e.index;s!==null&&this.setIndex(s.clone(t));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(t))}const r=e.morphAttributes;for(const c in r){const u=[],h=r[c];for(let d=0,p=h.length;d<p;d++)u.push(h[d].clone(t));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let c=0,u=a.length;c<u;c++){const h=a[c];this.addGroup(h.start,h.count,h.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const u_=new ot,to=new km,Xp=new yr,h_=new J,Sl=new J,Tl=new J,_l=new J,Nb=new J,Hp=new J,Kp=new Rt,Zp=new Rt,Yp=new Rt,d_=new J,p_=new J,f_=new J,jp=new J,Qp=new J;class bi extends nn{constructor(e=new br,t=new ya){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}getVertexPosition(e,t){const s=this.geometry,i=s.attributes.position,r=s.morphAttributes.position,a=s.morphTargetsRelative;t.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(r&&o){Hp.set(0,0,0);for(let l=0,c=r.length;l<c;l++){const u=o[l],h=r[l];u!==0&&(Nb.fromBufferAttribute(h,e),a?Hp.addScaledVector(Nb,u):Hp.addScaledVector(Nb.sub(t),u))}t.add(Hp)}return t}raycast(e,t){const s=this.geometry,i=this.material,r=this.matrixWorld;i!==void 0&&(s.boundingSphere===null&&s.computeBoundingSphere(),Xp.copy(s.boundingSphere),Xp.applyMatrix4(r),to.copy(e.ray).recast(e.near),!(Xp.containsPoint(to.origin)===!1&&(to.intersectSphere(Xp,h_)===null||to.origin.distanceToSquared(h_)>(e.far-e.near)**2))&&(u_.copy(r).invert(),to.copy(e.ray).applyMatrix4(u_),!(s.boundingBox!==null&&to.intersectsBox(s.boundingBox)===!1)&&this._computeIntersections(e,t,to)))}_computeIntersections(e,t,s){let i;const r=this.geometry,a=this.material,o=r.index,l=r.attributes.position,c=r.attributes.uv,u=r.attributes.uv1,h=r.attributes.normal,d=r.groups,p=r.drawRange;if(o!==null)if(Array.isArray(a))for(let f=0,y=d.length;f<y;f++){const m=d[f],g=a[m.materialIndex],b=Math.max(m.start,p.start),x=Math.min(o.count,Math.min(m.start+m.count,p.start+p.count));for(let v=b,w=x;v<w;v+=3){const _=o.getX(v),I=o.getX(v+1),C=o.getX(v+2);i=Jp(this,g,e,s,c,u,h,_,I,C),i&&(i.faceIndex=Math.floor(v/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const f=Math.max(0,p.start),y=Math.min(o.count,p.start+p.count);for(let m=f,g=y;m<g;m+=3){const b=o.getX(m),x=o.getX(m+1),v=o.getX(m+2);i=Jp(this,a,e,s,c,u,h,b,x,v),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}else if(l!==void 0)if(Array.isArray(a))for(let f=0,y=d.length;f<y;f++){const m=d[f],g=a[m.materialIndex],b=Math.max(m.start,p.start),x=Math.min(l.count,Math.min(m.start+m.count,p.start+p.count));for(let v=b,w=x;v<w;v+=3){const _=v,I=v+1,C=v+2;i=Jp(this,g,e,s,c,u,h,_,I,C),i&&(i.faceIndex=Math.floor(v/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const f=Math.max(0,p.start),y=Math.min(l.count,p.start+p.count);for(let m=f,g=y;m<g;m+=3){const b=m,x=m+1,v=m+2;i=Jp(this,a,e,s,c,u,h,b,x,v),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}}}function wP(n,e,t,s,i,r,a,o){let l;if(e.side===Ws?l=s.intersectTriangle(a,r,i,!0,o):l=s.intersectTriangle(i,r,a,e.side===Wr,o),l===null)return null;Qp.copy(o),Qp.applyMatrix4(n.matrixWorld);const c=t.ray.origin.distanceTo(Qp);return c<t.near||c>t.far?null:{distance:c,point:Qp.clone(),object:n}}function Jp(n,e,t,s,i,r,a,o,l,c){n.getVertexPosition(o,Sl),n.getVertexPosition(l,Tl),n.getVertexPosition(c,_l);const u=wP(n,e,t,s,Sl,Tl,_l,jp);if(u){i&&(Kp.fromBufferAttribute(i,o),Zp.fromBufferAttribute(i,l),Yp.fromBufferAttribute(i,c),u.uv=Ri.getInterpolation(jp,Sl,Tl,_l,Kp,Zp,Yp,new Rt)),r&&(Kp.fromBufferAttribute(r,o),Zp.fromBufferAttribute(r,l),Yp.fromBufferAttribute(r,c),u.uv1=Ri.getInterpolation(jp,Sl,Tl,_l,Kp,Zp,Yp,new Rt),u.uv2=u.uv1),a&&(d_.fromBufferAttribute(a,o),p_.fromBufferAttribute(a,l),f_.fromBufferAttribute(a,c),u.normal=Ri.getInterpolation(jp,Sl,Tl,_l,d_,p_,f_,new J),u.normal.dot(s.direction)>0&&u.normal.multiplyScalar(-1));const h={a:o,b:l,c,normal:new J,materialIndex:0};Ri.getNormal(Sl,Tl,_l,h.normal),u.face=h}return u}class Uh extends br{constructor(e=1,t=1,s=1,i=1,r=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:s,widthSegments:i,heightSegments:r,depthSegments:a};const o=this;i=Math.floor(i),r=Math.floor(r),a=Math.floor(a);const l=[],c=[],u=[],h=[];let d=0,p=0;f("z","y","x",-1,-1,s,t,e,a,r,0),f("z","y","x",1,-1,s,t,-e,a,r,1),f("x","z","y",1,1,e,s,t,i,a,2),f("x","z","y",1,-1,e,s,-t,i,a,3),f("x","y","z",1,-1,e,t,s,i,r,4),f("x","y","z",-1,-1,e,t,-s,i,r,5),this.setIndex(l),this.setAttribute("position",new zr(c,3)),this.setAttribute("normal",new zr(u,3)),this.setAttribute("uv",new zr(h,2));function f(y,m,g,b,x,v,w,_,I,C,S){const M=v/I,A=w/C,D=v/2,F=w/2,k=_/2,P=I+1,O=C+1;let V=0,$=0;const H=new J;for(let Y=0;Y<O;Y++){const G=Y*A-F;for(let B=0;B<P;B++){const te=B*M-D;H[y]=te*b,H[m]=G*x,H[g]=k,c.push(H.x,H.y,H.z),H[y]=0,H[m]=0,H[g]=_>0?1:-1,u.push(H.x,H.y,H.z),h.push(B/I),h.push(1-Y/C),V+=1}}for(let Y=0;Y<C;Y++)for(let G=0;G<I;G++){const B=d+G+P*Y,te=d+G+P*(Y+1),se=d+(G+1)+P*(Y+1),ae=d+(G+1)+P*Y;l.push(B,te,ae),l.push(te,se,ae),$+=6}o.addGroup(p,$,S),p+=$,d+=V}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Uh(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function ec(n){const e={};for(const t in n){e[t]={};for(const s in n[t]){const i=n[t][s];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][s]=null):e[t][s]=i.clone():Array.isArray(i)?e[t][s]=i.slice():e[t][s]=i}}return e}function Ss(n){const e={};for(let t=0;t<n.length;t++){const s=ec(n[t]);for(const i in s)e[i]=s[i]}return e}function SP(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function N2(n){return n.getRenderTarget()===null?n.outputColorSpace:Pt.workingColorSpace}const TP={clone:ec,merge:Ss};var _P=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,IP=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class No extends lr{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=_P,this.fragmentShader=IP,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=ec(e.uniforms),this.uniformsGroups=SP(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const s={};for(const i in this.extensions)this.extensions[i]===!0&&(s[i]=!0);return Object.keys(s).length>0&&(t.extensions=s),t}}class R2 extends nn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new ot,this.projectionMatrix=new ot,this.projectionMatrixInverse=new ot,this.coordinateSystem=Fr}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}class Ts extends R2{constructor(e=50,t=1,s=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=s,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=ql*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(gh*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return ql*2*Math.atan(Math.tan(gh*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(e,t,s,i,r,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(gh*.5*this.fov)/this.zoom,s=2*t,i=this.aspect*s,r=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const l=a.fullWidth,c=a.fullHeight;r+=a.offsetX*i/l,t-=a.offsetY*s/c,i*=a.width/l,s*=a.height/c}const o=this.filmOffset;o!==0&&(r+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(r,r+i,t,t-s,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const Il=-90,Ml=1;class MP extends nn{constructor(e,t,s){super(),this.type="CubeCamera",this.renderTarget=s,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Ts(Il,Ml,e,t);i.layers=this.layers,this.add(i);const r=new Ts(Il,Ml,e,t);r.layers=this.layers,this.add(r);const a=new Ts(Il,Ml,e,t);a.layers=this.layers,this.add(a);const o=new Ts(Il,Ml,e,t);o.layers=this.layers,this.add(o);const l=new Ts(Il,Ml,e,t);l.layers=this.layers,this.add(l);const c=new Ts(Il,Ml,e,t);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[s,i,r,a,o,l]=t;for(const c of t)this.remove(c);if(e===Fr)s.up.set(0,1,0),s.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),r.up.set(0,0,-1),r.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===Bf)s.up.set(0,-1,0),s.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),r.up.set(0,0,1),r.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of t)this.add(c),c.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:s,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[r,a,o,l,c,u]=this.children,h=e.getRenderTarget(),d=e.getActiveCubeFace(),p=e.getActiveMipmapLevel(),f=e.xr.enabled;e.xr.enabled=!1;const y=s.texture.generateMipmaps;s.texture.generateMipmaps=!1,e.setRenderTarget(s,0,i),e.render(t,r),e.setRenderTarget(s,1,i),e.render(t,a),e.setRenderTarget(s,2,i),e.render(t,o),e.setRenderTarget(s,3,i),e.render(t,l),e.setRenderTarget(s,4,i),e.render(t,c),s.texture.generateMipmaps=y,e.setRenderTarget(s,5,i),e.render(t,u),e.setRenderTarget(h,d,p),e.xr.enabled=f,s.texture.needsPMREMUpdate=!0}}class A2 extends is{constructor(e,t,s,i,r,a,o,l,c,u){e=e!==void 0?e:[],t=t!==void 0?t:Yl,super(e,t,s,i,r,a,o,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class CP extends ko{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const s={width:e,height:e,depth:1},i=[s,s,s,s,s,s];t.encoding!==void 0&&(bh("THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."),t.colorSpace=t.encoding===Ia?an:gi),this.texture=new A2(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:An}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const s={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Uh(5,5,5),r=new No({name:"CubemapFromEquirect",uniforms:ec(s.uniforms),vertexShader:s.vertexShader,fragmentShader:s.fragmentShader,side:Ws,blending:Sa});r.uniforms.tEquirect.value=t;const a=new bi(i,r),o=t.minFilter;return t.minFilter===Ra&&(t.minFilter=An),new MP(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,s,i){const r=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,s,i);e.setRenderTarget(r)}}const Rb=new J,EP=new J,kP=new wt;class co{constructor(e=new J(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,s,i){return this.normal.set(e,t,s),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,s){const i=Rb.subVectors(s,t).cross(EP.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const s=e.delta(Rb),i=this.normal.dot(s);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const r=-(e.start.dot(this.normal)+this.constant)/i;return r<0||r>1?null:t.copy(e.start).addScaledVector(s,r)}intersectsLine(e){const t=this.distanceToPoint(e.start),s=this.distanceToPoint(e.end);return t<0&&s>0||s<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const s=t||kP.getNormalMatrix(e),i=this.coplanarPoint(Rb).applyMatrix4(e),r=this.normal.applyMatrix3(s).normalize();return this.constant=-i.dot(r),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const no=new yr,qp=new J;class Zx{constructor(e=new co,t=new co,s=new co,i=new co,r=new co,a=new co){this.planes=[e,t,s,i,r,a]}set(e,t,s,i,r,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(s),o[3].copy(i),o[4].copy(r),o[5].copy(a),this}copy(e){const t=this.planes;for(let s=0;s<6;s++)t[s].copy(e.planes[s]);return this}setFromProjectionMatrix(e,t=Fr){const s=this.planes,i=e.elements,r=i[0],a=i[1],o=i[2],l=i[3],c=i[4],u=i[5],h=i[6],d=i[7],p=i[8],f=i[9],y=i[10],m=i[11],g=i[12],b=i[13],x=i[14],v=i[15];if(s[0].setComponents(l-r,d-c,m-p,v-g).normalize(),s[1].setComponents(l+r,d+c,m+p,v+g).normalize(),s[2].setComponents(l+a,d+u,m+f,v+b).normalize(),s[3].setComponents(l-a,d-u,m-f,v-b).normalize(),s[4].setComponents(l-o,d-h,m-y,v-x).normalize(),t===Fr)s[5].setComponents(l+o,d+h,m+y,v+x).normalize();else if(t===Bf)s[5].setComponents(o,h,y,x).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),no.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),no.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(no)}intersectsSprite(e){return no.center.set(0,0,0),no.radius=.7071067811865476,no.applyMatrix4(e.matrixWorld),this.intersectsSphere(no)}intersectsSphere(e){const t=this.planes,s=e.center,i=-e.radius;for(let r=0;r<6;r++)if(t[r].distanceToPoint(s)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let s=0;s<6;s++){const i=t[s];if(qp.x=i.normal.x>0?e.max.x:e.min.x,qp.y=i.normal.y>0?e.max.y:e.min.y,qp.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(qp)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let s=0;s<6;s++)if(t[s].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function L2(){let n=null,e=!1,t=null,s=null;function i(r,a){t(r,a),s=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(s=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(s),e=!1},setAnimationLoop:function(r){t=r},setContext:function(r){n=r}}}function NP(n,e){const t=e.isWebGL2,s=new WeakMap;function i(c,u){const h=c.array,d=c.usage,p=n.createBuffer();n.bindBuffer(u,p),n.bufferData(u,h,d),c.onUploadCallback();let f;if(h instanceof Float32Array)f=n.FLOAT;else if(h instanceof Uint16Array)if(c.isFloat16BufferAttribute)if(t)f=n.HALF_FLOAT;else throw new Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else f=n.UNSIGNED_SHORT;else if(h instanceof Int16Array)f=n.SHORT;else if(h instanceof Uint32Array)f=n.UNSIGNED_INT;else if(h instanceof Int32Array)f=n.INT;else if(h instanceof Int8Array)f=n.BYTE;else if(h instanceof Uint8Array)f=n.UNSIGNED_BYTE;else if(h instanceof Uint8ClampedArray)f=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+h);return{buffer:p,type:f,bytesPerElement:h.BYTES_PER_ELEMENT,version:c.version}}function r(c,u,h){const d=u.array,p=u.updateRange;n.bindBuffer(h,c),p.count===-1?n.bufferSubData(h,0,d):(t?n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d,p.offset,p.count):n.bufferSubData(h,p.offset*d.BYTES_PER_ELEMENT,d.subarray(p.offset,p.offset+p.count)),p.count=-1),u.onUploadCallback()}function a(c){return c.isInterleavedBufferAttribute&&(c=c.data),s.get(c)}function o(c){c.isInterleavedBufferAttribute&&(c=c.data);const u=s.get(c);u&&(n.deleteBuffer(u.buffer),s.delete(c))}function l(c,u){if(c.isGLBufferAttribute){const d=s.get(c);(!d||d.version<c.version)&&s.set(c,{buffer:c.buffer,type:c.type,bytesPerElement:c.elementSize,version:c.version});return}c.isInterleavedBufferAttribute&&(c=c.data);const h=s.get(c);h===void 0?s.set(c,i(c,u)):h.version<c.version&&(r(h.buffer,c,u),h.version=c.version)}return{get:a,remove:o,update:l}}class Yx extends br{constructor(e=1,t=1,s=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:s,heightSegments:i};const r=e/2,a=t/2,o=Math.floor(s),l=Math.floor(i),c=o+1,u=l+1,h=e/o,d=t/l,p=[],f=[],y=[],m=[];for(let g=0;g<u;g++){const b=g*d-a;for(let x=0;x<c;x++){const v=x*h-r;f.push(v,-b,0),y.push(0,0,1),m.push(x/o),m.push(1-g/l)}}for(let g=0;g<l;g++)for(let b=0;b<o;b++){const x=b+c*g,v=b+c*(g+1),w=b+1+c*(g+1),_=b+1+c*g;p.push(x,v,_),p.push(v,w,_)}this.setIndex(p),this.setAttribute("position",new zr(f,3)),this.setAttribute("normal",new zr(y,3)),this.setAttribute("uv",new zr(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Yx(e.width,e.height,e.widthSegments,e.heightSegments)}}var RP=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,AP=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,LP=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,PP=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,DP=`#ifdef USE_ALPHATEST
	if ( diffuseColor.a < alphaTest ) discard;
#endif`,FP=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,OP=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,GP=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,zP=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,VP=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,WP=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,UP=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,BP=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,$P=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#pragma unroll_loop_start
	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
		plane = clippingPlanes[ i ];
		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
	}
	#pragma unroll_loop_end
	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
		bool clipped = true;
		#pragma unroll_loop_start
		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
		}
		#pragma unroll_loop_end
		if ( clipped ) discard;
	#endif
#endif`,XP=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,HP=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,KP=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,ZP=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,YP=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,jP=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,QP=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,JP=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,qP=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_v0 0.339
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_v1 0.276
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_v4 0.046
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_v5 0.016
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_v6 0.0038
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,eD=`vec3 transformedNormal = objectNormal;
#ifdef USE_INSTANCING
	mat3 m = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );
	transformedNormal = m * transformedNormal;
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,tD=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,nD=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,sD=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,iD=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,rD="gl_FragColor = linearToOutputTexel( gl_FragColor );",aD=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,oD=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,lD=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,cD=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,uD=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,hD=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,dD=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,pD=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,fD=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,mD=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,gD=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,yD=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,bD=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,xD=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,vD=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,wD=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,SD=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,TD=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,_D=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,ID=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,MD=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,CD=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	anisotropyV /= material.anisotropy;
	material.anisotropy = saturate( material.anisotropy );
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;
#endif`,ED=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,kD=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,ND=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,RD=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,AD=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,LD=`#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,PD=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		varying float vFragDepth;
		varying float vIsPerspective;
	#else
		uniform float logDepthBufFC;
	#endif
#endif`,DD=`#ifdef USE_LOGDEPTHBUF
	#ifdef USE_LOGDEPTHBUF_EXT
		vFragDepth = 1.0 + gl_Position.w;
		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
	#else
		if ( isPerspectiveMatrix( projectionMatrix ) ) {
			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;
			gl_Position.z *= gl_Position.w;
		}
	#endif
#endif`,FD=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,OD=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,GD=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,zD=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,VD=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,WD=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,UD=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,BD=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,$D=`#ifdef USE_MORPHTARGETS
	uniform float morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,XD=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,HD=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,KD=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,ZD=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,YD=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,jD=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,QD=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,JD=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,qD=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,eF=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,tF=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,nF=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,sF=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,iF=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,rF=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,aF=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,oF=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,lF=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,cF=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,uF=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
		vec3 lightToPosition = shadowCoord.xyz;
		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;
		vec3 bd3D = normalize( lightToPosition );
		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
			return (
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
			) * ( 1.0 / 9.0 );
		#else
			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
		#endif
	}
#endif`,hF=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,dF=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,pF=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,fF=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,mF=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	uniform int boneTextureSize;
	mat4 getBoneMatrix( const in float i ) {
		float j = i * 4.0;
		float x = mod( j, float( boneTextureSize ) );
		float y = floor( j / float( boneTextureSize ) );
		float dx = 1.0 / float( boneTextureSize );
		float dy = 1.0 / float( boneTextureSize );
		y = dy * ( y + 0.5 );
		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );
		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );
		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );
		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );
		mat4 bone = mat4( v1, v2, v3, v4 );
		return bone;
	}
#endif`,gF=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,yF=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,bF=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,xF=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,vF=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,wF=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,SF=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,TF=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,_F=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,IF=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,MF=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,CF=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const EF=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,kF=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,NF=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,RF=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,AF=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,LF=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,PF=`#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,DF=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,FF=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <skinbase_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,OF=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( 1.0 );
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,GF=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,zF=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,VF=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,WF=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,UF=`#include <common>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,BF=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,$F=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,XF=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,HF=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,KF=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,ZF=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,YF=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,jF=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,QF=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,JF=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,qF=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,eO=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,tO=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec4 diffuseColor = vec4( diffuse, opacity );
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,nO=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,sO=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,iO=`#include <common>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,rO=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,aO=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,oO=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,gt={alphahash_fragment:RP,alphahash_pars_fragment:AP,alphamap_fragment:LP,alphamap_pars_fragment:PP,alphatest_fragment:DP,alphatest_pars_fragment:FP,aomap_fragment:OP,aomap_pars_fragment:GP,begin_vertex:zP,beginnormal_vertex:VP,bsdfs:WP,iridescence_fragment:UP,bumpmap_pars_fragment:BP,clipping_planes_fragment:$P,clipping_planes_pars_fragment:XP,clipping_planes_pars_vertex:HP,clipping_planes_vertex:KP,color_fragment:ZP,color_pars_fragment:YP,color_pars_vertex:jP,color_vertex:QP,common:JP,cube_uv_reflection_fragment:qP,defaultnormal_vertex:eD,displacementmap_pars_vertex:tD,displacementmap_vertex:nD,emissivemap_fragment:sD,emissivemap_pars_fragment:iD,colorspace_fragment:rD,colorspace_pars_fragment:aD,envmap_fragment:oD,envmap_common_pars_fragment:lD,envmap_pars_fragment:cD,envmap_pars_vertex:uD,envmap_physical_pars_fragment:SD,envmap_vertex:hD,fog_vertex:dD,fog_pars_vertex:pD,fog_fragment:fD,fog_pars_fragment:mD,gradientmap_pars_fragment:gD,lightmap_fragment:yD,lightmap_pars_fragment:bD,lights_lambert_fragment:xD,lights_lambert_pars_fragment:vD,lights_pars_begin:wD,lights_toon_fragment:TD,lights_toon_pars_fragment:_D,lights_phong_fragment:ID,lights_phong_pars_fragment:MD,lights_physical_fragment:CD,lights_physical_pars_fragment:ED,lights_fragment_begin:kD,lights_fragment_maps:ND,lights_fragment_end:RD,logdepthbuf_fragment:AD,logdepthbuf_pars_fragment:LD,logdepthbuf_pars_vertex:PD,logdepthbuf_vertex:DD,map_fragment:FD,map_pars_fragment:OD,map_particle_fragment:GD,map_particle_pars_fragment:zD,metalnessmap_fragment:VD,metalnessmap_pars_fragment:WD,morphcolor_vertex:UD,morphnormal_vertex:BD,morphtarget_pars_vertex:$D,morphtarget_vertex:XD,normal_fragment_begin:HD,normal_fragment_maps:KD,normal_pars_fragment:ZD,normal_pars_vertex:YD,normal_vertex:jD,normalmap_pars_fragment:QD,clearcoat_normal_fragment_begin:JD,clearcoat_normal_fragment_maps:qD,clearcoat_pars_fragment:eF,iridescence_pars_fragment:tF,opaque_fragment:nF,packing:sF,premultiplied_alpha_fragment:iF,project_vertex:rF,dithering_fragment:aF,dithering_pars_fragment:oF,roughnessmap_fragment:lF,roughnessmap_pars_fragment:cF,shadowmap_pars_fragment:uF,shadowmap_pars_vertex:hF,shadowmap_vertex:dF,shadowmask_pars_fragment:pF,skinbase_vertex:fF,skinning_pars_vertex:mF,skinning_vertex:gF,skinnormal_vertex:yF,specularmap_fragment:bF,specularmap_pars_fragment:xF,tonemapping_fragment:vF,tonemapping_pars_fragment:wF,transmission_fragment:SF,transmission_pars_fragment:TF,uv_pars_fragment:_F,uv_pars_vertex:IF,uv_vertex:MF,worldpos_vertex:CF,background_vert:EF,background_frag:kF,backgroundCube_vert:NF,backgroundCube_frag:RF,cube_vert:AF,cube_frag:LF,depth_vert:PF,depth_frag:DF,distanceRGBA_vert:FF,distanceRGBA_frag:OF,equirect_vert:GF,equirect_frag:zF,linedashed_vert:VF,linedashed_frag:WF,meshbasic_vert:UF,meshbasic_frag:BF,meshlambert_vert:$F,meshlambert_frag:XF,meshmatcap_vert:HF,meshmatcap_frag:KF,meshnormal_vert:ZF,meshnormal_frag:YF,meshphong_vert:jF,meshphong_frag:QF,meshphysical_vert:JF,meshphysical_frag:qF,meshtoon_vert:eO,meshtoon_frag:tO,points_vert:nO,points_frag:sO,shadow_vert:iO,shadow_frag:rO,sprite_vert:aO,sprite_frag:oO},ke={common:{diffuse:{value:new lt(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new wt},alphaMap:{value:null},alphaMapTransform:{value:new wt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new wt}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new wt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new wt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new wt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new wt},normalScale:{value:new Rt(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new wt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new wt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new wt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new wt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new lt(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new lt(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new wt},alphaTest:{value:0},uvTransform:{value:new wt}},sprite:{diffuse:{value:new lt(16777215)},opacity:{value:1},center:{value:new Rt(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new wt},alphaMap:{value:null},alphaMapTransform:{value:new wt},alphaTest:{value:0}}},er={basic:{uniforms:Ss([ke.common,ke.specularmap,ke.envmap,ke.aomap,ke.lightmap,ke.fog]),vertexShader:gt.meshbasic_vert,fragmentShader:gt.meshbasic_frag},lambert:{uniforms:Ss([ke.common,ke.specularmap,ke.envmap,ke.aomap,ke.lightmap,ke.emissivemap,ke.bumpmap,ke.normalmap,ke.displacementmap,ke.fog,ke.lights,{emissive:{value:new lt(0)}}]),vertexShader:gt.meshlambert_vert,fragmentShader:gt.meshlambert_frag},phong:{uniforms:Ss([ke.common,ke.specularmap,ke.envmap,ke.aomap,ke.lightmap,ke.emissivemap,ke.bumpmap,ke.normalmap,ke.displacementmap,ke.fog,ke.lights,{emissive:{value:new lt(0)},specular:{value:new lt(1118481)},shininess:{value:30}}]),vertexShader:gt.meshphong_vert,fragmentShader:gt.meshphong_frag},standard:{uniforms:Ss([ke.common,ke.envmap,ke.aomap,ke.lightmap,ke.emissivemap,ke.bumpmap,ke.normalmap,ke.displacementmap,ke.roughnessmap,ke.metalnessmap,ke.fog,ke.lights,{emissive:{value:new lt(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:gt.meshphysical_vert,fragmentShader:gt.meshphysical_frag},toon:{uniforms:Ss([ke.common,ke.aomap,ke.lightmap,ke.emissivemap,ke.bumpmap,ke.normalmap,ke.displacementmap,ke.gradientmap,ke.fog,ke.lights,{emissive:{value:new lt(0)}}]),vertexShader:gt.meshtoon_vert,fragmentShader:gt.meshtoon_frag},matcap:{uniforms:Ss([ke.common,ke.bumpmap,ke.normalmap,ke.displacementmap,ke.fog,{matcap:{value:null}}]),vertexShader:gt.meshmatcap_vert,fragmentShader:gt.meshmatcap_frag},points:{uniforms:Ss([ke.points,ke.fog]),vertexShader:gt.points_vert,fragmentShader:gt.points_frag},dashed:{uniforms:Ss([ke.common,ke.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:gt.linedashed_vert,fragmentShader:gt.linedashed_frag},depth:{uniforms:Ss([ke.common,ke.displacementmap]),vertexShader:gt.depth_vert,fragmentShader:gt.depth_frag},normal:{uniforms:Ss([ke.common,ke.bumpmap,ke.normalmap,ke.displacementmap,{opacity:{value:1}}]),vertexShader:gt.meshnormal_vert,fragmentShader:gt.meshnormal_frag},sprite:{uniforms:Ss([ke.sprite,ke.fog]),vertexShader:gt.sprite_vert,fragmentShader:gt.sprite_frag},background:{uniforms:{uvTransform:{value:new wt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:gt.background_vert,fragmentShader:gt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1}},vertexShader:gt.backgroundCube_vert,fragmentShader:gt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:gt.cube_vert,fragmentShader:gt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:gt.equirect_vert,fragmentShader:gt.equirect_frag},distanceRGBA:{uniforms:Ss([ke.common,ke.displacementmap,{referencePosition:{value:new J},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:gt.distanceRGBA_vert,fragmentShader:gt.distanceRGBA_frag},shadow:{uniforms:Ss([ke.lights,ke.fog,{color:{value:new lt(0)},opacity:{value:1}}]),vertexShader:gt.shadow_vert,fragmentShader:gt.shadow_frag}};er.physical={uniforms:Ss([er.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new wt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new wt},clearcoatNormalScale:{value:new Rt(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new wt},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new wt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new wt},sheen:{value:0},sheenColor:{value:new lt(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new wt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new wt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new wt},transmissionSamplerSize:{value:new Rt},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new wt},attenuationDistance:{value:0},attenuationColor:{value:new lt(0)},specularColor:{value:new lt(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new wt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new wt},anisotropyVector:{value:new Rt},anisotropyMap:{value:null},anisotropyMapTransform:{value:new wt}}]),vertexShader:gt.meshphysical_vert,fragmentShader:gt.meshphysical_frag};const ef={r:0,b:0,g:0};function lO(n,e,t,s,i,r,a){const o=new lt(0);let l=r===!0?0:1,c,u,h=null,d=0,p=null;function f(m,g){let b=!1,x=g.isScene===!0?g.background:null;x&&x.isTexture&&(x=(g.backgroundBlurriness>0?t:e).get(x)),x===null?y(o,l):x&&x.isColor&&(y(x,1),b=!0);const v=n.xr.getEnvironmentBlendMode();v==="additive"?s.buffers.color.setClear(0,0,0,1,a):v==="alpha-blend"&&s.buffers.color.setClear(0,0,0,0,a),(n.autoClear||b)&&n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil),x&&(x.isCubeTexture||x.mapping===Cm)?(u===void 0&&(u=new bi(new Uh(1,1,1),new No({name:"BackgroundCubeMaterial",uniforms:ec(er.backgroundCube.uniforms),vertexShader:er.backgroundCube.vertexShader,fragmentShader:er.backgroundCube.fragmentShader,side:Ws,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(w,_,I){this.matrixWorld.copyPosition(I.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),u.material.uniforms.envMap.value=x,u.material.uniforms.flipEnvMap.value=x.isCubeTexture&&x.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=g.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=g.backgroundIntensity,u.material.toneMapped=Pt.getTransfer(x.colorSpace)!==qt,(h!==x||d!==x.version||p!==n.toneMapping)&&(u.material.needsUpdate=!0,h=x,d=x.version,p=n.toneMapping),u.layers.enableAll(),m.unshift(u,u.geometry,u.material,0,0,null)):x&&x.isTexture&&(c===void 0&&(c=new bi(new Yx(2,2),new No({name:"BackgroundMaterial",uniforms:ec(er.background.uniforms),vertexShader:er.background.vertexShader,fragmentShader:er.background.fragmentShader,side:Wr,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=x,c.material.uniforms.backgroundIntensity.value=g.backgroundIntensity,c.material.toneMapped=Pt.getTransfer(x.colorSpace)!==qt,x.matrixAutoUpdate===!0&&x.updateMatrix(),c.material.uniforms.uvTransform.value.copy(x.matrix),(h!==x||d!==x.version||p!==n.toneMapping)&&(c.material.needsUpdate=!0,h=x,d=x.version,p=n.toneMapping),c.layers.enableAll(),m.unshift(c,c.geometry,c.material,0,0,null))}function y(m,g){m.getRGB(ef,N2(n)),s.buffers.color.setClear(ef.r,ef.g,ef.b,g,a)}return{getClearColor:function(){return o},setClearColor:function(m,g=1){o.set(m),l=g,y(o,l)},getClearAlpha:function(){return l},setClearAlpha:function(m){l=m,y(o,l)},render:f}}function cO(n,e,t,s){const i=n.getParameter(n.MAX_VERTEX_ATTRIBS),r=s.isWebGL2?null:e.get("OES_vertex_array_object"),a=s.isWebGL2||r!==null,o={},l=m(null);let c=l,u=!1;function h(k,P,O,V,$){let H=!1;if(a){const Y=y(V,O,P);c!==Y&&(c=Y,p(c.object)),H=g(k,V,O,$),H&&b(k,V,O,$)}else{const Y=P.wireframe===!0;(c.geometry!==V.id||c.program!==O.id||c.wireframe!==Y)&&(c.geometry=V.id,c.program=O.id,c.wireframe=Y,H=!0)}$!==null&&t.update($,n.ELEMENT_ARRAY_BUFFER),(H||u)&&(u=!1,C(k,P,O,V),$!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t.get($).buffer))}function d(){return s.isWebGL2?n.createVertexArray():r.createVertexArrayOES()}function p(k){return s.isWebGL2?n.bindVertexArray(k):r.bindVertexArrayOES(k)}function f(k){return s.isWebGL2?n.deleteVertexArray(k):r.deleteVertexArrayOES(k)}function y(k,P,O){const V=O.wireframe===!0;let $=o[k.id];$===void 0&&($={},o[k.id]=$);let H=$[P.id];H===void 0&&(H={},$[P.id]=H);let Y=H[V];return Y===void 0&&(Y=m(d()),H[V]=Y),Y}function m(k){const P=[],O=[],V=[];for(let $=0;$<i;$++)P[$]=0,O[$]=0,V[$]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:P,enabledAttributes:O,attributeDivisors:V,object:k,attributes:{},index:null}}function g(k,P,O,V){const $=c.attributes,H=P.attributes;let Y=0;const G=O.getAttributes();for(const B in G)if(G[B].location>=0){const se=$[B];let ae=H[B];if(ae===void 0&&(B==="instanceMatrix"&&k.instanceMatrix&&(ae=k.instanceMatrix),B==="instanceColor"&&k.instanceColor&&(ae=k.instanceColor)),se===void 0||se.attribute!==ae||ae&&se.data!==ae.data)return!0;Y++}return c.attributesNum!==Y||c.index!==V}function b(k,P,O,V){const $={},H=P.attributes;let Y=0;const G=O.getAttributes();for(const B in G)if(G[B].location>=0){let se=H[B];se===void 0&&(B==="instanceMatrix"&&k.instanceMatrix&&(se=k.instanceMatrix),B==="instanceColor"&&k.instanceColor&&(se=k.instanceColor));const ae={};ae.attribute=se,se&&se.data&&(ae.data=se.data),$[B]=ae,Y++}c.attributes=$,c.attributesNum=Y,c.index=V}function x(){const k=c.newAttributes;for(let P=0,O=k.length;P<O;P++)k[P]=0}function v(k){w(k,0)}function w(k,P){const O=c.newAttributes,V=c.enabledAttributes,$=c.attributeDivisors;O[k]=1,V[k]===0&&(n.enableVertexAttribArray(k),V[k]=1),$[k]!==P&&((s.isWebGL2?n:e.get("ANGLE_instanced_arrays"))[s.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](k,P),$[k]=P)}function _(){const k=c.newAttributes,P=c.enabledAttributes;for(let O=0,V=P.length;O<V;O++)P[O]!==k[O]&&(n.disableVertexAttribArray(O),P[O]=0)}function I(k,P,O,V,$,H,Y){Y===!0?n.vertexAttribIPointer(k,P,O,$,H):n.vertexAttribPointer(k,P,O,V,$,H)}function C(k,P,O,V){if(s.isWebGL2===!1&&(k.isInstancedMesh||V.isInstancedBufferGeometry)&&e.get("ANGLE_instanced_arrays")===null)return;x();const $=V.attributes,H=O.getAttributes(),Y=P.defaultAttributeValues;for(const G in H){const B=H[G];if(B.location>=0){let te=$[G];if(te===void 0&&(G==="instanceMatrix"&&k.instanceMatrix&&(te=k.instanceMatrix),G==="instanceColor"&&k.instanceColor&&(te=k.instanceColor)),te!==void 0){const se=te.normalized,ae=te.itemSize,fe=t.get(te);if(fe===void 0)continue;const be=fe.buffer,ge=fe.type,ve=fe.bytesPerElement,Oe=s.isWebGL2===!0&&(ge===n.INT||ge===n.UNSIGNED_INT||te.gpuType===h2);if(te.isInterleavedBufferAttribute){const Ce=te.data,q=Ce.stride,vt=te.offset;if(Ce.isInstancedInterleavedBuffer){for(let Ee=0;Ee<B.locationSize;Ee++)w(B.location+Ee,Ce.meshPerAttribute);k.isInstancedMesh!==!0&&V._maxInstanceCount===void 0&&(V._maxInstanceCount=Ce.meshPerAttribute*Ce.count)}else for(let Ee=0;Ee<B.locationSize;Ee++)v(B.location+Ee);n.bindBuffer(n.ARRAY_BUFFER,be);for(let Ee=0;Ee<B.locationSize;Ee++)I(B.location+Ee,ae/B.locationSize,ge,se,q*ve,(vt+ae/B.locationSize*Ee)*ve,Oe)}else{if(te.isInstancedBufferAttribute){for(let Ce=0;Ce<B.locationSize;Ce++)w(B.location+Ce,te.meshPerAttribute);k.isInstancedMesh!==!0&&V._maxInstanceCount===void 0&&(V._maxInstanceCount=te.meshPerAttribute*te.count)}else for(let Ce=0;Ce<B.locationSize;Ce++)v(B.location+Ce);n.bindBuffer(n.ARRAY_BUFFER,be);for(let Ce=0;Ce<B.locationSize;Ce++)I(B.location+Ce,ae/B.locationSize,ge,se,ae*ve,ae/B.locationSize*Ce*ve,Oe)}}else if(Y!==void 0){const se=Y[G];if(se!==void 0)switch(se.length){case 2:n.vertexAttrib2fv(B.location,se);break;case 3:n.vertexAttrib3fv(B.location,se);break;case 4:n.vertexAttrib4fv(B.location,se);break;default:n.vertexAttrib1fv(B.location,se)}}}}_()}function S(){D();for(const k in o){const P=o[k];for(const O in P){const V=P[O];for(const $ in V)f(V[$].object),delete V[$];delete P[O]}delete o[k]}}function M(k){if(o[k.id]===void 0)return;const P=o[k.id];for(const O in P){const V=P[O];for(const $ in V)f(V[$].object),delete V[$];delete P[O]}delete o[k.id]}function A(k){for(const P in o){const O=o[P];if(O[k.id]===void 0)continue;const V=O[k.id];for(const $ in V)f(V[$].object),delete V[$];delete O[k.id]}}function D(){F(),u=!0,c!==l&&(c=l,p(c.object))}function F(){l.geometry=null,l.program=null,l.wireframe=!1}return{setup:h,reset:D,resetDefaultState:F,dispose:S,releaseStatesOfGeometry:M,releaseStatesOfProgram:A,initAttributes:x,enableAttribute:v,disableUnusedAttributes:_}}function uO(n,e,t,s){const i=s.isWebGL2;let r;function a(c){r=c}function o(c,u){n.drawArrays(r,c,u),t.update(u,r,1)}function l(c,u,h){if(h===0)return;let d,p;if(i)d=n,p="drawArraysInstanced";else if(d=e.get("ANGLE_instanced_arrays"),p="drawArraysInstancedANGLE",d===null){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}d[p](r,c,u,h),t.update(u,r,h)}this.setMode=a,this.render=o,this.renderInstances=l}function hO(n,e,t){let s;function i(){if(s!==void 0)return s;if(e.has("EXT_texture_filter_anisotropic")===!0){const I=e.get("EXT_texture_filter_anisotropic");s=n.getParameter(I.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else s=0;return s}function r(I){if(I==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";I="mediump"}return I==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}const a=typeof WebGL2RenderingContext<"u"&&n.constructor.name==="WebGL2RenderingContext";let o=t.precision!==void 0?t.precision:"highp";const l=r(o);l!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",l,"instead."),o=l);const c=a||e.has("WEBGL_draw_buffers"),u=t.logarithmicDepthBuffer===!0,h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),d=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_TEXTURE_SIZE),f=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),y=n.getParameter(n.MAX_VERTEX_ATTRIBS),m=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),g=n.getParameter(n.MAX_VARYING_VECTORS),b=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),x=d>0,v=a||e.has("OES_texture_float"),w=x&&v,_=a?n.getParameter(n.MAX_SAMPLES):0;return{isWebGL2:a,drawBuffers:c,getMaxAnisotropy:i,getMaxPrecision:r,precision:o,logarithmicDepthBuffer:u,maxTextures:h,maxVertexTextures:d,maxTextureSize:p,maxCubemapSize:f,maxAttributes:y,maxVertexUniforms:m,maxVaryings:g,maxFragmentUniforms:b,vertexTextures:x,floatFragmentTextures:v,floatVertexTextures:w,maxSamples:_}}function dO(n){const e=this;let t=null,s=0,i=!1,r=!1;const a=new co,o=new wt,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(h,d){const p=h.length!==0||d||s!==0||i;return i=d,s=h.length,p},this.beginShadows=function(){r=!0,u(null)},this.endShadows=function(){r=!1},this.setGlobalState=function(h,d){t=u(h,d,0)},this.setState=function(h,d,p){const f=h.clippingPlanes,y=h.clipIntersection,m=h.clipShadows,g=n.get(h);if(!i||f===null||f.length===0||r&&!m)r?u(null):c();else{const b=r?0:s,x=b*4;let v=g.clippingState||null;l.value=v,v=u(f,d,x,p);for(let w=0;w!==x;++w)v[w]=t[w];g.clippingState=v,this.numIntersection=y?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==t&&(l.value=t,l.needsUpdate=s>0),e.numPlanes=s,e.numIntersection=0}function u(h,d,p,f){const y=h!==null?h.length:0;let m=null;if(y!==0){if(m=l.value,f!==!0||m===null){const g=p+y*4,b=d.matrixWorldInverse;o.getNormalMatrix(b),(m===null||m.length<g)&&(m=new Float32Array(g));for(let x=0,v=p;x!==y;++x,v+=4)a.copy(h[x]).applyMatrix4(b,o),a.normal.toArray(m,v),m[v+3]=a.constant}l.value=m,l.needsUpdate=!0}return e.numPlanes=y,e.numIntersection=0,m}}function pO(n){let e=new WeakMap;function t(a,o){return o===Of?a.mapping=Yl:o===L0&&(a.mapping=jl),a}function s(a){if(a&&a.isTexture&&a.isRenderTargetTexture===!1){const o=a.mapping;if(o===Of||o===L0)if(e.has(a)){const l=e.get(a).texture;return t(l,a.mapping)}else{const l=a.image;if(l&&l.height>0){const c=new CP(l.height/2);return c.fromEquirectangularTexture(n,a),e.set(a,c),a.addEventListener("dispose",i),t(c.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const l=e.get(o);l!==void 0&&(e.delete(o),l.dispose())}function r(){e=new WeakMap}return{get:s,dispose:r}}class jx extends R2{constructor(e=-1,t=1,s=1,i=-1,r=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=s,this.bottom=i,this.near=r,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,s,i,r,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=s,this.view.offsetY=i,this.view.width=r,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),s=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let r=s-e,a=s+e,o=i+t,l=i-t;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;r+=c*this.view.offsetX,a=r+c*this.view.width,o-=u*this.view.offsetY,l=o-u*this.view.height}this.projectionMatrix.makeOrthographic(r,a,o,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Ol=4,m_=[.125,.215,.35,.446,.526,.582],mo=20,Ab=new jx,g_=new lt;let Lb=null,Pb=0,Db=0;const uo=(1+Math.sqrt(5))/2,Cl=1/uo,y_=[new J(1,1,1),new J(-1,1,1),new J(1,1,-1),new J(-1,1,-1),new J(0,uo,Cl),new J(0,uo,-Cl),new J(Cl,0,uo),new J(-Cl,0,uo),new J(uo,Cl,0),new J(-uo,Cl,0)];class b_{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,s=.1,i=100){Lb=this._renderer.getRenderTarget(),Pb=this._renderer.getActiveCubeFace(),Db=this._renderer.getActiveMipmapLevel(),this._setSize(256);const r=this._allocateTargets();return r.depthBuffer=!0,this._sceneToCubeUV(e,s,i,r),t>0&&this._blur(r,0,0,t),this._applyPMREM(r),this._cleanup(r),r}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=w_(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=v_(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(Lb,Pb,Db),e.scissorTest=!1,tf(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Yl||e.mapping===jl?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),Lb=this._renderer.getRenderTarget(),Pb=this._renderer.getActiveCubeFace(),Db=this._renderer.getActiveMipmapLevel();const s=t||this._allocateTargets();return this._textureToCubeUV(e,s),this._applyPMREM(s),this._cleanup(s),s}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,s={magFilter:An,minFilter:An,generateMipmaps:!1,type:Dr,format:mi,colorSpace:Kn,depthBuffer:!1},i=x_(e,t,s);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=x_(e,t,s);const{_lodMax:r}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=fO(r)),this._blurMaterial=mO(r,e,t)}return i}_compileMaterial(e){const t=new bi(this._lodPlanes[0],e);this._renderer.compile(t,Ab)}_sceneToCubeUV(e,t,s,i){const o=new Ts(90,1,t,s),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,h=u.autoClear,d=u.toneMapping;u.getClearColor(g_),u.toneMapping=Ta,u.autoClear=!1;const p=new ya({name:"PMREM.Background",side:Ws,depthWrite:!1,depthTest:!1}),f=new bi(new Uh,p);let y=!1;const m=e.background;m?m.isColor&&(p.color.copy(m),e.background=null,y=!0):(p.color.copy(g_),y=!0);for(let g=0;g<6;g++){const b=g%3;b===0?(o.up.set(0,l[g],0),o.lookAt(c[g],0,0)):b===1?(o.up.set(0,0,l[g]),o.lookAt(0,c[g],0)):(o.up.set(0,l[g],0),o.lookAt(0,0,c[g]));const x=this._cubeSize;tf(i,b*x,g>2?x:0,x,x),u.setRenderTarget(i),y&&u.render(f,o),u.render(e,o)}f.geometry.dispose(),f.material.dispose(),u.toneMapping=d,u.autoClear=h,e.background=m}_textureToCubeUV(e,t){const s=this._renderer,i=e.mapping===Yl||e.mapping===jl;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=w_()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=v_());const r=i?this._cubemapMaterial:this._equirectMaterial,a=new bi(this._lodPlanes[0],r),o=r.uniforms;o.envMap.value=e;const l=this._cubeSize;tf(t,0,0,3*l,2*l),s.setRenderTarget(t),s.render(a,Ab)}_applyPMREM(e){const t=this._renderer,s=t.autoClear;t.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const r=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),a=y_[(i-1)%y_.length];this._blur(e,i-1,i,r,a)}t.autoClear=s}_blur(e,t,s,i,r){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,s,i,"latitudinal",r),this._halfBlur(a,e,s,s,i,"longitudinal",r)}_halfBlur(e,t,s,i,r,a,o){const l=this._renderer,c=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,h=new bi(this._lodPlanes[i],c),d=c.uniforms,p=this._sizeLods[s]-1,f=isFinite(r)?Math.PI/(2*p):2*Math.PI/(2*mo-1),y=r/f,m=isFinite(r)?1+Math.floor(u*y):mo;m>mo&&console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${mo}`);const g=[];let b=0;for(let I=0;I<mo;++I){const C=I/y,S=Math.exp(-C*C/2);g.push(S),I===0?b+=S:I<m&&(b+=2*S)}for(let I=0;I<g.length;I++)g[I]=g[I]/b;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=g,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:x}=this;d.dTheta.value=f,d.mipInt.value=x-s;const v=this._sizeLods[i],w=3*v*(i>x-Ol?i-x+Ol:0),_=4*(this._cubeSize-v);tf(t,w,_,3*v,2*v),l.setRenderTarget(t),l.render(h,Ab)}}function fO(n){const e=[],t=[],s=[];let i=n;const r=n-Ol+1+m_.length;for(let a=0;a<r;a++){const o=Math.pow(2,i);t.push(o);let l=1/o;a>n-Ol?l=m_[a-n+Ol-1]:a===0&&(l=0),s.push(l);const c=1/(o-2),u=-c,h=1+c,d=[u,u,h,u,h,h,u,u,h,h,u,h],p=6,f=6,y=3,m=2,g=1,b=new Float32Array(y*f*p),x=new Float32Array(m*f*p),v=new Float32Array(g*f*p);for(let _=0;_<p;_++){const I=_%3*2/3-1,C=_>2?0:-1,S=[I,C,0,I+2/3,C,0,I+2/3,C+1,0,I,C,0,I+2/3,C+1,0,I,C+1,0];b.set(S,y*f*_),x.set(d,m*f*_);const M=[_,_,_,_,_,_];v.set(M,g*f*_)}const w=new br;w.setAttribute("position",new Ms(b,y)),w.setAttribute("uv",new Ms(x,m)),w.setAttribute("faceIndex",new Ms(v,g)),e.push(w),i>Ol&&i--}return{lodPlanes:e,sizeLods:t,sigmas:s}}function x_(n,e,t){const s=new ko(n,e,t);return s.texture.mapping=Cm,s.texture.name="PMREM.cubeUv",s.scissorTest=!0,s}function tf(n,e,t,s,i){n.viewport.set(e,t,s,i),n.scissor.set(e,t,s,i)}function mO(n,e,t){const s=new Float32Array(mo),i=new J(0,1,0);return new No({name:"SphericalGaussianBlur",defines:{n:mo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:s},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:Qx(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function v_(){return new No({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:Qx(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function w_(){return new No({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:Qx(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function Qx(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function gO(n){let e=new WeakMap,t=null;function s(o){if(o&&o.isTexture){const l=o.mapping,c=l===Of||l===L0,u=l===Yl||l===jl;if(c||u)if(o.isRenderTargetTexture&&o.needsPMREMUpdate===!0){o.needsPMREMUpdate=!1;let h=e.get(o);return t===null&&(t=new b_(n)),h=c?t.fromEquirectangular(o,h):t.fromCubemap(o,h),e.set(o,h),h.texture}else{if(e.has(o))return e.get(o).texture;{const h=o.image;if(c&&h&&h.height>0||u&&h&&i(h)){t===null&&(t=new b_(n));const d=c?t.fromEquirectangular(o):t.fromCubemap(o);return e.set(o,d),o.addEventListener("dispose",r),d.texture}else return null}}}return o}function i(o){let l=0;const c=6;for(let u=0;u<c;u++)o[u]!==void 0&&l++;return l===c}function r(o){const l=o.target;l.removeEventListener("dispose",r);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:s,dispose:a}}function yO(n){const e={};function t(s){if(e[s]!==void 0)return e[s];let i;switch(s){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(s)}return e[s]=i,i}return{has:function(s){return t(s)!==null},init:function(s){s.isWebGL2?t("EXT_color_buffer_float"):(t("WEBGL_depth_texture"),t("OES_texture_float"),t("OES_texture_half_float"),t("OES_texture_half_float_linear"),t("OES_standard_derivatives"),t("OES_element_index_uint"),t("OES_vertex_array_object"),t("ANGLE_instanced_arrays")),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture")},get:function(s){const i=t(s);return i===null&&console.warn("THREE.WebGLRenderer: "+s+" extension not supported."),i}}}function bO(n,e,t,s){const i={},r=new WeakMap;function a(h){const d=h.target;d.index!==null&&e.remove(d.index);for(const f in d.attributes)e.remove(d.attributes[f]);for(const f in d.morphAttributes){const y=d.morphAttributes[f];for(let m=0,g=y.length;m<g;m++)e.remove(y[m])}d.removeEventListener("dispose",a),delete i[d.id];const p=r.get(d);p&&(e.remove(p),r.delete(d)),s.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(h,d){return i[d.id]===!0||(d.addEventListener("dispose",a),i[d.id]=!0,t.memory.geometries++),d}function l(h){const d=h.attributes;for(const f in d)e.update(d[f],n.ARRAY_BUFFER);const p=h.morphAttributes;for(const f in p){const y=p[f];for(let m=0,g=y.length;m<g;m++)e.update(y[m],n.ARRAY_BUFFER)}}function c(h){const d=[],p=h.index,f=h.attributes.position;let y=0;if(p!==null){const b=p.array;y=p.version;for(let x=0,v=b.length;x<v;x+=3){const w=b[x+0],_=b[x+1],I=b[x+2];d.push(w,_,_,I,I,w)}}else if(f!==void 0){const b=f.array;y=f.version;for(let x=0,v=b.length/3-1;x<v;x+=3){const w=x+0,_=x+1,I=x+2;d.push(w,_,_,I,I,w)}}else return;const m=new(S2(d)?k2:E2)(d,1);m.version=y;const g=r.get(h);g&&e.remove(g),r.set(h,m)}function u(h){const d=r.get(h);if(d){const p=h.index;p!==null&&d.version<p.version&&c(h)}else c(h);return r.get(h)}return{get:o,update:l,getWireframeAttribute:u}}function xO(n,e,t,s){const i=s.isWebGL2;let r;function a(d){r=d}let o,l;function c(d){o=d.type,l=d.bytesPerElement}function u(d,p){n.drawElements(r,p,o,d*l),t.update(p,r,1)}function h(d,p,f){if(f===0)return;let y,m;if(i)y=n,m="drawElementsInstanced";else if(y=e.get("ANGLE_instanced_arrays"),m="drawElementsInstancedANGLE",y===null){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}y[m](r,p,o,d*l,f),t.update(p,r,f)}this.setMode=a,this.setIndex=c,this.render=u,this.renderInstances=h}function vO(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function s(r,a,o){switch(t.calls++,a){case n.TRIANGLES:t.triangles+=o*(r/3);break;case n.LINES:t.lines+=o*(r/2);break;case n.LINE_STRIP:t.lines+=o*(r-1);break;case n.LINE_LOOP:t.lines+=o*r;break;case n.POINTS:t.points+=o*r;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:s}}function wO(n,e){return n[0]-e[0]}function SO(n,e){return Math.abs(e[1])-Math.abs(n[1])}function TO(n,e,t){const s={},i=new Float32Array(8),r=new WeakMap,a=new Xt,o=[];for(let c=0;c<8;c++)o[c]=[c,0];function l(c,u,h){const d=c.morphTargetInfluences;if(e.isWebGL2===!0){const f=u.morphAttributes.position||u.morphAttributes.normal||u.morphAttributes.color,y=f!==void 0?f.length:0;let m=r.get(u);if(m===void 0||m.count!==y){let P=function(){F.dispose(),r.delete(u),u.removeEventListener("dispose",P)};var p=P;m!==void 0&&m.texture.dispose();const x=u.morphAttributes.position!==void 0,v=u.morphAttributes.normal!==void 0,w=u.morphAttributes.color!==void 0,_=u.morphAttributes.position||[],I=u.morphAttributes.normal||[],C=u.morphAttributes.color||[];let S=0;x===!0&&(S=1),v===!0&&(S=2),w===!0&&(S=3);let M=u.attributes.position.count*S,A=1;M>e.maxTextureSize&&(A=Math.ceil(M/e.maxTextureSize),M=e.maxTextureSize);const D=new Float32Array(M*A*4*y),F=new I2(D,M,A,y);F.type=yi,F.needsUpdate=!0;const k=S*4;for(let O=0;O<y;O++){const V=_[O],$=I[O],H=C[O],Y=M*A*4*O;for(let G=0;G<V.count;G++){const B=G*k;x===!0&&(a.fromBufferAttribute(V,G),D[Y+B+0]=a.x,D[Y+B+1]=a.y,D[Y+B+2]=a.z,D[Y+B+3]=0),v===!0&&(a.fromBufferAttribute($,G),D[Y+B+4]=a.x,D[Y+B+5]=a.y,D[Y+B+6]=a.z,D[Y+B+7]=0),w===!0&&(a.fromBufferAttribute(H,G),D[Y+B+8]=a.x,D[Y+B+9]=a.y,D[Y+B+10]=a.z,D[Y+B+11]=H.itemSize===4?a.w:1)}}m={count:y,texture:F,size:new Rt(M,A)},r.set(u,m),u.addEventListener("dispose",P)}let g=0;for(let x=0;x<d.length;x++)g+=d[x];const b=u.morphTargetsRelative?1:1-g;h.getUniforms().setValue(n,"morphTargetBaseInfluence",b),h.getUniforms().setValue(n,"morphTargetInfluences",d),h.getUniforms().setValue(n,"morphTargetsTexture",m.texture,t),h.getUniforms().setValue(n,"morphTargetsTextureSize",m.size)}else{const f=d===void 0?0:d.length;let y=s[u.id];if(y===void 0||y.length!==f){y=[];for(let v=0;v<f;v++)y[v]=[v,0];s[u.id]=y}for(let v=0;v<f;v++){const w=y[v];w[0]=v,w[1]=d[v]}y.sort(SO);for(let v=0;v<8;v++)v<f&&y[v][1]?(o[v][0]=y[v][0],o[v][1]=y[v][1]):(o[v][0]=Number.MAX_SAFE_INTEGER,o[v][1]=0);o.sort(wO);const m=u.morphAttributes.position,g=u.morphAttributes.normal;let b=0;for(let v=0;v<8;v++){const w=o[v],_=w[0],I=w[1];_!==Number.MAX_SAFE_INTEGER&&I?(m&&u.getAttribute("morphTarget"+v)!==m[_]&&u.setAttribute("morphTarget"+v,m[_]),g&&u.getAttribute("morphNormal"+v)!==g[_]&&u.setAttribute("morphNormal"+v,g[_]),i[v]=I,b+=I):(m&&u.hasAttribute("morphTarget"+v)===!0&&u.deleteAttribute("morphTarget"+v),g&&u.hasAttribute("morphNormal"+v)===!0&&u.deleteAttribute("morphNormal"+v),i[v]=0)}const x=u.morphTargetsRelative?1:1-b;h.getUniforms().setValue(n,"morphTargetBaseInfluence",x),h.getUniforms().setValue(n,"morphTargetInfluences",i)}}return{update:l}}function _O(n,e,t,s){let i=new WeakMap;function r(l){const c=s.render.frame,u=l.geometry,h=e.get(l,u);if(i.get(h)!==c&&(e.update(h),i.set(h,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",o)===!1&&l.addEventListener("dispose",o),i.get(l)!==c&&(t.update(l.instanceMatrix,n.ARRAY_BUFFER),l.instanceColor!==null&&t.update(l.instanceColor,n.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const d=l.skeleton;i.get(d)!==c&&(d.update(),i.set(d,c))}return h}function a(){i=new WeakMap}function o(l){const c=l.target;c.removeEventListener("dispose",o),t.remove(c.instanceMatrix),c.instanceColor!==null&&t.remove(c.instanceColor)}return{update:r,dispose:a}}const P2=new is,D2=new I2,F2=new oP,O2=new A2,S_=[],T_=[],__=new Float32Array(16),I_=new Float32Array(9),M_=new Float32Array(4);function wc(n,e,t){const s=n[0];if(s<=0||s>0)return n;const i=e*t;let r=S_[i];if(r===void 0&&(r=new Float32Array(i),S_[i]=r),e!==0){s.toArray(r,0);for(let a=1,o=0;a!==e;++a)o+=t,n[a].toArray(r,o)}return r}function Fn(n,e){if(n.length!==e.length)return!1;for(let t=0,s=n.length;t<s;t++)if(n[t]!==e[t])return!1;return!0}function On(n,e){for(let t=0,s=e.length;t<s;t++)n[t]=e[t]}function Rm(n,e){let t=T_[e];t===void 0&&(t=new Int32Array(e),T_[e]=t);for(let s=0;s!==e;++s)t[s]=n.allocateTextureUnit();return t}function IO(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function MO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Fn(t,e))return;n.uniform2fv(this.addr,e),On(t,e)}}function CO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Fn(t,e))return;n.uniform3fv(this.addr,e),On(t,e)}}function EO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Fn(t,e))return;n.uniform4fv(this.addr,e),On(t,e)}}function kO(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Fn(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),On(t,e)}else{if(Fn(t,s))return;M_.set(s),n.uniformMatrix2fv(this.addr,!1,M_),On(t,s)}}function NO(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Fn(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),On(t,e)}else{if(Fn(t,s))return;I_.set(s),n.uniformMatrix3fv(this.addr,!1,I_),On(t,s)}}function RO(n,e){const t=this.cache,s=e.elements;if(s===void 0){if(Fn(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),On(t,e)}else{if(Fn(t,s))return;__.set(s),n.uniformMatrix4fv(this.addr,!1,__),On(t,s)}}function AO(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function LO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Fn(t,e))return;n.uniform2iv(this.addr,e),On(t,e)}}function PO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Fn(t,e))return;n.uniform3iv(this.addr,e),On(t,e)}}function DO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Fn(t,e))return;n.uniform4iv(this.addr,e),On(t,e)}}function FO(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function OO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Fn(t,e))return;n.uniform2uiv(this.addr,e),On(t,e)}}function GO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Fn(t,e))return;n.uniform3uiv(this.addr,e),On(t,e)}}function zO(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Fn(t,e))return;n.uniform4uiv(this.addr,e),On(t,e)}}function VO(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2D(e||P2,i)}function WO(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture3D(e||F2,i)}function UO(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTextureCube(e||O2,i)}function BO(n,e,t){const s=this.cache,i=t.allocateTextureUnit();s[0]!==i&&(n.uniform1i(this.addr,i),s[0]=i),t.setTexture2DArray(e||D2,i)}function $O(n){switch(n){case 5126:return IO;case 35664:return MO;case 35665:return CO;case 35666:return EO;case 35674:return kO;case 35675:return NO;case 35676:return RO;case 5124:case 35670:return AO;case 35667:case 35671:return LO;case 35668:case 35672:return PO;case 35669:case 35673:return DO;case 5125:return FO;case 36294:return OO;case 36295:return GO;case 36296:return zO;case 35678:case 36198:case 36298:case 36306:case 35682:return VO;case 35679:case 36299:case 36307:return WO;case 35680:case 36300:case 36308:case 36293:return UO;case 36289:case 36303:case 36311:case 36292:return BO}}function XO(n,e){n.uniform1fv(this.addr,e)}function HO(n,e){const t=wc(e,this.size,2);n.uniform2fv(this.addr,t)}function KO(n,e){const t=wc(e,this.size,3);n.uniform3fv(this.addr,t)}function ZO(n,e){const t=wc(e,this.size,4);n.uniform4fv(this.addr,t)}function YO(n,e){const t=wc(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function jO(n,e){const t=wc(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function QO(n,e){const t=wc(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function JO(n,e){n.uniform1iv(this.addr,e)}function qO(n,e){n.uniform2iv(this.addr,e)}function eG(n,e){n.uniform3iv(this.addr,e)}function tG(n,e){n.uniform4iv(this.addr,e)}function nG(n,e){n.uniform1uiv(this.addr,e)}function sG(n,e){n.uniform2uiv(this.addr,e)}function iG(n,e){n.uniform3uiv(this.addr,e)}function rG(n,e){n.uniform4uiv(this.addr,e)}function aG(n,e,t){const s=this.cache,i=e.length,r=Rm(t,i);Fn(s,r)||(n.uniform1iv(this.addr,r),On(s,r));for(let a=0;a!==i;++a)t.setTexture2D(e[a]||P2,r[a])}function oG(n,e,t){const s=this.cache,i=e.length,r=Rm(t,i);Fn(s,r)||(n.uniform1iv(this.addr,r),On(s,r));for(let a=0;a!==i;++a)t.setTexture3D(e[a]||F2,r[a])}function lG(n,e,t){const s=this.cache,i=e.length,r=Rm(t,i);Fn(s,r)||(n.uniform1iv(this.addr,r),On(s,r));for(let a=0;a!==i;++a)t.setTextureCube(e[a]||O2,r[a])}function cG(n,e,t){const s=this.cache,i=e.length,r=Rm(t,i);Fn(s,r)||(n.uniform1iv(this.addr,r),On(s,r));for(let a=0;a!==i;++a)t.setTexture2DArray(e[a]||D2,r[a])}function uG(n){switch(n){case 5126:return XO;case 35664:return HO;case 35665:return KO;case 35666:return ZO;case 35674:return YO;case 35675:return jO;case 35676:return QO;case 5124:case 35670:return JO;case 35667:case 35671:return qO;case 35668:case 35672:return eG;case 35669:case 35673:return tG;case 5125:return nG;case 36294:return sG;case 36295:return iG;case 36296:return rG;case 35678:case 36198:case 36298:case 36306:case 35682:return aG;case 35679:case 36299:case 36307:return oG;case 35680:case 36300:case 36308:case 36293:return lG;case 36289:case 36303:case 36311:case 36292:return cG}}class hG{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.setValue=$O(t.type)}}class dG{constructor(e,t,s){this.id=e,this.addr=s,this.cache=[],this.size=t.size,this.setValue=uG(t.type)}}class pG{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,s){const i=this.seq;for(let r=0,a=i.length;r!==a;++r){const o=i[r];o.setValue(e,t[o.id],s)}}}const Fb=/(\w+)(\])?(\[|\.)?/g;function C_(n,e){n.seq.push(e),n.map[e.id]=e}function fG(n,e,t){const s=n.name,i=s.length;for(Fb.lastIndex=0;;){const r=Fb.exec(s),a=Fb.lastIndex;let o=r[1];const l=r[2]==="]",c=r[3];if(l&&(o=o|0),c===void 0||c==="["&&a+2===i){C_(t,c===void 0?new hG(o,n,e):new dG(o,n,e));break}else{let h=t.map[o];h===void 0&&(h=new pG(o),C_(t,h)),t=h}}}class Rf{constructor(e,t){this.seq=[],this.map={};const s=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<s;++i){const r=e.getActiveUniform(t,i),a=e.getUniformLocation(t,r.name);fG(r,a,this)}}setValue(e,t,s,i){const r=this.map[t];r!==void 0&&r.setValue(e,s,i)}setOptional(e,t,s){const i=t[s];i!==void 0&&this.setValue(e,s,i)}static upload(e,t,s,i){for(let r=0,a=t.length;r!==a;++r){const o=t[r],l=s[o.id];l.needsUpdate!==!1&&o.setValue(e,l.value,i)}}static seqWithValue(e,t){const s=[];for(let i=0,r=e.length;i!==r;++i){const a=e[i];a.id in t&&s.push(a)}return s}}function E_(n,e,t){const s=n.createShader(e);return n.shaderSource(s,t),n.compileShader(s),s}const mG=37297;let gG=0;function yG(n,e){const t=n.split(`
`),s=[],i=Math.max(e-6,0),r=Math.min(e+6,t.length);for(let a=i;a<r;a++){const o=a+1;s.push(`${o===e?">":" "} ${o}: ${t[a]}`)}return s.join(`
`)}function bG(n){const e=Pt.getPrimaries(Pt.workingColorSpace),t=Pt.getPrimaries(n);let s;switch(e===t?s="":e===Uf&&t===Wf?s="LinearDisplayP3ToLinearSRGB":e===Wf&&t===Uf&&(s="LinearSRGBToLinearDisplayP3"),n){case Kn:case Em:return[s,"LinearTransferOETF"];case an:case Hx:return[s,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[s,"LinearTransferOETF"]}}function k_(n,e,t){const s=n.getShaderParameter(e,n.COMPILE_STATUS),i=n.getShaderInfoLog(e).trim();if(s&&i==="")return"";const r=/ERROR: 0:(\d+)/.exec(i);if(r){const a=parseInt(r[1]);return t.toUpperCase()+`

`+i+`

`+yG(n.getShaderSource(e),a)}else return i}function xG(n,e){const t=bG(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function vG(n,e){let t;switch(e){case d3:t="Linear";break;case p3:t="Reinhard";break;case f3:t="OptimizedCineon";break;case m3:t="ACESFilmic";break;case g3:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}function wG(n){return[n.extensionDerivatives||n.envMapCubeUVHeight||n.bumpMap||n.normalMapTangentSpace||n.clearcoatNormalMap||n.flatShading||n.shaderID==="physical"?"#extension GL_OES_standard_derivatives : enable":"",(n.extensionFragDepth||n.logarithmicDepthBuffer)&&n.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",n.extensionDrawBuffers&&n.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(n.extensionShaderTextureLOD||n.envMap||n.transmission)&&n.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(ch).join(`
`)}function SG(n){const e=[];for(const t in n){const s=n[t];s!==!1&&e.push("#define "+t+" "+s)}return e.join(`
`)}function TG(n,e){const t={},s=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<s;i++){const r=n.getActiveAttrib(e,i),a=r.name;let o=1;r.type===n.FLOAT_MAT2&&(o=2),r.type===n.FLOAT_MAT3&&(o=3),r.type===n.FLOAT_MAT4&&(o=4),t[a]={type:r.type,location:n.getAttribLocation(e,a),locationSize:o}}return t}function ch(n){return n!==""}function N_(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function R_(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const _G=/^[ \t]*#include +<([\w\d./]+)>/gm;function z0(n){return n.replace(_G,MG)}const IG=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function MG(n,e){let t=gt[e];if(t===void 0){const s=IG.get(e);if(s!==void 0)t=gt[s],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,s);else throw new Error("Can not resolve #include <"+e+">")}return z0(t)}const CG=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function A_(n){return n.replace(CG,EG)}function EG(n,e,t,s){let i="";for(let r=parseInt(e);r<parseInt(t);r++)i+=s.replace(/\[\s*i\s*\]/g,"[ "+r+" ]").replace(/UNROLLED_LOOP_INDEX/g,r);return i}function L_(n){let e="precision "+n.precision+` float;
precision `+n.precision+" int;";return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function kG(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===o2?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===VL?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Er&&(e="SHADOWMAP_TYPE_VSM"),e}function NG(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Yl:case jl:e="ENVMAP_TYPE_CUBE";break;case Cm:e="ENVMAP_TYPE_CUBE_UV";break}return e}function RG(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case jl:e="ENVMAP_MODE_REFRACTION";break}return e}function AG(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case l2:e="ENVMAP_BLENDING_MULTIPLY";break;case u3:e="ENVMAP_BLENDING_MIX";break;case h3:e="ENVMAP_BLENDING_ADD";break}return e}function LG(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,s=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:s,maxMip:t}}function PG(n,e,t,s){const i=n.getContext(),r=t.defines;let a=t.vertexShader,o=t.fragmentShader;const l=kG(t),c=NG(t),u=RG(t),h=AG(t),d=LG(t),p=t.isWebGL2?"":wG(t),f=SG(r),y=i.createProgram();let m,g,b=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(ch).join(`
`),m.length>0&&(m+=`
`),g=[p,"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f].filter(ch).join(`
`),g.length>0&&(g+=`
`)):(m=[L_(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors&&t.isWebGL2?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0&&t.isWebGL2?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(ch).join(`
`),g=[p,L_(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,f,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+c:"",t.envMap?"#define "+u:"",t.envMap?"#define "+h:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+l:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.useLegacyLights?"#define LEGACY_LIGHTS":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.logarithmicDepthBuffer&&t.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ta?"#define TONE_MAPPING":"",t.toneMapping!==Ta?gt.tonemapping_pars_fragment:"",t.toneMapping!==Ta?vG("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",gt.colorspace_pars_fragment,xG("linearToOutputTexel",t.outputColorSpace),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(ch).join(`
`)),a=z0(a),a=N_(a,t),a=R_(a,t),o=z0(o),o=N_(o,t),o=R_(o,t),a=A_(a),o=A_(o),t.isWebGL2&&t.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,m=["precision mediump sampler2DArray;","#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,g=["precision mediump sampler2DArray;","#define varying in",t.glslVersion===QT?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===QT?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+g);const x=b+m+a,v=b+g+o,w=E_(i,i.VERTEX_SHADER,x),_=E_(i,i.FRAGMENT_SHADER,v);i.attachShader(y,w),i.attachShader(y,_),t.index0AttributeName!==void 0?i.bindAttribLocation(y,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(y,0,"position"),i.linkProgram(y);function I(A){if(n.debug.checkShaderErrors){const D=i.getProgramInfoLog(y).trim(),F=i.getShaderInfoLog(w).trim(),k=i.getShaderInfoLog(_).trim();let P=!0,O=!0;if(i.getProgramParameter(y,i.LINK_STATUS)===!1)if(P=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,y,w,_);else{const V=k_(i,w,"vertex"),$=k_(i,_,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(y,i.VALIDATE_STATUS)+`

Program Info Log: `+D+`
`+V+`
`+$)}else D!==""?console.warn("THREE.WebGLProgram: Program Info Log:",D):(F===""||k==="")&&(O=!1);O&&(A.diagnostics={runnable:P,programLog:D,vertexShader:{log:F,prefix:m},fragmentShader:{log:k,prefix:g}})}i.deleteShader(w),i.deleteShader(_),C=new Rf(i,y),S=TG(i,y)}let C;this.getUniforms=function(){return C===void 0&&I(this),C};let S;this.getAttributes=function(){return S===void 0&&I(this),S};let M=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return M===!1&&(M=i.getProgramParameter(y,mG)),M},this.destroy=function(){s.releaseStatesOfProgram(this),i.deleteProgram(y),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=gG++,this.cacheKey=e,this.usedTimes=1,this.program=y,this.vertexShader=w,this.fragmentShader=_,this}let DG=0;class FG{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,s=e.fragmentShader,i=this._getShaderStage(t),r=this._getShaderStage(s),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(r)===!1&&(a.add(r),r.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const s of t)s.usedTimes--,s.usedTimes===0&&this.shaderCache.delete(s.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let s=t.get(e);return s===void 0&&(s=new Set,t.set(e,s)),s}_getShaderStage(e){const t=this.shaderCache;let s=t.get(e);return s===void 0&&(s=new OG(e),t.set(e,s)),s}}class OG{constructor(e){this.id=DG++,this.code=e,this.usedTimes=0}}function GG(n,e,t,s,i,r,a){const o=new M2,l=new FG,c=[],u=i.isWebGL2,h=i.logarithmicDepthBuffer,d=i.vertexTextures;let p=i.precision;const f={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function y(S){return S===0?"uv":`uv${S}`}function m(S,M,A,D,F){const k=D.fog,P=F.geometry,O=S.isMeshStandardMaterial?D.environment:null,V=(S.isMeshStandardMaterial?t:e).get(S.envMap||O),$=V&&V.mapping===Cm?V.image.height:null,H=f[S.type];S.precision!==null&&(p=i.getMaxPrecision(S.precision),p!==S.precision&&console.warn("THREE.WebGLProgram.getParameters:",S.precision,"not supported, using",p,"instead."));const Y=P.morphAttributes.position||P.morphAttributes.normal||P.morphAttributes.color,G=Y!==void 0?Y.length:0;let B=0;P.morphAttributes.position!==void 0&&(B=1),P.morphAttributes.normal!==void 0&&(B=2),P.morphAttributes.color!==void 0&&(B=3);let te,se,ae,fe;if(H){const _n=er[H];te=_n.vertexShader,se=_n.fragmentShader}else te=S.vertexShader,se=S.fragmentShader,l.update(S),ae=l.getVertexShaderID(S),fe=l.getFragmentShaderID(S);const be=n.getRenderTarget(),ge=F.isInstancedMesh===!0,ve=!!S.map,Oe=!!S.matcap,Ce=!!V,q=!!S.aoMap,vt=!!S.lightMap,Ee=!!S.bumpMap,Le=!!S.normalMap,Ae=!!S.displacementMap,Ye=!!S.emissiveMap,$e=!!S.metalnessMap,Je=!!S.roughnessMap,at=S.anisotropy>0,Vt=S.clearcoat>0,Dt=S.iridescence>0,z=S.sheen>0,R=S.transmission>0,ie=at&&!!S.anisotropyMap,ye=Vt&&!!S.clearcoatMap,me=Vt&&!!S.clearcoatNormalMap,xe=Vt&&!!S.clearcoatRoughnessMap,Xe=Dt&&!!S.iridescenceMap,_e=Dt&&!!S.iridescenceThicknessMap,De=z&&!!S.sheenColorMap,tt=z&&!!S.sheenRoughnessMap,It=!!S.specularMap,we=!!S.specularColorMap,Ft=!!S.specularIntensityMap,ht=R&&!!S.transmissionMap,it=R&&!!S.thicknessMap,je=!!S.gradientMap,We=!!S.alphaMap,Nt=S.alphaTest>0,Q=!!S.alphaHash,Pe=!!S.extensions,Te=!!P.attributes.uv1,he=!!P.attributes.uv2,Ie=!!P.attributes.uv3;let qe=Ta;return S.toneMapped&&(be===null||be.isXRRenderTarget===!0)&&(qe=n.toneMapping),{isWebGL2:u,shaderID:H,shaderType:S.type,shaderName:S.name,vertexShader:te,fragmentShader:se,defines:S.defines,customVertexShaderID:ae,customFragmentShaderID:fe,isRawShaderMaterial:S.isRawShaderMaterial===!0,glslVersion:S.glslVersion,precision:p,instancing:ge,instancingColor:ge&&F.instanceColor!==null,supportsVertexTextures:d,outputColorSpace:be===null?n.outputColorSpace:be.isXRRenderTarget===!0?be.texture.colorSpace:Kn,map:ve,matcap:Oe,envMap:Ce,envMapMode:Ce&&V.mapping,envMapCubeUVHeight:$,aoMap:q,lightMap:vt,bumpMap:Ee,normalMap:Le,displacementMap:d&&Ae,emissiveMap:Ye,normalMapObjectSpace:Le&&S.normalMapType===L3,normalMapTangentSpace:Le&&S.normalMapType===v2,metalnessMap:$e,roughnessMap:Je,anisotropy:at,anisotropyMap:ie,clearcoat:Vt,clearcoatMap:ye,clearcoatNormalMap:me,clearcoatRoughnessMap:xe,iridescence:Dt,iridescenceMap:Xe,iridescenceThicknessMap:_e,sheen:z,sheenColorMap:De,sheenRoughnessMap:tt,specularMap:It,specularColorMap:we,specularIntensityMap:Ft,transmission:R,transmissionMap:ht,thicknessMap:it,gradientMap:je,opaque:S.transparent===!1&&S.blending===Vl,alphaMap:We,alphaTest:Nt,alphaHash:Q,combine:S.combine,mapUv:ve&&y(S.map.channel),aoMapUv:q&&y(S.aoMap.channel),lightMapUv:vt&&y(S.lightMap.channel),bumpMapUv:Ee&&y(S.bumpMap.channel),normalMapUv:Le&&y(S.normalMap.channel),displacementMapUv:Ae&&y(S.displacementMap.channel),emissiveMapUv:Ye&&y(S.emissiveMap.channel),metalnessMapUv:$e&&y(S.metalnessMap.channel),roughnessMapUv:Je&&y(S.roughnessMap.channel),anisotropyMapUv:ie&&y(S.anisotropyMap.channel),clearcoatMapUv:ye&&y(S.clearcoatMap.channel),clearcoatNormalMapUv:me&&y(S.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:xe&&y(S.clearcoatRoughnessMap.channel),iridescenceMapUv:Xe&&y(S.iridescenceMap.channel),iridescenceThicknessMapUv:_e&&y(S.iridescenceThicknessMap.channel),sheenColorMapUv:De&&y(S.sheenColorMap.channel),sheenRoughnessMapUv:tt&&y(S.sheenRoughnessMap.channel),specularMapUv:It&&y(S.specularMap.channel),specularColorMapUv:we&&y(S.specularColorMap.channel),specularIntensityMapUv:Ft&&y(S.specularIntensityMap.channel),transmissionMapUv:ht&&y(S.transmissionMap.channel),thicknessMapUv:it&&y(S.thicknessMap.channel),alphaMapUv:We&&y(S.alphaMap.channel),vertexTangents:!!P.attributes.tangent&&(Le||at),vertexColors:S.vertexColors,vertexAlphas:S.vertexColors===!0&&!!P.attributes.color&&P.attributes.color.itemSize===4,vertexUv1s:Te,vertexUv2s:he,vertexUv3s:Ie,pointsUvs:F.isPoints===!0&&!!P.attributes.uv&&(ve||We),fog:!!k,useFog:S.fog===!0,fogExp2:k&&k.isFogExp2,flatShading:S.flatShading===!0,sizeAttenuation:S.sizeAttenuation===!0,logarithmicDepthBuffer:h,skinning:F.isSkinnedMesh===!0,morphTargets:P.morphAttributes.position!==void 0,morphNormals:P.morphAttributes.normal!==void 0,morphColors:P.morphAttributes.color!==void 0,morphTargetsCount:G,morphTextureStride:B,numDirLights:M.directional.length,numPointLights:M.point.length,numSpotLights:M.spot.length,numSpotLightMaps:M.spotLightMap.length,numRectAreaLights:M.rectArea.length,numHemiLights:M.hemi.length,numDirLightShadows:M.directionalShadowMap.length,numPointLightShadows:M.pointShadowMap.length,numSpotLightShadows:M.spotShadowMap.length,numSpotLightShadowsWithMaps:M.numSpotLightShadowsWithMaps,numLightProbes:M.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:S.dithering,shadowMapEnabled:n.shadowMap.enabled&&A.length>0,shadowMapType:n.shadowMap.type,toneMapping:qe,useLegacyLights:n._useLegacyLights,decodeVideoTexture:ve&&S.map.isVideoTexture===!0&&Pt.getTransfer(S.map.colorSpace)===qt,premultipliedAlpha:S.premultipliedAlpha,doubleSided:S.side===Pi,flipSided:S.side===Ws,useDepthPacking:S.depthPacking>=0,depthPacking:S.depthPacking||0,index0AttributeName:S.index0AttributeName,extensionDerivatives:Pe&&S.extensions.derivatives===!0,extensionFragDepth:Pe&&S.extensions.fragDepth===!0,extensionDrawBuffers:Pe&&S.extensions.drawBuffers===!0,extensionShaderTextureLOD:Pe&&S.extensions.shaderTextureLOD===!0,rendererExtensionFragDepth:u||s.has("EXT_frag_depth"),rendererExtensionDrawBuffers:u||s.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:u||s.has("EXT_shader_texture_lod"),rendererExtensionParallelShaderCompile:s.has("KHR_parallel_shader_compile"),customProgramCacheKey:S.customProgramCacheKey()}}function g(S){const M=[];if(S.shaderID?M.push(S.shaderID):(M.push(S.customVertexShaderID),M.push(S.customFragmentShaderID)),S.defines!==void 0)for(const A in S.defines)M.push(A),M.push(S.defines[A]);return S.isRawShaderMaterial===!1&&(b(M,S),x(M,S),M.push(n.outputColorSpace)),M.push(S.customProgramCacheKey),M.join()}function b(S,M){S.push(M.precision),S.push(M.outputColorSpace),S.push(M.envMapMode),S.push(M.envMapCubeUVHeight),S.push(M.mapUv),S.push(M.alphaMapUv),S.push(M.lightMapUv),S.push(M.aoMapUv),S.push(M.bumpMapUv),S.push(M.normalMapUv),S.push(M.displacementMapUv),S.push(M.emissiveMapUv),S.push(M.metalnessMapUv),S.push(M.roughnessMapUv),S.push(M.anisotropyMapUv),S.push(M.clearcoatMapUv),S.push(M.clearcoatNormalMapUv),S.push(M.clearcoatRoughnessMapUv),S.push(M.iridescenceMapUv),S.push(M.iridescenceThicknessMapUv),S.push(M.sheenColorMapUv),S.push(M.sheenRoughnessMapUv),S.push(M.specularMapUv),S.push(M.specularColorMapUv),S.push(M.specularIntensityMapUv),S.push(M.transmissionMapUv),S.push(M.thicknessMapUv),S.push(M.combine),S.push(M.fogExp2),S.push(M.sizeAttenuation),S.push(M.morphTargetsCount),S.push(M.morphAttributeCount),S.push(M.numDirLights),S.push(M.numPointLights),S.push(M.numSpotLights),S.push(M.numSpotLightMaps),S.push(M.numHemiLights),S.push(M.numRectAreaLights),S.push(M.numDirLightShadows),S.push(M.numPointLightShadows),S.push(M.numSpotLightShadows),S.push(M.numSpotLightShadowsWithMaps),S.push(M.numLightProbes),S.push(M.shadowMapType),S.push(M.toneMapping),S.push(M.numClippingPlanes),S.push(M.numClipIntersection),S.push(M.depthPacking)}function x(S,M){o.disableAll(),M.isWebGL2&&o.enable(0),M.supportsVertexTextures&&o.enable(1),M.instancing&&o.enable(2),M.instancingColor&&o.enable(3),M.matcap&&o.enable(4),M.envMap&&o.enable(5),M.normalMapObjectSpace&&o.enable(6),M.normalMapTangentSpace&&o.enable(7),M.clearcoat&&o.enable(8),M.iridescence&&o.enable(9),M.alphaTest&&o.enable(10),M.vertexColors&&o.enable(11),M.vertexAlphas&&o.enable(12),M.vertexUv1s&&o.enable(13),M.vertexUv2s&&o.enable(14),M.vertexUv3s&&o.enable(15),M.vertexTangents&&o.enable(16),M.anisotropy&&o.enable(17),M.alphaHash&&o.enable(18),S.push(o.mask),o.disableAll(),M.fog&&o.enable(0),M.useFog&&o.enable(1),M.flatShading&&o.enable(2),M.logarithmicDepthBuffer&&o.enable(3),M.skinning&&o.enable(4),M.morphTargets&&o.enable(5),M.morphNormals&&o.enable(6),M.morphColors&&o.enable(7),M.premultipliedAlpha&&o.enable(8),M.shadowMapEnabled&&o.enable(9),M.useLegacyLights&&o.enable(10),M.doubleSided&&o.enable(11),M.flipSided&&o.enable(12),M.useDepthPacking&&o.enable(13),M.dithering&&o.enable(14),M.transmission&&o.enable(15),M.sheen&&o.enable(16),M.opaque&&o.enable(17),M.pointsUvs&&o.enable(18),M.decodeVideoTexture&&o.enable(19),S.push(o.mask)}function v(S){const M=f[S.type];let A;if(M){const D=er[M];A=TP.clone(D.uniforms)}else A=S.uniforms;return A}function w(S,M){let A;for(let D=0,F=c.length;D<F;D++){const k=c[D];if(k.cacheKey===M){A=k,++A.usedTimes;break}}return A===void 0&&(A=new PG(n,M,S,r),c.push(A)),A}function _(S){if(--S.usedTimes===0){const M=c.indexOf(S);c[M]=c[c.length-1],c.pop(),S.destroy()}}function I(S){l.remove(S)}function C(){l.dispose()}return{getParameters:m,getProgramCacheKey:g,getUniforms:v,acquireProgram:w,releaseProgram:_,releaseShaderCache:I,programs:c,dispose:C}}function zG(){let n=new WeakMap;function e(r){let a=n.get(r);return a===void 0&&(a={},n.set(r,a)),a}function t(r){n.delete(r)}function s(r,a,o){n.get(r)[a]=o}function i(){n=new WeakMap}return{get:e,remove:t,update:s,dispose:i}}function VG(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function P_(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function D_(){const n=[];let e=0;const t=[],s=[],i=[];function r(){e=0,t.length=0,s.length=0,i.length=0}function a(h,d,p,f,y,m){let g=n[e];return g===void 0?(g={id:h.id,object:h,geometry:d,material:p,groupOrder:f,renderOrder:h.renderOrder,z:y,group:m},n[e]=g):(g.id=h.id,g.object=h,g.geometry=d,g.material=p,g.groupOrder=f,g.renderOrder=h.renderOrder,g.z=y,g.group=m),e++,g}function o(h,d,p,f,y,m){const g=a(h,d,p,f,y,m);p.transmission>0?s.push(g):p.transparent===!0?i.push(g):t.push(g)}function l(h,d,p,f,y,m){const g=a(h,d,p,f,y,m);p.transmission>0?s.unshift(g):p.transparent===!0?i.unshift(g):t.unshift(g)}function c(h,d){t.length>1&&t.sort(h||VG),s.length>1&&s.sort(d||P_),i.length>1&&i.sort(d||P_)}function u(){for(let h=e,d=n.length;h<d;h++){const p=n[h];if(p.id===null)break;p.id=null,p.object=null,p.geometry=null,p.material=null,p.group=null}}return{opaque:t,transmissive:s,transparent:i,init:r,push:o,unshift:l,finish:u,sort:c}}function WG(){let n=new WeakMap;function e(s,i){const r=n.get(s);let a;return r===void 0?(a=new D_,n.set(s,[a])):i>=r.length?(a=new D_,r.push(a)):a=r[i],a}function t(){n=new WeakMap}return{get:e,dispose:t}}function UG(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new J,color:new lt};break;case"SpotLight":t={position:new J,direction:new J,color:new lt,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new J,color:new lt,distance:0,decay:0};break;case"HemisphereLight":t={direction:new J,skyColor:new lt,groundColor:new lt};break;case"RectAreaLight":t={color:new lt,position:new J,halfWidth:new J,halfHeight:new J};break}return n[e.id]=t,t}}}function BG(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Rt};break;case"SpotLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Rt};break;case"PointLight":t={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Rt,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let $G=0;function XG(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function HG(n,e){const t=new UG,s=BG(),i={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let u=0;u<9;u++)i.probe.push(new J);const r=new J,a=new ot,o=new ot;function l(u,h){let d=0,p=0,f=0;for(let D=0;D<9;D++)i.probe[D].set(0,0,0);let y=0,m=0,g=0,b=0,x=0,v=0,w=0,_=0,I=0,C=0,S=0;u.sort(XG);const M=h===!0?Math.PI:1;for(let D=0,F=u.length;D<F;D++){const k=u[D],P=k.color,O=k.intensity,V=k.distance,$=k.shadow&&k.shadow.map?k.shadow.map.texture:null;if(k.isAmbientLight)d+=P.r*O*M,p+=P.g*O*M,f+=P.b*O*M;else if(k.isLightProbe){for(let H=0;H<9;H++)i.probe[H].addScaledVector(k.sh.coefficients[H],O);S++}else if(k.isDirectionalLight){const H=t.get(k);if(H.color.copy(k.color).multiplyScalar(k.intensity*M),k.castShadow){const Y=k.shadow,G=s.get(k);G.shadowBias=Y.bias,G.shadowNormalBias=Y.normalBias,G.shadowRadius=Y.radius,G.shadowMapSize=Y.mapSize,i.directionalShadow[y]=G,i.directionalShadowMap[y]=$,i.directionalShadowMatrix[y]=k.shadow.matrix,v++}i.directional[y]=H,y++}else if(k.isSpotLight){const H=t.get(k);H.position.setFromMatrixPosition(k.matrixWorld),H.color.copy(P).multiplyScalar(O*M),H.distance=V,H.coneCos=Math.cos(k.angle),H.penumbraCos=Math.cos(k.angle*(1-k.penumbra)),H.decay=k.decay,i.spot[g]=H;const Y=k.shadow;if(k.map&&(i.spotLightMap[I]=k.map,I++,Y.updateMatrices(k),k.castShadow&&C++),i.spotLightMatrix[g]=Y.matrix,k.castShadow){const G=s.get(k);G.shadowBias=Y.bias,G.shadowNormalBias=Y.normalBias,G.shadowRadius=Y.radius,G.shadowMapSize=Y.mapSize,i.spotShadow[g]=G,i.spotShadowMap[g]=$,_++}g++}else if(k.isRectAreaLight){const H=t.get(k);H.color.copy(P).multiplyScalar(O),H.halfWidth.set(k.width*.5,0,0),H.halfHeight.set(0,k.height*.5,0),i.rectArea[b]=H,b++}else if(k.isPointLight){const H=t.get(k);if(H.color.copy(k.color).multiplyScalar(k.intensity*M),H.distance=k.distance,H.decay=k.decay,k.castShadow){const Y=k.shadow,G=s.get(k);G.shadowBias=Y.bias,G.shadowNormalBias=Y.normalBias,G.shadowRadius=Y.radius,G.shadowMapSize=Y.mapSize,G.shadowCameraNear=Y.camera.near,G.shadowCameraFar=Y.camera.far,i.pointShadow[m]=G,i.pointShadowMap[m]=$,i.pointShadowMatrix[m]=k.shadow.matrix,w++}i.point[m]=H,m++}else if(k.isHemisphereLight){const H=t.get(k);H.skyColor.copy(k.color).multiplyScalar(O*M),H.groundColor.copy(k.groundColor).multiplyScalar(O*M),i.hemi[x]=H,x++}}b>0&&(e.isWebGL2||n.has("OES_texture_float_linear")===!0?(i.rectAreaLTC1=ke.LTC_FLOAT_1,i.rectAreaLTC2=ke.LTC_FLOAT_2):n.has("OES_texture_half_float_linear")===!0?(i.rectAreaLTC1=ke.LTC_HALF_1,i.rectAreaLTC2=ke.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.")),i.ambient[0]=d,i.ambient[1]=p,i.ambient[2]=f;const A=i.hash;(A.directionalLength!==y||A.pointLength!==m||A.spotLength!==g||A.rectAreaLength!==b||A.hemiLength!==x||A.numDirectionalShadows!==v||A.numPointShadows!==w||A.numSpotShadows!==_||A.numSpotMaps!==I||A.numLightProbes!==S)&&(i.directional.length=y,i.spot.length=g,i.rectArea.length=b,i.point.length=m,i.hemi.length=x,i.directionalShadow.length=v,i.directionalShadowMap.length=v,i.pointShadow.length=w,i.pointShadowMap.length=w,i.spotShadow.length=_,i.spotShadowMap.length=_,i.directionalShadowMatrix.length=v,i.pointShadowMatrix.length=w,i.spotLightMatrix.length=_+I-C,i.spotLightMap.length=I,i.numSpotLightShadowsWithMaps=C,i.numLightProbes=S,A.directionalLength=y,A.pointLength=m,A.spotLength=g,A.rectAreaLength=b,A.hemiLength=x,A.numDirectionalShadows=v,A.numPointShadows=w,A.numSpotShadows=_,A.numSpotMaps=I,A.numLightProbes=S,i.version=$G++)}function c(u,h){let d=0,p=0,f=0,y=0,m=0;const g=h.matrixWorldInverse;for(let b=0,x=u.length;b<x;b++){const v=u[b];if(v.isDirectionalLight){const w=i.directional[d];w.direction.setFromMatrixPosition(v.matrixWorld),r.setFromMatrixPosition(v.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(g),d++}else if(v.isSpotLight){const w=i.spot[f];w.position.setFromMatrixPosition(v.matrixWorld),w.position.applyMatrix4(g),w.direction.setFromMatrixPosition(v.matrixWorld),r.setFromMatrixPosition(v.target.matrixWorld),w.direction.sub(r),w.direction.transformDirection(g),f++}else if(v.isRectAreaLight){const w=i.rectArea[y];w.position.setFromMatrixPosition(v.matrixWorld),w.position.applyMatrix4(g),o.identity(),a.copy(v.matrixWorld),a.premultiply(g),o.extractRotation(a),w.halfWidth.set(v.width*.5,0,0),w.halfHeight.set(0,v.height*.5,0),w.halfWidth.applyMatrix4(o),w.halfHeight.applyMatrix4(o),y++}else if(v.isPointLight){const w=i.point[p];w.position.setFromMatrixPosition(v.matrixWorld),w.position.applyMatrix4(g),p++}else if(v.isHemisphereLight){const w=i.hemi[m];w.direction.setFromMatrixPosition(v.matrixWorld),w.direction.transformDirection(g),m++}}}return{setup:l,setupView:c,state:i}}function F_(n,e){const t=new HG(n,e),s=[],i=[];function r(){s.length=0,i.length=0}function a(h){s.push(h)}function o(h){i.push(h)}function l(h){t.setup(s,h)}function c(h){t.setupView(s,h)}return{init:r,state:{lightsArray:s,shadowsArray:i,lights:t},setupLights:l,setupLightsView:c,pushLight:a,pushShadow:o}}function KG(n,e){let t=new WeakMap;function s(r,a=0){const o=t.get(r);let l;return o===void 0?(l=new F_(n,e),t.set(r,[l])):a>=o.length?(l=new F_(n,e),o.push(l)):l=o[a],l}function i(){t=new WeakMap}return{get:s,dispose:i}}class ZG extends lr{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=R3,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class YG extends lr{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const jG=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,QG=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function JG(n,e,t){let s=new Zx;const i=new Rt,r=new Rt,a=new Xt,o=new ZG({depthPacking:A3}),l=new YG,c={},u=t.maxTextureSize,h={[Wr]:Ws,[Ws]:Wr,[Pi]:Pi},d=new No({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Rt},radius:{value:4}},vertexShader:jG,fragmentShader:QG}),p=d.clone();p.defines.HORIZONTAL_PASS=1;const f=new br;f.setAttribute("position",new Ms(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const y=new bi(f,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=o2;let g=this.type;this.render=function(w,_,I){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||w.length===0)return;const C=n.getRenderTarget(),S=n.getActiveCubeFace(),M=n.getActiveMipmapLevel(),A=n.state;A.setBlending(Sa),A.buffers.color.setClear(1,1,1,1),A.buffers.depth.setTest(!0),A.setScissorTest(!1);const D=g!==Er&&this.type===Er,F=g===Er&&this.type!==Er;for(let k=0,P=w.length;k<P;k++){const O=w[k],V=O.shadow;if(V===void 0){console.warn("THREE.WebGLShadowMap:",O,"has no shadow.");continue}if(V.autoUpdate===!1&&V.needsUpdate===!1)continue;i.copy(V.mapSize);const $=V.getFrameExtents();if(i.multiply($),r.copy(V.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(r.x=Math.floor(u/$.x),i.x=r.x*$.x,V.mapSize.x=r.x),i.y>u&&(r.y=Math.floor(u/$.y),i.y=r.y*$.y,V.mapSize.y=r.y)),V.map===null||D===!0||F===!0){const Y=this.type!==Er?{minFilter:$n,magFilter:$n}:{};V.map!==null&&V.map.dispose(),V.map=new ko(i.x,i.y,Y),V.map.texture.name=O.name+".shadowMap",V.camera.updateProjectionMatrix()}n.setRenderTarget(V.map),n.clear();const H=V.getViewportCount();for(let Y=0;Y<H;Y++){const G=V.getViewport(Y);a.set(r.x*G.x,r.y*G.y,r.x*G.z,r.y*G.w),A.viewport(a),V.updateMatrices(O,Y),s=V.getFrustum(),v(_,I,V.camera,O,this.type)}V.isPointLightShadow!==!0&&this.type===Er&&b(V,I),V.needsUpdate=!1}g=this.type,m.needsUpdate=!1,n.setRenderTarget(C,S,M)};function b(w,_){const I=e.update(y);d.defines.VSM_SAMPLES!==w.blurSamples&&(d.defines.VSM_SAMPLES=w.blurSamples,p.defines.VSM_SAMPLES=w.blurSamples,d.needsUpdate=!0,p.needsUpdate=!0),w.mapPass===null&&(w.mapPass=new ko(i.x,i.y)),d.uniforms.shadow_pass.value=w.map.texture,d.uniforms.resolution.value=w.mapSize,d.uniforms.radius.value=w.radius,n.setRenderTarget(w.mapPass),n.clear(),n.renderBufferDirect(_,null,I,d,y,null),p.uniforms.shadow_pass.value=w.mapPass.texture,p.uniforms.resolution.value=w.mapSize,p.uniforms.radius.value=w.radius,n.setRenderTarget(w.map),n.clear(),n.renderBufferDirect(_,null,I,p,y,null)}function x(w,_,I,C){let S=null;const M=I.isPointLight===!0?w.customDistanceMaterial:w.customDepthMaterial;if(M!==void 0)S=M;else if(S=I.isPointLight===!0?l:o,n.localClippingEnabled&&_.clipShadows===!0&&Array.isArray(_.clippingPlanes)&&_.clippingPlanes.length!==0||_.displacementMap&&_.displacementScale!==0||_.alphaMap&&_.alphaTest>0||_.map&&_.alphaTest>0){const A=S.uuid,D=_.uuid;let F=c[A];F===void 0&&(F={},c[A]=F);let k=F[D];k===void 0&&(k=S.clone(),F[D]=k),S=k}if(S.visible=_.visible,S.wireframe=_.wireframe,C===Er?S.side=_.shadowSide!==null?_.shadowSide:_.side:S.side=_.shadowSide!==null?_.shadowSide:h[_.side],S.alphaMap=_.alphaMap,S.alphaTest=_.alphaTest,S.map=_.map,S.clipShadows=_.clipShadows,S.clippingPlanes=_.clippingPlanes,S.clipIntersection=_.clipIntersection,S.displacementMap=_.displacementMap,S.displacementScale=_.displacementScale,S.displacementBias=_.displacementBias,S.wireframeLinewidth=_.wireframeLinewidth,S.linewidth=_.linewidth,I.isPointLight===!0&&S.isMeshDistanceMaterial===!0){const A=n.properties.get(S);A.light=I}return S}function v(w,_,I,C,S){if(w.visible===!1)return;if(w.layers.test(_.layers)&&(w.isMesh||w.isLine||w.isPoints)&&(w.castShadow||w.receiveShadow&&S===Er)&&(!w.frustumCulled||s.intersectsObject(w))){w.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,w.matrixWorld);const D=e.update(w),F=w.material;if(Array.isArray(F)){const k=D.groups;for(let P=0,O=k.length;P<O;P++){const V=k[P],$=F[V.materialIndex];if($&&$.visible){const H=x(w,$,C,S);n.renderBufferDirect(I,null,D,H,w,V)}}}else if(F.visible){const k=x(w,F,C,S);n.renderBufferDirect(I,null,D,k,w,null)}}const A=w.children;for(let D=0,F=A.length;D<F;D++)v(A[D],_,I,C,S)}}function qG(n,e,t){const s=t.isWebGL2;function i(){let Q=!1;const Pe=new Xt;let Te=null;const he=new Xt(0,0,0,0);return{setMask:function(Ie){Te!==Ie&&!Q&&(n.colorMask(Ie,Ie,Ie,Ie),Te=Ie)},setLocked:function(Ie){Q=Ie},setClear:function(Ie,qe,Lt,_n,li){li===!0&&(Ie*=_n,qe*=_n,Lt*=_n),Pe.set(Ie,qe,Lt,_n),he.equals(Pe)===!1&&(n.clearColor(Ie,qe,Lt,_n),he.copy(Pe))},reset:function(){Q=!1,Te=null,he.set(-1,0,0,0)}}}function r(){let Q=!1,Pe=null,Te=null,he=null;return{setTest:function(Ie){Ie?ve(n.DEPTH_TEST):Oe(n.DEPTH_TEST)},setMask:function(Ie){Pe!==Ie&&!Q&&(n.depthMask(Ie),Pe=Ie)},setFunc:function(Ie){if(Te!==Ie){switch(Ie){case s3:n.depthFunc(n.NEVER);break;case i3:n.depthFunc(n.ALWAYS);break;case r3:n.depthFunc(n.LESS);break;case Ff:n.depthFunc(n.LEQUAL);break;case a3:n.depthFunc(n.EQUAL);break;case o3:n.depthFunc(n.GEQUAL);break;case l3:n.depthFunc(n.GREATER);break;case c3:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}Te=Ie}},setLocked:function(Ie){Q=Ie},setClear:function(Ie){he!==Ie&&(n.clearDepth(Ie),he=Ie)},reset:function(){Q=!1,Pe=null,Te=null,he=null}}}function a(){let Q=!1,Pe=null,Te=null,he=null,Ie=null,qe=null,Lt=null,_n=null,li=null;return{setTest:function(Zt){Q||(Zt?ve(n.STENCIL_TEST):Oe(n.STENCIL_TEST))},setMask:function(Zt){Pe!==Zt&&!Q&&(n.stencilMask(Zt),Pe=Zt)},setFunc:function(Zt,xs,Zi){(Te!==Zt||he!==xs||Ie!==Zi)&&(n.stencilFunc(Zt,xs,Zi),Te=Zt,he=xs,Ie=Zi)},setOp:function(Zt,xs,Zi){(qe!==Zt||Lt!==xs||_n!==Zi)&&(n.stencilOp(Zt,xs,Zi),qe=Zt,Lt=xs,_n=Zi)},setLocked:function(Zt){Q=Zt},setClear:function(Zt){li!==Zt&&(n.clearStencil(Zt),li=Zt)},reset:function(){Q=!1,Pe=null,Te=null,he=null,Ie=null,qe=null,Lt=null,_n=null,li=null}}}const o=new i,l=new r,c=new a,u=new WeakMap,h=new WeakMap;let d={},p={},f=new WeakMap,y=[],m=null,g=!1,b=null,x=null,v=null,w=null,_=null,I=null,C=null,S=new lt(0,0,0),M=0,A=!1,D=null,F=null,k=null,P=null,O=null;const V=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let $=!1,H=0;const Y=n.getParameter(n.VERSION);Y.indexOf("WebGL")!==-1?(H=parseFloat(/^WebGL (\d)/.exec(Y)[1]),$=H>=1):Y.indexOf("OpenGL ES")!==-1&&(H=parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]),$=H>=2);let G=null,B={};const te=n.getParameter(n.SCISSOR_BOX),se=n.getParameter(n.VIEWPORT),ae=new Xt().fromArray(te),fe=new Xt().fromArray(se);function be(Q,Pe,Te,he){const Ie=new Uint8Array(4),qe=n.createTexture();n.bindTexture(Q,qe),n.texParameteri(Q,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(Q,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let Lt=0;Lt<Te;Lt++)s&&(Q===n.TEXTURE_3D||Q===n.TEXTURE_2D_ARRAY)?n.texImage3D(Pe,0,n.RGBA,1,1,he,0,n.RGBA,n.UNSIGNED_BYTE,Ie):n.texImage2D(Pe+Lt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,Ie);return qe}const ge={};ge[n.TEXTURE_2D]=be(n.TEXTURE_2D,n.TEXTURE_2D,1),ge[n.TEXTURE_CUBE_MAP]=be(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),s&&(ge[n.TEXTURE_2D_ARRAY]=be(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),ge[n.TEXTURE_3D]=be(n.TEXTURE_3D,n.TEXTURE_3D,1,1)),o.setClear(0,0,0,1),l.setClear(1),c.setClear(0),ve(n.DEPTH_TEST),l.setFunc(Ff),$e(!1),Je(bT),ve(n.CULL_FACE),Ae(Sa);function ve(Q){d[Q]!==!0&&(n.enable(Q),d[Q]=!0)}function Oe(Q){d[Q]!==!1&&(n.disable(Q),d[Q]=!1)}function Ce(Q,Pe){return p[Q]!==Pe?(n.bindFramebuffer(Q,Pe),p[Q]=Pe,s&&(Q===n.DRAW_FRAMEBUFFER&&(p[n.FRAMEBUFFER]=Pe),Q===n.FRAMEBUFFER&&(p[n.DRAW_FRAMEBUFFER]=Pe)),!0):!1}function q(Q,Pe){let Te=y,he=!1;if(Q)if(Te=f.get(Pe),Te===void 0&&(Te=[],f.set(Pe,Te)),Q.isWebGLMultipleRenderTargets){const Ie=Q.texture;if(Te.length!==Ie.length||Te[0]!==n.COLOR_ATTACHMENT0){for(let qe=0,Lt=Ie.length;qe<Lt;qe++)Te[qe]=n.COLOR_ATTACHMENT0+qe;Te.length=Ie.length,he=!0}}else Te[0]!==n.COLOR_ATTACHMENT0&&(Te[0]=n.COLOR_ATTACHMENT0,he=!0);else Te[0]!==n.BACK&&(Te[0]=n.BACK,he=!0);he&&(t.isWebGL2?n.drawBuffers(Te):e.get("WEBGL_draw_buffers").drawBuffersWEBGL(Te))}function vt(Q){return m!==Q?(n.useProgram(Q),m=Q,!0):!1}const Ee={[fo]:n.FUNC_ADD,[UL]:n.FUNC_SUBTRACT,[BL]:n.FUNC_REVERSE_SUBTRACT};if(s)Ee[ST]=n.MIN,Ee[TT]=n.MAX;else{const Q=e.get("EXT_blend_minmax");Q!==null&&(Ee[ST]=Q.MIN_EXT,Ee[TT]=Q.MAX_EXT)}const Le={[$L]:n.ZERO,[XL]:n.ONE,[HL]:n.SRC_COLOR,[R0]:n.SRC_ALPHA,[JL]:n.SRC_ALPHA_SATURATE,[jL]:n.DST_COLOR,[ZL]:n.DST_ALPHA,[KL]:n.ONE_MINUS_SRC_COLOR,[A0]:n.ONE_MINUS_SRC_ALPHA,[QL]:n.ONE_MINUS_DST_COLOR,[YL]:n.ONE_MINUS_DST_ALPHA,[qL]:n.CONSTANT_COLOR,[e3]:n.ONE_MINUS_CONSTANT_COLOR,[t3]:n.CONSTANT_ALPHA,[n3]:n.ONE_MINUS_CONSTANT_ALPHA};function Ae(Q,Pe,Te,he,Ie,qe,Lt,_n,li,Zt){if(Q===Sa){g===!0&&(Oe(n.BLEND),g=!1);return}if(g===!1&&(ve(n.BLEND),g=!0),Q!==WL){if(Q!==b||Zt!==A){if((x!==fo||_!==fo)&&(n.blendEquation(n.FUNC_ADD),x=fo,_=fo),Zt)switch(Q){case Vl:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case xT:n.blendFunc(n.ONE,n.ONE);break;case vT:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case wT:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",Q);break}else switch(Q){case Vl:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case xT:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case vT:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case wT:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",Q);break}v=null,w=null,I=null,C=null,S.set(0,0,0),M=0,b=Q,A=Zt}return}Ie=Ie||Pe,qe=qe||Te,Lt=Lt||he,(Pe!==x||Ie!==_)&&(n.blendEquationSeparate(Ee[Pe],Ee[Ie]),x=Pe,_=Ie),(Te!==v||he!==w||qe!==I||Lt!==C)&&(n.blendFuncSeparate(Le[Te],Le[he],Le[qe],Le[Lt]),v=Te,w=he,I=qe,C=Lt),(_n.equals(S)===!1||li!==M)&&(n.blendColor(_n.r,_n.g,_n.b,li),S.copy(_n),M=li),b=Q,A=!1}function Ye(Q,Pe){Q.side===Pi?Oe(n.CULL_FACE):ve(n.CULL_FACE);let Te=Q.side===Ws;Pe&&(Te=!Te),$e(Te),Q.blending===Vl&&Q.transparent===!1?Ae(Sa):Ae(Q.blending,Q.blendEquation,Q.blendSrc,Q.blendDst,Q.blendEquationAlpha,Q.blendSrcAlpha,Q.blendDstAlpha,Q.blendColor,Q.blendAlpha,Q.premultipliedAlpha),l.setFunc(Q.depthFunc),l.setTest(Q.depthTest),l.setMask(Q.depthWrite),o.setMask(Q.colorWrite);const he=Q.stencilWrite;c.setTest(he),he&&(c.setMask(Q.stencilWriteMask),c.setFunc(Q.stencilFunc,Q.stencilRef,Q.stencilFuncMask),c.setOp(Q.stencilFail,Q.stencilZFail,Q.stencilZPass)),Vt(Q.polygonOffset,Q.polygonOffsetFactor,Q.polygonOffsetUnits),Q.alphaToCoverage===!0?ve(n.SAMPLE_ALPHA_TO_COVERAGE):Oe(n.SAMPLE_ALPHA_TO_COVERAGE)}function $e(Q){D!==Q&&(Q?n.frontFace(n.CW):n.frontFace(n.CCW),D=Q)}function Je(Q){Q!==GL?(ve(n.CULL_FACE),Q!==F&&(Q===bT?n.cullFace(n.BACK):Q===zL?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):Oe(n.CULL_FACE),F=Q}function at(Q){Q!==k&&($&&n.lineWidth(Q),k=Q)}function Vt(Q,Pe,Te){Q?(ve(n.POLYGON_OFFSET_FILL),(P!==Pe||O!==Te)&&(n.polygonOffset(Pe,Te),P=Pe,O=Te)):Oe(n.POLYGON_OFFSET_FILL)}function Dt(Q){Q?ve(n.SCISSOR_TEST):Oe(n.SCISSOR_TEST)}function z(Q){Q===void 0&&(Q=n.TEXTURE0+V-1),G!==Q&&(n.activeTexture(Q),G=Q)}function R(Q,Pe,Te){Te===void 0&&(G===null?Te=n.TEXTURE0+V-1:Te=G);let he=B[Te];he===void 0&&(he={type:void 0,texture:void 0},B[Te]=he),(he.type!==Q||he.texture!==Pe)&&(G!==Te&&(n.activeTexture(Te),G=Te),n.bindTexture(Q,Pe||ge[Q]),he.type=Q,he.texture=Pe)}function ie(){const Q=B[G];Q!==void 0&&Q.type!==void 0&&(n.bindTexture(Q.type,null),Q.type=void 0,Q.texture=void 0)}function ye(){try{n.compressedTexImage2D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function me(){try{n.compressedTexImage3D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function xe(){try{n.texSubImage2D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function Xe(){try{n.texSubImage3D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function _e(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function De(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function tt(){try{n.texStorage2D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function It(){try{n.texStorage3D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function we(){try{n.texImage2D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function Ft(){try{n.texImage3D.apply(n,arguments)}catch(Q){console.error("THREE.WebGLState:",Q)}}function ht(Q){ae.equals(Q)===!1&&(n.scissor(Q.x,Q.y,Q.z,Q.w),ae.copy(Q))}function it(Q){fe.equals(Q)===!1&&(n.viewport(Q.x,Q.y,Q.z,Q.w),fe.copy(Q))}function je(Q,Pe){let Te=h.get(Pe);Te===void 0&&(Te=new WeakMap,h.set(Pe,Te));let he=Te.get(Q);he===void 0&&(he=n.getUniformBlockIndex(Pe,Q.name),Te.set(Q,he))}function We(Q,Pe){const he=h.get(Pe).get(Q);u.get(Pe)!==he&&(n.uniformBlockBinding(Pe,he,Q.__bindingPointIndex),u.set(Pe,he))}function Nt(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),s===!0&&(n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null)),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),d={},G=null,B={},p={},f=new WeakMap,y=[],m=null,g=!1,b=null,x=null,v=null,w=null,_=null,I=null,C=null,S=new lt(0,0,0),M=0,A=!1,D=null,F=null,k=null,P=null,O=null,ae.set(0,0,n.canvas.width,n.canvas.height),fe.set(0,0,n.canvas.width,n.canvas.height),o.reset(),l.reset(),c.reset()}return{buffers:{color:o,depth:l,stencil:c},enable:ve,disable:Oe,bindFramebuffer:Ce,drawBuffers:q,useProgram:vt,setBlending:Ae,setMaterial:Ye,setFlipSided:$e,setCullFace:Je,setLineWidth:at,setPolygonOffset:Vt,setScissorTest:Dt,activeTexture:z,bindTexture:R,unbindTexture:ie,compressedTexImage2D:ye,compressedTexImage3D:me,texImage2D:we,texImage3D:Ft,updateUBOMapping:je,uniformBlockBinding:We,texStorage2D:tt,texStorage3D:It,texSubImage2D:xe,texSubImage3D:Xe,compressedTexSubImage2D:_e,compressedTexSubImage3D:De,scissor:ht,viewport:it,reset:Nt}}function ez(n,e,t,s,i,r,a){const o=i.isWebGL2,l=i.maxTextures,c=i.maxCubemapSize,u=i.maxTextureSize,h=i.maxSamples,d=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,p=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),f=new WeakMap;let y;const m=new WeakMap;let g=!1;try{g=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function b(z,R){return g?new OffscreenCanvas(z,R):Sh("canvas")}function x(z,R,ie,ye){let me=1;if((z.width>ye||z.height>ye)&&(me=ye/Math.max(z.width,z.height)),me<1||R===!0)if(typeof HTMLImageElement<"u"&&z instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&z instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&z instanceof ImageBitmap){const xe=R?$f:Math.floor,Xe=xe(me*z.width),_e=xe(me*z.height);y===void 0&&(y=b(Xe,_e));const De=ie?b(Xe,_e):y;return De.width=Xe,De.height=_e,De.getContext("2d").drawImage(z,0,0,Xe,_e),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+z.width+"x"+z.height+") to ("+Xe+"x"+_e+")."),De}else return"data"in z&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+z.width+"x"+z.height+")."),z;return z}function v(z){return G0(z.width)&&G0(z.height)}function w(z){return o?!1:z.wrapS!==Os||z.wrapT!==Os||z.minFilter!==$n&&z.minFilter!==An}function _(z,R){return z.generateMipmaps&&R&&z.minFilter!==$n&&z.minFilter!==An}function I(z){n.generateMipmap(z)}function C(z,R,ie,ye,me=!1){if(o===!1)return R;if(z!==null){if(n[z]!==void 0)return n[z];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+z+"'")}let xe=R;if(R===n.RED&&(ie===n.FLOAT&&(xe=n.R32F),ie===n.HALF_FLOAT&&(xe=n.R16F),ie===n.UNSIGNED_BYTE&&(xe=n.R8)),R===n.RED_INTEGER&&(ie===n.UNSIGNED_BYTE&&(xe=n.R8UI),ie===n.UNSIGNED_SHORT&&(xe=n.R16UI),ie===n.UNSIGNED_INT&&(xe=n.R32UI),ie===n.BYTE&&(xe=n.R8I),ie===n.SHORT&&(xe=n.R16I),ie===n.INT&&(xe=n.R32I)),R===n.RG&&(ie===n.FLOAT&&(xe=n.RG32F),ie===n.HALF_FLOAT&&(xe=n.RG16F),ie===n.UNSIGNED_BYTE&&(xe=n.RG8)),R===n.RGBA){const Xe=me?Vf:Pt.getTransfer(ye);ie===n.FLOAT&&(xe=n.RGBA32F),ie===n.HALF_FLOAT&&(xe=n.RGBA16F),ie===n.UNSIGNED_BYTE&&(xe=Xe===qt?n.SRGB8_ALPHA8:n.RGBA8),ie===n.UNSIGNED_SHORT_4_4_4_4&&(xe=n.RGBA4),ie===n.UNSIGNED_SHORT_5_5_5_1&&(xe=n.RGB5_A1)}return(xe===n.R16F||xe===n.R32F||xe===n.RG16F||xe===n.RG32F||xe===n.RGBA16F||xe===n.RGBA32F)&&e.get("EXT_color_buffer_float"),xe}function S(z,R,ie){return _(z,ie)===!0||z.isFramebufferTexture&&z.minFilter!==$n&&z.minFilter!==An?Math.log2(Math.max(R.width,R.height))+1:z.mipmaps!==void 0&&z.mipmaps.length>0?z.mipmaps.length:z.isCompressedTexture&&Array.isArray(z.image)?R.mipmaps.length:1}function M(z){return z===$n||z===P0||z===Nf?n.NEAREST:n.LINEAR}function A(z){const R=z.target;R.removeEventListener("dispose",A),F(R),R.isVideoTexture&&f.delete(R)}function D(z){const R=z.target;R.removeEventListener("dispose",D),P(R)}function F(z){const R=s.get(z);if(R.__webglInit===void 0)return;const ie=z.source,ye=m.get(ie);if(ye){const me=ye[R.__cacheKey];me.usedTimes--,me.usedTimes===0&&k(z),Object.keys(ye).length===0&&m.delete(ie)}s.remove(z)}function k(z){const R=s.get(z);n.deleteTexture(R.__webglTexture);const ie=z.source,ye=m.get(ie);delete ye[R.__cacheKey],a.memory.textures--}function P(z){const R=z.texture,ie=s.get(z),ye=s.get(R);if(ye.__webglTexture!==void 0&&(n.deleteTexture(ye.__webglTexture),a.memory.textures--),z.depthTexture&&z.depthTexture.dispose(),z.isWebGLCubeRenderTarget)for(let me=0;me<6;me++){if(Array.isArray(ie.__webglFramebuffer[me]))for(let xe=0;xe<ie.__webglFramebuffer[me].length;xe++)n.deleteFramebuffer(ie.__webglFramebuffer[me][xe]);else n.deleteFramebuffer(ie.__webglFramebuffer[me]);ie.__webglDepthbuffer&&n.deleteRenderbuffer(ie.__webglDepthbuffer[me])}else{if(Array.isArray(ie.__webglFramebuffer))for(let me=0;me<ie.__webglFramebuffer.length;me++)n.deleteFramebuffer(ie.__webglFramebuffer[me]);else n.deleteFramebuffer(ie.__webglFramebuffer);if(ie.__webglDepthbuffer&&n.deleteRenderbuffer(ie.__webglDepthbuffer),ie.__webglMultisampledFramebuffer&&n.deleteFramebuffer(ie.__webglMultisampledFramebuffer),ie.__webglColorRenderbuffer)for(let me=0;me<ie.__webglColorRenderbuffer.length;me++)ie.__webglColorRenderbuffer[me]&&n.deleteRenderbuffer(ie.__webglColorRenderbuffer[me]);ie.__webglDepthRenderbuffer&&n.deleteRenderbuffer(ie.__webglDepthRenderbuffer)}if(z.isWebGLMultipleRenderTargets)for(let me=0,xe=R.length;me<xe;me++){const Xe=s.get(R[me]);Xe.__webglTexture&&(n.deleteTexture(Xe.__webglTexture),a.memory.textures--),s.remove(R[me])}s.remove(R),s.remove(z)}let O=0;function V(){O=0}function $(){const z=O;return z>=l&&console.warn("THREE.WebGLTextures: Trying to use "+z+" texture units while this GPU supports only "+l),O+=1,z}function H(z){const R=[];return R.push(z.wrapS),R.push(z.wrapT),R.push(z.wrapR||0),R.push(z.magFilter),R.push(z.minFilter),R.push(z.anisotropy),R.push(z.internalFormat),R.push(z.format),R.push(z.type),R.push(z.generateMipmaps),R.push(z.premultiplyAlpha),R.push(z.flipY),R.push(z.unpackAlignment),R.push(z.colorSpace),R.join()}function Y(z,R){const ie=s.get(z);if(z.isVideoTexture&&Vt(z),z.isRenderTargetTexture===!1&&z.version>0&&ie.__version!==z.version){const ye=z.image;if(ye===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ye.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{ve(ie,z,R);return}}t.bindTexture(n.TEXTURE_2D,ie.__webglTexture,n.TEXTURE0+R)}function G(z,R){const ie=s.get(z);if(z.version>0&&ie.__version!==z.version){ve(ie,z,R);return}t.bindTexture(n.TEXTURE_2D_ARRAY,ie.__webglTexture,n.TEXTURE0+R)}function B(z,R){const ie=s.get(z);if(z.version>0&&ie.__version!==z.version){ve(ie,z,R);return}t.bindTexture(n.TEXTURE_3D,ie.__webglTexture,n.TEXTURE0+R)}function te(z,R){const ie=s.get(z);if(z.version>0&&ie.__version!==z.version){Oe(ie,z,R);return}t.bindTexture(n.TEXTURE_CUBE_MAP,ie.__webglTexture,n.TEXTURE0+R)}const se={[Na]:n.REPEAT,[Os]:n.CLAMP_TO_EDGE,[Gf]:n.MIRRORED_REPEAT},ae={[$n]:n.NEAREST,[P0]:n.NEAREST_MIPMAP_NEAREST,[Nf]:n.NEAREST_MIPMAP_LINEAR,[An]:n.LINEAR,[u2]:n.LINEAR_MIPMAP_NEAREST,[Ra]:n.LINEAR_MIPMAP_LINEAR},fe={[P3]:n.NEVER,[W3]:n.ALWAYS,[D3]:n.LESS,[O3]:n.LEQUAL,[F3]:n.EQUAL,[V3]:n.GEQUAL,[G3]:n.GREATER,[z3]:n.NOTEQUAL};function be(z,R,ie){if(ie?(n.texParameteri(z,n.TEXTURE_WRAP_S,se[R.wrapS]),n.texParameteri(z,n.TEXTURE_WRAP_T,se[R.wrapT]),(z===n.TEXTURE_3D||z===n.TEXTURE_2D_ARRAY)&&n.texParameteri(z,n.TEXTURE_WRAP_R,se[R.wrapR]),n.texParameteri(z,n.TEXTURE_MAG_FILTER,ae[R.magFilter]),n.texParameteri(z,n.TEXTURE_MIN_FILTER,ae[R.minFilter])):(n.texParameteri(z,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE),n.texParameteri(z,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE),(z===n.TEXTURE_3D||z===n.TEXTURE_2D_ARRAY)&&n.texParameteri(z,n.TEXTURE_WRAP_R,n.CLAMP_TO_EDGE),(R.wrapS!==Os||R.wrapT!==Os)&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),n.texParameteri(z,n.TEXTURE_MAG_FILTER,M(R.magFilter)),n.texParameteri(z,n.TEXTURE_MIN_FILTER,M(R.minFilter)),R.minFilter!==$n&&R.minFilter!==An&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")),R.compareFunction&&(n.texParameteri(z,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(z,n.TEXTURE_COMPARE_FUNC,fe[R.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){const ye=e.get("EXT_texture_filter_anisotropic");if(R.magFilter===$n||R.minFilter!==Nf&&R.minFilter!==Ra||R.type===yi&&e.has("OES_texture_float_linear")===!1||o===!1&&R.type===Dr&&e.has("OES_texture_half_float_linear")===!1)return;(R.anisotropy>1||s.get(R).__currentAnisotropy)&&(n.texParameterf(z,ye.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(R.anisotropy,i.getMaxAnisotropy())),s.get(R).__currentAnisotropy=R.anisotropy)}}function ge(z,R){let ie=!1;z.__webglInit===void 0&&(z.__webglInit=!0,R.addEventListener("dispose",A));const ye=R.source;let me=m.get(ye);me===void 0&&(me={},m.set(ye,me));const xe=H(R);if(xe!==z.__cacheKey){me[xe]===void 0&&(me[xe]={texture:n.createTexture(),usedTimes:0},a.memory.textures++,ie=!0),me[xe].usedTimes++;const Xe=me[z.__cacheKey];Xe!==void 0&&(me[z.__cacheKey].usedTimes--,Xe.usedTimes===0&&k(R)),z.__cacheKey=xe,z.__webglTexture=me[xe].texture}return ie}function ve(z,R,ie){let ye=n.TEXTURE_2D;(R.isDataArrayTexture||R.isCompressedArrayTexture)&&(ye=n.TEXTURE_2D_ARRAY),R.isData3DTexture&&(ye=n.TEXTURE_3D);const me=ge(z,R),xe=R.source;t.bindTexture(ye,z.__webglTexture,n.TEXTURE0+ie);const Xe=s.get(xe);if(xe.version!==Xe.__version||me===!0){t.activeTexture(n.TEXTURE0+ie);const _e=Pt.getPrimaries(Pt.workingColorSpace),De=R.colorSpace===gi?null:Pt.getPrimaries(R.colorSpace),tt=R.colorSpace===gi||_e===De?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,R.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,R.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,R.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,tt);const It=w(R)&&v(R.image)===!1;let we=x(R.image,It,!1,u);we=Dt(R,we);const Ft=v(we)||o,ht=r.convert(R.format,R.colorSpace);let it=r.convert(R.type),je=C(R.internalFormat,ht,it,R.colorSpace,R.isVideoTexture);be(ye,R,Ft);let We;const Nt=R.mipmaps,Q=o&&R.isVideoTexture!==!0,Pe=Xe.__version===void 0||me===!0,Te=S(R,we,Ft);if(R.isDepthTexture)je=n.DEPTH_COMPONENT,o?R.type===yi?je=n.DEPTH_COMPONENT32F:R.type===ga?je=n.DEPTH_COMPONENT24:R.type===So?je=n.DEPTH24_STENCIL8:je=n.DEPTH_COMPONENT16:R.type===yi&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),R.format===To&&je===n.DEPTH_COMPONENT&&R.type!==$x&&R.type!==ga&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),R.type=ga,it=r.convert(R.type)),R.format===Ql&&je===n.DEPTH_COMPONENT&&(je=n.DEPTH_STENCIL,R.type!==So&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),R.type=So,it=r.convert(R.type))),Pe&&(Q?t.texStorage2D(n.TEXTURE_2D,1,je,we.width,we.height):t.texImage2D(n.TEXTURE_2D,0,je,we.width,we.height,0,ht,it,null));else if(R.isDataTexture)if(Nt.length>0&&Ft){Q&&Pe&&t.texStorage2D(n.TEXTURE_2D,Te,je,Nt[0].width,Nt[0].height);for(let he=0,Ie=Nt.length;he<Ie;he++)We=Nt[he],Q?t.texSubImage2D(n.TEXTURE_2D,he,0,0,We.width,We.height,ht,it,We.data):t.texImage2D(n.TEXTURE_2D,he,je,We.width,We.height,0,ht,it,We.data);R.generateMipmaps=!1}else Q?(Pe&&t.texStorage2D(n.TEXTURE_2D,Te,je,we.width,we.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,we.width,we.height,ht,it,we.data)):t.texImage2D(n.TEXTURE_2D,0,je,we.width,we.height,0,ht,it,we.data);else if(R.isCompressedTexture)if(R.isCompressedArrayTexture){Q&&Pe&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Te,je,Nt[0].width,Nt[0].height,we.depth);for(let he=0,Ie=Nt.length;he<Ie;he++)We=Nt[he],R.format!==mi?ht!==null?Q?t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,We.width,We.height,we.depth,ht,We.data,0,0):t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,he,je,We.width,We.height,we.depth,0,We.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Q?t.texSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,We.width,We.height,we.depth,ht,it,We.data):t.texImage3D(n.TEXTURE_2D_ARRAY,he,je,We.width,We.height,we.depth,0,ht,it,We.data)}else{Q&&Pe&&t.texStorage2D(n.TEXTURE_2D,Te,je,Nt[0].width,Nt[0].height);for(let he=0,Ie=Nt.length;he<Ie;he++)We=Nt[he],R.format!==mi?ht!==null?Q?t.compressedTexSubImage2D(n.TEXTURE_2D,he,0,0,We.width,We.height,ht,We.data):t.compressedTexImage2D(n.TEXTURE_2D,he,je,We.width,We.height,0,We.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Q?t.texSubImage2D(n.TEXTURE_2D,he,0,0,We.width,We.height,ht,it,We.data):t.texImage2D(n.TEXTURE_2D,he,je,We.width,We.height,0,ht,it,We.data)}else if(R.isDataArrayTexture)Q?(Pe&&t.texStorage3D(n.TEXTURE_2D_ARRAY,Te,je,we.width,we.height,we.depth),t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,we.width,we.height,we.depth,ht,it,we.data)):t.texImage3D(n.TEXTURE_2D_ARRAY,0,je,we.width,we.height,we.depth,0,ht,it,we.data);else if(R.isData3DTexture)Q?(Pe&&t.texStorage3D(n.TEXTURE_3D,Te,je,we.width,we.height,we.depth),t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,we.width,we.height,we.depth,ht,it,we.data)):t.texImage3D(n.TEXTURE_3D,0,je,we.width,we.height,we.depth,0,ht,it,we.data);else if(R.isFramebufferTexture){if(Pe)if(Q)t.texStorage2D(n.TEXTURE_2D,Te,je,we.width,we.height);else{let he=we.width,Ie=we.height;for(let qe=0;qe<Te;qe++)t.texImage2D(n.TEXTURE_2D,qe,je,he,Ie,0,ht,it,null),he>>=1,Ie>>=1}}else if(Nt.length>0&&Ft){Q&&Pe&&t.texStorage2D(n.TEXTURE_2D,Te,je,Nt[0].width,Nt[0].height);for(let he=0,Ie=Nt.length;he<Ie;he++)We=Nt[he],Q?t.texSubImage2D(n.TEXTURE_2D,he,0,0,ht,it,We):t.texImage2D(n.TEXTURE_2D,he,je,ht,it,We);R.generateMipmaps=!1}else Q?(Pe&&t.texStorage2D(n.TEXTURE_2D,Te,je,we.width,we.height),t.texSubImage2D(n.TEXTURE_2D,0,0,0,ht,it,we)):t.texImage2D(n.TEXTURE_2D,0,je,ht,it,we);_(R,Ft)&&I(ye),Xe.__version=xe.version,R.onUpdate&&R.onUpdate(R)}z.__version=R.version}function Oe(z,R,ie){if(R.image.length!==6)return;const ye=ge(z,R),me=R.source;t.bindTexture(n.TEXTURE_CUBE_MAP,z.__webglTexture,n.TEXTURE0+ie);const xe=s.get(me);if(me.version!==xe.__version||ye===!0){t.activeTexture(n.TEXTURE0+ie);const Xe=Pt.getPrimaries(Pt.workingColorSpace),_e=R.colorSpace===gi?null:Pt.getPrimaries(R.colorSpace),De=R.colorSpace===gi||Xe===_e?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,R.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,R.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,R.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,De);const tt=R.isCompressedTexture||R.image[0].isCompressedTexture,It=R.image[0]&&R.image[0].isDataTexture,we=[];for(let he=0;he<6;he++)!tt&&!It?we[he]=x(R.image[he],!1,!0,c):we[he]=It?R.image[he].image:R.image[he],we[he]=Dt(R,we[he]);const Ft=we[0],ht=v(Ft)||o,it=r.convert(R.format,R.colorSpace),je=r.convert(R.type),We=C(R.internalFormat,it,je,R.colorSpace),Nt=o&&R.isVideoTexture!==!0,Q=xe.__version===void 0||ye===!0;let Pe=S(R,Ft,ht);be(n.TEXTURE_CUBE_MAP,R,ht);let Te;if(tt){Nt&&Q&&t.texStorage2D(n.TEXTURE_CUBE_MAP,Pe,We,Ft.width,Ft.height);for(let he=0;he<6;he++){Te=we[he].mipmaps;for(let Ie=0;Ie<Te.length;Ie++){const qe=Te[Ie];R.format!==mi?it!==null?Nt?t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie,0,0,qe.width,qe.height,it,qe.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie,We,qe.width,qe.height,0,qe.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Nt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie,0,0,qe.width,qe.height,it,je,qe.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie,We,qe.width,qe.height,0,it,je,qe.data)}}}else{Te=R.mipmaps,Nt&&Q&&(Te.length>0&&Pe++,t.texStorage2D(n.TEXTURE_CUBE_MAP,Pe,We,we[0].width,we[0].height));for(let he=0;he<6;he++)if(It){Nt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,0,0,we[he].width,we[he].height,it,je,we[he].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,We,we[he].width,we[he].height,0,it,je,we[he].data);for(let Ie=0;Ie<Te.length;Ie++){const Lt=Te[Ie].image[he].image;Nt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie+1,0,0,Lt.width,Lt.height,it,je,Lt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie+1,We,Lt.width,Lt.height,0,it,je,Lt.data)}}else{Nt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,0,0,it,je,we[he]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,0,We,it,je,we[he]);for(let Ie=0;Ie<Te.length;Ie++){const qe=Te[Ie];Nt?t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie+1,0,0,it,je,qe.image[he]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+he,Ie+1,We,it,je,qe.image[he])}}}_(R,ht)&&I(n.TEXTURE_CUBE_MAP),xe.__version=me.version,R.onUpdate&&R.onUpdate(R)}z.__version=R.version}function Ce(z,R,ie,ye,me,xe){const Xe=r.convert(ie.format,ie.colorSpace),_e=r.convert(ie.type),De=C(ie.internalFormat,Xe,_e,ie.colorSpace);if(!s.get(R).__hasExternalTextures){const It=Math.max(1,R.width>>xe),we=Math.max(1,R.height>>xe);me===n.TEXTURE_3D||me===n.TEXTURE_2D_ARRAY?t.texImage3D(me,xe,De,It,we,R.depth,0,Xe,_e,null):t.texImage2D(me,xe,De,It,we,0,Xe,_e,null)}t.bindFramebuffer(n.FRAMEBUFFER,z),at(R)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,ye,me,s.get(ie).__webglTexture,0,Je(R)):(me===n.TEXTURE_2D||me>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&me<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,ye,me,s.get(ie).__webglTexture,xe),t.bindFramebuffer(n.FRAMEBUFFER,null)}function q(z,R,ie){if(n.bindRenderbuffer(n.RENDERBUFFER,z),R.depthBuffer&&!R.stencilBuffer){let ye=o===!0?n.DEPTH_COMPONENT24:n.DEPTH_COMPONENT16;if(ie||at(R)){const me=R.depthTexture;me&&me.isDepthTexture&&(me.type===yi?ye=n.DEPTH_COMPONENT32F:me.type===ga&&(ye=n.DEPTH_COMPONENT24));const xe=Je(R);at(R)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,xe,ye,R.width,R.height):n.renderbufferStorageMultisample(n.RENDERBUFFER,xe,ye,R.width,R.height)}else n.renderbufferStorage(n.RENDERBUFFER,ye,R.width,R.height);n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,z)}else if(R.depthBuffer&&R.stencilBuffer){const ye=Je(R);ie&&at(R)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,ye,n.DEPTH24_STENCIL8,R.width,R.height):at(R)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,ye,n.DEPTH24_STENCIL8,R.width,R.height):n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_STENCIL,R.width,R.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.RENDERBUFFER,z)}else{const ye=R.isWebGLMultipleRenderTargets===!0?R.texture:[R.texture];for(let me=0;me<ye.length;me++){const xe=ye[me],Xe=r.convert(xe.format,xe.colorSpace),_e=r.convert(xe.type),De=C(xe.internalFormat,Xe,_e,xe.colorSpace),tt=Je(R);ie&&at(R)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,tt,De,R.width,R.height):at(R)?d.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,tt,De,R.width,R.height):n.renderbufferStorage(n.RENDERBUFFER,De,R.width,R.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function vt(z,R){if(R&&R.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,z),!(R.depthTexture&&R.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!s.get(R.depthTexture).__webglTexture||R.depthTexture.image.width!==R.width||R.depthTexture.image.height!==R.height)&&(R.depthTexture.image.width=R.width,R.depthTexture.image.height=R.height,R.depthTexture.needsUpdate=!0),Y(R.depthTexture,0);const ye=s.get(R.depthTexture).__webglTexture,me=Je(R);if(R.depthTexture.format===To)at(R)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ye,0,me):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,ye,0);else if(R.depthTexture.format===Ql)at(R)?d.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ye,0,me):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,ye,0);else throw new Error("Unknown depthTexture format")}function Ee(z){const R=s.get(z),ie=z.isWebGLCubeRenderTarget===!0;if(z.depthTexture&&!R.__autoAllocateDepthBuffer){if(ie)throw new Error("target.depthTexture not supported in Cube render targets");vt(R.__webglFramebuffer,z)}else if(ie){R.__webglDepthbuffer=[];for(let ye=0;ye<6;ye++)t.bindFramebuffer(n.FRAMEBUFFER,R.__webglFramebuffer[ye]),R.__webglDepthbuffer[ye]=n.createRenderbuffer(),q(R.__webglDepthbuffer[ye],z,!1)}else t.bindFramebuffer(n.FRAMEBUFFER,R.__webglFramebuffer),R.__webglDepthbuffer=n.createRenderbuffer(),q(R.__webglDepthbuffer,z,!1);t.bindFramebuffer(n.FRAMEBUFFER,null)}function Le(z,R,ie){const ye=s.get(z);R!==void 0&&Ce(ye.__webglFramebuffer,z,z.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),ie!==void 0&&Ee(z)}function Ae(z){const R=z.texture,ie=s.get(z),ye=s.get(R);z.addEventListener("dispose",D),z.isWebGLMultipleRenderTargets!==!0&&(ye.__webglTexture===void 0&&(ye.__webglTexture=n.createTexture()),ye.__version=R.version,a.memory.textures++);const me=z.isWebGLCubeRenderTarget===!0,xe=z.isWebGLMultipleRenderTargets===!0,Xe=v(z)||o;if(me){ie.__webglFramebuffer=[];for(let _e=0;_e<6;_e++)if(o&&R.mipmaps&&R.mipmaps.length>0){ie.__webglFramebuffer[_e]=[];for(let De=0;De<R.mipmaps.length;De++)ie.__webglFramebuffer[_e][De]=n.createFramebuffer()}else ie.__webglFramebuffer[_e]=n.createFramebuffer()}else{if(o&&R.mipmaps&&R.mipmaps.length>0){ie.__webglFramebuffer=[];for(let _e=0;_e<R.mipmaps.length;_e++)ie.__webglFramebuffer[_e]=n.createFramebuffer()}else ie.__webglFramebuffer=n.createFramebuffer();if(xe)if(i.drawBuffers){const _e=z.texture;for(let De=0,tt=_e.length;De<tt;De++){const It=s.get(_e[De]);It.__webglTexture===void 0&&(It.__webglTexture=n.createTexture(),a.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(o&&z.samples>0&&at(z)===!1){const _e=xe?R:[R];ie.__webglMultisampledFramebuffer=n.createFramebuffer(),ie.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,ie.__webglMultisampledFramebuffer);for(let De=0;De<_e.length;De++){const tt=_e[De];ie.__webglColorRenderbuffer[De]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,ie.__webglColorRenderbuffer[De]);const It=r.convert(tt.format,tt.colorSpace),we=r.convert(tt.type),Ft=C(tt.internalFormat,It,we,tt.colorSpace,z.isXRRenderTarget===!0),ht=Je(z);n.renderbufferStorageMultisample(n.RENDERBUFFER,ht,Ft,z.width,z.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+De,n.RENDERBUFFER,ie.__webglColorRenderbuffer[De])}n.bindRenderbuffer(n.RENDERBUFFER,null),z.depthBuffer&&(ie.__webglDepthRenderbuffer=n.createRenderbuffer(),q(ie.__webglDepthRenderbuffer,z,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(me){t.bindTexture(n.TEXTURE_CUBE_MAP,ye.__webglTexture),be(n.TEXTURE_CUBE_MAP,R,Xe);for(let _e=0;_e<6;_e++)if(o&&R.mipmaps&&R.mipmaps.length>0)for(let De=0;De<R.mipmaps.length;De++)Ce(ie.__webglFramebuffer[_e][De],z,R,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+_e,De);else Ce(ie.__webglFramebuffer[_e],z,R,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+_e,0);_(R,Xe)&&I(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(xe){const _e=z.texture;for(let De=0,tt=_e.length;De<tt;De++){const It=_e[De],we=s.get(It);t.bindTexture(n.TEXTURE_2D,we.__webglTexture),be(n.TEXTURE_2D,It,Xe),Ce(ie.__webglFramebuffer,z,It,n.COLOR_ATTACHMENT0+De,n.TEXTURE_2D,0),_(It,Xe)&&I(n.TEXTURE_2D)}t.unbindTexture()}else{let _e=n.TEXTURE_2D;if((z.isWebGL3DRenderTarget||z.isWebGLArrayRenderTarget)&&(o?_e=z.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.")),t.bindTexture(_e,ye.__webglTexture),be(_e,R,Xe),o&&R.mipmaps&&R.mipmaps.length>0)for(let De=0;De<R.mipmaps.length;De++)Ce(ie.__webglFramebuffer[De],z,R,n.COLOR_ATTACHMENT0,_e,De);else Ce(ie.__webglFramebuffer,z,R,n.COLOR_ATTACHMENT0,_e,0);_(R,Xe)&&I(_e),t.unbindTexture()}z.depthBuffer&&Ee(z)}function Ye(z){const R=v(z)||o,ie=z.isWebGLMultipleRenderTargets===!0?z.texture:[z.texture];for(let ye=0,me=ie.length;ye<me;ye++){const xe=ie[ye];if(_(xe,R)){const Xe=z.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,_e=s.get(xe).__webglTexture;t.bindTexture(Xe,_e),I(Xe),t.unbindTexture()}}}function $e(z){if(o&&z.samples>0&&at(z)===!1){const R=z.isWebGLMultipleRenderTargets?z.texture:[z.texture],ie=z.width,ye=z.height;let me=n.COLOR_BUFFER_BIT;const xe=[],Xe=z.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,_e=s.get(z),De=z.isWebGLMultipleRenderTargets===!0;if(De)for(let tt=0;tt<R.length;tt++)t.bindFramebuffer(n.FRAMEBUFFER,_e.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+tt,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,_e.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+tt,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,_e.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,_e.__webglFramebuffer);for(let tt=0;tt<R.length;tt++){xe.push(n.COLOR_ATTACHMENT0+tt),z.depthBuffer&&xe.push(Xe);const It=_e.__ignoreDepthValues!==void 0?_e.__ignoreDepthValues:!1;if(It===!1&&(z.depthBuffer&&(me|=n.DEPTH_BUFFER_BIT),z.stencilBuffer&&(me|=n.STENCIL_BUFFER_BIT)),De&&n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,_e.__webglColorRenderbuffer[tt]),It===!0&&(n.invalidateFramebuffer(n.READ_FRAMEBUFFER,[Xe]),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[Xe])),De){const we=s.get(R[tt]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,we,0)}n.blitFramebuffer(0,0,ie,ye,0,0,ie,ye,me,n.NEAREST),p&&n.invalidateFramebuffer(n.READ_FRAMEBUFFER,xe)}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),De)for(let tt=0;tt<R.length;tt++){t.bindFramebuffer(n.FRAMEBUFFER,_e.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+tt,n.RENDERBUFFER,_e.__webglColorRenderbuffer[tt]);const It=s.get(R[tt]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,_e.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+tt,n.TEXTURE_2D,It,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,_e.__webglMultisampledFramebuffer)}}function Je(z){return Math.min(h,z.samples)}function at(z){const R=s.get(z);return o&&z.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&R.__useRenderToTexture!==!1}function Vt(z){const R=a.render.frame;f.get(z)!==R&&(f.set(z,R),z.update())}function Dt(z,R){const ie=z.colorSpace,ye=z.format,me=z.type;return z.isCompressedTexture===!0||z.isVideoTexture===!0||z.format===O0||ie!==Kn&&ie!==gi&&(Pt.getTransfer(ie)===qt?o===!1?e.has("EXT_sRGB")===!0&&ye===mi?(z.format=O0,z.minFilter=An,z.generateMipmaps=!1):R=T2.sRGBToLinear(R):(ye!==mi||me!==_a)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",ie)),R}this.allocateTextureUnit=$,this.resetTextureUnits=V,this.setTexture2D=Y,this.setTexture2DArray=G,this.setTexture3D=B,this.setTextureCube=te,this.rebindTextures=Le,this.setupRenderTarget=Ae,this.updateRenderTargetMipmap=Ye,this.updateMultisampleRenderTarget=$e,this.setupDepthRenderbuffer=Ee,this.setupFrameBufferTexture=Ce,this.useMultisampledRTT=at}function tz(n,e,t){const s=t.isWebGL2;function i(r,a=gi){let o;const l=Pt.getTransfer(a);if(r===_a)return n.UNSIGNED_BYTE;if(r===d2)return n.UNSIGNED_SHORT_4_4_4_4;if(r===p2)return n.UNSIGNED_SHORT_5_5_5_1;if(r===b3)return n.BYTE;if(r===x3)return n.SHORT;if(r===$x)return n.UNSIGNED_SHORT;if(r===h2)return n.INT;if(r===ga)return n.UNSIGNED_INT;if(r===yi)return n.FLOAT;if(r===Dr)return s?n.HALF_FLOAT:(o=e.get("OES_texture_half_float"),o!==null?o.HALF_FLOAT_OES:null);if(r===v3)return n.ALPHA;if(r===mi)return n.RGBA;if(r===w3)return n.LUMINANCE;if(r===S3)return n.LUMINANCE_ALPHA;if(r===To)return n.DEPTH_COMPONENT;if(r===Ql)return n.DEPTH_STENCIL;if(r===O0)return o=e.get("EXT_sRGB"),o!==null?o.SRGB_ALPHA_EXT:null;if(r===T3)return n.RED;if(r===f2)return n.RED_INTEGER;if(r===_3)return n.RG;if(r===m2)return n.RG_INTEGER;if(r===g2)return n.RGBA_INTEGER;if(r===cb||r===ub||r===hb||r===db)if(l===qt)if(o=e.get("WEBGL_compressed_texture_s3tc_srgb"),o!==null){if(r===cb)return o.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===ub)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===hb)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===db)return o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(o=e.get("WEBGL_compressed_texture_s3tc"),o!==null){if(r===cb)return o.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===ub)return o.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===hb)return o.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===db)return o.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===IT||r===MT||r===CT||r===ET)if(o=e.get("WEBGL_compressed_texture_pvrtc"),o!==null){if(r===IT)return o.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===MT)return o.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===CT)return o.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===ET)return o.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===I3)return o=e.get("WEBGL_compressed_texture_etc1"),o!==null?o.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===kT||r===NT)if(o=e.get("WEBGL_compressed_texture_etc"),o!==null){if(r===kT)return l===qt?o.COMPRESSED_SRGB8_ETC2:o.COMPRESSED_RGB8_ETC2;if(r===NT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:o.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===RT||r===AT||r===LT||r===PT||r===DT||r===FT||r===OT||r===GT||r===zT||r===VT||r===WT||r===UT||r===BT||r===$T)if(o=e.get("WEBGL_compressed_texture_astc"),o!==null){if(r===RT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:o.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===AT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:o.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===LT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:o.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===PT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:o.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===DT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:o.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===FT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:o.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===OT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:o.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===GT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:o.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===zT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:o.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===VT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:o.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===WT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:o.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===UT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:o.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===BT)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:o.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===$T)return l===qt?o.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:o.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===pb||r===XT||r===HT)if(o=e.get("EXT_texture_compression_bptc"),o!==null){if(r===pb)return l===qt?o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:o.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(r===XT)return o.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(r===HT)return o.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(r===M3||r===KT||r===ZT||r===YT)if(o=e.get("EXT_texture_compression_rgtc"),o!==null){if(r===pb)return o.COMPRESSED_RED_RGTC1_EXT;if(r===KT)return o.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(r===ZT)return o.COMPRESSED_RED_GREEN_RGTC2_EXT;if(r===YT)return o.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return r===So?s?n.UNSIGNED_INT_24_8:(o=e.get("WEBGL_depth_texture"),o!==null?o.UNSIGNED_INT_24_8_WEBGL:null):n[r]!==void 0?n[r]:null}return{convert:i}}class nz extends Ts{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Or extends nn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const sz={type:"move"};class Ob{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Or,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Or,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new J,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new J),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Or,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new J,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new J),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const s of e.hand.values())this._getHandJoint(t,s)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,s){let i=null,r=null,a=null;const o=this._targetRay,l=this._grip,c=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(c&&e.hand){a=!0;for(const y of e.hand.values()){const m=t.getJointPose(y,s),g=this._getHandJoint(c,y);m!==null&&(g.matrix.fromArray(m.transform.matrix),g.matrix.decompose(g.position,g.rotation,g.scale),g.matrixWorldNeedsUpdate=!0,g.jointRadius=m.radius),g.visible=m!==null}const u=c.joints["index-finger-tip"],h=c.joints["thumb-tip"],d=u.position.distanceTo(h.position),p=.02,f=.005;c.inputState.pinching&&d>p+f?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&d<=p-f&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(r=t.getPose(e.gripSpace,s),r!==null&&(l.matrix.fromArray(r.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,r.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(r.linearVelocity)):l.hasLinearVelocity=!1,r.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(r.angularVelocity)):l.hasAngularVelocity=!1));o!==null&&(i=t.getPose(e.targetRaySpace,s),i===null&&r!==null&&(i=r),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(sz)))}return o!==null&&(o.visible=i!==null),l!==null&&(l.visible=r!==null),c!==null&&(c.visible=a!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const s=new Or;s.matrixAutoUpdate=!1,s.visible=!1,e.joints[t.jointName]=s,e.add(s)}return e.joints[t.jointName]}}class iz extends is{constructor(e,t,s,i,r,a,o,l,c,u){if(u=u!==void 0?u:To,u!==To&&u!==Ql)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");s===void 0&&u===To&&(s=ga),s===void 0&&u===Ql&&(s=So),super(null,i,r,a,o,l,u,s,c),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=o!==void 0?o:$n,this.minFilter=l!==void 0?l:$n,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}class rz extends Zo{constructor(e,t){super();const s=this;let i=null,r=1,a=null,o="local-floor",l=1,c=null,u=null,h=null,d=null,p=null,f=null;const y=t.getContextAttributes();let m=null,g=null;const b=[],x=[],v=new Ts;v.layers.enable(1),v.viewport=new Xt;const w=new Ts;w.layers.enable(2),w.viewport=new Xt;const _=[v,w],I=new nz;I.layers.enable(1),I.layers.enable(2);let C=null,S=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(G){let B=b[G];return B===void 0&&(B=new Ob,b[G]=B),B.getTargetRaySpace()},this.getControllerGrip=function(G){let B=b[G];return B===void 0&&(B=new Ob,b[G]=B),B.getGripSpace()},this.getHand=function(G){let B=b[G];return B===void 0&&(B=new Ob,b[G]=B),B.getHandSpace()};function M(G){const B=x.indexOf(G.inputSource);if(B===-1)return;const te=b[B];te!==void 0&&(te.update(G.inputSource,G.frame,c||a),te.dispatchEvent({type:G.type,data:G.inputSource}))}function A(){i.removeEventListener("select",M),i.removeEventListener("selectstart",M),i.removeEventListener("selectend",M),i.removeEventListener("squeeze",M),i.removeEventListener("squeezestart",M),i.removeEventListener("squeezeend",M),i.removeEventListener("end",A),i.removeEventListener("inputsourceschange",D);for(let G=0;G<b.length;G++){const B=x[G];B!==null&&(x[G]=null,b[G].disconnect(B))}C=null,S=null,e.setRenderTarget(m),p=null,d=null,h=null,i=null,g=null,Y.stop(),s.isPresenting=!1,s.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(G){r=G,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(G){o=G,s.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||a},this.setReferenceSpace=function(G){c=G},this.getBaseLayer=function(){return d!==null?d:p},this.getBinding=function(){return h},this.getFrame=function(){return f},this.getSession=function(){return i},this.setSession=async function(G){if(i=G,i!==null){if(m=e.getRenderTarget(),i.addEventListener("select",M),i.addEventListener("selectstart",M),i.addEventListener("selectend",M),i.addEventListener("squeeze",M),i.addEventListener("squeezestart",M),i.addEventListener("squeezeend",M),i.addEventListener("end",A),i.addEventListener("inputsourceschange",D),y.xrCompatible!==!0&&await t.makeXRCompatible(),i.renderState.layers===void 0||e.capabilities.isWebGL2===!1){const B={antialias:i.renderState.layers===void 0?y.antialias:!0,alpha:!0,depth:y.depth,stencil:y.stencil,framebufferScaleFactor:r};p=new XRWebGLLayer(i,t,B),i.updateRenderState({baseLayer:p}),g=new ko(p.framebufferWidth,p.framebufferHeight,{format:mi,type:_a,colorSpace:e.outputColorSpace,stencilBuffer:y.stencil})}else{let B=null,te=null,se=null;y.depth&&(se=y.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,B=y.stencil?Ql:To,te=y.stencil?So:ga);const ae={colorFormat:t.RGBA8,depthFormat:se,scaleFactor:r};h=new XRWebGLBinding(i,t),d=h.createProjectionLayer(ae),i.updateRenderState({layers:[d]}),g=new ko(d.textureWidth,d.textureHeight,{format:mi,type:_a,depthTexture:new iz(d.textureWidth,d.textureHeight,te,void 0,void 0,void 0,void 0,void 0,void 0,B),stencilBuffer:y.stencil,colorSpace:e.outputColorSpace,samples:y.antialias?4:0});const fe=e.properties.get(g);fe.__ignoreDepthValues=d.ignoreDepthValues}g.isXRRenderTarget=!0,this.setFoveation(l),c=null,a=await i.requestReferenceSpace(o),Y.setContext(i),Y.start(),s.isPresenting=!0,s.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function D(G){for(let B=0;B<G.removed.length;B++){const te=G.removed[B],se=x.indexOf(te);se>=0&&(x[se]=null,b[se].disconnect(te))}for(let B=0;B<G.added.length;B++){const te=G.added[B];let se=x.indexOf(te);if(se===-1){for(let fe=0;fe<b.length;fe++)if(fe>=x.length){x.push(te),se=fe;break}else if(x[fe]===null){x[fe]=te,se=fe;break}if(se===-1)break}const ae=b[se];ae&&ae.connect(te)}}const F=new J,k=new J;function P(G,B,te){F.setFromMatrixPosition(B.matrixWorld),k.setFromMatrixPosition(te.matrixWorld);const se=F.distanceTo(k),ae=B.projectionMatrix.elements,fe=te.projectionMatrix.elements,be=ae[14]/(ae[10]-1),ge=ae[14]/(ae[10]+1),ve=(ae[9]+1)/ae[5],Oe=(ae[9]-1)/ae[5],Ce=(ae[8]-1)/ae[0],q=(fe[8]+1)/fe[0],vt=be*Ce,Ee=be*q,Le=se/(-Ce+q),Ae=Le*-Ce;B.matrixWorld.decompose(G.position,G.quaternion,G.scale),G.translateX(Ae),G.translateZ(Le),G.matrixWorld.compose(G.position,G.quaternion,G.scale),G.matrixWorldInverse.copy(G.matrixWorld).invert();const Ye=be+Le,$e=ge+Le,Je=vt-Ae,at=Ee+(se-Ae),Vt=ve*ge/$e*Ye,Dt=Oe*ge/$e*Ye;G.projectionMatrix.makePerspective(Je,at,Vt,Dt,Ye,$e),G.projectionMatrixInverse.copy(G.projectionMatrix).invert()}function O(G,B){B===null?G.matrixWorld.copy(G.matrix):G.matrixWorld.multiplyMatrices(B.matrixWorld,G.matrix),G.matrixWorldInverse.copy(G.matrixWorld).invert()}this.updateCamera=function(G){if(i===null)return;I.near=w.near=v.near=G.near,I.far=w.far=v.far=G.far,(C!==I.near||S!==I.far)&&(i.updateRenderState({depthNear:I.near,depthFar:I.far}),C=I.near,S=I.far);const B=G.parent,te=I.cameras;O(I,B);for(let se=0;se<te.length;se++)O(te[se],B);te.length===2?P(I,v,w):I.projectionMatrix.copy(v.projectionMatrix),V(G,I,B)};function V(G,B,te){te===null?G.matrix.copy(B.matrixWorld):(G.matrix.copy(te.matrixWorld),G.matrix.invert(),G.matrix.multiply(B.matrixWorld)),G.matrix.decompose(G.position,G.quaternion,G.scale),G.updateMatrixWorld(!0),G.projectionMatrix.copy(B.projectionMatrix),G.projectionMatrixInverse.copy(B.projectionMatrixInverse),G.isPerspectiveCamera&&(G.fov=ql*2*Math.atan(1/G.projectionMatrix.elements[5]),G.zoom=1)}this.getCamera=function(){return I},this.getFoveation=function(){if(!(d===null&&p===null))return l},this.setFoveation=function(G){l=G,d!==null&&(d.fixedFoveation=G),p!==null&&p.fixedFoveation!==void 0&&(p.fixedFoveation=G)};let $=null;function H(G,B){if(u=B.getViewerPose(c||a),f=B,u!==null){const te=u.views;p!==null&&(e.setRenderTargetFramebuffer(g,p.framebuffer),e.setRenderTarget(g));let se=!1;te.length!==I.cameras.length&&(I.cameras.length=0,se=!0);for(let ae=0;ae<te.length;ae++){const fe=te[ae];let be=null;if(p!==null)be=p.getViewport(fe);else{const ve=h.getViewSubImage(d,fe);be=ve.viewport,ae===0&&(e.setRenderTargetTextures(g,ve.colorTexture,d.ignoreDepthValues?void 0:ve.depthStencilTexture),e.setRenderTarget(g))}let ge=_[ae];ge===void 0&&(ge=new Ts,ge.layers.enable(ae),ge.viewport=new Xt,_[ae]=ge),ge.matrix.fromArray(fe.transform.matrix),ge.matrix.decompose(ge.position,ge.quaternion,ge.scale),ge.projectionMatrix.fromArray(fe.projectionMatrix),ge.projectionMatrixInverse.copy(ge.projectionMatrix).invert(),ge.viewport.set(be.x,be.y,be.width,be.height),ae===0&&(I.matrix.copy(ge.matrix),I.matrix.decompose(I.position,I.quaternion,I.scale)),se===!0&&I.cameras.push(ge)}}for(let te=0;te<b.length;te++){const se=x[te],ae=b[te];se!==null&&ae!==void 0&&ae.update(se,B,c||a)}$&&$(G,B),B.detectedPlanes&&s.dispatchEvent({type:"planesdetected",data:B}),f=null}const Y=new L2;Y.setAnimationLoop(H),this.setAnimationLoop=function(G){$=G},this.dispose=function(){}}}function az(n,e){function t(m,g){m.matrixAutoUpdate===!0&&m.updateMatrix(),g.value.copy(m.matrix)}function s(m,g){g.color.getRGB(m.fogColor.value,N2(n)),g.isFog?(m.fogNear.value=g.near,m.fogFar.value=g.far):g.isFogExp2&&(m.fogDensity.value=g.density)}function i(m,g,b,x,v){g.isMeshBasicMaterial||g.isMeshLambertMaterial?r(m,g):g.isMeshToonMaterial?(r(m,g),h(m,g)):g.isMeshPhongMaterial?(r(m,g),u(m,g)):g.isMeshStandardMaterial?(r(m,g),d(m,g),g.isMeshPhysicalMaterial&&p(m,g,v)):g.isMeshMatcapMaterial?(r(m,g),f(m,g)):g.isMeshDepthMaterial?r(m,g):g.isMeshDistanceMaterial?(r(m,g),y(m,g)):g.isMeshNormalMaterial?r(m,g):g.isLineBasicMaterial?(a(m,g),g.isLineDashedMaterial&&o(m,g)):g.isPointsMaterial?l(m,g,b,x):g.isSpriteMaterial?c(m,g):g.isShadowMaterial?(m.color.value.copy(g.color),m.opacity.value=g.opacity):g.isShaderMaterial&&(g.uniformsNeedUpdate=!1)}function r(m,g){m.opacity.value=g.opacity,g.color&&m.diffuse.value.copy(g.color),g.emissive&&m.emissive.value.copy(g.emissive).multiplyScalar(g.emissiveIntensity),g.map&&(m.map.value=g.map,t(g.map,m.mapTransform)),g.alphaMap&&(m.alphaMap.value=g.alphaMap,t(g.alphaMap,m.alphaMapTransform)),g.bumpMap&&(m.bumpMap.value=g.bumpMap,t(g.bumpMap,m.bumpMapTransform),m.bumpScale.value=g.bumpScale,g.side===Ws&&(m.bumpScale.value*=-1)),g.normalMap&&(m.normalMap.value=g.normalMap,t(g.normalMap,m.normalMapTransform),m.normalScale.value.copy(g.normalScale),g.side===Ws&&m.normalScale.value.negate()),g.displacementMap&&(m.displacementMap.value=g.displacementMap,t(g.displacementMap,m.displacementMapTransform),m.displacementScale.value=g.displacementScale,m.displacementBias.value=g.displacementBias),g.emissiveMap&&(m.emissiveMap.value=g.emissiveMap,t(g.emissiveMap,m.emissiveMapTransform)),g.specularMap&&(m.specularMap.value=g.specularMap,t(g.specularMap,m.specularMapTransform)),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest);const b=e.get(g).envMap;if(b&&(m.envMap.value=b,m.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=g.reflectivity,m.ior.value=g.ior,m.refractionRatio.value=g.refractionRatio),g.lightMap){m.lightMap.value=g.lightMap;const x=n._useLegacyLights===!0?Math.PI:1;m.lightMapIntensity.value=g.lightMapIntensity*x,t(g.lightMap,m.lightMapTransform)}g.aoMap&&(m.aoMap.value=g.aoMap,m.aoMapIntensity.value=g.aoMapIntensity,t(g.aoMap,m.aoMapTransform))}function a(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,g.map&&(m.map.value=g.map,t(g.map,m.mapTransform))}function o(m,g){m.dashSize.value=g.dashSize,m.totalSize.value=g.dashSize+g.gapSize,m.scale.value=g.scale}function l(m,g,b,x){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.size.value=g.size*b,m.scale.value=x*.5,g.map&&(m.map.value=g.map,t(g.map,m.uvTransform)),g.alphaMap&&(m.alphaMap.value=g.alphaMap,t(g.alphaMap,m.alphaMapTransform)),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest)}function c(m,g){m.diffuse.value.copy(g.color),m.opacity.value=g.opacity,m.rotation.value=g.rotation,g.map&&(m.map.value=g.map,t(g.map,m.mapTransform)),g.alphaMap&&(m.alphaMap.value=g.alphaMap,t(g.alphaMap,m.alphaMapTransform)),g.alphaTest>0&&(m.alphaTest.value=g.alphaTest)}function u(m,g){m.specular.value.copy(g.specular),m.shininess.value=Math.max(g.shininess,1e-4)}function h(m,g){g.gradientMap&&(m.gradientMap.value=g.gradientMap)}function d(m,g){m.metalness.value=g.metalness,g.metalnessMap&&(m.metalnessMap.value=g.metalnessMap,t(g.metalnessMap,m.metalnessMapTransform)),m.roughness.value=g.roughness,g.roughnessMap&&(m.roughnessMap.value=g.roughnessMap,t(g.roughnessMap,m.roughnessMapTransform)),e.get(g).envMap&&(m.envMapIntensity.value=g.envMapIntensity)}function p(m,g,b){m.ior.value=g.ior,g.sheen>0&&(m.sheenColor.value.copy(g.sheenColor).multiplyScalar(g.sheen),m.sheenRoughness.value=g.sheenRoughness,g.sheenColorMap&&(m.sheenColorMap.value=g.sheenColorMap,t(g.sheenColorMap,m.sheenColorMapTransform)),g.sheenRoughnessMap&&(m.sheenRoughnessMap.value=g.sheenRoughnessMap,t(g.sheenRoughnessMap,m.sheenRoughnessMapTransform))),g.clearcoat>0&&(m.clearcoat.value=g.clearcoat,m.clearcoatRoughness.value=g.clearcoatRoughness,g.clearcoatMap&&(m.clearcoatMap.value=g.clearcoatMap,t(g.clearcoatMap,m.clearcoatMapTransform)),g.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=g.clearcoatRoughnessMap,t(g.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),g.clearcoatNormalMap&&(m.clearcoatNormalMap.value=g.clearcoatNormalMap,t(g.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(g.clearcoatNormalScale),g.side===Ws&&m.clearcoatNormalScale.value.negate())),g.iridescence>0&&(m.iridescence.value=g.iridescence,m.iridescenceIOR.value=g.iridescenceIOR,m.iridescenceThicknessMinimum.value=g.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=g.iridescenceThicknessRange[1],g.iridescenceMap&&(m.iridescenceMap.value=g.iridescenceMap,t(g.iridescenceMap,m.iridescenceMapTransform)),g.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=g.iridescenceThicknessMap,t(g.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),g.transmission>0&&(m.transmission.value=g.transmission,m.transmissionSamplerMap.value=b.texture,m.transmissionSamplerSize.value.set(b.width,b.height),g.transmissionMap&&(m.transmissionMap.value=g.transmissionMap,t(g.transmissionMap,m.transmissionMapTransform)),m.thickness.value=g.thickness,g.thicknessMap&&(m.thicknessMap.value=g.thicknessMap,t(g.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=g.attenuationDistance,m.attenuationColor.value.copy(g.attenuationColor)),g.anisotropy>0&&(m.anisotropyVector.value.set(g.anisotropy*Math.cos(g.anisotropyRotation),g.anisotropy*Math.sin(g.anisotropyRotation)),g.anisotropyMap&&(m.anisotropyMap.value=g.anisotropyMap,t(g.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=g.specularIntensity,m.specularColor.value.copy(g.specularColor),g.specularColorMap&&(m.specularColorMap.value=g.specularColorMap,t(g.specularColorMap,m.specularColorMapTransform)),g.specularIntensityMap&&(m.specularIntensityMap.value=g.specularIntensityMap,t(g.specularIntensityMap,m.specularIntensityMapTransform))}function f(m,g){g.matcap&&(m.matcap.value=g.matcap)}function y(m,g){const b=e.get(g).light;m.referencePosition.value.setFromMatrixPosition(b.matrixWorld),m.nearDistance.value=b.shadow.camera.near,m.farDistance.value=b.shadow.camera.far}return{refreshFogUniforms:s,refreshMaterialUniforms:i}}function oz(n,e,t,s){let i={},r={},a=[];const o=t.isWebGL2?n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS):0;function l(b,x){const v=x.program;s.uniformBlockBinding(b,v)}function c(b,x){let v=i[b.id];v===void 0&&(f(b),v=u(b),i[b.id]=v,b.addEventListener("dispose",m));const w=x.program;s.updateUBOMapping(b,w);const _=e.render.frame;r[b.id]!==_&&(d(b),r[b.id]=_)}function u(b){const x=h();b.__bindingPointIndex=x;const v=n.createBuffer(),w=b.__size,_=b.usage;return n.bindBuffer(n.UNIFORM_BUFFER,v),n.bufferData(n.UNIFORM_BUFFER,w,_),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,x,v),v}function h(){for(let b=0;b<o;b++)if(a.indexOf(b)===-1)return a.push(b),b;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(b){const x=i[b.id],v=b.uniforms,w=b.__cache;n.bindBuffer(n.UNIFORM_BUFFER,x);for(let _=0,I=v.length;_<I;_++){const C=v[_];if(p(C,_,w)===!0){const S=C.__offset,M=Array.isArray(C.value)?C.value:[C.value];let A=0;for(let D=0;D<M.length;D++){const F=M[D],k=y(F);typeof F=="number"?(C.__data[0]=F,n.bufferSubData(n.UNIFORM_BUFFER,S+A,C.__data)):F.isMatrix3?(C.__data[0]=F.elements[0],C.__data[1]=F.elements[1],C.__data[2]=F.elements[2],C.__data[3]=F.elements[0],C.__data[4]=F.elements[3],C.__data[5]=F.elements[4],C.__data[6]=F.elements[5],C.__data[7]=F.elements[0],C.__data[8]=F.elements[6],C.__data[9]=F.elements[7],C.__data[10]=F.elements[8],C.__data[11]=F.elements[0]):(F.toArray(C.__data,A),A+=k.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,S,C.__data)}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function p(b,x,v){const w=b.value;if(v[x]===void 0){if(typeof w=="number")v[x]=w;else{const _=Array.isArray(w)?w:[w],I=[];for(let C=0;C<_.length;C++)I.push(_[C].clone());v[x]=I}return!0}else if(typeof w=="number"){if(v[x]!==w)return v[x]=w,!0}else{const _=Array.isArray(v[x])?v[x]:[v[x]],I=Array.isArray(w)?w:[w];for(let C=0;C<_.length;C++){const S=_[C];if(S.equals(I[C])===!1)return S.copy(I[C]),!0}}return!1}function f(b){const x=b.uniforms;let v=0;const w=16;let _=0;for(let I=0,C=x.length;I<C;I++){const S=x[I],M={boundary:0,storage:0},A=Array.isArray(S.value)?S.value:[S.value];for(let D=0,F=A.length;D<F;D++){const k=A[D],P=y(k);M.boundary+=P.boundary,M.storage+=P.storage}if(S.__data=new Float32Array(M.storage/Float32Array.BYTES_PER_ELEMENT),S.__offset=v,I>0){_=v%w;const D=w-_;_!==0&&D-M.boundary<0&&(v+=w-_,S.__offset=v)}v+=M.storage}return _=v%w,_>0&&(v+=w-_),b.__size=v,b.__cache={},this}function y(b){const x={boundary:0,storage:0};return typeof b=="number"?(x.boundary=4,x.storage=4):b.isVector2?(x.boundary=8,x.storage=8):b.isVector3||b.isColor?(x.boundary=16,x.storage=12):b.isVector4?(x.boundary=16,x.storage=16):b.isMatrix3?(x.boundary=48,x.storage=48):b.isMatrix4?(x.boundary=64,x.storage=64):b.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",b),x}function m(b){const x=b.target;x.removeEventListener("dispose",m);const v=a.indexOf(x.__bindingPointIndex);a.splice(v,1),n.deleteBuffer(i[x.id]),delete i[x.id],delete r[x.id]}function g(){for(const b in i)n.deleteBuffer(i[b]);a=[],i={},r={}}return{bind:l,update:c,dispose:g}}class G2{constructor(e={}){const{canvas:t=nP(),context:s=null,depth:i=!0,stencil:r=!0,alpha:a=!1,antialias:o=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:h=!1}=e;this.isWebGLRenderer=!0;let d;s!==null?d=s.getContextAttributes().alpha:d=a;const p=new Uint32Array(4),f=new Int32Array(4);let y=null,m=null;const g=[],b=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=an,this._useLegacyLights=!1,this.toneMapping=Ta,this.toneMappingExposure=1;const x=this;let v=!1,w=0,_=0,I=null,C=-1,S=null;const M=new Xt,A=new Xt;let D=null;const F=new lt(0);let k=0,P=t.width,O=t.height,V=1,$=null,H=null;const Y=new Xt(0,0,P,O),G=new Xt(0,0,P,O);let B=!1;const te=new Zx;let se=!1,ae=!1,fe=null;const be=new ot,ge=new Rt,ve=new J,Oe={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Ce(){return I===null?V:1}let q=s;function vt(L,ne){for(let oe=0;oe<L.length;oe++){const ce=L[oe],ue=t.getContext(ce,ne);if(ue!==null)return ue}return null}try{const L={alpha:!0,depth:i,stencil:r,antialias:o,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:h};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${Bx}`),t.addEventListener("webglcontextlost",Nt,!1),t.addEventListener("webglcontextrestored",Q,!1),t.addEventListener("webglcontextcreationerror",Pe,!1),q===null){const ne=["webgl2","webgl","experimental-webgl"];if(x.isWebGL1Renderer===!0&&ne.shift(),q=vt(ne,L),q===null)throw vt(ne)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}typeof WebGLRenderingContext<"u"&&q instanceof WebGLRenderingContext&&console.warn("THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."),q.getShaderPrecisionFormat===void 0&&(q.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(L){throw console.error("THREE.WebGLRenderer: "+L.message),L}let Ee,Le,Ae,Ye,$e,Je,at,Vt,Dt,z,R,ie,ye,me,xe,Xe,_e,De,tt,It,we,Ft,ht,it;function je(){Ee=new yO(q),Le=new hO(q,Ee,e),Ee.init(Le),Ft=new tz(q,Ee,Le),Ae=new qG(q,Ee,Le),Ye=new vO(q),$e=new zG,Je=new ez(q,Ee,Ae,$e,Le,Ft,Ye),at=new pO(x),Vt=new gO(x),Dt=new NP(q,Le),ht=new cO(q,Ee,Dt,Le),z=new bO(q,Dt,Ye,ht),R=new _O(q,z,Dt,Ye),tt=new TO(q,Le,Je),Xe=new dO($e),ie=new GG(x,at,Vt,Ee,Le,ht,Xe),ye=new az(x,$e),me=new WG,xe=new KG(Ee,Le),De=new lO(x,at,Vt,Ae,R,d,l),_e=new JG(x,R,Le),it=new oz(q,Ye,Le,Ae),It=new uO(q,Ee,Ye,Le),we=new xO(q,Ee,Ye,Le),Ye.programs=ie.programs,x.capabilities=Le,x.extensions=Ee,x.properties=$e,x.renderLists=me,x.shadowMap=_e,x.state=Ae,x.info=Ye}je();const We=new rz(x,q);this.xr=We,this.getContext=function(){return q},this.getContextAttributes=function(){return q.getContextAttributes()},this.forceContextLoss=function(){const L=Ee.get("WEBGL_lose_context");L&&L.loseContext()},this.forceContextRestore=function(){const L=Ee.get("WEBGL_lose_context");L&&L.restoreContext()},this.getPixelRatio=function(){return V},this.setPixelRatio=function(L){L!==void 0&&(V=L,this.setSize(P,O,!1))},this.getSize=function(L){return L.set(P,O)},this.setSize=function(L,ne,oe=!0){if(We.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}P=L,O=ne,t.width=Math.floor(L*V),t.height=Math.floor(ne*V),oe===!0&&(t.style.width=L+"px",t.style.height=ne+"px"),this.setViewport(0,0,L,ne)},this.getDrawingBufferSize=function(L){return L.set(P*V,O*V).floor()},this.setDrawingBufferSize=function(L,ne,oe){P=L,O=ne,V=oe,t.width=Math.floor(L*oe),t.height=Math.floor(ne*oe),this.setViewport(0,0,L,ne)},this.getCurrentViewport=function(L){return L.copy(M)},this.getViewport=function(L){return L.copy(Y)},this.setViewport=function(L,ne,oe,ce){L.isVector4?Y.set(L.x,L.y,L.z,L.w):Y.set(L,ne,oe,ce),Ae.viewport(M.copy(Y).multiplyScalar(V).floor())},this.getScissor=function(L){return L.copy(G)},this.setScissor=function(L,ne,oe,ce){L.isVector4?G.set(L.x,L.y,L.z,L.w):G.set(L,ne,oe,ce),Ae.scissor(A.copy(G).multiplyScalar(V).floor())},this.getScissorTest=function(){return B},this.setScissorTest=function(L){Ae.setScissorTest(B=L)},this.setOpaqueSort=function(L){$=L},this.setTransparentSort=function(L){H=L},this.getClearColor=function(L){return L.copy(De.getClearColor())},this.setClearColor=function(){De.setClearColor.apply(De,arguments)},this.getClearAlpha=function(){return De.getClearAlpha()},this.setClearAlpha=function(){De.setClearAlpha.apply(De,arguments)},this.clear=function(L=!0,ne=!0,oe=!0){let ce=0;if(L){let ue=!1;if(I!==null){const Ge=I.texture.format;ue=Ge===g2||Ge===m2||Ge===f2}if(ue){const Ge=I.texture.type,Ze=Ge===_a||Ge===ga||Ge===$x||Ge===So||Ge===d2||Ge===p2,et=De.getClearColor(),rt=De.getClearAlpha(),bt=et.r,dt=et.g,pt=et.b;Ze?(p[0]=bt,p[1]=dt,p[2]=pt,p[3]=rt,q.clearBufferuiv(q.COLOR,0,p)):(f[0]=bt,f[1]=dt,f[2]=pt,f[3]=rt,q.clearBufferiv(q.COLOR,0,f))}else ce|=q.COLOR_BUFFER_BIT}ne&&(ce|=q.DEPTH_BUFFER_BIT),oe&&(ce|=q.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),q.clear(ce)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",Nt,!1),t.removeEventListener("webglcontextrestored",Q,!1),t.removeEventListener("webglcontextcreationerror",Pe,!1),me.dispose(),xe.dispose(),$e.dispose(),at.dispose(),Vt.dispose(),R.dispose(),ht.dispose(),it.dispose(),ie.dispose(),We.dispose(),We.removeEventListener("sessionstart",li),We.removeEventListener("sessionend",Zt),fe&&(fe.dispose(),fe=null),xs.stop()};function Nt(L){L.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),v=!0}function Q(){console.log("THREE.WebGLRenderer: Context Restored."),v=!1;const L=Ye.autoReset,ne=_e.enabled,oe=_e.autoUpdate,ce=_e.needsUpdate,ue=_e.type;je(),Ye.autoReset=L,_e.enabled=ne,_e.autoUpdate=oe,_e.needsUpdate=ce,_e.type=ue}function Pe(L){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",L.statusMessage)}function Te(L){const ne=L.target;ne.removeEventListener("dispose",Te),he(ne)}function he(L){Ie(L),$e.remove(L)}function Ie(L){const ne=$e.get(L).programs;ne!==void 0&&(ne.forEach(function(oe){ie.releaseProgram(oe)}),L.isShaderMaterial&&ie.releaseShaderCache(L))}this.renderBufferDirect=function(L,ne,oe,ce,ue,Ge){ne===null&&(ne=Oe);const Ze=ue.isMesh&&ue.matrixWorld.determinant()<0,et=PL(L,ne,oe,ce,ue);Ae.setMaterial(ce,Ze);let rt=oe.index,bt=1;if(ce.wireframe===!0){if(rt=z.getWireframeAttribute(oe),rt===void 0)return;bt=2}const dt=oe.drawRange,pt=oe.attributes.position;let bn=dt.start*bt,Ys=(dt.start+dt.count)*bt;Ge!==null&&(bn=Math.max(bn,Ge.start*bt),Ys=Math.min(Ys,(Ge.start+Ge.count)*bt)),rt!==null?(bn=Math.max(bn,0),Ys=Math.min(Ys,rt.count)):pt!=null&&(bn=Math.max(bn,0),Ys=Math.min(Ys,pt.count));const Un=Ys-bn;if(Un<0||Un===1/0)return;ht.setup(ue,ce,et,oe,rt);let wr,dn=It;if(rt!==null&&(wr=Dt.get(rt),dn=we,dn.setIndex(wr)),ue.isMesh)ce.wireframe===!0?(Ae.setLineWidth(ce.wireframeLinewidth*Ce()),dn.setMode(q.LINES)):dn.setMode(q.TRIANGLES);else if(ue.isLine){let Mt=ce.linewidth;Mt===void 0&&(Mt=1),Ae.setLineWidth(Mt*Ce()),ue.isLineSegments?dn.setMode(q.LINES):ue.isLineLoop?dn.setMode(q.LINE_LOOP):dn.setMode(q.LINE_STRIP)}else ue.isPoints?dn.setMode(q.POINTS):ue.isSprite&&dn.setMode(q.TRIANGLES);if(ue.isInstancedMesh)dn.renderInstances(bn,Un,ue.count);else if(oe.isInstancedBufferGeometry){const Mt=oe._maxInstanceCount!==void 0?oe._maxInstanceCount:1/0,rb=Math.min(oe.instanceCount,Mt);dn.renderInstances(bn,Un,rb)}else dn.render(bn,Un)};function qe(L,ne,oe){L.transparent===!0&&L.side===Pi&&L.forceSinglePass===!1?(L.side=Ws,L.needsUpdate=!0,Ap(L,ne,oe),L.side=Wr,L.needsUpdate=!0,Ap(L,ne,oe),L.side=Pi):Ap(L,ne,oe)}this.compile=function(L,ne,oe=null){oe===null&&(oe=L),m=xe.get(oe),m.init(),b.push(m),oe.traverseVisible(function(ue){ue.isLight&&ue.layers.test(ne.layers)&&(m.pushLight(ue),ue.castShadow&&m.pushShadow(ue))}),L!==oe&&L.traverseVisible(function(ue){ue.isLight&&ue.layers.test(ne.layers)&&(m.pushLight(ue),ue.castShadow&&m.pushShadow(ue))}),m.setupLights(x._useLegacyLights);const ce=new Set;return L.traverse(function(ue){const Ge=ue.material;if(Ge)if(Array.isArray(Ge))for(let Ze=0;Ze<Ge.length;Ze++){const et=Ge[Ze];qe(et,oe,ue),ce.add(et)}else qe(Ge,oe,ue),ce.add(Ge)}),b.pop(),m=null,ce},this.compileAsync=function(L,ne,oe=null){const ce=this.compile(L,ne,oe);return new Promise(ue=>{function Ge(){if(ce.forEach(function(Ze){$e.get(Ze).currentProgram.isReady()&&ce.delete(Ze)}),ce.size===0){ue(L);return}setTimeout(Ge,10)}Ee.get("KHR_parallel_shader_compile")!==null?Ge():setTimeout(Ge,10)})};let Lt=null;function _n(L){Lt&&Lt(L)}function li(){xs.stop()}function Zt(){xs.start()}const xs=new L2;xs.setAnimationLoop(_n),typeof self<"u"&&xs.setContext(self),this.setAnimationLoop=function(L){Lt=L,We.setAnimationLoop(L),L===null?xs.stop():xs.start()},We.addEventListener("sessionstart",li),We.addEventListener("sessionend",Zt),this.render=function(L,ne){if(ne!==void 0&&ne.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(v===!0)return;L.matrixWorldAutoUpdate===!0&&L.updateMatrixWorld(),ne.parent===null&&ne.matrixWorldAutoUpdate===!0&&ne.updateMatrixWorld(),We.enabled===!0&&We.isPresenting===!0&&(We.cameraAutoUpdate===!0&&We.updateCamera(ne),ne=We.getCamera()),L.isScene===!0&&L.onBeforeRender(x,L,ne,I),m=xe.get(L,b.length),m.init(),b.push(m),be.multiplyMatrices(ne.projectionMatrix,ne.matrixWorldInverse),te.setFromProjectionMatrix(be),ae=this.localClippingEnabled,se=Xe.init(this.clippingPlanes,ae),y=me.get(L,g.length),y.init(),g.push(y),Zi(L,ne,0,x.sortObjects),y.finish(),x.sortObjects===!0&&y.sort($,H),this.info.render.frame++,se===!0&&Xe.beginShadows();const oe=m.state.shadowsArray;if(_e.render(oe,L,ne),se===!0&&Xe.endShadows(),this.info.autoReset===!0&&this.info.reset(),De.render(y,L),m.setupLights(x._useLegacyLights),ne.isArrayCamera){const ce=ne.cameras;for(let ue=0,Ge=ce.length;ue<Ge;ue++){const Ze=ce[ue];dT(y,L,Ze,Ze.viewport)}}else dT(y,L,ne);I!==null&&(Je.updateMultisampleRenderTarget(I),Je.updateRenderTargetMipmap(I)),L.isScene===!0&&L.onAfterRender(x,L,ne),ht.resetDefaultState(),C=-1,S=null,b.pop(),b.length>0?m=b[b.length-1]:m=null,g.pop(),g.length>0?y=g[g.length-1]:y=null};function Zi(L,ne,oe,ce){if(L.visible===!1)return;if(L.layers.test(ne.layers)){if(L.isGroup)oe=L.renderOrder;else if(L.isLOD)L.autoUpdate===!0&&L.update(ne);else if(L.isLight)m.pushLight(L),L.castShadow&&m.pushShadow(L);else if(L.isSprite){if(!L.frustumCulled||te.intersectsSprite(L)){ce&&ve.setFromMatrixPosition(L.matrixWorld).applyMatrix4(be);const Ze=R.update(L),et=L.material;et.visible&&y.push(L,Ze,et,oe,ve.z,null)}}else if((L.isMesh||L.isLine||L.isPoints)&&(!L.frustumCulled||te.intersectsObject(L))){const Ze=R.update(L),et=L.material;if(ce&&(L.boundingSphere!==void 0?(L.boundingSphere===null&&L.computeBoundingSphere(),ve.copy(L.boundingSphere.center)):(Ze.boundingSphere===null&&Ze.computeBoundingSphere(),ve.copy(Ze.boundingSphere.center)),ve.applyMatrix4(L.matrixWorld).applyMatrix4(be)),Array.isArray(et)){const rt=Ze.groups;for(let bt=0,dt=rt.length;bt<dt;bt++){const pt=rt[bt],bn=et[pt.materialIndex];bn&&bn.visible&&y.push(L,Ze,bn,oe,ve.z,pt)}}else et.visible&&y.push(L,Ze,et,oe,ve.z,null)}}const Ge=L.children;for(let Ze=0,et=Ge.length;Ze<et;Ze++)Zi(Ge[Ze],ne,oe,ce)}function dT(L,ne,oe,ce){const ue=L.opaque,Ge=L.transmissive,Ze=L.transparent;m.setupLightsView(oe),se===!0&&Xe.setGlobalState(x.clippingPlanes,oe),Ge.length>0&&LL(ue,Ge,ne,oe),ce&&Ae.viewport(M.copy(ce)),ue.length>0&&Rp(ue,ne,oe),Ge.length>0&&Rp(Ge,ne,oe),Ze.length>0&&Rp(Ze,ne,oe),Ae.buffers.depth.setTest(!0),Ae.buffers.depth.setMask(!0),Ae.buffers.color.setMask(!0),Ae.setPolygonOffset(!1)}function LL(L,ne,oe,ce){if((oe.isScene===!0?oe.overrideMaterial:null)!==null)return;const Ge=Le.isWebGL2;fe===null&&(fe=new ko(1,1,{generateMipmaps:!0,type:Ee.has("EXT_color_buffer_half_float")?Dr:_a,minFilter:Ra,samples:Ge?4:0})),x.getDrawingBufferSize(ge),Ge?fe.setSize(ge.x,ge.y):fe.setSize($f(ge.x),$f(ge.y));const Ze=x.getRenderTarget();x.setRenderTarget(fe),x.getClearColor(F),k=x.getClearAlpha(),k<1&&x.setClearColor(16777215,.5),x.clear();const et=x.toneMapping;x.toneMapping=Ta,Rp(L,oe,ce),Je.updateMultisampleRenderTarget(fe),Je.updateRenderTargetMipmap(fe);let rt=!1;for(let bt=0,dt=ne.length;bt<dt;bt++){const pt=ne[bt],bn=pt.object,Ys=pt.geometry,Un=pt.material,wr=pt.group;if(Un.side===Pi&&bn.layers.test(ce.layers)){const dn=Un.side;Un.side=Ws,Un.needsUpdate=!0,pT(bn,oe,ce,Ys,Un,wr),Un.side=dn,Un.needsUpdate=!0,rt=!0}}rt===!0&&(Je.updateMultisampleRenderTarget(fe),Je.updateRenderTargetMipmap(fe)),x.setRenderTarget(Ze),x.setClearColor(F,k),x.toneMapping=et}function Rp(L,ne,oe){const ce=ne.isScene===!0?ne.overrideMaterial:null;for(let ue=0,Ge=L.length;ue<Ge;ue++){const Ze=L[ue],et=Ze.object,rt=Ze.geometry,bt=ce===null?Ze.material:ce,dt=Ze.group;et.layers.test(oe.layers)&&pT(et,ne,oe,rt,bt,dt)}}function pT(L,ne,oe,ce,ue,Ge){L.onBeforeRender(x,ne,oe,ce,ue,Ge),L.modelViewMatrix.multiplyMatrices(oe.matrixWorldInverse,L.matrixWorld),L.normalMatrix.getNormalMatrix(L.modelViewMatrix),ue.onBeforeRender(x,ne,oe,ce,L,Ge),ue.transparent===!0&&ue.side===Pi&&ue.forceSinglePass===!1?(ue.side=Ws,ue.needsUpdate=!0,x.renderBufferDirect(oe,ne,ce,ue,L,Ge),ue.side=Wr,ue.needsUpdate=!0,x.renderBufferDirect(oe,ne,ce,ue,L,Ge),ue.side=Pi):x.renderBufferDirect(oe,ne,ce,ue,L,Ge),L.onAfterRender(x,ne,oe,ce,ue,Ge)}function Ap(L,ne,oe){ne.isScene!==!0&&(ne=Oe);const ce=$e.get(L),ue=m.state.lights,Ge=m.state.shadowsArray,Ze=ue.state.version,et=ie.getParameters(L,ue.state,Ge,ne,oe),rt=ie.getProgramCacheKey(et);let bt=ce.programs;ce.environment=L.isMeshStandardMaterial?ne.environment:null,ce.fog=ne.fog,ce.envMap=(L.isMeshStandardMaterial?Vt:at).get(L.envMap||ce.environment),bt===void 0&&(L.addEventListener("dispose",Te),bt=new Map,ce.programs=bt);let dt=bt.get(rt);if(dt!==void 0){if(ce.currentProgram===dt&&ce.lightsStateVersion===Ze)return mT(L,et),dt}else et.uniforms=ie.getUniforms(L),L.onBuild(oe,et,x),L.onBeforeCompile(et,x),dt=ie.acquireProgram(et,rt),bt.set(rt,dt),ce.uniforms=et.uniforms;const pt=ce.uniforms;return(!L.isShaderMaterial&&!L.isRawShaderMaterial||L.clipping===!0)&&(pt.clippingPlanes=Xe.uniform),mT(L,et),ce.needsLights=FL(L),ce.lightsStateVersion=Ze,ce.needsLights&&(pt.ambientLightColor.value=ue.state.ambient,pt.lightProbe.value=ue.state.probe,pt.directionalLights.value=ue.state.directional,pt.directionalLightShadows.value=ue.state.directionalShadow,pt.spotLights.value=ue.state.spot,pt.spotLightShadows.value=ue.state.spotShadow,pt.rectAreaLights.value=ue.state.rectArea,pt.ltc_1.value=ue.state.rectAreaLTC1,pt.ltc_2.value=ue.state.rectAreaLTC2,pt.pointLights.value=ue.state.point,pt.pointLightShadows.value=ue.state.pointShadow,pt.hemisphereLights.value=ue.state.hemi,pt.directionalShadowMap.value=ue.state.directionalShadowMap,pt.directionalShadowMatrix.value=ue.state.directionalShadowMatrix,pt.spotShadowMap.value=ue.state.spotShadowMap,pt.spotLightMatrix.value=ue.state.spotLightMatrix,pt.spotLightMap.value=ue.state.spotLightMap,pt.pointShadowMap.value=ue.state.pointShadowMap,pt.pointShadowMatrix.value=ue.state.pointShadowMatrix),ce.currentProgram=dt,ce.uniformsList=null,dt}function fT(L){if(L.uniformsList===null){const ne=L.currentProgram.getUniforms();L.uniformsList=Rf.seqWithValue(ne.seq,L.uniforms)}return L.uniformsList}function mT(L,ne){const oe=$e.get(L);oe.outputColorSpace=ne.outputColorSpace,oe.instancing=ne.instancing,oe.instancingColor=ne.instancingColor,oe.skinning=ne.skinning,oe.morphTargets=ne.morphTargets,oe.morphNormals=ne.morphNormals,oe.morphColors=ne.morphColors,oe.morphTargetsCount=ne.morphTargetsCount,oe.numClippingPlanes=ne.numClippingPlanes,oe.numIntersection=ne.numClipIntersection,oe.vertexAlphas=ne.vertexAlphas,oe.vertexTangents=ne.vertexTangents,oe.toneMapping=ne.toneMapping}function PL(L,ne,oe,ce,ue){ne.isScene!==!0&&(ne=Oe),Je.resetTextureUnits();const Ge=ne.fog,Ze=ce.isMeshStandardMaterial?ne.environment:null,et=I===null?x.outputColorSpace:I.isXRRenderTarget===!0?I.texture.colorSpace:Kn,rt=(ce.isMeshStandardMaterial?Vt:at).get(ce.envMap||Ze),bt=ce.vertexColors===!0&&!!oe.attributes.color&&oe.attributes.color.itemSize===4,dt=!!oe.attributes.tangent&&(!!ce.normalMap||ce.anisotropy>0),pt=!!oe.morphAttributes.position,bn=!!oe.morphAttributes.normal,Ys=!!oe.morphAttributes.color;let Un=Ta;ce.toneMapped&&(I===null||I.isXRRenderTarget===!0)&&(Un=x.toneMapping);const wr=oe.morphAttributes.position||oe.morphAttributes.normal||oe.morphAttributes.color,dn=wr!==void 0?wr.length:0,Mt=$e.get(ce),rb=m.state.lights;if(se===!0&&(ae===!0||L!==S)){const js=L===S&&ce.id===C;Xe.setState(ce,L,js)}let In=!1;ce.version===Mt.__version?(Mt.needsLights&&Mt.lightsStateVersion!==rb.state.version||Mt.outputColorSpace!==et||ue.isInstancedMesh&&Mt.instancing===!1||!ue.isInstancedMesh&&Mt.instancing===!0||ue.isSkinnedMesh&&Mt.skinning===!1||!ue.isSkinnedMesh&&Mt.skinning===!0||ue.isInstancedMesh&&Mt.instancingColor===!0&&ue.instanceColor===null||ue.isInstancedMesh&&Mt.instancingColor===!1&&ue.instanceColor!==null||Mt.envMap!==rt||ce.fog===!0&&Mt.fog!==Ge||Mt.numClippingPlanes!==void 0&&(Mt.numClippingPlanes!==Xe.numPlanes||Mt.numIntersection!==Xe.numIntersection)||Mt.vertexAlphas!==bt||Mt.vertexTangents!==dt||Mt.morphTargets!==pt||Mt.morphNormals!==bn||Mt.morphColors!==Ys||Mt.toneMapping!==Un||Le.isWebGL2===!0&&Mt.morphTargetsCount!==dn)&&(In=!0):(In=!0,Mt.__version=ce.version);let Qa=Mt.currentProgram;In===!0&&(Qa=Ap(ce,ne,ue));let gT=!1,Hu=!1,ab=!1;const vs=Qa.getUniforms(),Ja=Mt.uniforms;if(Ae.useProgram(Qa.program)&&(gT=!0,Hu=!0,ab=!0),ce.id!==C&&(C=ce.id,Hu=!0),gT||S!==L){vs.setValue(q,"projectionMatrix",L.projectionMatrix),vs.setValue(q,"viewMatrix",L.matrixWorldInverse);const js=vs.map.cameraPosition;js!==void 0&&js.setValue(q,ve.setFromMatrixPosition(L.matrixWorld)),Le.logarithmicDepthBuffer&&vs.setValue(q,"logDepthBufFC",2/(Math.log(L.far+1)/Math.LN2)),(ce.isMeshPhongMaterial||ce.isMeshToonMaterial||ce.isMeshLambertMaterial||ce.isMeshBasicMaterial||ce.isMeshStandardMaterial||ce.isShaderMaterial)&&vs.setValue(q,"isOrthographic",L.isOrthographicCamera===!0),S!==L&&(S=L,Hu=!0,ab=!0)}if(ue.isSkinnedMesh){vs.setOptional(q,ue,"bindMatrix"),vs.setOptional(q,ue,"bindMatrixInverse");const js=ue.skeleton;js&&(Le.floatVertexTextures?(js.boneTexture===null&&js.computeBoneTexture(),vs.setValue(q,"boneTexture",js.boneTexture,Je),vs.setValue(q,"boneTextureSize",js.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."))}const ob=oe.morphAttributes;if((ob.position!==void 0||ob.normal!==void 0||ob.color!==void 0&&Le.isWebGL2===!0)&&tt.update(ue,oe,Qa),(Hu||Mt.receiveShadow!==ue.receiveShadow)&&(Mt.receiveShadow=ue.receiveShadow,vs.setValue(q,"receiveShadow",ue.receiveShadow)),ce.isMeshGouraudMaterial&&ce.envMap!==null&&(Ja.envMap.value=rt,Ja.flipEnvMap.value=rt.isCubeTexture&&rt.isRenderTargetTexture===!1?-1:1),Hu&&(vs.setValue(q,"toneMappingExposure",x.toneMappingExposure),Mt.needsLights&&DL(Ja,ab),Ge&&ce.fog===!0&&ye.refreshFogUniforms(Ja,Ge),ye.refreshMaterialUniforms(Ja,ce,V,O,fe),Rf.upload(q,fT(Mt),Ja,Je)),ce.isShaderMaterial&&ce.uniformsNeedUpdate===!0&&(Rf.upload(q,fT(Mt),Ja,Je),ce.uniformsNeedUpdate=!1),ce.isSpriteMaterial&&vs.setValue(q,"center",ue.center),vs.setValue(q,"modelViewMatrix",ue.modelViewMatrix),vs.setValue(q,"normalMatrix",ue.normalMatrix),vs.setValue(q,"modelMatrix",ue.matrixWorld),ce.isShaderMaterial||ce.isRawShaderMaterial){const js=ce.uniformsGroups;for(let lb=0,OL=js.length;lb<OL;lb++)if(Le.isWebGL2){const yT=js[lb];it.update(yT,Qa),it.bind(yT,Qa)}else console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}return Qa}function DL(L,ne){L.ambientLightColor.needsUpdate=ne,L.lightProbe.needsUpdate=ne,L.directionalLights.needsUpdate=ne,L.directionalLightShadows.needsUpdate=ne,L.pointLights.needsUpdate=ne,L.pointLightShadows.needsUpdate=ne,L.spotLights.needsUpdate=ne,L.spotLightShadows.needsUpdate=ne,L.rectAreaLights.needsUpdate=ne,L.hemisphereLights.needsUpdate=ne}function FL(L){return L.isMeshLambertMaterial||L.isMeshToonMaterial||L.isMeshPhongMaterial||L.isMeshStandardMaterial||L.isShadowMaterial||L.isShaderMaterial&&L.lights===!0}this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return _},this.getRenderTarget=function(){return I},this.setRenderTargetTextures=function(L,ne,oe){$e.get(L.texture).__webglTexture=ne,$e.get(L.depthTexture).__webglTexture=oe;const ce=$e.get(L);ce.__hasExternalTextures=!0,ce.__hasExternalTextures&&(ce.__autoAllocateDepthBuffer=oe===void 0,ce.__autoAllocateDepthBuffer||Ee.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ce.__useRenderToTexture=!1))},this.setRenderTargetFramebuffer=function(L,ne){const oe=$e.get(L);oe.__webglFramebuffer=ne,oe.__useDefaultFramebuffer=ne===void 0},this.setRenderTarget=function(L,ne=0,oe=0){I=L,w=ne,_=oe;let ce=!0,ue=null,Ge=!1,Ze=!1;if(L){const rt=$e.get(L);rt.__useDefaultFramebuffer!==void 0?(Ae.bindFramebuffer(q.FRAMEBUFFER,null),ce=!1):rt.__webglFramebuffer===void 0?Je.setupRenderTarget(L):rt.__hasExternalTextures&&Je.rebindTextures(L,$e.get(L.texture).__webglTexture,$e.get(L.depthTexture).__webglTexture);const bt=L.texture;(bt.isData3DTexture||bt.isDataArrayTexture||bt.isCompressedArrayTexture)&&(Ze=!0);const dt=$e.get(L).__webglFramebuffer;L.isWebGLCubeRenderTarget?(Array.isArray(dt[ne])?ue=dt[ne][oe]:ue=dt[ne],Ge=!0):Le.isWebGL2&&L.samples>0&&Je.useMultisampledRTT(L)===!1?ue=$e.get(L).__webglMultisampledFramebuffer:Array.isArray(dt)?ue=dt[oe]:ue=dt,M.copy(L.viewport),A.copy(L.scissor),D=L.scissorTest}else M.copy(Y).multiplyScalar(V).floor(),A.copy(G).multiplyScalar(V).floor(),D=B;if(Ae.bindFramebuffer(q.FRAMEBUFFER,ue)&&Le.drawBuffers&&ce&&Ae.drawBuffers(L,ue),Ae.viewport(M),Ae.scissor(A),Ae.setScissorTest(D),Ge){const rt=$e.get(L.texture);q.framebufferTexture2D(q.FRAMEBUFFER,q.COLOR_ATTACHMENT0,q.TEXTURE_CUBE_MAP_POSITIVE_X+ne,rt.__webglTexture,oe)}else if(Ze){const rt=$e.get(L.texture),bt=ne||0;q.framebufferTextureLayer(q.FRAMEBUFFER,q.COLOR_ATTACHMENT0,rt.__webglTexture,oe||0,bt)}C=-1},this.readRenderTargetPixels=function(L,ne,oe,ce,ue,Ge,Ze){if(!(L&&L.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let et=$e.get(L).__webglFramebuffer;if(L.isWebGLCubeRenderTarget&&Ze!==void 0&&(et=et[Ze]),et){Ae.bindFramebuffer(q.FRAMEBUFFER,et);try{const rt=L.texture,bt=rt.format,dt=rt.type;if(bt!==mi&&Ft.convert(bt)!==q.getParameter(q.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const pt=dt===Dr&&(Ee.has("EXT_color_buffer_half_float")||Le.isWebGL2&&Ee.has("EXT_color_buffer_float"));if(dt!==_a&&Ft.convert(dt)!==q.getParameter(q.IMPLEMENTATION_COLOR_READ_TYPE)&&!(dt===yi&&(Le.isWebGL2||Ee.has("OES_texture_float")||Ee.has("WEBGL_color_buffer_float")))&&!pt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}ne>=0&&ne<=L.width-ce&&oe>=0&&oe<=L.height-ue&&q.readPixels(ne,oe,ce,ue,Ft.convert(bt),Ft.convert(dt),Ge)}finally{const rt=I!==null?$e.get(I).__webglFramebuffer:null;Ae.bindFramebuffer(q.FRAMEBUFFER,rt)}}},this.copyFramebufferToTexture=function(L,ne,oe=0){const ce=Math.pow(2,-oe),ue=Math.floor(ne.image.width*ce),Ge=Math.floor(ne.image.height*ce);Je.setTexture2D(ne,0),q.copyTexSubImage2D(q.TEXTURE_2D,oe,0,0,L.x,L.y,ue,Ge),Ae.unbindTexture()},this.copyTextureToTexture=function(L,ne,oe,ce=0){const ue=ne.image.width,Ge=ne.image.height,Ze=Ft.convert(oe.format),et=Ft.convert(oe.type);Je.setTexture2D(oe,0),q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL,oe.flipY),q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL,oe.premultiplyAlpha),q.pixelStorei(q.UNPACK_ALIGNMENT,oe.unpackAlignment),ne.isDataTexture?q.texSubImage2D(q.TEXTURE_2D,ce,L.x,L.y,ue,Ge,Ze,et,ne.image.data):ne.isCompressedTexture?q.compressedTexSubImage2D(q.TEXTURE_2D,ce,L.x,L.y,ne.mipmaps[0].width,ne.mipmaps[0].height,Ze,ne.mipmaps[0].data):q.texSubImage2D(q.TEXTURE_2D,ce,L.x,L.y,Ze,et,ne.image),ce===0&&oe.generateMipmaps&&q.generateMipmap(q.TEXTURE_2D),Ae.unbindTexture()},this.copyTextureToTexture3D=function(L,ne,oe,ce,ue=0){if(x.isWebGL1Renderer){console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");return}const Ge=L.max.x-L.min.x+1,Ze=L.max.y-L.min.y+1,et=L.max.z-L.min.z+1,rt=Ft.convert(ce.format),bt=Ft.convert(ce.type);let dt;if(ce.isData3DTexture)Je.setTexture3D(ce,0),dt=q.TEXTURE_3D;else if(ce.isDataArrayTexture)Je.setTexture2DArray(ce,0),dt=q.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}q.pixelStorei(q.UNPACK_FLIP_Y_WEBGL,ce.flipY),q.pixelStorei(q.UNPACK_PREMULTIPLY_ALPHA_WEBGL,ce.premultiplyAlpha),q.pixelStorei(q.UNPACK_ALIGNMENT,ce.unpackAlignment);const pt=q.getParameter(q.UNPACK_ROW_LENGTH),bn=q.getParameter(q.UNPACK_IMAGE_HEIGHT),Ys=q.getParameter(q.UNPACK_SKIP_PIXELS),Un=q.getParameter(q.UNPACK_SKIP_ROWS),wr=q.getParameter(q.UNPACK_SKIP_IMAGES),dn=oe.isCompressedTexture?oe.mipmaps[0]:oe.image;q.pixelStorei(q.UNPACK_ROW_LENGTH,dn.width),q.pixelStorei(q.UNPACK_IMAGE_HEIGHT,dn.height),q.pixelStorei(q.UNPACK_SKIP_PIXELS,L.min.x),q.pixelStorei(q.UNPACK_SKIP_ROWS,L.min.y),q.pixelStorei(q.UNPACK_SKIP_IMAGES,L.min.z),oe.isDataTexture||oe.isData3DTexture?q.texSubImage3D(dt,ue,ne.x,ne.y,ne.z,Ge,Ze,et,rt,bt,dn.data):oe.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),q.compressedTexSubImage3D(dt,ue,ne.x,ne.y,ne.z,Ge,Ze,et,rt,dn.data)):q.texSubImage3D(dt,ue,ne.x,ne.y,ne.z,Ge,Ze,et,rt,bt,dn),q.pixelStorei(q.UNPACK_ROW_LENGTH,pt),q.pixelStorei(q.UNPACK_IMAGE_HEIGHT,bn),q.pixelStorei(q.UNPACK_SKIP_PIXELS,Ys),q.pixelStorei(q.UNPACK_SKIP_ROWS,Un),q.pixelStorei(q.UNPACK_SKIP_IMAGES,wr),ue===0&&ce.generateMipmaps&&q.generateMipmap(dt),Ae.unbindTexture()},this.initTexture=function(L){L.isCubeTexture?Je.setTextureCube(L,0):L.isData3DTexture?Je.setTexture3D(L,0):L.isDataArrayTexture||L.isCompressedArrayTexture?Je.setTexture2DArray(L,0):Je.setTexture2D(L,0),Ae.unbindTexture()},this.resetState=function(){w=0,_=0,I=null,Ae.reset(),ht.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Fr}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===Hx?"display-p3":"srgb",t.unpackColorSpace=Pt.workingColorSpace===Em?"display-p3":"srgb"}get physicallyCorrectLights(){return console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),!this.useLegacyLights}set physicallyCorrectLights(e){console.warn("THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."),this.useLegacyLights=!e}get outputEncoding(){return console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace===an?Ia:x2}set outputEncoding(e){console.warn("THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."),this.outputColorSpace=e===Ia?an:Kn}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class lz extends G2{}lz.prototype.isWebGL1Renderer=!0;class O_ extends nn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t}}class cz{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=F0,this.updateRange={offset:0,count:-1},this.version=0,this.uuid=Fi()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,s){e*=this.stride,s*=t.stride;for(let i=0,r=this.stride;i<r;i++)this.array[e+i]=t.array[s+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),s=new this.constructor(t,this.stride);return s.setUsage(this.usage),s}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Fi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const ws=new J;class Jx{constructor(e,t,s,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=s,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,s=this.data.count;t<s;t++)ws.fromBufferAttribute(this,t),ws.applyMatrix4(e),this.setXYZ(t,ws.x,ws.y,ws.z);return this}applyNormalMatrix(e){for(let t=0,s=this.count;t<s;t++)ws.fromBufferAttribute(this,t),ws.applyNormalMatrix(e),this.setXYZ(t,ws.x,ws.y,ws.z);return this}transformDirection(e){for(let t=0,s=this.count;t<s;t++)ws.fromBufferAttribute(this,t),ws.transformDirection(e),this.setXYZ(t,ws.x,ws.y,ws.z);return this}setX(e,t){return this.normalized&&(t=Wt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Wt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Wt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Wt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=sr(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=sr(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=sr(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=sr(t,this.array)),t}setXY(e,t,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this}setXYZ(e,t,s,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array),i=Wt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this}setXYZW(e,t,s,i,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Wt(t,this.array),s=Wt(s,this.array),i=Wt(i,this.array),r=Wt(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=s,this.data.array[e+2]=i,this.data.array[e+3]=r,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return new Ms(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Jx(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let s=0;s<this.count;s++){const i=s*this.data.stride+this.offset;for(let r=0;r<this.itemSize;r++)t.push(this.data.array[i+r])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const G_=new J,z_=new Xt,V_=new Xt,uz=new J,W_=new ot,nf=new J,Gb=new yr,U_=new ot,zb=new km;class hz extends bi{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=_T,this.bindMatrix=new ot,this.bindMatrixInverse=new ot,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new jr),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,nf),this.boundingBox.expandByPoint(nf)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new yr),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let s=0;s<t.count;s++)this.getVertexPosition(s,nf),this.boundingSphere.expandByPoint(nf)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const s=this.material,i=this.matrixWorld;s!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Gb.copy(this.boundingSphere),Gb.applyMatrix4(i),e.ray.intersectsSphere(Gb)!==!1&&(U_.copy(i).invert(),zb.copy(e.ray).applyMatrix4(U_),!(this.boundingBox!==null&&zb.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,zb)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Xt,t=this.geometry.attributes.skinWeight;for(let s=0,i=t.count;s<i;s++){e.fromBufferAttribute(t,s);const r=1/e.manhattanLength();r!==1/0?e.multiplyScalar(r):e.set(1,0,0,0),t.setXYZW(s,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===_T?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===y3?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const s=this.skeleton,i=this.geometry;z_.fromBufferAttribute(i.attributes.skinIndex,e),V_.fromBufferAttribute(i.attributes.skinWeight,e),G_.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let r=0;r<4;r++){const a=V_.getComponent(r);if(a!==0){const o=z_.getComponent(r);W_.multiplyMatrices(s.bones[o].matrixWorld,s.boneInverses[o]),t.addScaledVector(uz.copy(G_).applyMatrix4(W_),a)}}return t.applyMatrix4(this.bindMatrixInverse)}boneTransform(e,t){return console.warn("THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."),this.applyBoneTransform(e,t)}}class z2 extends nn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class V2 extends is{constructor(e=null,t=1,s=1,i,r,a,o,l,c=$n,u=$n,h,d){super(null,a,o,l,c,u,i,r,h,d),this.isDataTexture=!0,this.image={data:e,width:t,height:s},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const B_=new ot,dz=new ot;class qx{constructor(e=[],t=[]){this.uuid=Fi(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.boneTextureSize=0,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let s=0,i=this.bones.length;s<i;s++)this.boneInverses.push(new ot)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const s=new ot;this.bones[e]&&s.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(s)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&s.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const s=this.bones[e];s&&(s.parent&&s.parent.isBone?(s.matrix.copy(s.parent.matrixWorld).invert(),s.matrix.multiply(s.matrixWorld)):s.matrix.copy(s.matrixWorld),s.matrix.decompose(s.position,s.quaternion,s.scale))}}update(){const e=this.bones,t=this.boneInverses,s=this.boneMatrices,i=this.boneTexture;for(let r=0,a=e.length;r<a;r++){const o=e[r]?e[r].matrixWorld:dz;B_.multiplyMatrices(o,t[r]),B_.toArray(s,r*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new qx(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=w2(e),e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const s=new V2(t,e,e,mi,yi);return s.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=s,this.boneTextureSize=e,this}getBoneByName(e){for(let t=0,s=this.bones.length;t<s;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let s=0,i=e.bones.length;s<i;s++){const r=e.bones[s];let a=t[r];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",r),a=new z2),this.bones.push(a),this.boneInverses.push(new ot().fromArray(e.boneInverses[s]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,s=this.boneInverses;for(let i=0,r=t.length;i<r;i++){const a=t[i];e.bones.push(a.uuid);const o=s[i];e.boneInverses.push(o.toArray())}return e}}class V0 extends Ms{constructor(e,t,s,i=1){super(e,t,s),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const El=new ot,$_=new ot,sf=[],X_=new jr,pz=new ot,Qu=new bi,Ju=new yr;class fz extends bi{constructor(e,t,s){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new V0(new Float32Array(s*16),16),this.instanceColor=null,this.count=s,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<s;i++)this.setMatrixAt(i,pz)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new jr),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,El),X_.copy(e.boundingBox).applyMatrix4(El),this.boundingBox.union(X_)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new yr),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let s=0;s<t;s++)this.getMatrixAt(s,El),Ju.copy(e.boundingSphere).applyMatrix4(El),this.boundingSphere.union(Ju)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}raycast(e,t){const s=this.matrixWorld,i=this.count;if(Qu.geometry=this.geometry,Qu.material=this.material,Qu.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Ju.copy(this.boundingSphere),Ju.applyMatrix4(s),e.ray.intersectsSphere(Ju)!==!1))for(let r=0;r<i;r++){this.getMatrixAt(r,El),$_.multiplyMatrices(s,El),Qu.matrixWorld=$_,Qu.raycast(e,sf);for(let a=0,o=sf.length;a<o;a++){const l=sf[a];l.instanceId=r,l.object=this,t.push(l)}sf.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new V0(new Float32Array(this.instanceMatrix.count*3),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class W2 extends lr{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new lt(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const H_=new J,K_=new J,Z_=new ot,Vb=new km,rf=new yr;class e1 extends nn{constructor(e=new br,t=new W2){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[0];for(let i=1,r=t.count;i<r;i++)H_.fromBufferAttribute(t,i-1),K_.fromBufferAttribute(t,i),s[i]=s[i-1],s[i]+=H_.distanceTo(K_);e.setAttribute("lineDistance",new zr(s,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Line.threshold,a=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),rf.copy(s.boundingSphere),rf.applyMatrix4(i),rf.radius+=r,e.ray.intersectsSphere(rf)===!1)return;Z_.copy(i).invert(),Vb.copy(e.ray).applyMatrix4(Z_);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=new J,u=new J,h=new J,d=new J,p=this.isLineSegments?2:1,f=s.index,m=s.attributes.position;if(f!==null){const g=Math.max(0,a.start),b=Math.min(f.count,a.start+a.count);for(let x=g,v=b-1;x<v;x+=p){const w=f.getX(x),_=f.getX(x+1);if(c.fromBufferAttribute(m,w),u.fromBufferAttribute(m,_),Vb.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const C=e.ray.origin.distanceTo(d);C<e.near||C>e.far||t.push({distance:C,point:h.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}else{const g=Math.max(0,a.start),b=Math.min(m.count,a.start+a.count);for(let x=g,v=b-1;x<v;x+=p){if(c.fromBufferAttribute(m,x),u.fromBufferAttribute(m,x+1),Vb.distanceSqToSegment(c,u,d,h)>l)continue;d.applyMatrix4(this.matrixWorld);const _=e.ray.origin.distanceTo(d);_<e.near||_>e.far||t.push({distance:_,point:h.clone().applyMatrix4(this.matrixWorld),index:x,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}const Y_=new J,j_=new J;class mz extends e1{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,s=[];for(let i=0,r=t.count;i<r;i+=2)Y_.fromBufferAttribute(t,i),j_.fromBufferAttribute(t,i+1),s[i]=i===0?0:s[i-1],s[i+1]=s[i]+Y_.distanceTo(j_);e.setAttribute("lineDistance",new zr(s,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class gz extends e1{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class U2 extends lr{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new lt(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const Q_=new ot,W0=new km,af=new yr,of=new J;class yz extends nn{constructor(e=new br,t=new U2){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const s=this.geometry,i=this.matrixWorld,r=e.params.Points.threshold,a=s.drawRange;if(s.boundingSphere===null&&s.computeBoundingSphere(),af.copy(s.boundingSphere),af.applyMatrix4(i),af.radius+=r,e.ray.intersectsSphere(af)===!1)return;Q_.copy(i).invert(),W0.copy(e.ray).applyMatrix4(Q_);const o=r/((this.scale.x+this.scale.y+this.scale.z)/3),l=o*o,c=s.index,h=s.attributes.position;if(c!==null){const d=Math.max(0,a.start),p=Math.min(c.count,a.start+a.count);for(let f=d,y=p;f<y;f++){const m=c.getX(f);of.fromBufferAttribute(h,m),J_(of,m,l,i,e,t,this)}}else{const d=Math.max(0,a.start),p=Math.min(h.count,a.start+a.count);for(let f=d,y=p;f<y;f++)of.fromBufferAttribute(h,f),J_(of,f,l,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,s=Object.keys(t);if(s.length>0){const i=t[s[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let r=0,a=i.length;r<a;r++){const o=i[r].name||String(r);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=r}}}}}function J_(n,e,t,s,i,r,a){const o=W0.distanceSqToPoint(n);if(o<t){const l=new J;W0.closestPointToPoint(n,l),l.applyMatrix4(s);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;r.push({distance:c,distanceToRay:Math.sqrt(o),point:l,index:e,face:null,object:a})}}class t1 extends lr{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new lt(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new lt(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=v2,this.normalScale=new Rt(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Va extends t1{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Rt(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return ts(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new lt(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new lt(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new lt(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function lf(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function bz(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function xz(n){function e(i,r){return n[i]-n[r]}const t=n.length,s=new Array(t);for(let i=0;i!==t;++i)s[i]=i;return s.sort(e),s}function q_(n,e,t){const s=n.length,i=new n.constructor(s);for(let r=0,a=0;a!==s;++r){const o=t[r]*e;for(let l=0;l!==e;++l)i[a++]=n[o+l]}return i}function B2(n,e,t,s){let i=1,r=n[0];for(;r!==void 0&&r[s]===void 0;)r=n[i++];if(r===void 0)return;let a=r[s];if(a!==void 0)if(Array.isArray(a))do a=r[s],a!==void 0&&(e.push(r.time),t.push.apply(t,a)),r=n[i++];while(r!==void 0);else if(a.toArray!==void 0)do a=r[s],a!==void 0&&(e.push(r.time),a.toArray(t,t.length)),r=n[i++];while(r!==void 0);else do a=r[s],a!==void 0&&(e.push(r.time),t.push(a)),r=n[i++];while(r!==void 0)}class Bh{constructor(e,t,s,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(s),this.sampleValues=t,this.valueSize=s,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let s=this._cachedIndex,i=t[s],r=t[s-1];e:{t:{let a;n:{s:if(!(e<i)){for(let o=s+2;;){if(i===void 0){if(e<r)break s;return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}if(s===o)break;if(r=i,i=t[++s],e<i)break t}a=t.length;break n}if(!(e>=r)){const o=t[1];e<o&&(s=2,r=o);for(let l=s-2;;){if(r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(s===l)break;if(i=r,r=t[--s-1],e>=r)break t}a=s,s=0;break n}break e}for(;s<a;){const o=s+a>>>1;e<t[o]?a=o:s=o+1}if(i=t[s],r=t[s-1],r===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return s=t.length,this._cachedIndex=s,this.copySampleValue_(s-1)}this._cachedIndex=s,this.intervalChanged_(s,r,i)}return this.interpolate_(s,r,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i;for(let a=0;a!==i;++a)t[a]=s[r+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class vz extends Bh{constructor(e,t,s,i){super(e,t,s,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Dl,endingEnd:Dl}}intervalChanged_(e,t,s){const i=this.parameterPositions;let r=e-2,a=e+1,o=i[r],l=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case Fl:r=e,o=2*t-s;break;case zf:r=i.length-2,o=t+i[r]-i[r+1];break;default:r=e,o=s}if(l===void 0)switch(this.getSettings_().endingEnd){case Fl:a=e,l=2*s-t;break;case zf:a=1,l=s+i[1]-i[0];break;default:a=e-1,l=t}const c=(s-t)*.5,u=this.valueSize;this._weightPrev=c/(t-o),this._weightNext=c/(l-s),this._offsetPrev=r*u,this._offsetNext=a*u}interpolate_(e,t,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=this._offsetPrev,h=this._offsetNext,d=this._weightPrev,p=this._weightNext,f=(s-t)/(i-t),y=f*f,m=y*f,g=-d*m+2*d*y-d*f,b=(1+d)*m+(-1.5-2*d)*y+(-.5+d)*f+1,x=(-1-p)*m+(1.5+p)*y+.5*f,v=p*m-p*y;for(let w=0;w!==o;++w)r[w]=g*a[u+w]+b*a[c+w]+x*a[l+w]+v*a[h+w];return r}}class $2 extends Bh{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=e*o,c=l-o,u=(s-t)/(i-t),h=1-u;for(let d=0;d!==o;++d)r[d]=a[c+d]*h+a[l+d]*u;return r}}class wz extends Bh{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class xr{constructor(e,t,s,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=lf(t,this.TimeBufferType),this.values=lf(s,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let s;if(t.toJSON!==this.toJSON)s=t.toJSON(e);else{s={name:e.name,times:lf(e.times,Array),values:lf(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(s.interpolation=i)}return s.type=e.ValueTypeName,s}InterpolantFactoryMethodDiscrete(e){return new wz(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new $2(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new vz(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case wh:t=this.InterpolantFactoryMethodDiscrete;break;case Jl:t=this.InterpolantFactoryMethodLinear;break;case fb:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const s="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(s);return console.warn("THREE.KeyframeTrack:",s),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return wh;case this.InterpolantFactoryMethodLinear:return Jl;case this.InterpolantFactoryMethodSmooth:return fb}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let s=0,i=t.length;s!==i;++s)t[s]*=e}return this}trim(e,t){const s=this.times,i=s.length;let r=0,a=i-1;for(;r!==i&&s[r]<e;)++r;for(;a!==-1&&s[a]>t;)--a;if(++a,r!==0||a!==i){r>=a&&(a=Math.max(a,1),r=a-1);const o=this.getValueSize();this.times=s.slice(r,a),this.values=this.values.slice(r*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const s=this.times,i=this.values,r=s.length;r===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==r;o++){const l=s[o];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,l),e=!1;break}if(a!==null&&a>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,l,a),e=!1;break}a=l}if(i!==void 0&&bz(i))for(let o=0,l=i.length;o!==l;++o){const c=i[o];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),s=this.getValueSize(),i=this.getInterpolation()===fb,r=e.length-1;let a=1;for(let o=1;o<r;++o){let l=!1;const c=e[o],u=e[o+1];if(c!==u&&(o!==1||c!==e[0]))if(i)l=!0;else{const h=o*s,d=h-s,p=h+s;for(let f=0;f!==s;++f){const y=t[h+f];if(y!==t[d+f]||y!==t[p+f]){l=!0;break}}}if(l){if(o!==a){e[a]=e[o];const h=o*s,d=a*s;for(let p=0;p!==s;++p)t[d+p]=t[h+p]}++a}}if(r>0){e[a]=e[r];for(let o=r*s,l=a*s,c=0;c!==s;++c)t[l+c]=t[o+c];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=t.slice(0,a*s)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),s=this.constructor,i=new s(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}xr.prototype.TimeBufferType=Float32Array;xr.prototype.ValueBufferType=Float32Array;xr.prototype.DefaultInterpolation=Jl;class Sc extends xr{}Sc.prototype.ValueTypeName="bool";Sc.prototype.ValueBufferType=Array;Sc.prototype.DefaultInterpolation=wh;Sc.prototype.InterpolantFactoryMethodLinear=void 0;Sc.prototype.InterpolantFactoryMethodSmooth=void 0;class X2 extends xr{}X2.prototype.ValueTypeName="color";class tc extends xr{}tc.prototype.ValueTypeName="number";class Sz extends Bh{constructor(e,t,s,i){super(e,t,s,i)}interpolate_(e,t,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=(s-t)/(i-t);let c=e*o;for(let u=c+o;c!==u;c+=4)Is.slerpFlat(r,0,a,c-o,a,c,l);return r}}class Ro extends xr{InterpolantFactoryMethodLinear(e){return new Sz(this.times,this.values,this.getValueSize(),e)}}Ro.prototype.ValueTypeName="quaternion";Ro.prototype.DefaultInterpolation=Jl;Ro.prototype.InterpolantFactoryMethodSmooth=void 0;class Tc extends xr{}Tc.prototype.ValueTypeName="string";Tc.prototype.ValueBufferType=Array;Tc.prototype.DefaultInterpolation=wh;Tc.prototype.InterpolantFactoryMethodLinear=void 0;Tc.prototype.InterpolantFactoryMethodSmooth=void 0;class nc extends xr{}nc.prototype.ValueTypeName="vector";class U0{constructor(e,t=-1,s,i=Xx){this.name=e,this.tracks=s,this.duration=t,this.blendMode=i,this.uuid=Fi(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],s=e.tracks,i=1/(e.fps||1);for(let a=0,o=s.length;a!==o;++a)t.push(_z(s[a]).scale(i));const r=new this(e.name,e.duration,t,e.blendMode);return r.uuid=e.uuid,r}static toJSON(e){const t=[],s=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let r=0,a=s.length;r!==a;++r)t.push(xr.toJSON(s[r]));return i}static CreateFromMorphTargetSequence(e,t,s,i){const r=t.length,a=[];for(let o=0;o<r;o++){let l=[],c=[];l.push((o+r-1)%r,o,(o+1)%r),c.push(0,1,0);const u=xz(l);l=q_(l,1,u),c=q_(c,1,u),!i&&l[0]===0&&(l.push(r),c.push(c[0])),a.push(new tc(".morphTargetInfluences["+t[o].name+"]",l,c).scale(1/s))}return new this(e,-1,a)}static findByName(e,t){let s=e;if(!Array.isArray(e)){const i=e;s=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<s.length;i++)if(s[i].name===t)return s[i];return null}static CreateClipsFromMorphTargetSequences(e,t,s){const i={},r=/^([\w-]*?)([\d]+)$/;for(let o=0,l=e.length;o<l;o++){const c=e[o],u=c.name.match(r);if(u&&u.length>1){const h=u[1];let d=i[h];d||(i[h]=d=[]),d.push(c)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,s));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const s=function(h,d,p,f,y){if(p.length!==0){const m=[],g=[];B2(p,m,g,f),m.length!==0&&y.push(new h(d,m,g))}},i=[],r=e.name||"default",a=e.fps||30,o=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let h=0;h<c.length;h++){const d=c[h].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const p={};let f;for(f=0;f<d.length;f++)if(d[f].morphTargets)for(let y=0;y<d[f].morphTargets.length;y++)p[d[f].morphTargets[y]]=-1;for(const y in p){const m=[],g=[];for(let b=0;b!==d[f].morphTargets.length;++b){const x=d[f];m.push(x.time),g.push(x.morphTarget===y?1:0)}i.push(new tc(".morphTargetInfluence["+y+"]",m,g))}l=p.length*a}else{const p=".bones["+t[h].name+"]";s(nc,p+".position",d,"pos",i),s(Ro,p+".quaternion",d,"rot",i),s(nc,p+".scale",d,"scl",i)}}return i.length===0?null:new this(r,l,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let s=0,i=e.length;s!==i;++s){const r=this.tracks[s];t=Math.max(t,r.times[r.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Tz(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return tc;case"vector":case"vector2":case"vector3":case"vector4":return nc;case"color":return X2;case"quaternion":return Ro;case"bool":case"boolean":return Sc;case"string":return Tc}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function _z(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Tz(n.type);if(n.times===void 0){const t=[],s=[];B2(n.keys,t,s,"value"),n.times=t,n.values=s}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const sc={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class H2{constructor(e,t,s){const i=this;let r=!1,a=0,o=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=s,this.itemStart=function(u){o++,r===!1&&i.onStart!==void 0&&i.onStart(u,a,o),r=!0},this.itemEnd=function(u){a++,i.onProgress!==void 0&&i.onProgress(u,a,o),a===o&&(r=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,h){return c.push(u,h),this},this.removeHandler=function(u){const h=c.indexOf(u);return h!==-1&&c.splice(h,2),this},this.getHandler=function(u){for(let h=0,d=c.length;h<d;h+=2){const p=c[h],f=c[h+1];if(p.global&&(p.lastIndex=0),p.test(u))return f}return null}}}const Iz=new H2;class Wa{constructor(e){this.manager=e!==void 0?e:Iz,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const s=this;return new Promise(function(i,r){s.load(e,i,t,r)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Wa.DEFAULT_MATERIAL_NAME="__DEFAULT";const Cr={};class Mz extends Error{constructor(e,t){super(e),this.response=t}}class Am extends Wa{constructor(e){super(e)}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=sc.get(e);if(r!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(r),this.manager.itemEnd(e)},0),r;if(Cr[e]!==void 0){Cr[e].push({onLoad:t,onProgress:s,onError:i});return}Cr[e]=[],Cr[e].push({onLoad:t,onProgress:s,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,l=this.responseType;fetch(a).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=Cr[e],h=c.body.getReader(),d=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),p=d?parseInt(d):0,f=p!==0;let y=0;const m=new ReadableStream({start(g){b();function b(){h.read().then(({done:x,value:v})=>{if(x)g.close();else{y+=v.byteLength;const w=new ProgressEvent("progress",{lengthComputable:f,loaded:y,total:p});for(let _=0,I=u.length;_<I;_++){const C=u[_];C.onProgress&&C.onProgress(w)}g.enqueue(v),b()}})}}});return new Response(m)}else throw new Mz(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,o));case"json":return c.json();default:if(o===void 0)return c.text();{const h=/charset="?([^;"\s]*)"?/i.exec(o),d=h&&h[1]?h[1].toLowerCase():void 0,p=new TextDecoder(d);return c.arrayBuffer().then(f=>p.decode(f))}}}).then(c=>{sc.add(e,c);const u=Cr[e];delete Cr[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onLoad&&p.onLoad(c)}}).catch(c=>{const u=Cr[e];if(u===void 0)throw this.manager.itemError(e),c;delete Cr[e];for(let h=0,d=u.length;h<d;h++){const p=u[h];p.onError&&p.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Cz extends Wa{constructor(e){super(e)}load(e,t,s,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=sc.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const o=Sh("img");function l(){u(),sc.add(e,this),t&&t(this),r.manager.itemEnd(e)}function c(h){u(),i&&i(h),r.manager.itemError(e),r.manager.itemEnd(e)}function u(){o.removeEventListener("load",l,!1),o.removeEventListener("error",c,!1)}return o.addEventListener("load",l,!1),o.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),r.manager.itemStart(e),o.src=e,o}}class Ez extends Wa{constructor(e){super(e)}load(e,t,s,i){const r=this,a=new V2,o=new Am(this.manager);return o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setPath(this.path),o.setWithCredentials(r.withCredentials),o.load(e,function(l){let c;try{c=r.parse(l)}catch(u){if(i!==void 0)i(u);else{console.error(u);return}}c.image!==void 0?a.image=c.image:c.data!==void 0&&(a.image.width=c.width,a.image.height=c.height,a.image.data=c.data),a.wrapS=c.wrapS!==void 0?c.wrapS:Os,a.wrapT=c.wrapT!==void 0?c.wrapT:Os,a.magFilter=c.magFilter!==void 0?c.magFilter:An,a.minFilter=c.minFilter!==void 0?c.minFilter:An,a.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0?a.colorSpace=c.colorSpace:c.encoding!==void 0&&(a.encoding=c.encoding),c.flipY!==void 0&&(a.flipY=c.flipY),c.format!==void 0&&(a.format=c.format),c.type!==void 0&&(a.type=c.type),c.mipmaps!==void 0&&(a.mipmaps=c.mipmaps,a.minFilter=Ra),c.mipmapCount===1&&(a.minFilter=An),c.generateMipmaps!==void 0&&(a.generateMipmaps=c.generateMipmaps),a.needsUpdate=!0,t&&t(a,c)},s,i),a}}class K2 extends Wa{constructor(e){super(e)}load(e,t,s,i){const r=new is,a=new Cz(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){r.image=o,r.needsUpdate=!0,t!==void 0&&t(r)},s,i),r}}class n1 extends nn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new lt(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),t}}const Wb=new ot,eI=new J,tI=new J;class s1{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Rt(512,512),this.map=null,this.mapPass=null,this.matrix=new ot,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Zx,this._frameExtents=new Rt(1,1),this._viewportCount=1,this._viewports=[new Xt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,s=this.matrix;eI.setFromMatrixPosition(e.matrixWorld),t.position.copy(eI),tI.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(tI),t.updateMatrixWorld(),Wb.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Wb),s.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),s.multiply(Wb)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class kz extends s1{constructor(){super(new Ts(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,s=ql*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,r=e.distance||t.far;(s!==t.fov||i!==t.aspect||r!==t.far)&&(t.fov=s,t.aspect=i,t.far=r,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class Nz extends n1{constructor(e,t,s=0,i=Math.PI/3,r=0,a=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(nn.DEFAULT_UP),this.updateMatrix(),this.target=new nn,this.distance=s,this.angle=i,this.penumbra=r,this.decay=a,this.map=null,this.shadow=new kz}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const nI=new ot,qu=new J,Ub=new J;class Rz extends s1{constructor(){super(new Ts(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Rt(4,2),this._viewportCount=6,this._viewports=[new Xt(2,1,1,1),new Xt(0,1,1,1),new Xt(3,1,1,1),new Xt(1,1,1,1),new Xt(3,0,1,1),new Xt(1,0,1,1)],this._cubeDirections=[new J(1,0,0),new J(-1,0,0),new J(0,0,1),new J(0,0,-1),new J(0,1,0),new J(0,-1,0)],this._cubeUps=[new J(0,1,0),new J(0,1,0),new J(0,1,0),new J(0,1,0),new J(0,0,1),new J(0,0,-1)]}updateMatrices(e,t=0){const s=this.camera,i=this.matrix,r=e.distance||s.far;r!==s.far&&(s.far=r,s.updateProjectionMatrix()),qu.setFromMatrixPosition(e.matrixWorld),s.position.copy(qu),Ub.copy(s.position),Ub.add(this._cubeDirections[t]),s.up.copy(this._cubeUps[t]),s.lookAt(Ub),s.updateMatrixWorld(),i.makeTranslation(-qu.x,-qu.y,-qu.z),nI.multiplyMatrices(s.projectionMatrix,s.matrixWorldInverse),this._frustum.setFromProjectionMatrix(nI)}}class Az extends n1{constructor(e,t,s=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=s,this.decay=i,this.shadow=new Rz}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class Lz extends s1{constructor(){super(new jx(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class Pz extends n1{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(nn.DEFAULT_UP),this.updateMatrix(),this.target=new nn,this.shadow=new Lz}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class B0{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class Dz extends Wa{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,s,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const r=this,a=sc.get(e);if(a!==void 0)return r.manager.itemStart(e),setTimeout(function(){t&&t(a),r.manager.itemEnd(e)},0),a;const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader,fetch(e,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(r.options,{colorSpaceConversion:"none"}))}).then(function(l){sc.add(e,l),t&&t(l),r.manager.itemEnd(e)}).catch(function(l){i&&i(l),r.manager.itemError(e),r.manager.itemEnd(e)}),r.manager.itemStart(e)}}let cf;class Z2{static getContext(){return cf===void 0&&(cf=new(window.AudioContext||window.webkitAudioContext)),cf}static setContext(e){cf=e}}class Fz extends Wa{constructor(e){super(e)}load(e,t,s,i){const r=this,a=new Am(this.manager);a.setResponseType("arraybuffer"),a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){try{const c=l.slice(0);Z2.getContext().decodeAudioData(c,function(h){t(h)},o)}catch(c){o(c)}},s,i);function o(l){i?i(l):console.error(l),r.manager.itemError(e)}}}class Y2{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=sI(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const t=sI();e=(t-this.oldTime)/1e3,this.oldTime=t,this.elapsedTime+=e}return e}}function sI(){return(typeof performance>"u"?Date:performance).now()}const so=new J,iI=new Is,Oz=new J,io=new J;class Gz extends nn{constructor(){super(),this.type="AudioListener",this.context=Z2.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Y2}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const t=this.context.listener,s=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(so,iI,Oz),io.set(0,0,-1).applyQuaternion(iI),t.positionX){const i=this.context.currentTime+this.timeDelta;t.positionX.linearRampToValueAtTime(so.x,i),t.positionY.linearRampToValueAtTime(so.y,i),t.positionZ.linearRampToValueAtTime(so.z,i),t.forwardX.linearRampToValueAtTime(io.x,i),t.forwardY.linearRampToValueAtTime(io.y,i),t.forwardZ.linearRampToValueAtTime(io.z,i),t.upX.linearRampToValueAtTime(s.x,i),t.upY.linearRampToValueAtTime(s.y,i),t.upZ.linearRampToValueAtTime(s.z,i)}else t.setPosition(so.x,so.y,so.z),t.setOrientation(io.x,io.y,io.z,s.x,s.y,s.z)}}class j2 extends nn{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const t=this.context.createBufferSource();return t.buffer=this.buffer,t.loop=this.loop,t.loopStart=this.loopStart,t.loopEnd=this.loopEnd,t.onended=this.onEnded.bind(this),t.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=t,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,t=this.filters.length;e<t;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){if(this.detune=e,this.source.detune!==void 0)return this.isPlaying===!0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}class zz{constructor(e,t,s){this.binding=e,this.valueSize=s;let i,r,a;switch(t){case"quaternion":i=this._slerp,r=this._slerpAdditive,a=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(s*6),this._workIndex=5;break;case"string":case"bool":i=this._select,r=this._select,a=this._setAdditiveIdentityOther,this.buffer=new Array(s*5);break;default:i=this._lerp,r=this._lerpAdditive,a=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(s*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=r,this._setIdentity=a,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,t){const s=this.buffer,i=this.valueSize,r=e*i+i;let a=this.cumulativeWeight;if(a===0){for(let o=0;o!==i;++o)s[r+o]=s[o];a=t}else{a+=t;const o=t/a;this._mixBufferRegion(s,r,0,o,i)}this.cumulativeWeight=a}accumulateAdditive(e){const t=this.buffer,s=this.valueSize,i=s*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(t,i,0,e,s),this.cumulativeWeightAdditive+=e}apply(e){const t=this.valueSize,s=this.buffer,i=e*t+t,r=this.cumulativeWeight,a=this.cumulativeWeightAdditive,o=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,r<1){const l=t*this._origIndex;this._mixBufferRegion(s,i,l,1-r,t)}a>0&&this._mixBufferRegionAdditive(s,i,this._addIndex*t,1,t);for(let l=t,c=t+t;l!==c;++l)if(s[l]!==s[l+t]){o.setValue(s,i);break}}saveOriginalState(){const e=this.binding,t=this.buffer,s=this.valueSize,i=s*this._origIndex;e.getValue(t,i);for(let r=s,a=i;r!==a;++r)t[r]=t[i+r%s];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,t=e+this.valueSize;for(let s=e;s<t;s++)this.buffer[s]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,t=this._addIndex*this.valueSize;for(let s=0;s<this.valueSize;s++)this.buffer[t+s]=this.buffer[e+s]}_select(e,t,s,i,r){if(i>=.5)for(let a=0;a!==r;++a)e[t+a]=e[s+a]}_slerp(e,t,s,i){Is.slerpFlat(e,t,e,t,e,s,i)}_slerpAdditive(e,t,s,i,r){const a=this._workIndex*r;Is.multiplyQuaternionsFlat(e,a,e,t,e,s),Is.slerpFlat(e,t,e,t,e,a,i)}_lerp(e,t,s,i,r){const a=1-i;for(let o=0;o!==r;++o){const l=t+o;e[l]=e[l]*a+e[s+o]*i}}_lerpAdditive(e,t,s,i,r){for(let a=0;a!==r;++a){const o=t+a;e[o]=e[o]+e[s+a]*i}}}const i1="\\[\\]\\.:\\/",Vz=new RegExp("["+i1+"]","g"),r1="[^"+i1+"]",Wz="[^"+i1.replace("\\.","")+"]",Uz=/((?:WC+[\/:])*)/.source.replace("WC",r1),Bz=/(WCOD+)?/.source.replace("WCOD",Wz),$z=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",r1),Xz=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",r1),Hz=new RegExp("^"+Uz+Bz+$z+Xz+"$"),Kz=["material","materials","bones","map"];class Zz{constructor(e,t,s){const i=s||Ot.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const s=this._targetGroup.nCachedObjects_,i=this._bindings[s];i!==void 0&&i.getValue(e,t)}setValue(e,t){const s=this._bindings;for(let i=this._targetGroup.nCachedObjects_,r=s.length;i!==r;++i)s[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,s=e.length;t!==s;++t)e[t].unbind()}}class Ot{constructor(e,t,s){this.path=t,this.parsedPath=s||Ot.parseTrackName(t),this.node=Ot.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,s){return e&&e.isAnimationObjectGroup?new Ot.Composite(e,t,s):new Ot(e,t,s)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(Vz,"")}static parseTrackName(e){const t=Hz.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const s={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=s.nodeName&&s.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const r=s.nodeName.substring(i+1);Kz.indexOf(r)!==-1&&(s.nodeName=s.nodeName.substring(0,i),s.objectName=r)}if(s.propertyName===null||s.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return s}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const s=e.skeleton.getBoneByName(t);if(s!==void 0)return s}if(e.children){const s=function(r){for(let a=0;a<r.length;a++){const o=r[a];if(o.name===t||o.uuid===t)return o;const l=s(o.children);if(l)return l}return null},i=s(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)e[t++]=s[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const s=this.resolvedProperty;for(let i=0,r=s.length;i!==r;++i)s[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,s=t.objectName,i=t.propertyName;let r=t.propertyIndex;if(e||(e=Ot.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(s){let c=t.objectIndex;switch(s){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[s]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[s]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const a=e[i];if(a===void 0){const c=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(r!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[r]!==void 0&&(r=e.morphTargetDictionary[r])}l=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=r}else a.fromArray!==void 0&&a.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(l=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Ot.Composite=Zz;Ot.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Ot.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Ot.prototype.GetterByBindingType=[Ot.prototype._getValue_direct,Ot.prototype._getValue_array,Ot.prototype._getValue_arrayElement,Ot.prototype._getValue_toArray];Ot.prototype.SetterByBindingTypeAndVersioning=[[Ot.prototype._setValue_direct,Ot.prototype._setValue_direct_setNeedsUpdate,Ot.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_array,Ot.prototype._setValue_array_setNeedsUpdate,Ot.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_arrayElement,Ot.prototype._setValue_arrayElement_setNeedsUpdate,Ot.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Ot.prototype._setValue_fromArray,Ot.prototype._setValue_fromArray_setNeedsUpdate,Ot.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Yz{constructor(e,t,s=null,i=t.blendMode){this._mixer=e,this._clip=t,this._localRoot=s,this.blendMode=i;const r=t.tracks,a=r.length,o=new Array(a),l={endingStart:Dl,endingEnd:Dl};for(let c=0;c!==a;++c){const u=r[c].createInterpolant(null);o[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=o,this._propertyBindings=new Array(a),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=y2,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,t){return this.loop=e,this.repetitions=t,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,t,s){if(e.fadeOut(t),this.fadeIn(t),s){const i=this._clip.duration,r=e._clip.duration,a=r/i,o=i/r;e.warp(1,a,t),this.warp(o,1,t)}return this}crossFadeTo(e,t,s){return e.crossFadeFrom(this,t,s)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,t,s){const i=this._mixer,r=i.time,a=this.timeScale;let o=this._timeScaleInterpolant;o===null&&(o=i._lendControlInterpolant(),this._timeScaleInterpolant=o);const l=o.parameterPositions,c=o.sampleValues;return l[0]=r,l[1]=r+s,c[0]=e/a,c[1]=t/a,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,t,s,i){if(!this.enabled){this._updateWeight(e);return}const r=this._startTime;if(r!==null){const l=(e-r)*s;l<0||s===0?t=0:(this._startTime=null,t=s*l)}t*=this._updateTimeScale(e);const a=this._updateTime(t),o=this._updateWeight(e);if(o>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case k3:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulateAdditive(o);break;case Xx:default:for(let u=0,h=l.length;u!==h;++u)l[u].evaluate(a),c[u].accumulate(i,o)}}}_updateWeight(e){let t=0;if(this.enabled){t=this.weight;const s=this._weightInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=t,t}_updateTimeScale(e){let t=0;if(!this.paused){t=this.timeScale;const s=this._timeScaleInterpolant;if(s!==null){const i=s.evaluate(e)[0];t*=i,e>s.parameterPositions[1]&&(this.stopWarping(),t===0?this.paused=!0:this.timeScale=t)}}return this._effectiveTimeScale=t,t}_updateTime(e){const t=this._clip.duration,s=this.loop;let i=this.time+e,r=this._loopCount;const a=s===E3;if(e===0)return r===-1?i:a&&(r&1)===1?t-i:i;if(s===C3){r===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=t)i=t;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(r===-1&&(e>=0?(r=0,this._setEndings(!0,this.repetitions===0,a)):this._setEndings(this.repetitions===0,!0,a)),i>=t||i<0){const o=Math.floor(i/t);i-=t*o,r+=Math.abs(o);const l=this.repetitions-r;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?t:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,a)}else this._setEndings(!1,!1,a);this._loopCount=r,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:o})}}else this.time=i;if(a&&(r&1)===1)return t-i}return i}_setEndings(e,t,s){const i=this._interpolantSettings;s?(i.endingStart=Fl,i.endingEnd=Fl):(e?i.endingStart=this.zeroSlopeAtStart?Fl:Dl:i.endingStart=zf,t?i.endingEnd=this.zeroSlopeAtEnd?Fl:Dl:i.endingEnd=zf)}_scheduleFading(e,t,s){const i=this._mixer,r=i.time;let a=this._weightInterpolant;a===null&&(a=i._lendControlInterpolant(),this._weightInterpolant=a);const o=a.parameterPositions,l=a.sampleValues;return o[0]=r,l[0]=t,o[1]=r+e,l[1]=s,this}}const jz=new Float32Array(1);class Qz extends Zo{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,t){const s=e._localRoot||this._root,i=e._clip.tracks,r=i.length,a=e._propertyBindings,o=e._interpolants,l=s.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let h=0;h!==r;++h){const d=i[h],p=d.name;let f=u[p];if(f!==void 0)++f.referenceCount,a[h]=f;else{if(f=a[h],f!==void 0){f._cacheIndex===null&&(++f.referenceCount,this._addInactiveBinding(f,l,p));continue}const y=t&&t._propertyBindings[h].binding.parsedPath;f=new zz(Ot.create(s,p,y),d.ValueTypeName,d.getValueSize()),++f.referenceCount,this._addInactiveBinding(f,l,p),a[h]=f}o[h].resultBuffer=f.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const s=(e._localRoot||this._root).uuid,i=e._clip.uuid,r=this._actionsByClip[i];this._bindAction(e,r&&r.knownActions[0]),this._addInactiveAction(e,i,s)}const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];r.useCount++===0&&(this._lendBinding(r),r.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.useCount===0&&(r.restoreOriginalState(),this._takeBackBinding(r))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const t=e._cacheIndex;return t!==null&&t<this._nActiveActions}_addInactiveAction(e,t,s){const i=this._actions,r=this._actionsByClip;let a=r[t];if(a===void 0)a={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,r[t]=a;else{const o=a.knownActions;e._byClipCacheIndex=o.length,o.push(e)}e._cacheIndex=i.length,i.push(e),a.actionByRoot[s]=e}_removeInactiveAction(e){const t=this._actions,s=t[t.length-1],i=e._cacheIndex;s._cacheIndex=i,t[i]=s,t.pop(),e._cacheIndex=null;const r=e._clip.uuid,a=this._actionsByClip,o=a[r],l=o.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const h=o.actionByRoot,d=(e._localRoot||this._root).uuid;delete h[d],l.length===0&&delete a[r],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const t=e._propertyBindings;for(let s=0,i=t.length;s!==i;++s){const r=t[s];--r.referenceCount===0&&this._removeInactiveBinding(r)}}_lendAction(e){const t=this._actions,s=e._cacheIndex,i=this._nActiveActions++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackAction(e){const t=this._actions,s=e._cacheIndex,i=--this._nActiveActions,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_addInactiveBinding(e,t,s){const i=this._bindingsByRootAndName,r=this._bindings;let a=i[t];a===void 0&&(a={},i[t]=a),a[s]=e,e._cacheIndex=r.length,r.push(e)}_removeInactiveBinding(e){const t=this._bindings,s=e.binding,i=s.rootNode.uuid,r=s.path,a=this._bindingsByRootAndName,o=a[i],l=t[t.length-1],c=e._cacheIndex;l._cacheIndex=c,t[c]=l,t.pop(),delete o[r],Object.keys(o).length===0&&delete a[i]}_lendBinding(e){const t=this._bindings,s=e._cacheIndex,i=this._nActiveBindings++,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_takeBackBinding(e){const t=this._bindings,s=e._cacheIndex,i=--this._nActiveBindings,r=t[i];e._cacheIndex=i,t[i]=e,r._cacheIndex=s,t[s]=r}_lendControlInterpolant(){const e=this._controlInterpolants,t=this._nActiveControlInterpolants++;let s=e[t];return s===void 0&&(s=new $2(new Float32Array(2),new Float32Array(2),1,jz),s.__cacheIndex=t,e[t]=s),s}_takeBackControlInterpolant(e){const t=this._controlInterpolants,s=e.__cacheIndex,i=--this._nActiveControlInterpolants,r=t[i];e.__cacheIndex=i,t[i]=e,r.__cacheIndex=s,t[s]=r}clipAction(e,t,s){const i=t||this._root,r=i.uuid;let a=typeof e=="string"?U0.findByName(i,e):e;const o=a!==null?a.uuid:e,l=this._actionsByClip[o];let c=null;if(s===void 0&&(a!==null?s=a.blendMode:s=Xx),l!==void 0){const h=l.actionByRoot[r];if(h!==void 0&&h.blendMode===s)return h;c=l.knownActions[0],a===null&&(a=c._clip)}if(a===null)return null;const u=new Yz(this,a,t,s);return this._bindAction(u,c),this._addInactiveAction(u,o,r),u}existingAction(e,t){const s=t||this._root,i=s.uuid,r=typeof e=="string"?U0.findByName(s,e):e,a=r?r.uuid:e,o=this._actionsByClip[a];return o!==void 0&&o.actionByRoot[i]||null}stopAllAction(){const e=this._actions,t=this._nActiveActions;for(let s=t-1;s>=0;--s)e[s].stop();return this}update(e){e*=this.timeScale;const t=this._actions,s=this._nActiveActions,i=this.time+=e,r=Math.sign(e),a=this._accuIndex^=1;for(let c=0;c!==s;++c)t[c]._update(i,e,r,a);const o=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)o[c].apply(a);return this}setTime(e){this.time=0;for(let t=0;t<this._actions.length;t++)this._actions[t].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const t=this._actions,s=e.uuid,i=this._actionsByClip,r=i[s];if(r!==void 0){const a=r.knownActions;for(let o=0,l=a.length;o!==l;++o){const c=a[o];this._deactivateAction(c);const u=c._cacheIndex,h=t[t.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,h._cacheIndex=u,t[u]=h,t.pop(),this._removeInactiveBindingsForAction(c)}delete i[s]}}uncacheRoot(e){const t=e.uuid,s=this._actionsByClip;for(const a in s){const o=s[a].actionByRoot,l=o[t];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,r=i[t];if(r!==void 0)for(const a in r){const o=r[a];o.restoreOriginalState(),this._removeInactiveBinding(o)}}uncacheAction(e,t){const s=this.existingAction(e,t);s!==null&&(this._deactivateAction(s),this._removeInactiveAction(s))}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:Bx}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=Bx);var Yo=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Jz(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function qz(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function s(){if(this instanceof s){var i=[null];i.push.apply(i,arguments);var r=Function.bind.apply(e,i);return new r}return e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(s){var i=Object.getOwnPropertyDescriptor(n,s);Object.defineProperty(t,s,i.get?i:{enumerable:!0,get:function(){return n[s]}})}),t}const rI=(n,e)=>{const t=2*Math.PI*e*n;return t/(t+1)},aI=(n,e,t)=>n*e+(1-n)*t;class eV{constructor({minCutOff:e,beta:t}){this.minCutOff=e,this.beta=t,this.dCutOff=.001,this.xPrev=null,this.dxPrev=null,this.tPrev=null,this.initialized=!1}reset(){this.initialized=!1}filter(e,t){if(!this.initialized)return this.initialized=!0,this.xPrev=t,this.dxPrev=t.map(()=>0),this.tPrev=e,t;const{xPrev:s,tPrev:i,dxPrev:r}=this,a=e-i,o=rI(a,this.dCutOff),l=[],c=[],u=[];for(let h=0;h<t.length;h++){l[h]=(t[h]-s[h])/a,c[h]=aI(o,l[h],r[h]);const d=this.minCutOff+this.beta*Math.abs(c[h]),p=rI(a,d);u[h]=aI(p,t[h],s[h])}return this.xPrev=u,this.dxPrev=c,this.tPrev=e,u}}const tV=`<div class="mindar-ui-overlay mindar-ui-loading">
  <div class="loader"/>
</div>
`,nV=`<div class="mindar-ui-overlay mindar-ui-compatibility">
  <div class="content">
    <h1>Failed to launch :(</h1>
    <p>
      Looks like your device/browser is not compatible.
    </p>

    <br/>
    <br/>
    <p>
      Please try the following recommended browsers:
    </p>
    <p>
      For Android device - Chrome
    </p>
    <p>
      For iOS device - Safari
    </p>
  </div>
</div>
`,sV=`<div class="mindar-ui-overlay mindar-ui-scanning">
  <div class="scanning">
    <div class="inner">
      <div class="scanline"/>
    </div>
  </div>
</div>
`,iV=".mindar-ui-overlay{display:flex;align-items:center;justify-content:center;position:absolute;left:0;right:0;top:0;bottom:0;background:transparent;z-index:2}.mindar-ui-overlay.hidden{display:none}.mindar-ui-loading .loader{border:16px solid #222;border-top:16px solid white;opacity:.8;border-radius:50%;width:120px;height:120px;animation:spin 2s linear infinite}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.mindar-ui-compatibility .content{background:black;color:#fff;opacity:.8;text-align:center;margin:20px;padding:20px;min-height:50vh}@media (min-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:50vh;height:50vh}}@media (max-aspect-ratio: 1/1){.mindar-ui-scanning .scanning{width:80vw;height:80vw}}.mindar-ui-scanning .scanning .inner{position:relative;width:100%;height:100%;opacity:.8;background:linear-gradient(to right,white 10px,transparent 10px) 0 0,linear-gradient(to right,white 10px,transparent 10px) 0 100%,linear-gradient(to left,white 10px,transparent 10px) 100% 0,linear-gradient(to left,white 10px,transparent 10px) 100% 100%,linear-gradient(to bottom,white 10px,transparent 10px) 0 0,linear-gradient(to bottom,white 10px,transparent 10px) 100% 0,linear-gradient(to top,white 10px,transparent 10px) 0 100%,linear-gradient(to top,white 10px,transparent 10px) 100% 100%;background-repeat:no-repeat;background-size:40px 40px}.mindar-ui-scanning .scanning .inner .scanline{position:absolute;width:100%;height:10px;background:white;animation:move 2s linear infinite}@keyframes move{0%,to{top:0%}50%{top:calc(100% - 10px)}}";let rV=class{constructor({uiLoading:e,uiScanning:t,uiError:s}){const i=document.createElement("style");i.innerText=iV,document.head.appendChild(i),e==="yes"?this.loadingModal=this._loadHTML(tV):e!=="no"&&(this.loadingModal=document.querySelector(e)),s==="yes"?this.compatibilityModal=this._loadHTML(nV):s!=="no"&&(this.compatibilityModal=document.querySelector(s)),t==="yes"?this.scanningMask=this._loadHTML(sV):t!=="no"&&(this.scanningMask=document.querySelector(t)),this.hideLoading(),this.hideCompatibility(),this.hideScanning()}showLoading(){this.loadingModal&&this.loadingModal.classList.remove("hidden")}hideLoading(){this.loadingModal&&this.loadingModal.classList.add("hidden")}showCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.remove("hidden")}hideCompatibility(){this.compatibilityModal&&this.compatibilityModal.classList.add("hidden")}showScanning(){this.scanningMask&&this.scanningMask.classList.remove("hidden")}hideScanning(){this.scanningMask&&this.scanningMask.classList.add("hidden")}_loadHTML(e){const t=document.createElement("template");t.innerHTML=e.trim();const s=t.content.firstChild;return document.getElementsByTagName("body")[0].appendChild(s),s}};function aV(n,e){for(var t=0;t<e.length;t++){const s=e[t];if(typeof s!="string"&&!Array.isArray(s)){for(const i in s)if(i!=="default"&&!(i in n)){const r=Object.getOwnPropertyDescriptor(s,i);r&&Object.defineProperty(n,i,r.get?r:{enumerable:!0,get:()=>s[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oV=1e-7,lV=1e-4;let a1=class{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}},Lm=class{refCount(e){return Ps("refCount")}incRef(e){return Ps("incRef")}timerAvailable(){return!0}time(e){return Ps("time")}read(e){return Ps("read")}readSync(e){return Ps("readSync")}readToGPU(e,t){return Ps("readToGPU")}numDataIds(){return Ps("numDataIds")}disposeData(e,t){return Ps("disposeData")}write(e,t,s){return Ps("write")}move(e,t,s,i,r){return Ps("move")}createTensorFromGPUData(e,t,s){return Ps("createTensorFromGPUData")}memory(){return Ps("memory")}floatPrecision(){return Ps("floatPrecision")}epsilon(){return this.floatPrecision()===32?oV:lV}dispose(){return Ps("dispose")}};function Ps(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o1(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,Lr(n,e,t)}function cV(n,e){if(n.length!==e.length)throw new Error(`Array sizes must match to be shuffled together First array length was ${n.length}Second array length was ${e.length}`);let t=n.length,s=0;for(;t>0;)s=Math.random()*t|0,t--,Lr(n,t,s),Lr(e,t,s)}function Aa(n,e,t){return Math.max(n,Math.min(e,t))}function Pm(n){return n%2===0?n:n+1}function Lr(n,e,t){const s=n[e];n[e]=n[t],n[t]=s}function Q2(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function uV(n,e){const t=Math.random();return e*t+(1-t)*n}function hV(n,e){let t=0;for(let s=0;s<n.length;s++){const i=Number(n[s])-Number(e[s]);t+=i*i}return t}function E(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function jn(n,e,t=""){E(St(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function jo(n){E(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function re(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function dV(n){return n.length===0}function St(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function Ao(n){return n%1===0}function pV(n){if(Math.tanh!=null)return Math.tanh(n);if(n===1/0)return 1;if(n===-1/0)return-1;{const e=Math.exp(2*n);return(e-1)/(e+1)}}function Xf(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function fV(n){const e=new Uint32Array(n);for(let t=0;t<n;++t)e[t]=t;return o1(e),e}function _o(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function $0(n,e=i=>0,t,s){return new Promise((i,r)=>{let a=0;const o=()=>{if(n()){i();return}a++;const l=e(a);if(t!=null&&a>=t){r();return}s!=null?s(o,l):setTimeout(o,l)};o()})}function l1(n,e){let t=1,s=-1;for(let r=0;r<n.length;++r)if(n[r]>=0)t*=n[r];else if(n[r]===-1){if(s!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${s} and dim ${r}`);s=r}else if(n[r]<0)throw Error(`Shapes can not be < 0. Found ${n[r]} at dim ${r}`);if(s===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[s]=e/t,i}function mt(n,e){const t=e.length;return n=n==null?e.map((s,i)=>i):[].concat(n),E(n.every(s=>s>=-t&&s<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),E(n.every(s=>Ao(s)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(s=>s<0?t+s:s)}function Qr(n,e){const t=[],s=[],i=e!=null&&Array.isArray(e)&&e.length===0,r=e==null||i?null:mt(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(r!=null){if(r[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(r[a]==null||r[a]>o)&&n[o]===1&&(t.push(n[o]),s.push(o)),r[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),s.push(o))}return{newShape:t,keptDims:s}}function Rn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else throw new Error(`Unknown data type ${n}`);return t}function pn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function J2(n,e){for(let t=0;t<n.length;t++){const s=n[t];if(isNaN(s)||!isFinite(s))throw Error(`A tensor of type ${e} being uploaded contains ${s}.`)}}function q2(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function c1(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Th(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function eC(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function ir(n){return typeof n=="string"||n instanceof String}function tC(n){return typeof n=="boolean"}function Hf(n){return typeof n=="number"}function _c(n){return Array.isArray(n)?_c(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Hf(n)?"float32":ir(n)?"string":tC(n)?"bool":"float32"}function La(n){return!!(n&&n.constructor&&n.call&&n.apply)}function Kf(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function He(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let s=e-3;s>=0;--s)t[s]=t[s+1]*n[s+1];return t}function nC(n,e,t,s=!1){const i=new Array;if(e.length===1){const r=e[0]*(s?2:1);for(let a=0;a<r;a++)i[a]=t[n+a]}else{const r=e[0],a=e.slice(1),o=a.reduce((l,c)=>l*c)*(s?2:1);for(let l=0;l<r;l++)i[l]=nC(n+l*o,a,t,s)}return i}function ni(n,e,t=!1){if(n.length===0)return e[0];const s=n.reduce((i,r)=>i*r)*(t?2:1);if(s===0)return[];if(s!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return nC(0,n,e,t)}function sC(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function Dm(n,e){const t=Zn(n,e);for(let s=0;s<t.length;s++)t[s]=1;return t}function Zn(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function u1(n,e){const t=n.reduce((s,i)=>s*i,1);if(e==null||e==="float32")return ni(n,new Float32Array(t));if(e==="int32")return ni(n,new Int32Array(t));if(e==="bool")return ni(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function Ks(n){n.forEach(e=>{E(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function Oi(n,e,t){if(e===0)return 0;if(e===1)return n[0];let s=n[n.length-1];for(let i=0;i<n.length-1;++i)s+=t[i]*n[i];return s}function Qo(n,e,t){if(e===0)return[];if(e===1)return[n];const s=new Array(e);for(let i=0;i<s.length-1;++i)s[i]=Math.floor(n/t[i]),n-=s[i]*t[i];return s[s.length-1]=n,s}function Ur(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI="tfjsflags";class iC{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=mV,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,s){if(this.flagRegistry[e]={evaluationFn:t,setHook:s},this.urlFlags[e]!=null){const i=this.urlFlags[e];ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ur(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);oI in e&&e[oI].split(",").forEach(t=>{const[s,i]=t.split(":");this.urlFlags[s]=yV(s,i)})}}function mV(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...s)=>(gV(e,s[0],s[1]),s.join("="))),e}function gV(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function yV(n,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${n}.`)}function ee(){return h1}let h1=null;function bV(n){h1=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let Bb;function rC(){if(Bb==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");Bb=n}return Bb}function xV(){const n=rC();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function d1(n,e){const t=xV();if(t.has(n))return t.get(n);{const s=e();return t.set(n,s),t.get(n)}}const $h="Abs",Ic="Acos",Mc="Acosh",Jo="Add",Xh="AddN",Fm="All",Om="Any",Hh="ArgMax",Kh="ArgMin",Cc="Asin",Ec="Asinh",kc="Atan",Nc="Atanh",Rc="Atan2",Zh="AvgPool",Gm="AvgPoolGrad",Yh="AvgPool3D",zm="AvgPool3DGrad",jh="BatchMatMul",Qh="BatchToSpaceND",Vm="Bincount",aC="BroadcastTo",Wm="BroadcastArgs",Ac="Cast",Lc="Ceil",Pc="ClipByValue",Um="Complex",Jh="ComplexAbs",qh="Concat",ed="Conv2D",Bm="Conv2DBackpropFilter",td="Conv2DBackpropInput",nd="Conv3D",$m="Conv3DBackpropFilterV2",Xm="Conv3DBackpropInputV2",Dc="Cos",Fc="Cosh",Hm="Cumprod",sd="Cumsum",Km="CropAndResize",Zm="DenseBincount",Ym="DepthToSpace",id="DepthwiseConv2dNative",jm="DepthwiseConv2dNativeBackpropFilter",Qm="DepthwiseConv2dNativeBackpropInput",Jm="Diag",rd="Dilation2D",Zf="Dilation2DBackpropInput",Yf="Dilation2DBackpropFilter",Oc="RealDiv",qm="Einsum",Gc="Elu",eg="EluGrad",zc="Erf",ad="Equal",Vc="Exp",od="ExpandDims",Wc="Expm1",tg="FFT",ng="Fill",sg="FlipLeftRight",Uc="Floor",Bc="FloorDiv",ld="FusedBatchNorm",cd="GatherV2",ig="GatherNd",ud="Greater",$c="GreaterEqual",Xc="Identity",rg="IFFT",ag="Imag",Hc="IsFinite",Kc="IsInf",Zc="IsNan",hd="LeakyRelu",dd="Less",pd="LessEqual",og="LinSpace",Yc="Log",jc="Log1p",fd="LogicalAnd",md="LogicalNot",gd="LogicalOr",vV="LogicalXor",oC="LogSoftmax",wV="LowerBound",yd="LRN",lg="LRNGrad",bd="Max",Qc="Maximum",xd="MaxPool",cg="MaxPoolGrad",vd="MaxPool3D",ug="MaxPool3DGrad",hg="MaxPoolWithArgmax",wd="Mean",Sd="Min",Jc="Minimum",Td="MirrorPad",qc="Mod",dg="Multinomial",eu="Multiply",_d="Neg",Id="NotEqual",pg="NonMaxSuppressionV3",fg="NonMaxSuppressionV4",mg="NonMaxSuppressionV5",Md="OnesLike",Cd="OneHot",Ed="Pack",kd="PadV2",SV="Pool",tu="Pow",Nd="Prelu",Rd="Prod",gg="RaggedGather",yg="RaggedRange",bg="RaggedTensorToTensor",xg="Range",vg="Real",nu="Reciprocal",su="Relu",Ad="Reshape",Ld="ResizeNearestNeighbor",wg="ResizeNearestNeighborGrad",Pd="ResizeBilinear",Sg="ResizeBilinearGrad",iu="Relu6",Dd="Reverse",ru="Round",au="Rsqrt",Tg="ScatterNd",_g="SearchSorted",Fd="Select",ou="Selu",Od="Slice",lu="Sin",cu="Sinh",uu="Sign",hu="Sigmoid",du="Softplus",pu="Sqrt",Gd="Sum",zd="SpaceToBatchND",Vd="SplitV",Wd="Softmax",Ig="SparseFillEmptyRows",Mg="SparseReshape",Cg="SparseSegmentMean",Eg="SparseSegmentSum",kg="SparseToDense",fu="SquaredDifference",Ng="Square",Rg="StridedSlice",Ag="StringNGrams",Lg="StringSplit",Pg="StringToHashBucketFast",mu="Sub",gu="Tan",yu="Tanh",bu="Tile",Dg="TopK",Fg="Transform",Io="Transpose",Og="Unique",Ud="Unpack",Bd="UnsortedSegmentSum",TV="UpperBound",$d="ZerosLike",xu="Step",jf="FromPixels",Gg="RotateWithOffset",_h="_FusedMatMul",Ih="FusedConv2D",Mh="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qs(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.warn(...n)}function _V(...n){ee().getBool("IS_TEST")||ee().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ic=d1("kernelRegistry",()=>new Map),Ch=d1("gradRegistry",()=>new Map);function Qf(n,e){const t=p1(n,e);return ic.get(t)}function X0(n){return Ch.get(n)}function Jf(n){const e=ic.entries(),t=[];for(;;){const{done:s,value:i}=e.next();if(s)break;const[r,a]=i,[o]=r.split("_");o===n&&t.push(a)}return t}function As(n){const{kernelName:e,backendName:t}=n,s=p1(e,t);ic.has(s)&&qs(`The kernel '${e}' for backend '${t}' is already registered`),ic.set(s,n)}function lC(n){const{kernelName:e}=n;Ch.has(e)&&ee().getBool("DEBUG")&&qs(`Overriding the gradient for '${e}'`),Ch.set(e,n)}function IV(n,e){const t=p1(n,e);if(!ic.has(t))throw new Error(`The kernel '${n}' for backend '${e}' is not registered`);ic.delete(t)}function MV(n){if(!Ch.has(n))throw new Error(`The gradient '${n}' for backend is not registered`);Ch.delete(n)}function CV(n,e){Jf(n).forEach(t=>{const s=Object.assign({},t,{backendName:e});As(s)})}function p1(n,e){return`${e}_${n}`}var cC=jt,xi=null;try{xi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function jt(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}jt.prototype.__isLong__;Object.defineProperty(jt.prototype,"__isLong__",{value:!0});function Zs(n){return(n&&n.__isLong__)===!0}jt.isLong=Zs;var lI={},cI={};function qo(n,e){var t,s,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(s=cI[n],s)?s:(t=Qt(n,(n|0)<0?-1:0,!0),i&&(cI[n]=t),t)):(n|=0,(i=-128<=n&&n<128)&&(s=lI[n],s)?s:(t=Qt(n,n<0?-1:0,!1),i&&(lI[n]=t),t))}jt.fromInt=qo;function vi(n,e){if(isNaN(n))return e?vo:wi;if(e){if(n<0)return vo;if(n>=uC)return pC}else{if(n<=-hI)return zs;if(n+1>=hI)return dC}return n<0?vi(-n,e).neg():Qt(n%rc|0,n/rc|0,e)}jt.fromNumber=vi;function Qt(n,e,t){return new jt(n,e,t)}jt.fromBits=Qt;var qf=Math.pow;function f1(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return wi;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var s;if((s=n.indexOf("-"))>0)throw Error("interior hyphen");if(s===0)return f1(n.substring(1),e,t).neg();for(var i=vi(qf(t,8)),r=wi,a=0;a<n.length;a+=8){var o=Math.min(8,n.length-a),l=parseInt(n.substring(a,a+o),t);if(o<8){var c=vi(qf(t,o));r=r.mul(c).add(vi(l))}else r=r.mul(i),r=r.add(vi(l))}return r.unsigned=e,r}jt.fromString=f1;function $i(n,e){return typeof n=="number"?vi(n,e):typeof n=="string"?f1(n,e):Qt(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}jt.fromValue=$i;var uI=65536,EV=1<<24,rc=uI*uI,uC=rc*rc,hI=uC/2,dI=qo(EV),wi=qo(0);jt.ZERO=wi;var vo=qo(0,!0);jt.UZERO=vo;var Gl=qo(1);jt.ONE=Gl;var hC=qo(1,!0);jt.UONE=hC;var H0=qo(-1);jt.NEG_ONE=H0;var dC=Qt(-1,2147483647,!1);jt.MAX_VALUE=dC;var pC=Qt(-1,-1,!0);jt.MAX_UNSIGNED_VALUE=pC;var zs=Qt(0,-2147483648,!1);jt.MIN_VALUE=zs;var Me=jt.prototype;Me.toInt=function(){return this.unsigned?this.low>>>0:this.low};Me.toNumber=function(){return this.unsigned?(this.high>>>0)*rc+(this.low>>>0):this.high*rc+(this.low>>>0)};Me.toString=function(n){if(n=n||10,n<2||36<n)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(zs)){var e=vi(n),t=this.div(e),s=t.mul(e).sub(this);return t.toString(n)+s.toInt().toString(n)}else return"-"+this.neg().toString(n);for(var i=vi(qf(n,6),this.unsigned),r=this,a="";;){var o=r.div(i),l=r.sub(o.mul(i)).toInt()>>>0,c=l.toString(n);if(r=o,r.isZero())return c+a;for(;c.length<6;)c="0"+c;a=""+c+a}};Me.getHighBits=function(){return this.high};Me.getHighBitsUnsigned=function(){return this.high>>>0};Me.getLowBits=function(){return this.low};Me.getLowBitsUnsigned=function(){return this.low>>>0};Me.getNumBitsAbs=function(){if(this.isNegative())return this.eq(zs)?64:this.neg().getNumBitsAbs();for(var n=this.high!=0?this.high:this.low,e=31;e>0&&!(n&1<<e);e--);return this.high!=0?e+33:e+1};Me.isZero=function(){return this.high===0&&this.low===0};Me.eqz=Me.isZero;Me.isNegative=function(){return!this.unsigned&&this.high<0};Me.isPositive=function(){return this.unsigned||this.high>=0};Me.isOdd=function(){return(this.low&1)===1};Me.isEven=function(){return(this.low&1)===0};Me.equals=function(n){return Zs(n)||(n=$i(n)),this.unsigned!==n.unsigned&&this.high>>>31===1&&n.high>>>31===1?!1:this.high===n.high&&this.low===n.low};Me.eq=Me.equals;Me.notEquals=function(n){return!this.eq(n)};Me.neq=Me.notEquals;Me.ne=Me.notEquals;Me.lessThan=function(n){return this.comp(n)<0};Me.lt=Me.lessThan;Me.lessThanOrEqual=function(n){return this.comp(n)<=0};Me.lte=Me.lessThanOrEqual;Me.le=Me.lessThanOrEqual;Me.greaterThan=function(n){return this.comp(n)>0};Me.gt=Me.greaterThan;Me.greaterThanOrEqual=function(n){return this.comp(n)>=0};Me.gte=Me.greaterThanOrEqual;Me.ge=Me.greaterThanOrEqual;Me.compare=function(n){if(Zs(n)||(n=$i(n)),this.eq(n))return 0;var e=this.isNegative(),t=n.isNegative();return e&&!t?-1:!e&&t?1:this.unsigned?n.high>>>0>this.high>>>0||n.high===this.high&&n.low>>>0>this.low>>>0?-1:1:this.sub(n).isNegative()?-1:1};Me.comp=Me.compare;Me.negate=function(){return!this.unsigned&&this.eq(zs)?zs:this.not().add(Gl)};Me.neg=Me.negate;Me.add=function(n){Zs(n)||(n=$i(n));var e=this.high>>>16,t=this.high&65535,s=this.low>>>16,i=this.low&65535,r=n.high>>>16,a=n.high&65535,o=n.low>>>16,l=n.low&65535,c=0,u=0,h=0,d=0;return d+=i+l,h+=d>>>16,d&=65535,h+=s+o,u+=h>>>16,h&=65535,u+=t+a,c+=u>>>16,u&=65535,c+=e+r,c&=65535,Qt(h<<16|d,c<<16|u,this.unsigned)};Me.subtract=function(n){return Zs(n)||(n=$i(n)),this.add(n.neg())};Me.sub=Me.subtract;Me.multiply=function(n){if(this.isZero())return wi;if(Zs(n)||(n=$i(n)),xi){var e=xi.mul(this.low,this.high,n.low,n.high);return Qt(e,xi.get_high(),this.unsigned)}if(n.isZero())return wi;if(this.eq(zs))return n.isOdd()?zs:wi;if(n.eq(zs))return this.isOdd()?zs:wi;if(this.isNegative())return n.isNegative()?this.neg().mul(n.neg()):this.neg().mul(n).neg();if(n.isNegative())return this.mul(n.neg()).neg();if(this.lt(dI)&&n.lt(dI))return vi(this.toNumber()*n.toNumber(),this.unsigned);var t=this.high>>>16,s=this.high&65535,i=this.low>>>16,r=this.low&65535,a=n.high>>>16,o=n.high&65535,l=n.low>>>16,c=n.low&65535,u=0,h=0,d=0,p=0;return p+=r*c,d+=p>>>16,p&=65535,d+=i*c,h+=d>>>16,d&=65535,d+=r*l,h+=d>>>16,d&=65535,h+=s*c,u+=h>>>16,h&=65535,h+=i*l,u+=h>>>16,h&=65535,h+=r*o,u+=h>>>16,h&=65535,u+=t*c+s*l+i*o+r*a,u&=65535,Qt(d<<16|p,u<<16|h,this.unsigned)};Me.mul=Me.multiply;Me.divide=function(n){if(Zs(n)||(n=$i(n)),n.isZero())throw Error("division by zero");if(xi){if(!this.unsigned&&this.high===-2147483648&&n.low===-1&&n.high===-1)return this;var e=(this.unsigned?xi.div_u:xi.div_s)(this.low,this.high,n.low,n.high);return Qt(e,xi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?vo:wi;var t,s,i;if(this.unsigned){if(n.unsigned||(n=n.toUnsigned()),n.gt(this))return vo;if(n.gt(this.shru(1)))return hC;i=vo}else{if(this.eq(zs)){if(n.eq(Gl)||n.eq(H0))return zs;if(n.eq(zs))return Gl;var r=this.shr(1);return t=r.div(n).shl(1),t.eq(wi)?n.isNegative()?Gl:H0:(s=this.sub(n.mul(t)),i=t.add(s.div(n)),i)}else if(n.eq(zs))return this.unsigned?vo:wi;if(this.isNegative())return n.isNegative()?this.neg().div(n.neg()):this.neg().div(n).neg();if(n.isNegative())return this.div(n.neg()).neg();i=wi}for(s=this;s.gte(n);){t=Math.max(1,Math.floor(s.toNumber()/n.toNumber()));for(var a=Math.ceil(Math.log(t)/Math.LN2),o=a<=48?1:qf(2,a-48),l=vi(t),c=l.mul(n);c.isNegative()||c.gt(s);)t-=o,l=vi(t,this.unsigned),c=l.mul(n);l.isZero()&&(l=Gl),i=i.add(l),s=s.sub(c)}return i};Me.div=Me.divide;Me.modulo=function(n){if(Zs(n)||(n=$i(n)),xi){var e=(this.unsigned?xi.rem_u:xi.rem_s)(this.low,this.high,n.low,n.high);return Qt(e,xi.get_high(),this.unsigned)}return this.sub(this.div(n).mul(n))};Me.mod=Me.modulo;Me.rem=Me.modulo;Me.not=function(){return Qt(~this.low,~this.high,this.unsigned)};Me.and=function(n){return Zs(n)||(n=$i(n)),Qt(this.low&n.low,this.high&n.high,this.unsigned)};Me.or=function(n){return Zs(n)||(n=$i(n)),Qt(this.low|n.low,this.high|n.high,this.unsigned)};Me.xor=function(n){return Zs(n)||(n=$i(n)),Qt(this.low^n.low,this.high^n.high,this.unsigned)};Me.shiftLeft=function(n){return Zs(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?Qt(this.low<<n,this.high<<n|this.low>>>32-n,this.unsigned):Qt(0,this.low<<n-32,this.unsigned)};Me.shl=Me.shiftLeft;Me.shiftRight=function(n){return Zs(n)&&(n=n.toInt()),(n&=63)===0?this:n<32?Qt(this.low>>>n|this.high<<32-n,this.high>>n,this.unsigned):Qt(this.high>>n-32,this.high>=0?0:-1,this.unsigned)};Me.shr=Me.shiftRight;Me.shiftRightUnsigned=function(n){if(Zs(n)&&(n=n.toInt()),n&=63,n===0)return this;var e=this.high;if(n<32){var t=this.low;return Qt(t>>>n|e<<32-n,e>>>n,this.unsigned)}else return n===32?Qt(e,0,this.unsigned):Qt(e>>>n-32,0,this.unsigned)};Me.shru=Me.shiftRightUnsigned;Me.shr_u=Me.shiftRightUnsigned;Me.toSigned=function(){return this.unsigned?Qt(this.low,this.high,!1):this};Me.toUnsigned=function(){return this.unsigned?this:Qt(this.low,this.high,!0)};Me.toBytes=function(n){return n?this.toBytesLE():this.toBytesBE()};Me.toBytesLE=function(){var n=this.high,e=this.low;return[e&255,e>>>8&255,e>>>16&255,e>>>24,n&255,n>>>8&255,n>>>16&255,n>>>24]};Me.toBytesBE=function(){var n=this.high,e=this.low;return[n>>>24,n>>>16&255,n>>>8&255,n&255,e>>>24,e>>>16&255,e>>>8&255,e&255]};jt.fromBytes=function(n,e,t){return t?jt.fromBytesLE(n,e):jt.fromBytesBE(n,e)};jt.fromBytesLE=function(n,e){return new jt(n[0]|n[1]<<8|n[2]<<16|n[3]<<24,n[4]|n[5]<<8|n[6]<<16|n[7]<<24,e)};jt.fromBytesBE=function(n,e){return new jt(n[4]<<24|n[5]<<16|n[6]<<8|n[7],n[0]<<24|n[1]<<16|n[2]<<8|n[3],e)};const fC=Jz(cC),kV=aV({__proto__:null,default:fC},[cC]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const go=fC||kV;function Xd(n){return go.fromString(n,!0,16)}const mC=Xd("c3a5c85c97cb3127"),ho=Xd("b492b66fbe98f273"),cs=Xd("9ae16a3b2f90404f");function K0(n){return n.xor(n.shru(47))}function gC(n,e,t){const s=n.slice(e,e+t);return go.fromBytes(Array.from(s),!0,!0)}function $t(n,e){return gC(n,e,8)}function pI(n,e){return gC(n,e,4)}function Ln(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Ma(n,e,t=Xd("9ddfea08eb382d69")){let s=n.xor(e).mul(t);s=s.xor(s.shru(47));let i=e.xor(s).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function NV(n,e,t,s,i,r){i=i.add(n),r=Ln(r.add(i).add(s),21);const a=i;return i=i.add(e),i=i.add(t),r=r.add(Ln(i,44)),[i.add(s),r.add(a)]}function uf(n,e,t,s){return NV($t(n,e),$t(n,e+8),$t(n,e+16),$t(n,e+24),t,s)}function RV(n,e=n.length){if(e>=8){const t=cs.add(e*2),s=$t(n,0).add(cs),i=$t(n,e-8),r=Ln(i,37).mul(t).add(s),a=Ln(s,25).add(i).mul(t);return Ma(r,a,t)}if(e>=4){const t=cs.add(e*2),s=pI(n,0);return Ma(s.shl(3).add(e),pI(n,e-4),t)}if(e>0){const t=n[0],s=n[e>>1],i=n[e-1],r=t+(s<<8),a=e+(i<<2);return K0(cs.mul(r).xor(mC.mul(a))).mul(cs)}return cs}function AV(n,e=n.length){const t=cs.add(e*2),s=$t(n,0).mul(ho),i=$t(n,8),r=$t(n,e-8).mul(t),a=$t(n,e-16).mul(cs);return Ma(Ln(s.add(i),43).add(Ln(r,30)).add(a),s.add(Ln(i.add(cs),18)).add(r),t)}function LV(n,e=n.length){const t=cs.add(e*2),s=$t(n,0).mul(cs),i=$t(n,8),r=$t(n,e-8).mul(t),a=$t(n,e-16).mul(cs),o=Ln(s.add(i),43).add(Ln(r,30)).add(a),l=Ma(o,s.add(Ln(i.add(cs),18)).add(r),t),c=$t(n,16).mul(t),u=$t(n,24),h=o.add($t(n,e-32)).mul(t),d=l.add($t(n,e-24)).mul(t);return Ma(Ln(c.add(u),43).add(Ln(h,30)).add(d),c.add(Ln(u.add(s),18)).add(h),t)}function yC(n,e=n.length){const t=go.fromNumber(81,!0);if(e<=32)return e<=16?RV(n,e):AV(n,e);if(e<=64)return LV(n,e);let s=t,i=t.mul(ho).add(113),r=K0(i.mul(cs).add(113)).mul(cs),a=[go.UZERO,go.UZERO],o=[go.UZERO,go.UZERO];s=s.mul(cs).add($t(n,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do s=Ln(s.add(i).add(a[0]).add($t(n,l+8)),37).mul(ho),i=Ln(i.add(a[1]).add($t(n,l+48)),42).mul(ho),s=s.xor(o[1]),i=i.add(a[0]).add($t(n,l+40)),r=Ln(r.add(o[0]),33).mul(ho),a=uf(n,l,a[1].mul(ho),s.add(o[0])),o=uf(n,l+32,r.add(o[1]),i.add($t(n,l+16))),[r,s]=[s,r],l+=64;while(l!==c);const h=ho.add(r.and(255).shl(1));return l=u,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),s=Ln(s.add(i).add(a[0]).add($t(n,l+8)),37).mul(h),i=Ln(i.add(a[1]).add($t(n,l+48)),42).mul(h),s=s.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add($t(n,l+40))),r=Ln(r.add(o[0]),33).mul(h),a=uf(n,l,a[1].mul(h),s.add(o[0])),o=uf(n,l+32,r.add(o[1]),i.add($t(n,l+16))),[r,s]=[s,r],Ma(Ma(a[0],o[0],h).add(K0(i).mul(mC)).add(r),Ma(a[1],o[1],h).add(s),h)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jr(n,e){return e==="string"?cr(n):Ua([n],e)}function PV(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Ua(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=pr(n)),ee().getBool("DEBUG")&&J2(n,e),PV(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let s=0;s<t.length;++s)Math.round(n[s])!==0&&(t[s]=1);return t}else throw new Error(`Unknown data type ${e}`)}function Xn(){return ee().platform.now()}function bC(n,e){return ee().platform.fetch(n,e)}function cr(n,e="utf-8"){return e=e||"utf-8",ee().platform.encode(n,e)}function Br(n,e="utf-8"){return e=e||"utf-8",ee().platform.decode(n,e)}function Pn(n){return ee().platform.isTypedArray(n)}function pr(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||Ur(n)||n==null||Pn(n)&&t)e.push(n);else if(Array.isArray(n)||Pn(n))for(let s=0;s<n.length;++s)pr(n[s],e,t);else{let s=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(s=Math.max(s,Number(i)));for(let i=0;i<=s;i++)pr(n[i],e,t)}return e}const DV=Object.freeze(Object.defineProperty({__proto__:null,arraysEqual:St,assert:E,assertNonNegativeIntegerDimensions:Ks,assertNonNull:jo,assertShapesMatch:jn,bytesFromStringArray:eC,bytesPerElement:Th,checkConversionForErrors:J2,clamp:Aa,computeStrides:He,convertBackendValuesAndArrayBuffer:sC,createScalarValue:Jr,createShuffledIndices:fV,decodeString:Br,distSquared:hV,encodeString:cr,fetch:bC,fingerPrint64:yC,flatten:pr,getArrayFromDType:pn,getTypedArrayFromDType:Rn,hasEncodingLoss:c1,hexToLong:Xd,indexToLoc:Qo,inferDtype:_c,inferFromImplicitShape:l1,isBoolean:tC,isFunction:La,isInt:Ao,isNumber:Hf,isPromise:Ur,isScalarShape:dV,isString:ir,isTypedArray:Pn,isValidDtype:q2,locToIndex:Oi,makeOnesTypedArray:Dm,makeZerosNestedTypedArray:u1,makeZerosTypedArray:Zn,nearestDivisor:Kf,nearestLargerEven:Pm,now:Xn,parseAxisParam:mt,randUniform:uV,repeatedTry:$0,rightPad:_o,shuffle:o1,shuffleCombo:cV,sizeFromShape:re,sizeToSquarishShape:Xf,squeezeShape:Qr,sum:Q2,swap:Lr,tanh:pV,toNestedArray:ni,toTypedArray:Ua},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FV{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new GV)}profileKernel(e,t,s){let i;const r=()=>{i=s()};let a;const o=Xn();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(r);else{r();for(const l of i)l.dataSync();a=Promise.resolve({kernelMs:Xn()-o})}if(ee().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<i.length;l++){const c=i[l];c.data().then(u=>{OV(u,c.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:s,timeMs:i,inputs:r,extraInfo:a}=e;s.forEach(o=>{Promise.all([o.data(),i,a]).then(l=>{this.logger.logKernelProfile(t,o,l[0],l[1],r,l[2])})})}}function OV(n,e,t){if(e!=="float32")return!1;for(let s=0;s<n.length;s++){const i=n[s];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class GV{logKernelProfile(e,t,s,i,r,a){const o=typeof i=="number"?_o(`${i}ms`,9):i.error,l=_o(e,25),c=t.rank,u=t.size,h=_o(t.shape.toString(),14);let d="";for(const p in r){const f=r[p];if(f!=null){const y=f.shape||t.shape,m=y.length;d+=`${p}: ${m}D ${m>0?y:""} `}}console.log(`%c${l}	%c${o}	%c${c}D ${h}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n,e,t){const s={},i={};for(let l=0;l<e.length;l++)s[e[l].id]=!0;for(let l=0;l<n.length;l++){const c=n[l],u=c.inputs;for(const h in u){const d=u[h];let p=!1;for(let f=0;f<e.length;f++)if(s[d.id]){c.outputs.forEach(y=>s[y.id]=!0),p=!0,i[c.id]=!0;break}if(p)break}}const r={};r[t.id]=!0;const a={};for(let l=n.length-1;l>=0;l--){const c=n[l],u=c.inputs;for(let h=0;h<c.outputs.length;h++)if(r[c.outputs[h].id]){for(const d in u)r[u[d].id]=!0,a[c.id]=!0;break}}const o=[];for(let l=0;l<n.length;l++){const c=n[l];if(i[c.id]&&a[c.id]){const u={};for(const d in c.inputs){const p=c.inputs[d];s[p.id]&&(u[d]=p)}const h=Object.assign({},c);h.inputs=u,h.outputs=c.outputs,o.push(h)}}return o}function VV(n,e,t,s){for(let i=e.length-1;i>=0;i--){const r=e[i],a=[];if(r.outputs.forEach(l=>{const c=n[l.id];c!=null?a.push(c):a.push(null)}),r.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${r.kernelName}.`);const o=r.gradient(a);for(const l in r.inputs){if(!(l in o))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(o)}.`);const c=t(()=>o[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=r.inputs[l];if(!St(c.shape,u.shape))throw new Error(`Error in gradient for op ${r.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=c;else{const h=n[u.id];n[u.id]=s(h,c),h.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fI=20,eh=3,$b=7;function WV(n,e,t,s){const i=He(e),r=UV(n,e,t,i),a=e.length,o=Af(n,e,t,i,r),l=["Tensor"];return s&&(l.push(`  dtype: ${t}`),l.push(`  rank: ${a}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(o.map(c=>"    "+c).join(`
`)),l.join(`
`)}function UV(n,e,t,s){const i=re(e),r=s[s.length-1],a=new Array(r).fill(0),o=e.length,l=t==="complex64"?hh(n):n;if(o>1)for(let c=0;c<i/r;c++){const u=c*r;for(let h=0;h<r;h++)a[h]=Math.max(a[h],uh(l[u+h],0,t).length)}return a}function uh(n,e,t){let s;return Array.isArray(n)?s=`${parseFloat(n[0].toFixed($b))} + ${parseFloat(n[1].toFixed($b))}j`:ir(n)?s=`'${n}'`:t==="bool"?s=xC(n):s=parseFloat(n.toFixed($b)).toString(),_o(s,e)}function xC(n){return n===0?"false":"true"}function Af(n,e,t,s,i,r=!0){const a=t==="complex64"?2:1,o=e[0],l=e.length;if(l===0){if(t==="complex64"){const y=hh(n);return[uh(y[0],0,t)]}return t==="bool"?[xC(n[0])]:[n[0].toString()]}if(l===1){if(o>fI){const y=eh*a;let m=Array.from(n.slice(0,y)),g=Array.from(n.slice((o-eh)*a,o*a));return t==="complex64"&&(m=hh(m),g=hh(g)),["["+m.map((b,x)=>uh(b,i[x],t)).join(", ")+", ..., "+g.map((b,x)=>uh(b,i[o-eh+x],t)).join(", ")+"]"]}return["["+(t==="complex64"?hh(n):Array.from(n)).map((y,m)=>uh(y,i[m],t)).join(", ")+"]"]}const c=e.slice(1),u=s.slice(1),h=s[0]*a,d=[];if(o>fI){for(let y=0;y<eh;y++){const m=y*h,g=m+h;d.push(...Af(n.slice(m,g),c,t,u,i,!1))}d.push("...");for(let y=o-eh;y<o;y++){const m=y*h,g=m+h;d.push(...Af(n.slice(m,g),c,t,u,i,y===o-1))}}else for(let y=0;y<o;y++){const m=y*h,g=m+h;d.push(...Af(n.slice(m,g),c,t,u,i,y===o-1))}const p=l===2?",":"";d[0]="["+(o>0?d[0]+p:"");for(let y=1;y<d.length-1;y++)d[y]=" "+d[y]+p;let f=`,
`;for(let y=2;y<l;y++)f+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(r?"":f),d}function hh(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class En{constructor(e,t,s){if(this.dtype=t,this.shape=e.slice(),this.size=re(e),s!=null){const i=s.length;E(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=s||pn(t,this.size),this.strides=He(e)}set(e,...t){t.length===0&&(t=[0]),E(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const s=this.locToIndex(t);this.values[s]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const r=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(r)}t++}let s=e[e.length-1];for(let i=0;i<e.length-1;++i)s+=this.strides[i]*e[i];return this.values[s]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let s=0;s<e.length-1;++s)t+=this.strides[s]*e[s];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let s=0;s<t.length-1;++s)t[s]=Math.floor(e/this.strides[s]),e-=t[s]*this.strides[s];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Ai().makeTensor(this.values,this.shape,this.dtype)}}let Ai=null,Al=null;function BV(n){Ai=n}function $V(n){Al=n}let Et=class{constructor(e,t,s,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=re(e),this.strides=He(e),this.dataId=s,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Al.buffer(this.shape,this.dtype,e)}bufferSync(){return Al.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return ni(this.shape,e,this.dtype==="complex64")}arraySync(){return ni(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Ai().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(s=>Br(s))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Ai().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Ai().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Br(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Ai().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Ai().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Al.print(this,e)}clone(){return this.throwIfDisposed(),Al.clone(this)}toString(e=!1){const t=this.dataSync();return WV(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Al.cast(this,e)}variable(e=!0,t,s){return this.throwIfDisposed(),Ai().makeVariable(this,e,t,s)}};Object.defineProperty(Et,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function le(){return d1("Tensor",()=>Et)}le();class Eh extends Et{constructor(e,t,s,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=s}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!St(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Ai().disposeTensor(this),this.dataId=e.dataId,Ai().incRef(this,null)}dispose(){Ai().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(Eh,Symbol.hasInstance,{value:n=>n instanceof Et&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Z0;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(Z0||(Z0={}));var Y0;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(Y0||(Y0={}));var j0;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(j0||(j0={}));var Q0;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(Q0||(Q0={}));var J0;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(J0||(J0={}));const XV={float32:Q0,int32:Y0,bool:j0,complex64:J0};function Es(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return XV[n][e]}function zg(n){return Es(n,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cn(n,e){if(n.dtype===e.dtype)return[n,e];const t=Es(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function vC(n,e){E(n.dtype===e.dtype,()=>`The dtypes of the first(${n.dtype}) and second(${e.dtype}) input must match`)}function Vg(n,e){return e.some(t=>t.id===n.id)}function $r(n){const e=[];return wC(n,e,new Set),e}function wC(n,e,t){if(n==null)return;if(n instanceof Et){e.push(n);return}if(!HV(n))return;const s=n;for(const i in s){const r=s[i];t.has(r)||(t.add(r),wC(r,e,t))}}function HV(n){return Array.isArray(n)||typeof n=="object"}const KV=Object.freeze(Object.defineProperty({__proto__:null,assertTypesMatch:vC,getTensorsInContainer:$r,isTensorInList:Vg,makeTypesMatch:cn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xb(n){return n.kernelName!=null}class mI{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class ac{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new mI}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t];if(await this.initializeBackend(s).success){await this.setBackend(s);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,s=1){return e in this.registryFactory?(qs(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:s},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:s}=this.initializeBackend(e);if(!(s?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new FV(this.backendInstance),!0}setupRegisteredKernels(){Jf(this.backendName).forEach(e=>{e.setupFunc!=null&&e.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){Jf(e).forEach(t=>{t.disposeFunc!=null&&t.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const s=t.factory();if(s&&!(s instanceof Lm)&&typeof s.then=="function"){const i=++this.pendingBackendInitId,r=s.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,qs(`Initialization of backend ${e} failed`),qs(a.stack||a.message)),!1));return this.pendingBackendInit=r,{success:r,asyncInit:!0}}else return this.registry[e]=s,{success:!0,asyncInit:!1}}catch(s){return qs(`Initialization of backend ${e} failed`),qs(s.stack||s.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const s=e[t],{success:i,asyncInit:r}=this.initializeBackend(s);if(r||i)return{name:s,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const s=this.state.tensorInfo.get(t),i=s.backend,r=this.readSync(t),a=i.refCount(t);i.disposeData(t,!0),s.backend=e,e.move(t,r,s.shape,s.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let s=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");s=e}let i;return this.scopedRun(()=>this.startScope(s),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,s){e();try{const i=s();return t(),i}catch(i){throw t(),i}}nextTensorId(){return ac.nextTensorId++}nextVariableId(){return ac.nextVariableId++}clone(e){const t=W.runKernel(Xc,{x:e}),s={x:e},i=a=>({x:()=>{const o="float32",l={x:a},c={dtype:o};return W.runKernel(Ac,l,c)}}),r=[];return this.addTapeNode(this.state.activeScope.name,s,[t],i,r,{}),t}runKernel(e,t,s){if(this.backendName==null&&this.backend,Qf(e,this.backendName)==null)throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:s})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,s){const i=this.backend.numDataIds();let r=0;s.forEach(l=>{r+=l.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-t-r-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,s=[];const i=this.isTapeOn(),r=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let l;const c=Xb(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Xb(e)){const{kernelName:f,inputs:y,attrs:m}=e;this.backendName==null&&this.backend;const g=Qf(f,this.backendName);E(g!=null,()=>`Cannot find registered kernel '${f}' for backend '${this.backendName}'`),o=()=>{const b=this.backend.numDataIds();l=g.kernelFunc({inputs:y,attrs:m,backend:this.backend});const x=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(f,b,x);const v=x.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(i){const w=this.getTensorsForGradient(f,y,v);s=this.saveTensorsForBackwardMode(w)}return v}}else{const{forwardFunc:f}=e,y=m=>{i&&(s=m.map(g=>this.keep(this.clone(g))))};o=()=>{const m=this.backend.numDataIds();l=this.tidy(()=>f(this.backend,y));const g=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,m,g),g}}const{inputs:u,attrs:h}=e,d=Xb(e)?null:e.backwardsFunc;let p;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(p=this.profiler.profileKernel(c,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(p),t=p.outputs)}),i&&this.addTapeNode(c,u,t,d,s,h),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(f=>u[f]!=null?u[f].shape:null),outputShapes:t.map(f=>f.shape),kernelTimeMs:p.timeMs,extraInfo:p.extraInfo}),Array.isArray(l)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(t=>this.keep(this.clone(t)))}getTensorsForGradient(e,t,s){const i=X0(e);if(i!=null){const r=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(E(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(c=>t[c])):o=r.map(c=>t[c]);const l=s.filter((c,u)=>a[u]);return o.concat(l)}return[]}makeTensor(e,t,s,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");s=s||"float32",i=i||this.backend;let r=e;s==="string"&&ir(e[0])&&(r=e.map(l=>cr(l)));const a=i.write(r,t,s),o=new Et(t,s,a,this.nextTensorId());if(this.trackTensor(o,i),s==="string"){const l=this.state.tensorInfo.get(a),c=eC(r);this.state.numBytes+=c-l.bytes,l.bytes=c}return o}makeTensorFromDataId(e,t,s,i){s=s||"float32";const r={dataId:e,shape:t,dtype:s};return this.makeTensorFromTensorInfo(r,i)}makeTensorFromTensorInfo(e,t){const{dataId:s,shape:i,dtype:r}=e,a=new Et(i,r,s,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,s,i){s=s||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const r=new Eh(e,t,s,this.nextTensorId());if(this.state.registeredVariables[r.name]!=null)throw new Error(`Variable with name ${r.name} was already registered`);return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let s=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(s=e.size*Th(e.dtype)),this.state.numBytes+=s,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:s})),e instanceof Eh||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const s=e.size*Th(e.dtype);this.state.numBytes-=s}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,s=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-s;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,s,i,r,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:s,saved:r},l=X0(e);l!=null&&(i=l.gradFunc),i!=null&&(o.gradient=c=>(c=c.map((u,h)=>{if(u==null){const d=s[h],p=Zn(d.size,d.dtype);return this.makeTensor(p,d.shape,d.dtype)}return u}),i(c.length>1?c:c[0],r,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=$r(e),s=new Set(t.map(r=>r.id));for(let r=0;r<this.state.activeScope.track.length;r++){const a=this.state.activeScope.track[r];!a.kept&&!s.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(r=>{!r.kept&&r.scopeId===i.id&&this.track(r)})}gradients(e,t,s,i=!1){if(E(t.length>0,()=>"gradients() received an empty list of xs."),s!=null&&s.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${s.dtype}'`);const r=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));E(r instanceof Et,()=>"The result y returned by f() must be a tensor.");const a=zV(this.state.activeTape,t,r);if(!i&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[r.id]=s??ZV(r.shape),VV(o,a,c=>this.tidy(c),YV);const l=t.map(c=>o[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:r,grads:l}})}customGrad(e){return E(La(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{E(t.every(o=>o instanceof Et),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let s;const i={};t.forEach((o,l)=>{i[l]=o});const r=(o,l)=>(s=e(...t,l),E(s.value instanceof Et,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),E(La(s.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),s.value),a=(o,l)=>{const c=s.gradFunc(o,l),u=Array.isArray(c)?c:[c];E(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),E(u.every(d=>d instanceof Et),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const h={};return u.forEach((d,p)=>{h[p]=()=>d}),h};return this.runKernelFunc({forwardFunc:r,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=Xn(),s=await this.backend.time(e);return s.wallMs=Xn()-t,s}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new mI;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}ac.nextTensorId=0;ac.nextVariableId=0;function ZV(n){const e=Dm(re(n),"float32");return W.makeTensor(e,n,"float32")}function SC(){const n=rC();if(n._tfengine==null){const e=new iC(n);n._tfengine=new ac(e)}return bV(n._tfengine.ENV),BV(()=>n._tfengine),n._tfengine}const W=SC();function YV(n,e){const t={a:n,b:e};return W.runKernel(Jo,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jV(){return typeof navigator<"u"&&navigator!=null}let q0;function QV(n){q0=n}function m1(n){if(q0!==void 0)return q0;if(n||jV()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function g1(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}const JV=Object.freeze(Object.defineProperty({__proto__:null,isBrowser:g1,isMobile:m1,mockIsMobile:QV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ii=ee();ii.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ii.registerFlag("IS_BROWSER",()=>g1());ii.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ii.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ii.registerFlag("PROD",()=>!1);ii.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ii.getBool("DEBUG"));ii.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ii.registerFlag("IS_TEST",()=>!1);ii.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ii.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ii.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ii.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fr(n,e){let t=n;if(Pn(n))return e==="string"?[]:[n.length];if(typeof n=="object"){if("texture"in n){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if("buffer"in n&&!(n.buffer instanceof ArrayBuffer))return[n.buffer.size/(e==null?4:Th(e))]}if(!Array.isArray(n))return[];const s=[];for(;Array.isArray(t)||Pn(t)&&e!=="string";)s.push(t.length),t=t[0];return Array.isArray(n)&&ee().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&TC(n,s,[]),s}function TC(n,e,t){if(t=t||[],!Array.isArray(n)&&!Pn(n)){E(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}E(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),E(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const s=e.slice(1);for(let i=0;i<n.length;++i)TC(n[i],s,t.concat(i))}function gI(n,e,t,s){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${s}' must be ${n} tensor, but got ${e} tensor`)}}function N(n,e,t,s="numeric"){if(n instanceof Et)return gI(s,n.dtype,e,t),n;let i=_c(n);if(i!=="string"&&["bool","int32","float32"].indexOf(s)>=0&&(i=s),gI(s,i,e,t),n==null||!Pn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const o=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${o}'`)}const r=fr(n,i);!Pn(n)&&!Array.isArray(n)&&(n=[n]);const a=i!=="string"?Ua(n,i):pr(n,[],!0);return W.makeTensor(a,r,i)}function kh(n,e,t,s="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((i,r)=>N(i,`${e}[${r}]`,t,s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y1="__op";function U(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const s=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+y1;const i=(...r)=>{W.startScope(t);try{const a=s(...r);return Ur(a)&&console.error("Cannot return a Promise inside of tidy."),W.endScope(a),a}catch(a){throw W.endScope(null),a}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qV(n,e){const t=N(n,"real","complex"),s=N(e,"imag","complex");jn(t.shape,s.shape,`real and imag shapes, ${t.shape} and ${s.shape}, must match in call to tf.complex().`);const i={real:t,imag:s};return W.runKernel(Um,i)}const Xr=U({complex_:qV});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ba(n,e,t,s){if(s==null)s=_c(n);else if(s==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(typeof n=="object"&&("texture"in n||"buffer"in n&&!(n.buffer instanceof ArrayBuffer))){if(s!=="float32"&&s!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${s}.`);return W.backend.createTensorFromGPUData(n,e||t,s)}if(!Pn(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){Ks(e);const i=re(e),r=re(t);E(i===r,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${r}`);for(let a=0;a<t.length;++a){const o=t[a],l=a===t.length-1?o!==re(e.slice(a)):!0;E(t[a]===e[a]||!l,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Pn(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=s!=="string"?Ua(n,s):pr(n,[],!0),W.makeTensor(n,e,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n,e,t){const s=fr(n,t);return Ba(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ex={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const em=4;async function tx(n,e){const t=[],s=[],i=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<i.length;++a){const o=i[a],l=Array.isArray(n)?n[a].tensor:n[o];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${l.dtype}`);const c={name:o,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async h=>{const d=await l.bytes(),p=d.reduce((m,g)=>m+g.length,0)+em*d.length,f=new Uint8Array(p);let y=0;for(let m=0;m<d.length;m++){const g=d[m],b=new Uint8Array(new Uint32Array([g.length]).buffer);f.set(b,y),y+=em,f.set(g,y),y+=g.length}h(f)});s.push(u)}else s.push(l.data());e!=null&&(c.group=e),t.push(c)}const r=await Promise.all(s);return{data:eW(r),specs:t}}function b1(n,e){const t={};let s,i=0;for(const r of e){const a=r.name,o=r.dtype,l=r.shape,c=re(l);let u;if("quantization"in r){const h=r.quantization;if(h.dtype==="uint8"||h.dtype==="uint16"){if(!("min"in h&&"scale"in h))throw new Error(`Weight ${r.name} with quantization ${h.dtype} doesn't have corresponding metadata min and scale.`)}else if(h.dtype==="float16"){if(o!=="float32")throw new Error(`Weight ${r.name} is quantized with ${h.dtype} which only supports weights of type float32 not ${o}.`)}else throw new Error(`Weight ${r.name} has unknown quantization dtype ${h.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const d=ex[h.dtype],p=n.slice(i,i+c*d),f=h.dtype==="uint8"?new Uint8Array(p):new Uint16Array(p);if(o==="float32")if(h.dtype==="uint8"||h.dtype==="uint16"){u=new Float32Array(f.length);for(let y=0;y<f.length;y++){const m=f[y];u[y]=m*h.scale+h.min}}else if(h.dtype==="float16")s===void 0&&(s=aW()),u=s(f);else throw new Error(`Unsupported quantization type ${h.dtype} for weight type float32.`);else if(o==="int32"){if(h.dtype!=="uint8"&&h.dtype!=="uint16")throw new Error(`Unsupported quantization type ${h.dtype} for weight type int32.`);u=new Int32Array(f.length);for(let y=0;y<f.length;y++){const m=f[y];u[y]=Math.round(m*h.scale+h.min)}}else throw new Error(`Unsupported dtype in weight '${a}': ${o}`);i+=c*d}else if(o==="string"){const h=re(r.shape);u=[];for(let d=0;d<h;d++){const p=new Uint32Array(n.slice(i,i+em))[0];i+=em;const f=new Uint8Array(n.slice(i,i+p));u.push(f),i+=p}}else{const h=ex[o],d=n.slice(i,i+c*h);if(o==="float32")u=new Float32Array(d);else if(o==="int32")u=new Int32Array(d);else if(o==="bool")u=new Uint8Array(d);else if(o==="complex64"){u=new Float32Array(d);const p=new Float32Array(u.length/2),f=new Float32Array(u.length/2);for(let g=0;g<p.length;g++)p[g]=u[g*2],f[g]=u[g*2+1];const y=en(p,l,"float32"),m=en(f,l,"float32");t[a]=Xr(y,m),y.dispose(),m.dispose()}else throw new Error(`Unsupported dtype in weight '${a}': ${o}`);i+=c*h}o!=="complex64"&&(t[a]=en(u,l,o))}return t}function eW(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(r=>{if(e+=r.byteLength,t.push(r.byteLength===r.buffer.byteLength?r:new r.constructor(r)),!(r instanceof Float32Array||r instanceof Int32Array||r instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${r.constructor.name}`)});const s=new Uint8Array(e);let i=0;return t.forEach(r=>{s.set(new Uint8Array(r.buffer),i),i+=r.byteLength}),s.buffer}const x1=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function yI(n){return x1?Buffer.byteLength(n):new Blob([n]).size}function tW(n){if(x1)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let s=0,i=e.length;s<i;s++)t+=String.fromCharCode(e[s]);return btoa(t)}function nW(n){if(x1){const s=Buffer.from(n,"base64");return s.buffer.slice(s.byteOffset,s.byteOffset+s.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let s=0;s<e.length;++s)t.set([e.charCodeAt(s)],s);return t.buffer}function Wg(n){if(n.length===1)return n[0];let e=0;n.forEach(i=>{e+=i.byteLength});const t=new Uint8Array(e);let s=0;return n.forEach(i=>{t.set(new Uint8Array(i),s),s+=i.byteLength}),t.buffer}function bI(n){const e="/";for(n=n.trim();n.endsWith(e);)n=n.slice(0,n.length-1);const t=n.split(e);return t[t.length-1]}function _C(n,e){const t={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy,weightsManifest:e};return n.signature!=null&&(t.signature=n.signature),n.userDefinedMetadata!=null&&(t.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(t.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(t.initializerSignature=n.initializerSignature),n.trainingConfig!=null&&(t.trainingConfig=n.trainingConfig),t}function v1(n,e,t){const s={modelTopology:n.modelTopology,format:n.format,generatedBy:n.generatedBy,convertedBy:n.convertedBy};if(n.trainingConfig!=null&&(s.trainingConfig=n.trainingConfig),n.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!t)throw new Error("modelJSON has weightsManifest but weightData is null");s.weightSpecs=e,s.weightData=t}return n.signature!=null&&(s.signature=n.signature),n.userDefinedMetadata!=null&&(s.userDefinedMetadata=n.userDefinedMetadata),n.modelInitializer!=null&&(s.modelInitializer=n.modelInitializer),n.initializerSignature!=null&&(s.initializerSignature=n.initializerSignature),s}async function w1(n,e){let t,s;return n.weightsManifest!=null&&([t,s]=await e(n.weightsManifest)),v1(n,t,s)}function Hd(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:yI(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:yI(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:n.weightData.byteLength}}function S1(n){const e=[];for(const t of n)e.push(...t.weights);return e}function sW(){const n=t=>{let s=t<<13,i=0;for(;!(s&8388608);)i-=8388608,s<<=1;return s&=-8388609,i+=947912704,s|i},e=new Uint32Array(2048);e[0]=0;for(let t=1;t<1024;t++)e[t]=n(t);for(let t=1024;t<2048;t++)e[t]=939524096+(t-1024<<13);return e}function iW(){const n=new Uint32Array(64);n[0]=0,n[31]=1199570944,n[32]=2147483648,n[63]=3347054592;for(let e=1;e<31;e++)n[e]=e<<23;for(let e=33;e<63;e++)n[e]=2147483648+(e-32<<23);return n}function rW(){const n=new Uint32Array(64);for(let e=0;e<64;e++)n[e]=1024;return n[0]=n[32]=0,n}function aW(){const n=sW(),e=iW(),t=rW();return s=>{const i=new ArrayBuffer(4*s.length),r=new Uint32Array(i);for(let a=0;a<s.length;a++){const o=s[a],l=n[t[o>>10]+(o&1023)]+e[o>>10];r[a]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class rn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return rn.instance==null&&(rn.instance=new rn),rn.instance}static registerSaveRouter(e){rn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){rn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return rn.getHandlers(e,"save")}static getLoadHandlers(e,t){return rn.getHandlers(e,"load",t)}static getHandlers(e,t,s){const i=[];return(t==="load"?rn.getInstance().loadRouters:rn.getInstance().saveRouters).forEach(r=>{const a=r(e,s);a!==null&&i.push(a)}),i}}const oW=n=>rn.registerSaveRouter(n),lW=n=>rn.registerLoadRouter(n),IC=n=>rn.getSaveHandlers(n),MC=(n,e)=>rn.getLoadHandlers(n,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nx="tensorflowjs",sx=1,wo="models_store",ba="model_info_store";function CC(){if(!ee().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function ix(n){const e=n.result;e.createObjectStore(wo,{keyPath:"modelPath"}),e.createObjectStore(ba,{keyPath:"modelPath"})}class Lo{constructor(e){if(this.indexedDB=CC(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((s,i)=>{const r=this.indexedDB.open(nx,sx);r.onupgradeneeded=()=>ix(r),r.onsuccess=()=>{const a=r.result;if(t==null){const o=a.transaction(wo,"readonly"),l=o.objectStore(wo).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));s(l.result.modelArtifacts)},l.onerror=c=>(a.close(),i(l.error)),o.oncomplete=()=>a.close()}else{const o=Hd(t),l=a.transaction(ba,"readwrite");let c=l.objectStore(ba);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:o});let h;u.onsuccess=()=>{h=a.transaction(wo,"readwrite");const d=h.objectStore(wo).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o});d.onsuccess=()=>s({modelArtifactsInfo:o}),d.onerror=p=>{c=l.objectStore(ba);const f=c.delete(this.modelPath);f.onsuccess=()=>(a.close(),i(d.error)),f.onerror=y=>(a.close(),i(d.error))}},u.onerror=d=>(a.close(),i(u.error)),l.oncomplete=()=>{h==null?a.close():h.oncomplete=()=>a.close()}}},r.onerror=a=>i(r.error)})}}Lo.URL_SCHEME="indexeddb://";const EC=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Lo.URL_SCHEME)?cW(n.slice(Lo.URL_SCHEME.length)):null;rn.registerSaveRouter(EC);rn.registerLoadRouter(EC);function cW(n){return new Lo(n)}function uW(n){return n.startsWith(Lo.URL_SCHEME)?n.slice(Lo.URL_SCHEME.length):n}class hW{constructor(){this.indexedDB=CC()}async listModels(){return new Promise((e,t)=>{const s=this.indexedDB.open(nx,sx);s.onupgradeneeded=()=>ix(s),s.onsuccess=()=>{const i=s.result,r=i.transaction(ba,"readonly"),a=r.objectStore(ba).getAll();a.onsuccess=()=>{const o={};for(const l of a.result)o[l.modelPath]=l.modelArtifactsInfo;e(o)},a.onerror=o=>(i.close(),t(a.error)),r.oncomplete=()=>i.close()},s.onerror=i=>t(s.error)})}async removeModel(e){return e=uW(e),new Promise((t,s)=>{const i=this.indexedDB.open(nx,sx);i.onupgradeneeded=()=>ix(i),i.onsuccess=()=>{const r=i.result,a=r.transaction(ba,"readwrite"),o=a.objectStore(ba),l=o.get(e);let c;l.onsuccess=()=>{if(l.result==null)return r.close(),s(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=o.delete(e),h=()=>{c=r.transaction(wo,"readwrite");const d=c.objectStore(wo).delete(e);d.onsuccess=()=>t(l.result.modelArtifactsInfo),d.onerror=p=>s(l.error)};u.onsuccess=h,u.onerror=d=>(h(),r.close(),s(l.error))}},l.onerror=u=>(r.close(),s(l.error)),a.oncomplete=()=>{c==null?r.close():c.oncomplete=()=>r.close()}},i.onerror=r=>s(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pr="/",Ll="tensorflowjs_models",kC="info",dW="model_topology",pW="weight_specs",fW="weight_data",mW="model_metadata";function NC(n){return{info:[Ll,n,kC].join(Pr),topology:[Ll,n,dW].join(Pr),weightSpecs:[Ll,n,pW].join(Pr),weightData:[Ll,n,fW].join(Pr),modelMetadata:[Ll,n,mW].join(Pr)}}function RC(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function gW(n){const e=n.split(Pr);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(Pr)}function yW(n){return n.startsWith(Po.URL_SCHEME)?n.slice(Po.URL_SCHEME.length):n}class Po{constructor(e){if(!ee().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=NC(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),s=JSON.stringify(e.weightSpecs),i=Hd(e);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,s),this.LS.setItem(this.keys.weightData,tW(e.weightData));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:i}}catch{throw RC(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},s=JSON.parse(this.LS.getItem(this.keys.topology));if(s==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=s;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const r=this.LS.getItem(this.keys.modelMetadata);if(r!=null){const o=JSON.parse(r);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=nW(a),t}}Po.URL_SCHEME="localstorage://";const AC=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Po.URL_SCHEME)?bW(n.slice(Po.URL_SCHEME.length)):null;rn.registerSaveRouter(AC);rn.registerLoadRouter(AC);function bW(n){return new Po(n)}class xW{constructor(){E(ee().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),E(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Ll+Pr,s=Pr+kC;for(let i=0;i<this.LS.length;++i){const r=this.LS.key(i);if(r.startsWith(t)&&r.endsWith(s)){const a=gW(r);e[a]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){e=yW(e);const t=NC(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const s=JSON.parse(this.LS.getItem(t.info));return RC(t),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ul="://";class ls{constructor(){this.managers={}}static getInstance(){return ls.instance==null&&(ls.instance=new ls),ls.instance}static registerManager(e,t){E(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Ul)&&(e=e.slice(0,e.indexOf(Ul))),E(e.length>0,()=>"scheme must not be an empty string.");const s=ls.getInstance();E(s.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),s.managers[e]=t}static getManager(e){const t=ls.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ls.getInstance().managers)}}function Lf(n){if(n.indexOf(Ul)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${ls.getSchemes().join(",")}`);return{scheme:n.split(Ul)[0],path:n.split(Ul)[1]}}async function LC(n,e,t=!1){E(n!==e,()=>`Old path and new path are the same: '${n}'`);const s=rn.getLoadHandlers(n);E(s.length>0,()=>`Copying failed because no load handler is found for source URL ${n}.`),E(s.length<2,()=>`Copying failed because more than one (${s.length}) load handlers for source URL ${n}.`);const i=s[0],r=rn.getSaveHandlers(e);E(r.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),E(r.length<2,()=>`Copying failed because more than one (${s.length}) save handlers for destination URL ${e}.`);const a=r[0],o=Lf(n).scheme,l=Lf(n).path,c=o===Lf(n).scheme,u=await i.load();t&&c&&await ls.getManager(o).removeModel(l);const h=await a.save(u);return t&&!c&&await ls.getManager(o).removeModel(l),h.modelArtifactsInfo}async function vW(){const n=ls.getSchemes(),e={};for(const t of n){const s=await ls.getManager(t).listModels();for(const i in s){const r=t+Ul+i;e[r]=s[i]}}return e}async function wW(n){const e=Lf(n);return ls.getManager(e.scheme).removeModel(e.path)}async function SW(n,e){return LC(n,e,!1)}async function TW(n,e){return LC(n,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _W{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ee().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",s=>{if(s.source===window&&s.data.name===this.messageName){s.stopPropagation();const i=this.functionRefs[s.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}}if(ee().get("IS_BROWSER")){ee().setPlatform("browser",new _W);try{ls.registerManager(Po.URL_SCHEME,new xW)}catch{}try{ls.registerManager(Lo.URL_SCHEME,new hW)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IW={importFetch:()=>require("node-fetch")};let Hb;class MW{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ee().global.fetch!=null?ee().global.fetch(e,t):(Hb==null&&(Hb=IW.importFetch()),Hb(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ee().get("IS_NODE")&&!ee().get("IS_BROWSER")&&ee().setPlatform("node",new MW);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ut(n,e="float32",t){return e=e||"float32",Ks(n),new En(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CW(n,e){const t=N(n,"x","cast");if(!q2(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const s={x:t},i={dtype:e};return W.runKernel(Ac,s,i)}const Se=U({cast_:CW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EW(n){const e={x:N(n,"x","clone","string_or_numeric")};return W.runKernel(Xc,e)}const ur=U({clone_:EW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T1(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */SC();const kW={buffer:ut,cast:Se,clone:ur,print:T1};$V(kW);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NW(){ee().set("PROD",!0)}function RW(){ee().set("DEBUG",!0)}function AW(){ee().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function LW(n){ee().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(n+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function PW(){W.disposeVariables()}function Ut(){return W}function Nh(){return W.memory()}function DW(n){return W.profile(n)}function j(n,e){return W.tidy(n,e)}function nt(n){$r(n).forEach(e=>e.dispose())}function hn(n){return W.keep(n)}function FW(n){return W.time(n)}function OW(n){return W.setBackend(n)}function GW(){return W.ready()}function zW(){return W.backendName}function VW(n){W.removeBackend(n)}function WW(n){return W.findBackend(n)}function UW(n){return W.findBackendFactory(n)}function _1(n,e,t=1){return W.registerBackend(n,e,t)}function Gr(){return W.backend}function BW(n,e){ee().setPlatform(n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $W(n,e){let t=N(n,"a","add"),s=N(e,"b","add");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(Jo,i)}const de=U({add_:$W});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XW(n,e){let t=N(n,"a","floorDiv"),s=N(e,"b","floorDiv");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(Bc,i)}const Ug=U({floorDiv_:XW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HW(n,e){let t=N(n,"a","div"),s=N(e,"b","div");if([t,s]=cn(t,s),t.dtype==="int32"&&s.dtype==="int32")return Ug(t,s);const i={a:t,b:s},r={};return W.runKernel(Oc,i,r)}const Ue=U({div_:HW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KW(n,e){let t=N(n,"a","mul"),s=N(e,"b","mul");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(eu,i)}const X=U({mul_:KW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZW(n){const e=N(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return W.runKernel(Jh,t)}else{const t={x:e};return W.runKernel($h,t)}}const xn=U({abs_:ZW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YW(n){const e={x:N(n,"x","acos")};return W.runKernel(Ic,e)}const I1=U({acos_:YW});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jW(n){const e={x:N(n,"x","acosh")};return W.runKernel(Mc,e)}const M1=U({acosh_:jW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QW(n,e=null,t=!1){const s={x:N(n,"x","all","bool")},i={axis:e,keepDims:t};return W.runKernel(Fm,s,i)}const Bg=U({all_:QW});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JW(n,e=null,t=!1){const s={x:N(n,"x","any","bool")},i={axis:e,keepDims:t};return W.runKernel(Om,s,i)}const Rh=U({any_:JW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qW(n,e=0){const t={x:N(n,"x","argMax")},s={axis:e};return W.runKernel(Hh,t,s)}const Do=U({argMax_:qW});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(n,e=0){const t={x:N(n,"x","argMin")},s={axis:e};return W.runKernel(Kh,t,s)}const C1=U({argMin_:eU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n){const e={x:N(n,"x","asin")};return W.runKernel(Cc,e)}const E1=U({asin_:tU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n){const e={x:N(n,"x","asinh")};return W.runKernel(Ec,e)}const k1=U({asinh_:nU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sU(n){const e={x:N(n,"x","atan")};return W.runKernel(kc,e)}const N1=U({atan_:sU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(n,e){let t=N(n,"a","atan2"),s=N(e,"b","atan2");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(Rc,i)}const R1=U({atan2_:iU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rU(n){const e={x:N(n,"x","atanh")};return W.runKernel(Nc,e)}const A1=U({atanh_:rU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kd(n,e,t,s,i="NHWC",r){const a=n[3],o=[...e,a],l=ea(i);return zn(n,o,t,r,s,null,null,l)}function _i(n,e,t,s,i,r,a="channelsLast"){const[o,l]=Ah(e);let c;if(a==="channelsLast")c=[o,l,n[3],n[3]];else if(a==="channelsFirst")c=[o,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return zn(n,c,t,s,i,r,!1,a)}function qr(n,e,t,s,i,r,a="NDHWC"){const[o,l,c]=rx(e);let u,h;if(a==="NDHWC")h="channelsLast",u=[o,l,c,n[4],n[4]];else if(a==="NCDHW")h="channelsFirst",u=[o,l,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return $a(n,u,t,s,i,!1,h,r)}function zn(n,e,t,s,i,r,a=!1,o="channelsLast"){let[l,c,u,h]=[-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,h]=n;else if(o==="channelsFirst")[l,h,c,u]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,p,,f]=e,[y,m]=Ah(t),[g,b]=Ah(s),x=Bl(d,g),v=Bl(p,b),{padInfo:w,outHeight:_,outWidth:I}=lU(i,c,u,y,m,x,v,r,o),C=a?f*h:f;let S;return o==="channelsFirst"?S=[l,C,_,I]:o==="channelsLast"&&(S=[l,_,I,C]),{batchSize:l,dataFormat:o,inHeight:c,inWidth:u,inChannels:h,outHeight:_,outWidth:I,outChannels:C,padInfo:w,strideHeight:y,strideWidth:m,filterHeight:d,filterWidth:p,effectiveFilterHeight:x,effectiveFilterWidth:v,dilationHeight:g,dilationWidth:b,inShape:n,outShape:S,filterShape:e}}function $a(n,e,t,s,i,r=!1,a="channelsLast",o){let[l,c,u,h,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,h,d]=n;else if(a==="channelsFirst")[l,d,c,u,h]=n;else throw new Error(`Unknown dataFormat ${a}`);const[p,f,y,,m]=e,[g,b,x]=rx(t),[v,w,_]=rx(s),I=Bl(p,v),C=Bl(f,w),S=Bl(y,_),{padInfo:M,outDepth:A,outHeight:D,outWidth:F}=cU(i,c,u,h,g,b,x,I,C,S,o),k=r?m*d:m;let P;return a==="channelsFirst"?P=[l,k,A,D,F]:a==="channelsLast"&&(P=[l,A,D,F,k]),{batchSize:l,dataFormat:a,inDepth:c,inHeight:u,inWidth:h,inChannels:d,outDepth:A,outHeight:D,outWidth:F,outChannels:k,padInfo:M,strideDepth:g,strideHeight:b,strideWidth:x,filterDepth:p,filterHeight:f,filterWidth:y,effectiveFilterDepth:I,effectiveFilterHeight:C,effectiveFilterWidth:S,dilationDepth:v,dilationHeight:w,dilationWidth:_,inShape:n,outShape:P,filterShape:e}}function aU(n,e,t,s,i){s==null&&(s=L1(n,e,t));const r=n[0],a=n[1],o=Lh((r-e+2*s)/t+1,i),l=Lh((a-e+2*s)/t+1,i);return[o,l]}function oU(n,e,t,s,i,r){i==null&&(i=L1(n,e[0],s[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*i>=e[o]&&(a[o]=Lh((n[o]-e[o]+2*i)/s[o]+1,r));return a}function L1(n,e,t,s=1){const i=Bl(e,s);return Math.floor((n[0]*(t-1)-t+i)/2)}function Ah(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function rx(n){return typeof n=="number"?[n,n,n]:n}function Bl(n,e){return e<=1?n:n+(n-1)*(e-1)}function lU(n,e,t,s,i,r,a,o,l){let c,u,h;if(typeof n=="number"){c={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const d=aU([e,t],r,s,n,o);u=d[0],h=d[1]}else if(n==="same"){u=Math.ceil(e/s),h=Math.ceil(t/i);const d=Math.max(0,(u-1)*s+r-e),p=Math.max(0,(h-1)*i+a-t),f=Math.floor(d/2),y=d-f,m=Math.floor(p/2),g=p-m;c={top:f,bottom:y,left:m,right:g,type:"SAME"}}else if(n==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-r+1)/s),h=Math.ceil((t-a+1)/i);else if(typeof n=="object"){const d=l==="channelsLast"?n[1][0]:n[2][0],p=l==="channelsLast"?n[1][1]:n[2][1],f=l==="channelsLast"?n[2][0]:n[3][0],y=l==="channelsLast"?n[2][1]:n[3][1];c={top:d,bottom:p,left:f,right:y,type:d===0&&p===0&&f===0&&y===0?"VALID":"EXPLICIT"},u=Lh((e-r+d+p)/s+1,o),h=Lh((t-a+f+y)/i+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:c,outHeight:u,outWidth:h}}function cU(n,e,t,s,i,r,a,o,l,c,u){let h,d,p,f;if(n==="valid"&&(n=0),typeof n=="number"){h={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const y=oU([e,t,s,1],[o,l,c],1,[i,r,a],n,u);d=y[0],p=y[1],f=y[2]}else if(n==="same"){d=Math.ceil(e/i),p=Math.ceil(t/r),f=Math.ceil(s/a);const y=(d-1)*i+o-e,m=(p-1)*r+l-t,g=(f-1)*a+c-s,b=Math.floor(y/2),x=y-b,v=Math.floor(m/2),w=m-v,_=Math.floor(g/2),I=g-_;h={top:v,bottom:w,left:_,right:I,front:b,back:x,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}function Lh(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Pa(n){const[e,t,s]=Ah(n);return e===1&&t===1&&s===1}function Qn(n,e){return Pa(n)||Pa(e)}function Fo(n){return Ah(n).every(e=>e>0)}function ea(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function ms(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")E(Ao(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(s=>{s.forEach(i=>{E(Ao(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(n,e){const t={x:N(n,"x","reshape","string_or_numeric")},s={shape:e};return W.runKernel(Ad,t,s)}const K=U({reshape_:uU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hU(n,e,t,s,i){const r=N(n,"x","avgPool","float32"),a=1;E(Qn(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=r,l=!1;r.rank===3&&(l=!0,o=K(r,[1,r.shape[0],r.shape[1],r.shape[2]])),E(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),ms("avgPool",s,i);const c={x:o},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i};let h=W.runKernel(Zh,c,u);return h=Se(h,r.dtype),l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const Zd=U({avgPool_:hU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n,e,t,s,i,r="NDHWC"){const a=N(n,"x","avgPool3d","float32");let o=a,l=!1;a.rank===4&&(l=!0,o=K(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),E(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),E(r==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),E(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),ms("avgPool3d",s,i);const c={x:o},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r};let h=W.runKernel(Yh,c,u);return h=Se(h,o.dtype),l?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const P1=U({avgPool3d_:dU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pU(n,e=0){E(n.length>=1,()=>"Pass at least one tensor to concat");const t=kh(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(r=>{if(r.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${r.dtype}. `)}),t.length===1)return ur(t[0]);const s=t,i={axis:e};return W.runKernel(qh,s,i)}const fn=U({concat_:pU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n,e,t=!1,s=!1){let i=N(n,"a","matMul"),r=N(e,"b","matMul");[i,r]=cn(i,r);const a={a:i,b:r},o={transposeA:t,transposeB:s};return W.runKernel(jh,a,o)}const ft=U({matMul_:fU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mU(n){const e={x:N(n,"x","sigmoid","float32")};return W.runKernel(hu,e)}const Gi=U({sigmoid_:mU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(n,e,t){const s=N(n,"x","slice","string_or_numeric");if(s.rank===0)throw new Error("Slicing scalar is not possible");const i={x:s},r={begin:e,size:t};return W.runKernel(Od,i,r)}const Tt=U({slice_:gU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n){const e={x:N(n,"x","tanh","float32")};return W.runKernel(yu,e)}const Oo=U({tanh_:yU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n,e,t){const s=N(n,"x","batchToSpaceND"),i=e.reduce((o,l)=>o*l);E(s.rank>=1+e.length,()=>`input rank is ${s.rank} but should be > than blockShape.length ${e.length}`),E(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),E(s.shape[0]%i===0,()=>`input tensor batch is ${s.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const r={x:s},a={blockShape:e,crops:t};return W.runKernel(Qh,r,a)}const Yd=U({batchToSpaceND_:bU});function xU(n){let e;return n.rank===0||n.rank===1?e=K(n,[1,1,1,n.size]):n.rank===2?e=K(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=K(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,e,t,s,i,r){r==null&&(r=.001);const a=N(n,"x","batchNorm"),o=N(e,"mean","batchNorm"),l=N(t,"variance","batchNorm");let c;i!=null&&(c=N(i,"scale","batchNorm"));let u;s!=null&&(u=N(s,"offset","batchNorm")),E(o.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(c==null||o.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const h={x:xU(a),scale:c,offset:u,mean:o,variance:l},d={varianceEpsilon:r},p=W.runKernel(ld,h,d);return K(p,a.shape)}const vu=U({batchNorm_:vU});function wU(n,e,t,s,i,r){const a=N(n,"x","batchNorm"),o=N(e,"mean","batchNorm"),l=N(t,"variance","batchNorm");let c;i!=null&&(c=N(i,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),E(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),E(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),E(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&E(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&E(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),vu(a,o,l,u,c,r)}const D1=U({batchNorm2d_:wU});function SU(n,e,t,s,i,r){const a=N(n,"x","batchNorm"),o=N(e,"mean","batchNorm"),l=N(t,"variance","batchNorm");let c;i!=null&&(c=N(i,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),E(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),E(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),E(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&E(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&E(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),vu(a,o,l,u,c,r)}const F1=U({batchNorm3d_:SU});function TU(n,e,t,s,i,r){const a=N(n,"x","batchNorm"),o=N(e,"mean","batchNorm"),l=N(t,"variance","batchNorm");let c;i!=null&&(c=N(i,"scale","batchNorm"));let u;return s!=null&&(u=N(s,"offset","batchNorm")),E(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),E(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),E(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&E(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&E(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),vu(a,o,l,u,c,r)}const O1=U({batchNorm4d_:TU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(n,e,t){const s=N(n,"x","bincount"),i=N(e,"weights","bincount");E(s.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${s.dtype}`),E(t>=0,()=>`size must be non-negative, but got ${t}.`),E(i.size===s.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${s.shape}, weights shape: ${i.shape}.`);const r={x:s,weights:i},a={size:t};return W.runKernel(Vm,r,a)}const G1=U({bincount_:_U});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n,e){let t=N(n,"broadcastTo","x");const s=t.shape;if(Ks(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=K(t,l)}const i=t.shape,r=Array.from(e);for(let l=e.length-1;l>=0;l--)if(i[l]===e[l])r[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${s}] cannot be broadcast to [${e}].`);if(r.map((l,c)=>l>1?c:-1).filter(l=>l>=0).length===0)return ur(t);const a={x:t},o={reps:r};return W.runKernel(bu,a,o)}const Mo=U({broadcastTo_:IU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n){const e={x:N(n,"x","ceil","float32")};return W.runKernel(Lc,e)}const z1=U({ceil_:MU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function el(n,e,t){Ks(n);const s={shape:n,value:e,dtype:t};return W.runKernel(ng,{},s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CU(n,e,t){const s=N(n,"x","clipByValue");if(E(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return el(s.shape,e,s.dtype);const i={x:s},r={clipValueMin:e,clipValueMax:t};return W.runKernel(Pc,i,r)}const ks=U({clipByValue_:CU});function EU(n){return fn(n,0)}const V1=U({concat1d_:EU});function kU(n,e){return fn(n,e)}const W1=U({concat2d_:kU});function NU(n,e){return fn(n,e)}const U1=U({concat3d_:NU});function RU(n,e){return fn(n,e)}const B1=U({concat4d_:RU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(n,e,t,s,i="NHWC",r=[1,1],a){const o=N(n,"x","conv2d","float32"),l=N(e,"filter","conv2d","float32");let c=o,u=!1;o.rank===3&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),E(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),E(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),ms("conv2d",s,a);const h=i==="NHWC"?c.shape[3]:c.shape[1];E(h===l.shape[2],()=>`Error in conv2d: depth of input (${h}) must match input depth for filter ${l.shape[2]}.`),E(Qn(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),E(Fo(r),()=>"Error in conv2D: Dilated rates should be larger than 0."),E(Fo(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},f=W.runKernel(ed,d,p);return u?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Hr=U({conv2d_:AU});function LU(n,e,t,s,i="NWC",r=1,a){const o=N(n,"x","conv1d"),l=N(e,"filter","conv1d");let c=o,u=!1;o.rank===2&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1]])),E(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),E(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),ms("conv1d",s,a),E(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),E(Qn(t,r),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${r}'`),E(Fo(r),()=>"Error in conv1D: Dilated rates should be larger than 0."),E(Fo(t),()=>"Error in conv1D: Stride should be larger than 0."),E(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const h=K(l,[1,l.shape[0],l.shape[1],l.shape[2]]),d=K(c,[c.shape[0],1,c.shape[1],c.shape[2]]),p=Hr(d,h,[1,t],s,"NHWC",[1,r],a);return u?K(p,[p.shape[2],p.shape[3]]):K(p,[p.shape[0],p.shape[2],p.shape[3]])}const $g=U({conv1d_:LU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(n,e,t,s,i,r="NHWC",a){E(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,l=e,c=!1;e.rank===3&&(c=!0,l=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),E(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),E(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),E(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=r==="NHWC"?o[3]:o[1],h=r==="NHWC"?l.shape[3]:l.shape[1];E(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),E(h===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${h}) must match output depth for filter ${t.shape[3]}.`),ms("conv2dDerInput",i,a);const d={dy:l,filter:t},p={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,inputShape:o},f=W.runKernel(td,d,p);return c?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const $1=U({conv2DBackpropInput_:PU});function DU(n,e,t,s,i,r){const a=N(n,"x","conv2dTranspose"),o=N(e,"filter","conv2dTranspose");return $1(t,a,o,s,i,"NHWC",r)}const Xg=U({conv2dTranspose_:DU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n,e,t,s,i="NDHWC",r=[1,1,1]){const a=N(n,"x","conv3d"),o=N(e,"filter","conv3d");let l=a,c=!1;a.rank===4&&(c=!0,l=K(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),E(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),E(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),E(l.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${o.shape[3]}.`),E(Qn(t,r),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),E(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),E(Fo(r),()=>"Error in conv3D: Dilated rates should be larger than 0."),E(Fo(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:l,filter:o},h={strides:t,pad:s,dataFormat:i,dilations:r},d=W.runKernel(nd,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const X1=U({conv3d_:FU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(n,e,t,s,i){E(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let r=n,a=e,o=!1;e.rank===4&&(o=!0,a=K(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),r=[1,n[0],n[1],n[2],n[3]]);const l=r[4],c=a.shape[4];E(r.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${r.length}.`),E(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),E(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),E(l===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${t.shape[3]}.`),E(c===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${t.shape[4]}.`);const u={dy:a,filter:t},h={pad:i,strides:s,inputShape:r},d=W.runKernel(Xm,u,h);return o?K(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const PC=U({conv3DBackpropInput_:OU});function GU(n,e,t,s,i){const r=N(n,"x","conv3dTranspose"),a=N(e,"filter","conv3dTranspose");return PC(t,r,a,s,i)}const H1=U({conv3dTranspose_:GU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zU(n){const e={x:N(n,"x","cos","float32")};return W.runKernel(Dc,e)}const jd=U({cos_:zU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VU(n){const e={x:N(n,"x","cosh","float32")};return W.runKernel(Fc,e)}const Hg=U({cosh_:VU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(n,e=0,t=!1,s=!1){const i={x:N(n,"x","cumprod")},r={axis:e,exclusive:t,reverse:s};return W.runKernel(Hm,i,r)}const Ph=U({cumprod_:WU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UU(n,e=0,t=!1,s=!1){const i={x:N(n,"x","cumsum")},r={axis:e,exclusive:t,reverse:s};return W.runKernel(sd,i,r)}const Kg=U({cumsum_:UU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(n,e,t,s=!1){const i=N(n,"x","denseBincount"),r=N(e,"weights","denseBincount");E(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),E(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),E(t>=0,()=>`size must be non-negative, but got ${t}.`),E(r.size===i.size||r.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${r.shape}.`);const a={x:i,weights:r},o={size:t,binaryOutput:s};return W.runKernel(Zm,a,o)}const tm=U({denseBincount_:BU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n,e,t="NHWC"){const s=N(n,"x","depthToSpace","float32"),i=t==="NHWC"?s.shape[1]:s.shape[2],r=t==="NHWC"?s.shape[2]:s.shape[3],a=t==="NHWC"?s.shape[3]:s.shape[1];E(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),E(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${s.shape}`),E(r*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${r} and ${e} for depthToSpace with input shape
        ${s.shape}`),E(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${s.shape}`);const o={x:s},l={blockSize:e,dataFormat:t};return W.runKernel(Ym,o,l)}const K1=U({depthToSpace_:$U});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(n,e,t,s,i="NHWC",r=[1,1],a){const o=N(n,"x","depthwiseConv2d","float32"),l=N(e,"filter","depthwiseConv2d","float32");let c=o,u=!1;o.rank===3&&(u=!0,c=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),E(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),E(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const h=i==="NHWC"?c.shape[3]:c.shape[1];E(h===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${h}) must match the inChannels dimension in filter ${l.shape[2]}.`),ms("depthwiseConv2d",s,a);const d={x:c,filter:l},p={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a},f=W.runKernel(id,d,p);return u?K(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const wu=U({depthwiseConv2d_:XU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HU(n,e,t,s,i=[1,1],r="NHWC"){const a=N(n,"x","dilation2d"),o=N(e,"filter","dilation2d");E(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),E(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),E(r==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${r}`);let l=a,c=!1;a.rank===3&&(l=K(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=!0),E(l.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${l.shape[3]} vs ${o.shape[2]}`);const u={x:l,filter:o},h={strides:t,pad:s,dilations:i},d=W.runKernel(rd,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const Z1=U({dilation2d_:HU});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Go(n,e){const t=n.length,s=[];for(let i=0;i<t;i++){const r=t-1-i,a=n[r]||1;(e[e.length-1-i]||1)>1&&a===1&&s.unshift(r)}return s}function Sn(n,e){const t=[];for(let s=0;s<e.length;s++){const i=n[n.length-s-1],r=e.length-s-1,a=e[r];(i==null||i===1&&a>1)&&t.unshift(r)}return t}function st(n,e){const t=[],s=Math.max(n.length,e.length);for(let i=0;i<s;i++){let r=n[n.length-i-1];r==null&&(r=1);let a=e[e.length-i-1];if(a==null&&(a=1),r===1)t.unshift(a);else if(a===1)t.unshift(r);else if(r!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else t.unshift(r)}return t}const KU=Object.freeze(Object.defineProperty({__proto__:null,assertAndGetBroadcastShape:st,getBroadcastDims:Go,getReductionAxes:Sn},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n,e){let t=N(n,"a","equal","string_or_numeric"),s=N(e,"b","equal","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(ad,i)}const Us=U({equal_:ZU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(n,e,t){const s=N(e,"a","where"),i=N(t,"b","where"),r=N(n,"condition","where","bool"),a=st(st(r.shape,s.shape),i.shape),o=Mo(r,a),l=Mo(s,a),c=Mo(i,a),u={condition:o,t:l,e:c};return W.runKernel(Fd,u)}const rs=U({where_:YU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jU(n){const e={x:N(n,"x","zerosLike")};return W.runKernel($d,e)}const _t=U({zerosLike_:jU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QU(n,e){let t=N(n,"a","div"),s=N(e,"b","div");[t,s]=cn(t,s);const i=Ue(t,s),r=_t(i),a=Us(s,r);return rs(a,r,i)}const Y1=U({divNoNan_:QU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(n,e){const t=N(n,"t1","dot"),s=N(e,"t2","dot");E((t.rank===1||t.rank===2)&&(s.rank===1||s.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${s.rank}.`);const i=t.rank===1?t.size:t.shape[1],r=s.rank===1?s.size:s.shape[0];if(E(i===r,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${r}.`),t.rank===1&&s.rank===1){const a=K(t,[1,-1]),o=K(s,[-1,1]),l=ft(a,o);return K(l,[])}else if(t.rank===1&&s.rank===2){const a=K(t,[1,-1]),o=K(s,[s.shape[0],s.shape[1]]),l=ft(a,o);return K(l,[l.size])}else if(t.rank===2&&s.rank===1){const a=K(s,[-1,1]),o=ft(t,a);return K(o,[o.size])}else{const a=K(s,[s.shape[0],s.shape[1]]);return ft(t,a)}}const j1=U({dot_:JU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n){const e={x:N(n,"x","elu","float32")};return W.runKernel(Gc,e)}const Su=U({elu_:qU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n){let e=N(n,"x","erf");E(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Se(e,"float32"));const t={x:e};return W.runKernel(zc,t)}const Q1=U({erf_:eB});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J1(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function DC(n,e,t){const s=n.length+e.length,i=[];let r=0,a=0;for(let o=0;o<s;o++)t.indexOf(o)===-1?i.push(n[r++]):i.push(e[a++]);return i}function Vn(n,e){const t=[],s=n.length;for(let r=0;r<s;r++)e.indexOf(r)===-1&&t.push(n[r]);const i=e.map(r=>n[r]);return[t,i]}function mn(n,e){const t=e.map(s=>1);return DC(n,t,e)}function Jn(n,e,t){E(J1(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function un(n,e){if(J1(n,e))return null;const t=[];for(let s=0;s<e;++s)n.indexOf(s)===-1&&t.push(s);return n.forEach(s=>t.push(s)),t}function Xa(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function gn(n,e){const t=[];for(let s=e-n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tB(n,e=null,t=!1){const s={x:N(n,"x","max")},i={reductionIndices:e,keepDims:t};return W.runKernel(bd,s,i)}const si=U({max_:tB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n,e=null,t=!1){const s={x:N(n,"x","min")},i={axis:e,keepDims:t};return W.runKernel(Sd,s,i)}const oc=U({min_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(n,e){let t=N(n,"base","pow"),s=N(e,"exp","pow");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(tu,i)}const Kr=U({pow_:sB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ke(n,e){if((Pn(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Pn(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Ba(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n){const e={x:N(n,"x","sqrt","float32")};return W.runKernel(pu,e)}const Yn=U({sqrt_:iB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(n){const e=N(n,"x","square"),t={};return W.runKernel("Square",{x:e},t)}const zt=U({square_:rB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n,e=null,t=!1){let s=N(n,"x","sum");s.dtype==="bool"&&(s=Se(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return W.runKernel(Gd,i,r)}const ze=U({sum_:aB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n,e="euclidean",t=null,s=!1){n=N(n,"x","norm");const i=FC(n,e,t);let r=i.shape;if(s){const a=mt(t,n.shape);r=mn(i.shape,a)}return K(i,r)}function FC(n,e,t=null){if(n.rank===0)return xn(n);if(n.rank!==1&&t===null)return FC(K(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return ze(xn(n),t);if(e===1/0)return si(xn(n),t);if(e===-1/0)return oc(xn(n),t);if(e==="euclidean"||e===2)return Yn(ze(Kr(xn(n),Ke(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return si(ze(xn(n),t[0]),t[1]-1);if(e===1/0)return si(ze(xn(n),t[1]),t[0]);if(e===-1/0)return oc(ze(xn(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return Yn(ze(zt(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Tu=U({norm_:oB});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(n,e=null,t=!1){return Tu(n,"euclidean",e,t)}const q1=U({euclideanNorm_:lB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cB(n){const e={x:N(n,"x","exp")};return W.runKernel(Vc,e)}const Bs=U({exp_:cB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uB(n,e=0){const t=N(n,"x","expandDims","string_or_numeric");E(e<=t.rank,()=>"Axis must be <= rank of the tensor");const s={input:t},i={dim:e};return W.runKernel(od,s,i)}const ns=U({expandDims_:uB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n){const e={x:N(n,"x","expm1")};return W.runKernel(Wc,e)}const ev=U({expm1_:hB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(n,e){const t=N(n,"x","tile","string_or_numeric");E(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const s={x:t},i={reps:e};return W.runKernel(bu,s,i)}const ei=U({tile_:dB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n,e,t,s="float32"){e==null&&(e=n);const i=ut([n,e],s),r=n<=e?n:e;for(let o=0;o<r;++o)i.set(1,o,o);const a=K(i.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return ei(ns(a,0),[t[0],1,1]);if(t.length===2)return ei(ns(ns(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return ei(ns(ns(ns(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Zg=U({eye_:pB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n){const e={x:N(n,"x","floor","float32")};return W.runKernel(Uc,e)}const _u=U({floor_:fB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n,e,t=0,s=0){const i=N(n,"x","gather"),r=N(e,"indices","gather","int32"),a={x:i,indices:r},o={axis:t,batchDims:s};return W.runKernel(cd,a,o)}const Iu=U({gather_:mB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n,e){let t=N(n,"a","greater","string_or_numeric"),s=N(e,"b","greater","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(ud,i)}const gs=U({greater_:gB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yB(n,e){let t=N(n,"a","greaterEqual","string_or_numeric"),s=N(e,"b","greaterEqual","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel($c,i)}const ta=U({greaterEqual_:yB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(n){const e={input:N(n,"input","imag")};return W.runKernel(ag,e)}const Qd=U({imag_:bB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(n){const e={x:N(n,"x","isFinite")};return W.runKernel(Hc,e)}const tv=U({isFinite_:xB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vB(n){const e={x:N(n,"x","isInf")};return W.runKernel(Kc,e)}const nv=U({isInf_:vB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(n){const e={x:N(n,"x","isNaN")};return W.runKernel(Zc,e)}const sv=U({isNaN_:wB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SB(n,e=.2){const t={x:N(n,"x","leakyRelu")},s={alpha:e};return W.runKernel(hd,t,s)}const Jd=U({leakyRelu_:SB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(n,e){let t=N(n,"a","less","string_or_numeric"),s=N(e,"b","less","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(dd,i)}const Yg=U({less_:TB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(n,e){let t=N(n,"a","lessEqual","string_or_numeric"),s=N(e,"b","lessEqual","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(pd,i)}const Ha=U({lessEqual_:_B});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n,e=5,t=1,s=1,i=.5){const r=N(n,"x","localResponseNormalization");E(r.rank===4||r.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${r.rank}.`),E(Ao(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=r,o=!1;r.rank===3&&(o=!0,a=K(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const l={x:a},c={depthRadius:e,bias:t,alpha:s,beta:i},u=W.runKernel(yd,l,c);return o?K(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const iv=U({localResponseNormalization_:IB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n){const e={x:N(n,"x","log","float32")};return W.runKernel(Yc,e)}const $s=U({log_:MB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CB(n){const e={x:N(n,"x","log1p")};return W.runKernel(jc,e)}const qd=U({log1p_:CB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n){return E(La(n),()=>"The f passed in grad(f) must be a function"),(e,t)=>{const s=N(e,"x","tf.grad","string_or_numeric"),i=t!=null?N(t,"dy","tf.grad"):null;return W.tidy(()=>{const{value:r,grads:a}=W.gradients(()=>n(s),[s],i);return i!=null&&jn(r.shape,i.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),jg(a),a[0]})}}function kB(n){return E(La(n),()=>"The f passed in grads(f) must be a function"),(e,t)=>{E(Array.isArray(e),()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s");const s=kh(e,"args","tf.grads","string_or_numeric"),i=t!=null?N(t,"dy","tf.grads"):null;return W.tidy(()=>{const{value:r,grads:a}=W.gradients(()=>n(...s),s,i);return i!=null&&jn(r.shape,i.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),jg(a),a})}}function NB(n){return E(La(n),()=>"The f passed in valueAndGrad(f) must be a function"),(e,t)=>{E(e instanceof Et,()=>"The x passed in valueAndGrad(f)(x) must be a tensor"),E(t==null||t instanceof Et,()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor");const{grads:s,value:i}=W.gradients(()=>n(e),[e],t);return jg(s),{grad:s[0],value:i}}}function RB(n){return E(La(n),()=>"The f passed in valueAndGrads(f) must be a function"),(e,t)=>{E(Array.isArray(e)&&e.every(i=>i instanceof Et),()=>"The args passed in valueAndGrads(f)(args) must be array of tensors"),E(t==null||t instanceof Et,()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor");const s=W.gradients(()=>n(...e),e,t);return t!=null&&jn(s.value.shape,t.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),jg(s.grads),s}}function OC(n,e){E(La(n),()=>"The f passed in variableGrads(f) must be a function"),E(e==null||Array.isArray(e)&&e.every(c=>c instanceof Eh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const c in W.registeredVariables)e.push(W.registeredVariables[c])}const s=t?e.filter(c=>!c.trainable):null,i=e.length;e=e.filter(c=>c.trainable),E(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const r=!0,{value:a,grads:o}=W.gradients(n,e,null,r);E(o.some(c=>c!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),E(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const l={};return e.forEach((c,u)=>{o[u]!=null&&(l[c.name]=o[u])}),s!=null&&s.forEach(c=>l[c.name]=null),{value:a,grads:l}}function mr(n){return W.customGrad(n)}function jg(n){if(n.filter(e=>e==null).length>0)throw new Error(`Cannot compute gradient of y=f(x) with respect to x. Make sure that
    the f you passed encloses all operations that lead from x to y.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AB(n){const e={x:N(n,"x","neg")};return W.runKernel(_d,e)}const Jt=U({neg_:AB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LB(n){const e={x:N(n,"x","softplus")};return W.runKernel(du,e)}const tl=U({softplus_:LB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(n){const e=N(n,"x","logSigmoid");return mr(t=>({value:Jt(tl(Jt(t))),gradFunc:s=>X(s,Gi(Jt(t)))}))(e)}const rv=U({logSigmoid_:PB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DB(n,e){let t=N(n,"a","sub"),s=N(e,"b","sub");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(mu,i)}const Fe=U({sub_:DB});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n,e=-1){const t=N(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return mr((s,i)=>{const r=si(s,e,!0),a=Fe(s,r),o=Fe(Se(a,"float32"),$s(ze(Bs(a),e,!0)));return i([o]),{value:o,gradFunc:(l,c)=>{const[u]=c,h=!0,d=Bs(u);return Fe(l,X(ze(l,e,h),d))}}})(t)}const Qg=U({logSoftmax_:FB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n,e=null,t=!1){const s=N(n,"x","logSumExp"),i=mt(e,s.shape),r=si(s,i,!0),a=Fe(s,r),o=Bs(a),l=ze(o,i),c=$s(l),u=de(K(r,c.shape),c);if(t){const h=mn(u.shape,i);return K(u,h)}return u}const Jg=U({logSumExp_:OB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n,e){const t=N(n,"a","logicalAnd","bool"),s=N(e,"b","logicalAnd","bool");st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(fd,i)}const Ti=U({logicalAnd_:GB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zB(n){const e={x:N(n,"x","logicalNot","bool")};return W.runKernel(md,e)}const ep=U({logicalNot_:zB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(n,e){const t=N(n,"a","logicalOr","bool"),s=N(e,"b","logicalOr","bool");st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(gd,i)}const qg=U({logicalOr_:VB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n,e){const t=N(n,"a","logicalXor","bool"),s=N(e,"b","logicalXor","bool");return st(t.shape,s.shape),Ti(qg(n,e),ep(Ti(n,e)))}const av=U({logicalXor_:WB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(n,e,t,s,i){const r=N(n,"x","maxPool"),a=1;let o=r,l=!1;r.rank===3&&(l=!0,o=K(r,[1,r.shape[0],r.shape[1],r.shape[2]])),E(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),E(Qn(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),ms("maxPool",s,i);const c={x:o},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i},h=W.runKernel(xd,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const tp=U({maxPool_:UB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n,e=[1,1,1],t,s,i,r="NDHWC"){const a=N(n,"x","maxPool3d");let o=a,l=!1;a.rank===4&&(l=!0,o=K(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),E(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),E(r==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${r}`),ms("maxPool3d",s,i);const c={x:o},u={filterSize:e,strides:t,pad:s,dimRoundingMode:i,dataFormat:r},h=W.runKernel(vd,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const ov=U({maxPool3d_:BB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $B(n,e){let t=N(n,"a","maximum"),s=N(e,"b","maximum");[t,s]=cn(t,s),t.dtype==="bool"&&(t=Se(t,"int32"),s=Se(s,"int32")),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(Qc,i)}const vr=U({maximum_:$B});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n,e=null,t=!1){const s={x:N(n,"x","mean")},i={axis:e,keepDims:t};return W.runKernel(wd,s,i)}const on=U({mean_:XB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vn(n,e="float32"){if(Ks(n),e==="complex64"){const s=vn(n,"float32"),i=vn(n,"float32");return Xr(s,i)}const t=Zn(re(n),e);return W.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vs(n,e="float32"){if(Ks(n),e==="complex64"){const s=Vs(n,"float32"),i=vn(n,"float32");return Xr(s,i)}const t=Dm(re(n),e);return W.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(n,e){let t=N(n,"a","minimum"),s=N(e,"b","minimum");[t,s]=cn(t,s),t.dtype==="bool"&&(t=Se(t,"int32"),s=Se(s,"int32")),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(Jc,i)}const Mu=U({minimum_:HB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB(n,e,t){E(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const s=N(n,"x","mirrorPad");if(s.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");E(e.length===s.rank,()=>`Padding doesn't match input. Must be ${s.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let o=0;o<s.rank;o++)E(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),E(e[o][0]>=0&&e[o][0]<=s.shape[o]-i&&e[o][1]>=0&&e[o][1]<=s.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${s.shape[o]-i} or less than 0 for input of shape ${s.shape}`);const r={paddings:e,mode:t},a={x:s};return W.runKernel(Td,a,r)}const lv=U({mirrorPad_:KB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZB(n,e){let t=N(n,"a","mod"),s=N(e,"b","mod");[t,s]=cn(t,s);const i={a:t,b:s};return W.runKernel(qc,i)}const cv=U({mod_:ZB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(n,e=null,t=!1){n=N(n,"x","moments");const s=mt(e,n.shape),i=on(n,s,t);let r=i.shape;t||(r=mn(i.shape,s));const a=zt(Fe(Se(n,"float32"),K(i,r))),o=on(a,s,t);return{mean:i,variance:o}}const np=U({moments_:YB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jB(n,e){let t=N(n,"a","notEqual","string_or_numeric"),s=N(e,"b","notEqual","string_or_numeric");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s};return W.runKernel(Id,i)}const zo=U({notEqual_:jB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(n,e,t=1,s=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const r={indices:N(n,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:t,offValue:s};return W.runKernel(Cd,r,a)}const lc=U({oneHot_:QB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JB(n){const e={x:N(n,"x","onesLike")};return W.runKernel(Md,e)}const Xs=U({onesLike_:JB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qB(n,e,t=0){const s=N(n,"x","pad");if(s.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},r={x:s};return W.runKernel(kd,r,i)}const na=U({pad_:qB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e$(n,e,t){const s=N(n,"x","spaceToBatchND");E(s.rank>=1+e.length,()=>`input rank ${s.rank} should be > than [blockShape] ${e.length}`),E(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),E(s.shape.reduce((a,o,l)=>l>0&&l<=e.length?a&&(o+t[l-1][0]+t[l-1][1])%e[l-1]===0:a,!0),()=>`input spatial dimensions ${s.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:s},r={blockShape:e,paddings:t};return W.runKernel(zd,i,r)}const sp=U({spaceToBatchND_:e$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n,e,t,s,i,r,a){i==null&&(i=[1,1]),r==null&&(r=1),s===0&&(s="valid");const o=N(n,"x","maxPool");let l=o,c=!1;o.rank===3&&(c=!0,l=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),E(Qn(r,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${r} and dilations '${i}'`);const u=_i(l.shape,e,r,i,s),h=[u.dilationHeight,u.dilationWidth];let d;s==="same"?d=s$([u.filterHeight,u.filterWidth],h):d=[[0,0],[0,0]];const p=h[0]===1&&h[1]===1,[f,y]=n$([u.inHeight,u.inWidth],h,d),m=p?s:"valid",g=p?l:sp(l,h,f),b=(t==="avg"?()=>Zd(g,e,r,m,a):()=>tp(g,e,r,m,a))(),x=p?b:Yd(b,h,y);return c?K(x,[x.shape[1],x.shape[2],x.shape[3]]):x}function n$(n,e,t){const s=t.map(u=>u[0]),i=t.map(u=>u[1]),r=n.concat(s,i),a=e.map((u,h)=>(u-r[h]%u)%u),o=i.map((u,h)=>u+a[h]),l=e.map((u,h)=>[s[h],o[h]]),c=e.map((u,h)=>[0,a[h]]);return[l,c]}function s$(n,e){const t=n.map((r,a)=>r+(r-1)*(e[a]-1)).map(r=>r-1),s=t.map(r=>Math.floor(r/2)),i=t.map((r,a)=>r-s[a]);return t.map((r,a)=>[s[a],i[a]])}const uv=U({pool_:t$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i$(n,e){const t=N(n,"x","prelu"),s=N(e,"alpha","prelu"),i={x:t,alpha:s};return W.runKernel(Nd,i)}const ip=U({prelu_:i$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n,e=null,t=!1){let s=N(n,"x","prod");s.dtype==="bool"&&(s=Se(s,"int32"));const i={x:s},r={axis:e,keepDims:t};return W.runKernel(Rd,i,r)}const hv=U({prod_:r$});var GC={exports:{}};(function(n){(function(e,t,s){function i(l){var c=this,u=o();c.next=function(){var h=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=h-(c.c=h|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function r(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function a(l,c){var u=new i(l),h=c&&c.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,h&&(typeof h=="object"&&r(h,u),d.state=function(){return r(u,{})}),d}function o(){var l=4022871197,c=function(u){u=String(u);for(var h=0;h<u.length;h++){l+=u.charCodeAt(h);var d=.02519603282416938*l;l=d>>>0,d-=l,d*=l,l=d>>>0,d-=l,l+=d*4294967296}return(l>>>0)*23283064365386963e-26};return c}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.alea=a})(Yo,n,!1)})(GC);var a$=GC.exports,zC={exports:{}};(function(n){(function(e,t,s){function i(o){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var h=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^h^h>>>8},o===(o|0)?l.x=o:c+=o;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l}function a(o,l){var c=new i(o),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.xor128=a})(Yo,n,!1)})(zC);var o$=zC.exports,VC={exports:{}};(function(n){(function(e,t,s){function i(o){var l=this,c="";l.next=function(){var h=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(h^h<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,o===(o|0)?l.x=o:c+=o;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function r(o,l){return l.x=o.x,l.y=o.y,l.z=o.z,l.w=o.w,l.v=o.v,l.d=o.d,l}function a(o,l){var c=new i(o),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.xorwow=a})(Yo,n,!1)})(VC);var l$=VC.exports,WC={exports:{}};(function(n){(function(e,t,s){function i(o){var l=this;l.next=function(){var u=l.x,h=l.i,d,p;return d=u[h],d^=d>>>7,p=d^d<<24,d=u[h+1&7],p^=d^d>>>10,d=u[h+3&7],p^=d^d>>>3,d=u[h+4&7],p^=d^d<<7,d=u[h+7&7],d=d^d<<13,p^=d^d<<9,u[h]=p,l.i=h+1&7,p};function c(u,h){var d,p=[];if(h===(h|0))p[0]=h;else for(h=""+h,d=0;d<h.length;++d)p[d&7]=p[d&7]<<15^h.charCodeAt(d)+p[d+1&7]<<13;for(;p.length<8;)p.push(0);for(d=0;d<8&&p[d]===0;++d);for(d==8?p[7]=-1:p[d],u.x=p,u.i=0,d=256;d>0;--d)u.next()}c(l,o)}function r(o,l){return l.x=o.x.slice(),l.i=o.i,l}function a(o,l){o==null&&(o=+new Date);var c=new i(o),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.x&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.xorshift7=a})(Yo,n,!1)})(WC);var c$=WC.exports,UC={exports:{}};(function(n){(function(e,t,s){function i(o){var l=this;l.next=function(){var u=l.w,h=l.X,d=l.i,p,f;return l.w=u=u+1640531527|0,f=h[d+34&127],p=h[d=d+1&127],f^=f<<13,p^=p<<17,f^=f>>>15,p^=p>>>12,f=h[d]=f^p,l.i=d,f+(u^u>>>16)|0};function c(u,h){var d,p,f,y,m,g=[],b=128;for(h===(h|0)?(p=h,h=null):(h=h+"\0",p=0,b=Math.max(b,h.length)),f=0,y=-32;y<b;++y)h&&(p^=h.charCodeAt((y+32)%h.length)),y===0&&(m=p),p^=p<<10,p^=p>>>15,p^=p<<4,p^=p>>>13,y>=0&&(m=m+1640531527|0,d=g[y&127]^=p+m,f=d==0?f+1:0);for(f>=128&&(g[(h&&h.length||0)&127]=-1),f=127,y=4*128;y>0;--y)p=g[f+34&127],d=g[f=f+1&127],p^=p<<13,d^=d<<17,p^=p>>>15,d^=d>>>12,g[f]=p^d;u.w=m,u.X=g,u.i=f}c(l,o)}function r(o,l){return l.i=o.i,l.w=o.w,l.X=o.X.slice(),l}function a(o,l){o==null&&(o=+new Date);var c=new i(o),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(u.X&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.xor4096=a})(Yo,n,!1)})(UC);var u$=UC.exports,BC={exports:{}};(function(n){(function(e,t,s){function i(o){var l=this,c="";l.next=function(){var h=l.b,d=l.c,p=l.d,f=l.a;return h=h<<25^h>>>7^d,d=d-p|0,p=p<<24^p>>>8^f,f=f-h|0,l.b=h=h<<20^h>>>12^d,l.c=d=d-p|0,l.d=p<<16^d>>>16^f,l.a=f-h|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,o===Math.floor(o)?(l.a=o/4294967296|0,l.b=o|0):c+=o;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function r(o,l){return l.a=o.a,l.b=o.b,l.c=o.c,l.d=o.d,l}function a(o,l){var c=new i(o),u=l&&l.state,h=function(){return(c.next()>>>0)/4294967296};return h.double=function(){do var d=c.next()>>>11,p=(c.next()>>>0)/4294967296,f=(d+p)/(1<<21);while(f===0);return f},h.int32=c.next,h.quick=h,u&&(typeof u=="object"&&r(u,c),h.state=function(){return r(c,{})}),h}t&&t.exports?t.exports=a:s&&s.amd?s(function(){return a}):this.tychei=a})(Yo,n,!1)})(BC);var h$=BC.exports,$C={exports:{}};const d$={},p$=Object.freeze(Object.defineProperty({__proto__:null,default:d$},Symbol.toStringTag,{value:"Module"})),f$=qz(p$);(function(n){(function(e,t,s){var i=256,r=6,a=52,o="random",l=s.pow(i,r),c=s.pow(2,a),u=c*2,h=i-1,d;function p(v,w,_){var I=[];w=w==!0?{entropy:!0}:w||{};var C=g(m(w.entropy?[v,x(t)]:v??b(),3),I),S=new f(I),M=function(){for(var A=S.g(r),D=l,F=0;A<c;)A=(A+F)*i,D*=i,F=S.g(1);for(;A>=u;)A/=2,D/=2,F>>>=1;return(A+F)/D};return M.int32=function(){return S.g(4)|0},M.quick=function(){return S.g(4)/4294967296},M.double=M,g(x(S.S),t),(w.pass||_||function(A,D,F,k){return k&&(k.S&&y(k,S),A.state=function(){return y(S,{})}),F?(s[o]=A,D):A})(M,C,"global"in w?w.global:this==s,w.state)}function f(v){var w,_=v.length,I=this,C=0,S=I.i=I.j=0,M=I.S=[];for(_||(v=[_++]);C<i;)M[C]=C++;for(C=0;C<i;C++)M[C]=M[S=h&S+v[C%_]+(w=M[C])],M[S]=w;(I.g=function(A){for(var D,F=0,k=I.i,P=I.j,O=I.S;A--;)D=O[k=h&k+1],F=F*i+O[h&(O[k]=O[P=h&P+D])+(O[P]=D)];return I.i=k,I.j=P,F})(i)}function y(v,w){return w.i=v.i,w.j=v.j,w.S=v.S.slice(),w}function m(v,w){var _=[],I=typeof v,C;if(w&&I=="object")for(C in v)try{_.push(m(v[C],w-1))}catch{}return _.length?_:I=="string"?v:v+"\0"}function g(v,w){for(var _=v+"",I,C=0;C<_.length;)w[h&C]=h&(I^=w[h&C]*19)+_.charCodeAt(C++);return x(w)}function b(){try{var v;return d&&(v=d.randomBytes)?v=v(i):(v=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(v)),x(v)}catch{var w=e.navigator,_=w&&w.plugins;return[+new Date,e,_,e.screen,x(t)]}}function x(v){return String.fromCharCode.apply(0,v)}if(g(s.random(),t),n.exports){n.exports=p;try{d=f$}catch{}}else s["seed"+o]=p})(typeof self<"u"?self:Yo,[],Math)})($C);var m$=$C.exports,g$=a$,y$=o$,b$=l$,x$=c$,v$=u$,w$=h$,nl=m$;nl.alea=g$;nl.xor128=y$;nl.xorwow=b$;nl.xorshift7=x$;nl.xor4096=v$;nl.tychei=w$;var Cu=nl;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dv{constructor(e,t,s,i,r){this.mean=e,this.stdDev=t,this.dtype=s,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=r||Math.random();this.random=Cu.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,s=!1;for(;!s;){let i,r,a;do i=2*this.random()-1,r=2*this.random()-1,a=i*i+r*r;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*i*o,t=this.mean+this.stdDev*r*o,(!this.truncated||this.isValidTruncated(e))&&(s=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class S${constructor(e,t,s,i){this.alpha=e,this.beta=1/t,this.dtype=s;const r=i||Math.random();this.randu=Cu.alea(r.toString()),this.randn=new dv(0,1,s,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,s,i,r,a;for(;;){do i=this.randn.nextValue(),a=1+this.c*i;while(a<=0);if(a*=a*a,e=i*i,t=1-.331*e*e,s=.5*e+this.d*(1-a+Math.log(a)),r=this.randu(),r<t||Math.log(r)<s)break}return a=1/this.beta*this.d*a,this.alpha<1&&(a*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(a)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class T${constructor(e=0,t=1,s,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=s,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Cu.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n,e=0,t=1,s,i){if(Ks(n),s!=null&&s==="bool")throw new Error(`Unsupported data type ${s}`);const r=new dv(e,t,s,!1,i),a=ut(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const ey=U({randomNormal_:_$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I$(n,e=0,t=1,s="float32",i){Ks(n);const r=ut(n,s),a=new T$(e,t,null,i);for(let o=0;o<r.values.length;o++)r.values[o]=a.nextValue();return r.toTensor()}const Eu=U({randomUniform_:I$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vo(n,e,t=1,s="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:s};return W.runKernel(xg,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M$(n){const e={input:N(n,"input","real")};return W.runKernel(vg,e)}const cc=U({real_:M$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C$(n){const e={x:N(n,"x","reciprocal")};return W.runKernel(nu,e)}const pv=U({reciprocal_:C$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E$(n){const e={x:N(n,"x","relu")};return W.runKernel(su,e)}const Xi=U({relu_:E$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k$(n){const e={x:N(n,"x","relu6")};return W.runKernel(iu,e)}const ty=U({relu6_:k$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(n,e){const t={x:N(n,"x","reverse")},s={dims:e};return W.runKernel(Dd,t,s)}const ri=U({reverse_:N$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R$(n){const e={x:N(n,"x","round")};return W.runKernel(ru,e)}const ny=U({round_:R$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A$(n){const e={x:N(n,"x","rsqrt","float32")};return W.runKernel(au,e)}const sy=U({rsqrt_:A$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const e={x:N(n,"x","selu")};return W.runKernel(ou,e)}const iy=U({selu_:L$});function P$(n,e,t,s,i,r=[1,1],a="NHWC"){const o=N(n,"x","separableConv2d"),l=N(e,"depthwiseFilter","separableConv2d"),c=N(t,"pointwiseFilter","separableConv2d");let u=o,h=!1;if(o.rank===3&&(h=!0,u=K(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");E(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),E(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),E(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),E(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),E(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const d=l.shape[2],p=l.shape[3];E(c.shape[2]===d*p,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*p}, but got ${c.shape[2]}.`);const f=wu(u,l,s,i,a,r),y=Hr(f,c,1,"valid",a);return h?K(y,[y.shape[1],y.shape[2],y.shape[3]]):y}const ry=U({separableConv2d_:P$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n){const e={x:N(n,"x","sign")};return W.runKernel(uu,e)}const fv=U({sign_:D$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F$(n){const e={x:N(n,"x","sin","float32")};return W.runKernel(lu,e)}const ay=U({sin_:F$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O$(n){const e={x:N(n,"x","sinh")};return W.runKernel(cu,e)}const oy=U({sinh_:O$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G$(n,e,t){const s=N(n,"x","slice1d");return E(s.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${s.rank} tensor`),Tt(s,[e],[t])}const rp=U({slice1d_:G$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t){const s=N(n,"x","slice2d");return E(s.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${s.rank} tensor`),Tt(s,e,t)}const ly=U({slice2d_:z$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V$(n,e,t){const s=N(n,"x","slice3d");return E(s.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${s.rank} tensor`),Tt(s,e,t)}const ap=U({slice3d_:V$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n,e,t){const s=N(n,"x","slice4d");return E(s.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${s.rank} tensor`),Tt(s,e,t)}const uc=U({slice4d_:W$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U$(n,e=-1){const t=N(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const s={logits:t},i={dim:e};return W.runKernel(Wd,s,i)}const op=U({softmax_:U$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B$(n){E(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(tg,e)}const lp=U({fft_:B$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $$(n){E(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return W.runKernel(rg,e)}const hc=U({ifft_:$$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n){const e=n.shape[n.shape.length-1],t=n.size/e;let s;if(e<=2){const i=K(n,[t,e]);s=hc(i)}else{const i=[t,2*(e-1)],r=K(cc(n),[t,e]),a=K(Qd(n),[t,e]),o=ri(Tt(r,[0,1],[t,e-2]),1),l=X(ri(Tt(a,[0,1],[t,e-2]),1),Ke(-1)),c=fn([r,o],1),u=fn([a,l],1),h=K(Xr(c,u),[i[0],i[1]]);s=hc(h)}if(s=cc(s),n.rank===3&&n.shape[0]!==0){const i=s,r=n.shape[0];s=K(s,[r,s.shape[0]/r,s.shape[1]]),i.dispose()}return s}const cy=U({irfft_:X$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H$(n,e,t=0){const s={x:N(n,"x","split")},i={numOrSizeSplits:e,axis:t};return W.runKernel(Vd,s,i)}const Cs=U({split_:H$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K$(n,e){E(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const s=n.size/t;let i;if(e!=null&&e<t){const f=n.shape.map(m=>0),y=n.shape.map(m=>m);y[n.shape.length-1]=e,i=Tt(n,f,y),t=e}else if(e!=null&&e>t){const f=n.shape.map(y=>y);f[n.shape.length-1]=e-t,i=fn([n,vn(f)],n.shape.length-1),t=e}else i=n;const r=_t(i),a=K(Xr(i,r),[s,t]),o=lp(a),l=Math.floor(t/2)+1,c=cc(o),u=Qd(o),h=Cs(c,[l,t-l],c.shape.length-1),d=Cs(u,[l,t-l],u.shape.length-1),p=i.shape.slice();return p[i.shape.length-1]=l,K(Xr(h[0],d[0]),p)}const cp=U({rfft_:K$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z$(n,e){let t=N(n,"a","squaredDifference"),s=N(e,"b","squaredDifference");[t,s]=cn(t,s),st(t.shape,s.shape);const i={a:t,b:s},r={};return W.runKernel(fu,i,r)}const uy=U({squaredDifference_:Z$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e){const t=N(n,"x","squeeze","string_or_numeric");return K(t,Qr(t.shape,e).newShape)}const Ka=U({squeeze_:Y$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e=0){const t=kh(n,"tensors","stack","string_or_numeric");E(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&E(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const s=t,i={axis:e};return W.runKernel(Ed,s,i)}const ps=U({stack_:j$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q$(n,e=0){const t={x:N(n,"x","step")},s={alpha:e};return W.runKernel(xu,t,s)}const sl=U({step_:Q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n,e,t,s,i=0,r=0,a=0,o=0,l=0){const c={x:N(n,"x","stridedSlice","string_or_numeric")},u={begin:e,end:t,strides:s,beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};return W.runKernel(Rg,c,u)}const mv=U({stridedSlice_:J$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q$(n){const e={x:N(n,"x","tan","float32")};return W.runKernel(gu,e)}const gv=U({tan_:q$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ss(n,e){jo(n);const t=fr(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Ba(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ca(n,e,t){if(jo(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const s=fr(n,t);if(s.length!==2&&s.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Ba(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yv(n,e,t){if(jo(n),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const s=fr(n,t);if(s.length!==3&&s.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Ba(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(n,e=1,t=!0){const s=N(n,"x","topk");if(s.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=s.shape[s.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const r={x:s},a={k:e,sorted:t},[o,l]=W.runKernel(Dg,r,a);return{values:o,indices:l}}const bv=U({topk_:eX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tX(n,e=0,t=1,s,i){if(Ks(n),s!=null&&s==="bool")throw new Error("Unsupported data type $ { dtype }");const r=new dv(e,t,s,!0,i),a=ut(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const hy=U({truncatedNormal_:tX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(n,e=0){const t=N(n,"x","unique","string_or_numeric");E(t.rank>0,()=>"The input tensor must be at least 1D");const s={x:t},i={axis:e},[r,a]=W.runKernel(Og,s,i);return{values:r,indices:a}}const xv=U({unique_:nX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sX(n,e,t){const s=N(n,"x","unsortedSegmentSum"),i=N(e,"segmentIds","unsortedSegmentSum","int32");E(Ao(t),()=>"numSegments must be of dtype int");const r={x:s,segmentIds:i},a={numSegments:t};return W.runKernel(Bd,r,a)}const dy=U({unsortedSegmentSum_:sX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(n,e=0){const t=N(n,"x","unstack","string_or_numeric");E(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const s={value:t},i={axis:e};return W.runKernel(Ud,s,i)}const ai=U({unstack_:iX});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vv(n,e=!0,t,s){return W.makeVariable(n,e,t,s)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function py(n,e){const t=[];for(let r=0;r<e.length;r++)e[r]&&t.push(r);const s=ut(n,"int32"),i=ut([t.length,n.length],"int32");for(let r=0;r<t.length;r++){const a=s.indexToLoc(t[r]),o=r*n.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rX(n,e,t){const s=N(n,"x","transpose");if(e==null&&(e=s.shape.map((a,o)=>o).reverse()),E(s.rank===e.length,()=>`Error in transpose: rank of input ${s.rank} must match length of perm ${e}.`),e.forEach(a=>{E(a>=0&&a<s.rank,()=>`All entries in 'perm' must be between 0 and ${s.rank-1} but got ${e}`)}),s.rank<=1)return s.clone();const i={x:s},r={perm:e};return s.dtype==="complex64"?j(()=>{let a=cc(s),o=Qd(s);return a=W.runKernel(Io,{x:a},r),o=W.runKernel(Io,{x:o},r),t&&(o=Jt(o)),Xr(a,o)}):W.runKernel(Io,i,r)}const xt=U({transpose_:rX});function wv(n,e,t){const s=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,r=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${s}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(r+` update.rank < ${i}. `);if(n.length<s+(t.rank-i))throw new Error(r+` Output shape length < ${s+(t.rank-i)}`);if(t.rank!==i+n.length-s)throw new Error(r+` update.rank != ${i+n.length-s}`);for(let a=0;a<i;++a)if(t.shape[a]!==e.shape[a])throw new Error(r+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-i;++a)if(t.shape[a+i]!==n[a+s])throw new Error(r+` updates.shape[${a+i}] (${t.shape[a+i]}) != shape[${a+i}] (${n[a+i]})`)}function Sv(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}wv(t,e,n)}function ku(n,e,t){const s=e.shape.length,i=s>1?e.shape[s-1]:1,r=t.length;let a=1;for(let h=i;h<r;++h)a*=t[h];const o=i<1?1:i,l=re(e.shape)/o,c=[...He(t.slice(0,i)),1],u=re(t);return{sliceRank:i,numUpdates:l,sliceSize:a,strides:c,outputSize:u}}const aX=Object.freeze(Object.defineProperty({__proto__:null,calculateShapes:ku,validateInput:Sv,validateUpdateShape:wv},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oX(n,e){if(e==null)return n.shape.slice();if(St(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let s=0;s<n.shape.length;s++)e[s]==null&&n.shape[s]!=null?t.push(n.shape[s]):t.push(e[s]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lX(n,e,t,s){const i=N(n,"x","dropout");if(E(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),E(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Et?i.clone():i;const r=oX(i,t),a=1-e,o=Ue(_u(de(Eu(r,0,1,"float32",s),a)),a);return X(i,o)}const Tv=U({dropout_:lX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _v(n){return Math.floor(Math.pow(2,Math.ceil(Math.log(n)/Math.log(2))))}function fy(n,e,t){const s=1-n%2,i=new Float32Array(n);for(let r=0;r<n;++r){const a=2*Math.PI*r/(n+s-1);i[r]=e-t*Math.cos(a)}return ss(i,"float32")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cX(n,e,t,s,i,r="NHWC",a){let o=n;n.rank===3&&(o=K(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=K(e,[1,e.shape[0],e.shape[1],e.shape[2]])),E(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),E(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),E(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const c=r==="NHWC"?o.shape[3]:o.shape[1],u=r==="NHWC"?l.shape[3]:l.shape[1];E(c===t[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${t[2]}.`),E(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),ms("conv2dDerFilter",i,a);const h={x:o,dy:l},d={strides:s,pad:i,dataFormat:r,dimRoundingMode:a,filterShape:t};return W.runKernel(Bm,h,d)}const Iv=U({conv2DBackpropFilter_:cX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function my(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return X(n,sl(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function gy(n,e){let t=e;const s=Sn(n.shape,e.shape);return s.length>0&&(t=ze(t,s)),K(t,n.shape)}function yy(n,e,t,s){if(e==="linear")return n;if(e==="relu")return Xi(n);if(e==="elu")return Su(n);if(e==="relu6")return ty(n);if(e==="prelu")return ip(n,t);if(e==="leakyrelu")return Jd(n,s);if(e==="sigmoid")return Gi(n);throw new Error(`Unknown fused activation ${e}.`)}const by=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",by(W.state.gradientDepth,l)===!1){E(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let _=Hr(n,e,t,s,i,r,a);return o!=null&&(_=de(_,o)),yy(_,l,c,u)}const h=N(n,"x","conv2d","float32"),d=N(e,"filter","conv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=K(h,[1,h.shape[0],h.shape[1],h.shape[2]])),E(p.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${p.rank}.`),E(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),ms("fused conv2d",s,a);const y=i==="NHWC"?p.shape[3]:p.shape[1];E(d.shape[2]===y,()=>`Error in conv2d: depth of input (${y}) must match input depth for filter ${d.shape[2]}.`),E(Qn(t,r),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`);const m=zn(p.shape,d.shape,t,r,s,a);let g;o!=null&&(g=N(o,"bias","fused conv2d"),[g]=cn(g,h),i==="NHWC"?st(m.outShape,g.shape):(E(g.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${g.shape.length}.`),E(g.shape.length===0||g.shape[0]===m.outChannels||g.shape[0]===1,()=>`Error in fused conv2d: bias shape (${g.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let b;if(c!=null){const _=c.shape;if(E(_.length<=1||_.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${_.length}.`),_.length===1)E(_[0]===1||_[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the number of output channels (${m.outChannels}).`);else if(_.length===3)try{st(_,m.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${_}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(I)}b=N(c,"prelu weights","fused conv2d")}const x=(_,I)=>{E(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[C,S,M,A]=I,D=my(_,M,l);E(Pa(r),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const F=$1(S.shape,D,C,t,s),k=Iv(S,D,C.shape,t,s),P=[F,k];if(A!=null){const O=gy(A,D);P.push(O)}return P},v={x:p,filter:d,bias:g,preluActivationWeights:b},w={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return o==null?mr((_,I,C)=>{let S=W.runKernel(Ih,v,w);return C([I,_,S]),f&&(S=K(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:x}})(p,d):mr((_,I,C,S)=>{let M=W.runKernel(Ih,v,w);return S([I,_,M,C]),f&&(M=K(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:x}})(p,d,g)}const XC=U({fusedConv2d_:uX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hX(n,e,t,s,i,r=[1,1],a){let o=n;n.rank===3&&(o=K(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let l=e;l.rank===3&&(l=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:o,dy:l},u={strides:s,pad:i,dimRoundingMode:a,dilations:r,filterShape:t};return W.runKernel(jm,c,u)}const HC=U({depthwiseConv2dNativeBackpropFilter_:hX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(n,e,t,s,i,r=[1,1],a){let o=e,l=!1;e.rank===3&&(l=!0,o=K(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:o,filter:t},u={strides:s,pad:i,dimRoundingMode:a,dilations:r,inputShape:n},h=W.runKernel(Qm,c,u);return l?K(h,[h.shape[1],h.shape[2],h.shape[3]]):h}const KC=U({depthwiseConv2dNativeBackpropInput_:dX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pX({a:n,b:e,transposeA:t=!1,transposeB:s=!1,bias:i,activation:r="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(by(W.state.gradientDepth,r)===!1){let M=ft(n,e,t,s);return i!=null&&(M=de(M,i)),yy(M,r,a,o)}let l=N(n,"a","fused matMul"),c=N(e,"b","fused matMul");[l,c]=cn(l,c);const u=t?l.shape[l.rank-2]:l.shape[l.rank-1],h=s?c.shape[c.rank-1]:c.shape[c.rank-2],d=t?l.shape[l.rank-1]:l.shape[l.rank-2],p=s?c.shape[c.rank-2]:c.shape[c.rank-1],f=l.shape.slice(0,-2),y=c.shape.slice(0,-2),m=re(f),g=re(y);E(u===h,()=>`Error in fused matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${t} and transposeB=${s} must match.`);const b=st(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([d,p]),x=t?K(l,[m,u,d]):K(l,[m,d,u]),v=s?K(c,[g,p,h]):K(c,[g,h,p]);let w;i!=null&&(w=N(i,"bias","fused matMul"),[w]=cn(w,l),st(b,w.shape));let _;a!=null&&(_=N(a,"prelu weights","fused matMul"));const I=(M,A)=>{const[D,F,k,P]=A,O=my(K(M,k.shape),k,r);let V,$;if(!t&&!s?(V=ft(O,F,!1,!0),$=ft(D,O,!0,!1)):!t&&s?(V=ft(O,F,!1,!1),$=ft(O,D,!0,!1)):t&&!s?(V=ft(F,O,!1,!0),$=ft(D,O,!1,!1)):(V=ft(F,O,!0,!0),$=ft(O,D,!0,!0)),i!=null){const H=gy(P,O);return[V,$,H]}else return[V,$]},C={a:x,b:v,bias:w,preluActivationWeights:_},S={transposeA:t,transposeB:s,activation:r,leakyreluAlpha:o};return i==null?mr((M,A,D)=>{const F=W.runKernel(_h,C,S);return D([M,A,F]),{value:K(F,b),gradFunc:I}})(x,v):mr((M,A,D,F)=>{const k=W.runKernel(_h,C,S);return F([M,A,k,D]),{value:K(k,b),gradFunc:I}})(x,v,w)}const ax=U({fusedMatMul_:pX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fX(n){return fy(n,.54,.46)}const mX=U({hammingWindow_:fX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gX(n){return fy(n,.5,.5)}const ZC=U({hannWindow_:gX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yX(n,e,t,s=!1,i=0){let r=0;const a=[];for(;r+e<=n.size;)a.push(Tt(n,r,e)),r+=t;if(s)for(;r<n.size;){const o=r+e-n.size,l=fn([Tt(n,r,e-o),el([o],i)]);a.push(l),r+=t}return a.length===0?Ca([],[0,e]):K(fn(a),[a.length,e])}const YC=U({frame_:yX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bX(n,e,t,s,i=ZC){s==null&&(s=_v(e));const r=YC(n,e,t),a=X(r,i(e));return cp(a,s)}const xX=U({stft_:bX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vX(n,e,t,s,i="bilinear",r=0){const a=N(n,"image","cropAndResize"),o=N(e,"boxes","cropAndResize","float32"),l=N(t,"boxInd","cropAndResize","int32"),c=o.shape[0];E(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),E(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${o.shape}.`),E(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${o.shape}.`),E(s.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${s.length}.`),E(s[0]>=1&&s[1]>=1,()=>`cropSize must be atleast [1,1], but was ${s}`),E(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:a,boxes:o,boxInd:l},h={method:i,extrapolationValue:r,cropSize:s};return W.runKernel(Km,u,h)}const wX=U({cropAndResize_:vX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SX(n){const e=N(n,"image","flipLeftRight","float32");E(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return W.runKernel(sg,t,{})}const TX=U({flipLeftRight_:SX});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _X(n){const e=N(n,"image","grayscaleToRGB"),t=e.rank-1,s=e.shape[t];E(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),E(s===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${s}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,ei(e,i)}const IX=U({grayscaleToRGB_:_X});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(n,e,t=0,s=.5){const i=N(n,"image","rotateWithOffset","float32");E(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const r={image:i},a={radians:e,fillValue:t,center:s};return W.runKernel(Gg,r,a)}const CX=U({rotateWithOffset_:MX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nu(n,e,t,s,i,r){s==null&&(s=.5),i==null&&(i=Number.NEGATIVE_INFINITY),r==null&&(r=0);const a=n.shape[0];return t=Math.min(t,a),E(0<=s&&s<=1,()=>`iouThreshold must be in [0, 1], but was '${s}'`),E(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),E(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),E(e.rank===1,()=>"scores must be a 1D tensor"),E(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),E(0<=r&&r<=1,()=>`softNmsSigma must be in [0, 1], but was '${r}'`),{maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=N(n,"boxes","nonMaxSuppression","float32"),a=N(e,"scores","nonMaxSuppression","float32"),o=Nu(r,a,t,s,i);t=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l={maxOutputSize:t,iouThreshold:s,scoreThreshold:i};return W.runKernel(pg,{boxes:r,scores:a},l)}const kX=U({nonMaxSuppression_:EX});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NX(n,e,t){const s=RX(n,e,t),i=s<0?-(s+1):s;n.splice(i,0,e)}function RX(n,e,t){return LX(n,e,t||AX)}function AX(n,e){return n>e?1:n<e?-1:0}function LX(n,e,t){let s=0,i=n.length,r=0,a=!1;for(;s<i;){r=s+(i-s>>>1);const o=t(e,n[r]);o>0?s=r+1:(i=r,a=!o)}return a?s:-s-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xy(n,e,t,s,i){return Mv(n,e,t,s,i,0)}function vy(n,e,t,s,i,r){return Mv(n,e,t,s,i,0,!1,r,!0)}function wy(n,e,t,s,i,r){return Mv(n,e,t,s,i,r,!0)}function Mv(n,e,t,s,i,r,a=!1,o=!1,l=!1){const c=[];for(let m=0;m<e.length;m++)e[m]>i&&c.push({score:e[m],boxIndex:m,suppressBeginIndex:0});c.sort(xI);const u=r>0?-.5/r:0,h=[],d=[];for(;h.length<t&&c.length>0;){const m=c.pop(),{score:g,boxIndex:b,suppressBeginIndex:x}=m;if(g<i)break;let v=!1;for(let w=h.length-1;w>=x;--w){const _=PX(n,b,h[w]);if(_>=s){v=!0;break}if(m.score=m.score*DX(s,u,_),m.score<=i)break}m.suppressBeginIndex=h.length,v||(m.score===g?(h.push(b),d.push(m.score)):m.score>i&&NX(c,m,xI))}const p=h.length,f=t-p;o&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const y={selectedIndices:h};return a&&(y.selectedScores=d),l&&(y.validOutputs=p),y}function PX(n,e,t){const s=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),r=Math.min(s[0],s[2]),a=Math.min(s[1],s[3]),o=Math.max(s[0],s[2]),l=Math.max(s[1],s[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),h=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),p=(o-r)*(l-a),f=(h-c)*(d-u);if(p<=0||f<=0)return 0;const y=Math.max(r,c),m=Math.max(a,u),g=Math.min(o,h),b=Math.min(l,d),x=Math.max(g-y,0)*Math.max(b-m,0);return x/(p+f-x)}function DX(n,e,t){const s=Math.exp(e*t*t);return t<=n?s:0}function xI(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function FX(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY){const r=N(n,"boxes","nonMaxSuppressionAsync"),a=N(e,"scores","nonMaxSuppressionAsync"),o=Nu(r,a,t,s,i);t=o.maxOutputSize,s=o.iouThreshold,i=o.scoreThreshold;const l=await Promise.all([r.data(),a.data()]),c=l[0],u=l[1],{selectedIndices:h}=xy(c,u,t,s,i);return r!==n&&r.dispose(),a!==e&&a.dispose(),ss(h,"int32")}const OX=FX;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GX(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=N(n,"boxes","nonMaxSuppression"),o=N(e,"scores","nonMaxSuppression"),l=Nu(a,o,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c={boxes:a,scores:o},u={maxOutputSize:t,iouThreshold:s,scoreThreshold:i,softNmsSigma:r},h=W.runKernel(mg,c,u);return{selectedIndices:h[0],selectedScores:h[1]}}const zX=U({nonMaxSuppressionWithScore_:GX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function VX(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=0){const a=N(n,"boxes","nonMaxSuppressionAsync"),o=N(e,"scores","nonMaxSuppressionAsync"),l=Nu(a,o,t,s,i,r);t=l.maxOutputSize,s=l.iouThreshold,i=l.scoreThreshold,r=l.softNmsSigma;const c=await Promise.all([a.data(),o.data()]),u=c[0],h=c[1],{selectedIndices:d,selectedScores:p}=wy(u,h,t,s,i,r);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:ss(d,"int32"),selectedScores:ss(p)}}const WX=VX;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UX(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=N(n,"boxes","nonMaxSuppression"),o=N(e,"scores","nonMaxSuppression"),l=Nu(a,o,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,d={boxes:a,scores:o},p={maxOutputSize:c,iouThreshold:u,scoreThreshold:h,padToMaxOutputSize:r},f=W.runKernel(fg,d,p);return{selectedIndices:f[0],validOutputs:f[1]}}const BX=U({nonMaxSuppressionPadded_:UX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function $X(n,e,t,s=.5,i=Number.NEGATIVE_INFINITY,r=!1){const a=N(n,"boxes","nonMaxSuppressionAsync"),o=N(e,"scores","nonMaxSuppressionAsync"),l=Nu(a,o,t,s,i,null),c=l.maxOutputSize,u=l.iouThreshold,h=l.scoreThreshold,[d,p]=await Promise.all([a.data(),o.data()]),{selectedIndices:f,validOutputs:y}=vy(d,p,c,u,h,r);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:ss(f,"int32"),validOutputs:Ke(y,"int32")}}const XX=$X;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HX(n,e,t=!1,s=!1){const i=N(n,"images","resizeBilinear");E(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),E(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),E(s===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=W.runKernel(Pd,o,l);return a?K(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const jC=U({resizeBilinear_:HX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KX(n,e,t=!1,s=!1){const i=N(n,"images","resizeNearestNeighbor");E(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),E(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),E(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),E(s===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let r=i,a=!1;i.rank===3&&(a=!0,r=K(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:r},l={alignCorners:t,halfPixelCenters:s,size:e},c=W.runKernel(Ld,o,l);return a?K(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const QC=U({resizeNearestNeighbor_:KX});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZX(n,e="binary",t=!1,s=.5){const i=N(n,"image","threshold"),r=.2989,a=.587,o=.114,l=i.shape[0]*i.shape[1];let c=X(ss([s]),255),u,h,d,p;if(E(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),E(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),E(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),E(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,h,d]=Cs(i,[1,1,1],-1);const y=X(u,r),m=X(h,a),g=X(d,o);p=de(de(y,m),g)}else p=n;if(e==="otsu"){const y=G1(Se(ny(p),"int32"),en([]),256);c=YX(y,l)}const f=t?Ha(p,c):gs(p,c);return Se(X(f,255),"int32")}function YX(n,e){let t=ss([-1]),s=ss([0]),i=ss([0]),r,a,o,l,c,u;for(let h=0;h<n.size-1;h++){r=Tt(n,0,h+1),a=Tt(n,h+1),c=Ue(ze(r),e),u=Ue(ze(a),e);const d=ze(X(r,Vo(0,r.size)));o=Ue(d,ze(r));const p=el(a.shape,r.size),f=de(Vo(0,a.size),p),y=X(a,f);l=Ue(ze(y),ze(a));const m=Fe(o,l),g=Fe(o,l),b=X(c,u);i=X(X(b,m),g);const x=gs(i,s);s=rs(x,i,s),t=rs(x,ss([h]),t)}return t}const jX=U({threshold_:ZX});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QX(n,e,t="nearest",s="constant",i=0,r){const a=N(n,"image","transform","float32"),o=N(e,"transforms","transform","float32");E(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),E(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),E(r==null||r.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${r}.`);const l={image:a,transforms:o},c={interpolation:t,fillMode:s,fillValue:i,outputShape:r};return W.runKernel(Fg,l,c)}const JX=U({transform_:QX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qX(n,e,t){E(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),E(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`);const s=N(n,"a","bandPart");E(s.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${s.rank}.`);const i=s.shape,[r,a]=s.shape.slice(-2);if(!(e<=r))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${r}).`);if(!(t<=a))throw new Error(`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`);e<0&&(e=r),t<0&&(t=a);const o=K(Vo(0,r,1,"int32"),[-1,1]),l=Vo(0,a,1,"int32"),c=Fe(o,l),u=Ti(Ha(c,Ke(+e,"int32")),ta(c,Ke(-t,"int32"))),h=vn([r,a],s.dtype);return K(ps(ai(K(s,[-1,r,a])).map(d=>rs(u,d,h))),i)}const eH=U({bandPart_:qX});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tH(n){let e;if(Array.isArray(n)){e=!1,E(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let r=1;r<n.length;++r)E(n[r].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[r].shape[0]} vs. ${i})`)}else e=!0,n=Cs(n,n.shape[0],0).map(i=>Ka(i,[0]));E(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],s=n;for(let i=0;i<n.length;++i)t.push(W.tidy(()=>{let r=s[i];if(i>0)for(let a=0;a<i;++a){const o=X(ze(X(t[a],r)),t[a]);r=Fe(r,o)}return Ue(r,Tu(r,"euclidean"))}));return e?ps(t,0):t}const nH=U({gramSchmidt_:tH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sH(n,e=!1){if(E(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return vI(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((l,c)=>l*c),s=ai(K(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],r=[];s.forEach(l=>{const[c,u]=vI(l,e);i.push(c),r.push(u)});const a=K(ps(i,0),n.shape),o=K(ps(r,0),n.shape);return[a,o]}}function vI(n,e=!1){return W.tidy(()=>{E(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],s=n.shape[1];let i=Zg(t),r=ur(n);const a=Ca([[1]],[1,1]);let o=ur(a);const l=t>=s?s:t;for(let c=0;c<l;++c){const u=r,h=o,d=i;[o,r,i]=W.tidy(()=>{const p=Tt(r,[c,c],[t-c,1]),f=Tu(p),y=Tt(r,[c,c],[1,1]),m=rs(gs(y,0),Ca([[-1]]),Ca([[1]])),g=Fe(y,X(m,f)),b=Ue(p,g);b.shape[0]===1?o=ur(a):o=fn([a,Tt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const x=Jt(Ue(ft(m,g),f)),v=Tt(r,[c,0],[t-c,s]),w=X(x,o),_=xt(o);if(c===0)r=Fe(v,ft(w,ft(_,v)));else{const S=Fe(v,ft(w,ft(_,v)));r=fn([Tt(r,[0,0],[c,s]),S],0)}const I=xt(w),C=Tt(i,[0,c],[t,i.shape[1]-c]);if(c===0)i=Fe(C,ft(ft(C,o),I));else{const S=Fe(C,ft(ft(C,o),I));i=fn([Tt(i,[0,0],[t,c]),S],1)}return[o,r,i]}),nt([u,h,d])}return!e&&t>s&&(i=Tt(i,[0,0],[t,s]),r=Tt(r,[0,0],[s,s])),[i,r]})}const iH=U({qr_:sH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var us;(function(n){n[n.NONE=0]="NONE",n[n.MEAN=1]="MEAN",n[n.SUM=2]="SUM",n[n.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(us||(us={}));function rH(n,e,t=us.SUM_BY_NONZERO_WEIGHTS){const s=N(n,"losses","computeWeightedLoss");let i=null;e!=null&&(i=N(e,"weights","computeWeightedLoss"));const r=i==null?s:X(s,i);if(t===us.NONE)return r;if(t===us.SUM)return ze(r);if(t===us.MEAN){if(i==null)return on(r);{const a=s.size/i.size,o=Ue(ze(r),ze(i));return a>1?Ue(o,Ke(a)):o}}if(t===us.SUM_BY_NONZERO_WEIGHTS){if(i==null)return Ue(ze(r),Ke(s.size));{const a=X(i,Vs(s.shape)),o=Se(ze(zo(a,Ke(0))),"float32");return Ue(ze(r),o)}}throw Error(`Unknown reduction: ${t}`)}const sa=U({computeWeightedLoss_:rH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aH(n,e,t,s=us.SUM_BY_NONZERO_WEIGHTS){const i=N(n,"labels","absoluteDifference"),r=N(e,"predictions","absoluteDifference");let a=null;t!=null&&(a=N(t,"weights","absoluteDifference")),jn(i.shape,r.shape,"Error in absoluteDifference: ");const o=xn(Fe(i,r));return sa(o,a,s)}const oH=U({absoluteDifference_:aH});function lH(n,e,t,s,i=us.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","cosineDistance"),a=N(e,"predictions","cosineDistance");let o=null;s!=null&&(o=N(s,"weights","cosineDistance")),jn(r.shape,a.shape,"Error in cosineDistance: ");const l=Ke(1),c=Fe(l,ze(X(r,a),t,!0));return sa(c,o,i)}const cH=U({cosineDistance_:lH});function uH(n,e,t,s=us.SUM_BY_NONZERO_WEIGHTS){let i=N(n,"labels","hingeLoss");const r=N(e,"predictions","hingeLoss");let a=null;t!=null&&(a=N(t,"weights","hingeLoss")),jn(i.shape,r.shape,"Error in hingeLoss: ");const o=Ke(1);i=Fe(X(Ke(2),i),o);const l=Xi(Fe(o,X(i,r)));return sa(l,a,s)}const hH=U({hingeLoss_:uH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dH(n,e,t,s=1,i=us.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","huberLoss"),a=N(e,"predictions","huberLoss");let o=null;t!=null&&(o=N(t,"weights","huberLoss")),jn(r.shape,a.shape,"Error in huberLoss: ");const l=Ke(s),c=xn(Fe(a,r)),u=Mu(c,l),h=Fe(c,u),d=de(X(Ke(.5),zt(u)),X(l,h));return sa(d,o,i)}const pH=U({huberLoss_:dH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fH(n,e,t,s=1e-7,i=us.SUM_BY_NONZERO_WEIGHTS){const r=N(n,"labels","logLoss"),a=N(e,"predictions","logLoss");let o=null;t!=null&&(o=N(t,"weights","logLoss")),jn(r.shape,a.shape,"Error in logLoss: ");const l=Ke(1),c=Ke(s),u=Jt(X(r,$s(de(a,c)))),h=X(Fe(l,r),$s(de(Fe(l,a),c))),d=Fe(u,h);return sa(d,o,i)}const mH=U({logLoss_:fH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gH(n,e,t,s=us.SUM_BY_NONZERO_WEIGHTS){const i=N(n,"labels","meanSquaredError"),r=N(e,"predictions","meanSquaredError");let a=null;t!=null&&(a=N(t,"weights","meanSquaredError")),jn(i.shape,r.shape,"Error in meanSquaredError: ");const o=uy(i,r);return sa(o,a,s)}const yH=U({meanSquaredError_:gH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bH(n,e){const t=N(n,"labels","sigmoidCrossEntropyWithLogits"),s=N(e,"logits","sigmoidCrossEntropyWithLogits");jn(t.shape,s.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=Xi(s),r=X(s,t),a=qd(Bs(Jt(xn(s))));return de(Fe(i,r),a)}function xH(n,e,t,s=0,i=us.SUM_BY_NONZERO_WEIGHTS){let r=N(n,"multiClassLabels","sigmoidCrossEntropy");const a=N(e,"logits","sigmoidCrossEntropy");let o=null;if(t!=null&&(o=N(t,"weights","sigmoidCrossEntropy")),jn(r.shape,a.shape,"Error in sigmoidCrossEntropy: "),s>0){const c=Ke(s),u=Ke(1),h=Ke(.5);r=de(X(r,Fe(u,c)),X(h,c))}const l=bH(r,a);return sa(l,o,i)}const vH=U({sigmoidCrossEntropy_:xH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wH(n,e,t=-1){if(t===-1&&(t=e.rank-1),t!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${t}`);return mr((s,i,r)=>{const a=Jg(i,[t],!0),o=Fe(Se(i,"float32"),a);r([s,o]);const l=Jt(X(o,s));return{value:ze(l,[t]),gradFunc:(c,u)=>{const[h,d]=u,p=mn(c.shape,[t]);return[X(K(c,p),Fe(Se(h,"float32"),Bs(d))),X(K(c,p),Fe(Bs(d),Se(h,"float32")))]}}})(n,e)}function SH(n,e,t,s=0,i=us.SUM_BY_NONZERO_WEIGHTS){let r=N(n,"onehotLabels","softmaxCrossEntropy");const a=N(e,"logits","softmaxCrossEntropy");let o=null;if(t!=null&&(o=N(t,"weights","softmaxCrossEntropy")),jn(r.shape,a.shape,"Error in softmaxCrossEntropy: "),s>0){const c=Ke(s),u=Ke(1),h=Ke(r.shape[1]);r=de(X(r,Fe(u,c)),Ue(c,h))}const l=wH(r,a);return sa(l,o,i)}const TH=U({softmaxCrossEntropy_:SH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _H(n,e,t,s){const i=N(n,"indices","sparseFillEmptyRows","int32"),r=N(e,"values","sparseFillEmptyRows"),a=N(t,"denseShape","sparseFillEmptyRows","int32"),o=N(s,"defaultValue","sparseFillEmptyRows",r.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(r.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${r.shape}`);if(a.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${a.shape}`);if(o.rank!==0)throw new Error(`Default value should be a scalar but received shape ${o.shape}`);const l={indices:i,values:r,denseShape:a,defaultValue:o},c=W.runKernel(Ig,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const IH=U({sparseFillEmptyRows_:_H});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MH(n,e,t){const s=N(n,"inputIndices","sparseReshape","int32"),i=N(e,"inputShape","sparseReshape","int32"),r=N(t,"newShape","sparseReshape","int32");if(s.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${s.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(r.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${r.shape}`);const a={inputIndices:s,inputShape:i,newShape:r},o=W.runKernel(Mg,a);return{outputIndices:o[0],outputShape:o[1]}}const CH=U({sparseReshape_:MH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EH(n,e,t){const s=N(n,"data","sparseSegmentMean"),i=N(e,"indices","sparseSegmentMean","int32"),r=N(t,"segmentIds","sparseSegmentMean","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${r.shape}`);const a={data:s,indices:i,segmentIds:r};return W.runKernel(Cg,a)}const kH=U({sparseSegmentMean_:EH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NH(n,e,t){const s=N(n,"data","sparseSegmentSum"),i=N(e,"indices","sparseSegmentSum","int32"),r=N(t,"segmentIds","sparseSegmentSum","int32");if(s.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(r.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${r.shape}`);const a={data:s,indices:i,segmentIds:r};return W.runKernel(Eg,a)}const RH=U({sparseSegmentSum_:NH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AH(n,e,t,s,i,r,a,o){const l=N(n,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=N(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:t,nGramWidths:s,leftPad:i,rightPad:r,padWidth:a,preserveShortSequences:o},h={data:l,dataSplits:c},d=W.runKernel(Ag,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}const LH=U({stringNGrams_:AH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PH(n,e,t=!0){const s=N(n,"input","stringSplit","string"),i=N(e,"delimiter","stringSplit","string");if(s.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${s.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const r={skipEmpty:t},a={input:s,delimiter:i},o=W.runKernel(Lg,a,r);return{indices:o[0],values:o[1],shape:o[2]}}const DH=U({stringSplit_:PH});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FH(n,e){const t=N(n,"input","stringToHashBucketFast","string"),s={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:t};return W.runKernel(Pg,i,s)}const OH=U({stringToHashBucketFast_:FH});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JC={fft:lp,ifft:hc,rfft:cp,irfft:cy},qC={hammingWindow:mX,hannWindow:ZC,frame:YC,stft:xX},rr={flipLeftRight:TX,grayscaleToRGB:IX,resizeNearestNeighbor:QC,resizeBilinear:jC,rotateWithOffset:CX,cropAndResize:wX,nonMaxSuppression:kX,nonMaxSuppressionAsync:OX,nonMaxSuppressionWithScore:zX,nonMaxSuppressionWithScoreAsync:WX,nonMaxSuppressionPadded:BX,nonMaxSuppressionPaddedAsync:XX,threshold:jX,transform:JX},Cv={bandPart:eH,gramSchmidt:nH,qr:iH},eE={absoluteDifference:oH,computeWeightedLoss:sa,cosineDistance:cH,hingeLoss:hH,huberLoss:pH,logLoss:mH,meanSquaredError:yH,sigmoidCrossEntropy:vH,softmaxCrossEntropy:TH},tE={sparseFillEmptyRows:IH,sparseReshape:CH,sparseSegmentMean:kH,sparseSegmentSum:RH},nE={stringNGrams:LH,stringSplit:DH,stringToHashBucketFast:OH};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class il{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}let rl=class Pl{constructor(){this.classNameMap={}}static getMap(){return Pl.instance==null&&(Pl.instance=new Pl),Pl.instance}static register(e){Pl.getMap().classNameMap[e.className]=[e,e.fromConfig]}};function pe(n){E(n.className!=null,()=>"Class being registered does not have the static className property defined."),E(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),E(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),rl.register(n)}const GH=Object.freeze(Object.defineProperty({__proto__:null,Serializable:il,SerializationMap:rl,registerClass:pe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ia extends il{minimize(e,t=!1,s){const{value:i,grads:r}=this.computeGradients(e,s);if(s!=null){const a=s.map(o=>({name:o.name,tensor:r[o.name]}));this.applyGradients(a)}else this.applyGradients(r);return nt(r),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return OC(e,t)}dispose(){this.iterations_!=null&&nt(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:Ke(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(ia,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ev extends ia{constructor(e,t,s=null){super(),this.learningRate=e,this.rho=t,this.epsilon=s,this.accumulatedGrads=[],this.accumulatedUpdates=[],s==null&&(this.epsilon=W.backend.epsilon())}static get className(){return"Adadelta"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,s)=>{const i=W.registeredVariables[t],r=!1;this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${t}/accum_grad`,variable:j(()=>_t(i).variable(r))}),this.accumulatedUpdates[s]==null&&(this.accumulatedUpdates[s]={originalName:`${t}/accum_var`,variable:j(()=>_t(i).variable(r))});const a=Array.isArray(e)?e[s].tensor:e[t];if(a==null)return;const o=this.accumulatedGrads[s].variable,l=this.accumulatedUpdates[s].variable;j(()=>{const c=de(X(o,this.rho),X(zt(a),1-this.rho)),u=X(Ue(Yn(de(l,this.epsilon)),Yn(de(o,this.epsilon))),a),h=de(X(l,this.rho),X(zt(u),1-this.rho));o.assign(c),l.assign(h);const d=de(X(u,-this.learningRate),i);i.assign(d)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(nt(this.accumulatedGrads.map(e=>e.variable)),nt(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,s=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kv extends ia{constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}static get className(){return"Adagrad"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,s)=>{const i=W.registeredVariables[t];this.accumulatedGrads[s]==null&&(this.accumulatedGrads[s]={originalName:`${t}/accumulator`,variable:j(()=>el(i.shape,this.initialAccumulatorValue).variable(!1))});const r=Array.isArray(e)?e[s].tensor:e[t];if(r==null)return;const a=this.accumulatedGrads[s].variable;j(()=>{const o=de(a,zt(r));a.assign(o);const l=de(X(Ue(r,Yn(de(o,W.backend.epsilon()))),-this.learningRate),i);i.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&nt(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nv extends ia{constructor(e,t,s,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],j(()=>{this.accBeta1=Ke(t).variable(),this.accBeta2=Ke(s).variable()}),i==null&&(this.epsilon=W.backend.epsilon())}static get className(){return"Adam"}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);j(()=>{const s=Fe(1,this.accBeta1),i=Fe(1,this.accBeta2);t.forEach((r,a)=>{const o=W.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:j(()=>_t(o).variable(l))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${r}/v`,variable:j(()=>_t(o).variable(l))});const c=Array.isArray(e)?e[a].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[a].variable,h=this.accumulatedSecondMoment[a].variable,d=de(X(u,this.beta1),X(c,1-this.beta1)),p=de(X(h,this.beta2),X(zt(c),1-this.beta2)),f=Ue(d,s),y=Ue(p,i);u.assign(d),h.assign(p);const m=de(X(Ue(f,de(Yn(y),this.epsilon)),-this.learningRate),o);o.assign(m)}),this.accBeta1.assign(X(this.accBeta1,this.beta1)),this.accBeta2.assign(X(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&nt(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),j(()=>{this.accBeta1.assign(Kr(this.beta1,this.iterations_+1)),this.accBeta2.assign(Kr(this.beta2,this.iterations_+1))});const t=e.length/2,s=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rv extends ia{constructor(e,t,s,i=null,r=0){super(),this.learningRate=e,this.beta1=t,this.beta2=s,this.epsilon=i,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],j(()=>{this.iteration=Ke(0).variable(),this.accBeta1=Ke(t).variable()}),i==null&&(this.epsilon=W.backend.epsilon())}static get className(){return"Adamax"}applyGradients(e){const t=Array.isArray(e)?e.map(s=>s.name):Object.keys(e);j(()=>{const s=Fe(1,this.accBeta1),i=Ue(-this.learningRate,de(X(this.iteration,this.decay),1));t.forEach((r,a)=>{const o=W.registeredVariables[r],l=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${r}/m`,variable:_t(o).variable(l)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${r}/v`,variable:_t(o).variable(l)});const c=Array.isArray(e)?e[a].tensor:e[r];if(c==null)return;const u=this.accumulatedFirstMoment[a].variable,h=this.accumulatedWeightedInfNorm[a].variable,d=de(X(u,this.beta1),X(c,1-this.beta1)),p=X(h,this.beta2),f=xn(c),y=vr(p,f);u.assign(d),h.assign(y);const m=de(X(Ue(i,s),Ue(d,de(y,this.epsilon))),o);o.assign(m)}),this.iteration.assign(de(this.iteration,1)),this.accBeta1.assign(X(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&nt(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&nt(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Sy extends ia{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}static get className(){return"SGD"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,s)=>{const i=Array.isArray(e)?e[s].tensor:e[t];if(i==null)return;const r=W.registeredVariables[t];j(()=>{const a=de(X(this.c,i),r);r.assign(a)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=hn(Ke(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Av extends Sy{constructor(e,t,s=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=s,this.accumulations=[],this.m=Ke(this.momentum)}static get className(){return"Momentum"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,s)=>{const i=W.registeredVariables[t];this.accumulations[s]==null&&(this.accumulations[s]={originalName:`${t}/momentum`,variable:j(()=>_t(i).variable(!1))});const r=this.accumulations[s].variable,a=Array.isArray(e)?e[s].tensor:e[t];a!=null&&j(()=>{let o;const l=de(X(this.m,r),a);this.useNesterov?o=de(X(this.c,de(a,X(l,this.m))),i):o=de(X(this.c,l),i),r.assign(l),i.assign(o)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&nt(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(s=>({originalName:s.name,variable:s.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lv extends ia{constructor(e,t=.9,s=0,i=null,r=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=s,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,i==null&&(this.epsilon=W.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}static get className(){return"RMSProp"}applyGradients(e){(Array.isArray(e)?e.map(t=>t.name):Object.keys(e)).forEach((t,s)=>{const i=W.registeredVariables[t],r=!1;this.accumulatedMeanSquares[s]==null&&(this.accumulatedMeanSquares[s]={originalName:`${t}/rms`,variable:j(()=>_t(i).variable(r))}),this.accumulatedMoments[s]==null&&(this.accumulatedMoments[s]={originalName:`${t}/momentum`,variable:j(()=>_t(i).variable(r))}),this.accumulatedMeanGrads[s]==null&&this.centered&&(this.accumulatedMeanGrads[s]={originalName:`${t}/mg`,variable:j(()=>_t(i).variable(r))});const a=Array.isArray(e)?e[s].tensor:e[t];if(a==null)return;const o=this.accumulatedMeanSquares[s].variable,l=this.accumulatedMoments[s].variable;j(()=>{const c=de(X(o,this.decay),X(zt(a),1-this.decay));if(this.centered){const u=this.accumulatedMeanGrads[s].variable,h=de(X(u,this.decay),X(a,1-this.decay)),d=Ue(X(a,this.learningRate),Yn(Fe(c,de(zt(h),this.epsilon)))),p=de(X(l,this.momentum),d);o.assign(c),u.assign(h),l.assign(p);const f=Fe(i,p);i.assign(f)}else{const u=de(X(o,this.decay),X(zt(a),1-this.decay)),h=de(X(l,this.momentum),Ue(X(a,this.learningRate),Yn(de(u,this.epsilon))));o.assign(u),l.assign(h);const d=Fe(i,h);i.assign(d)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&nt(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&nt(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&nt(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,s=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(s)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zH=[Ev,kv,Nv,Rv,Av,Lv,Sy];function VH(){for(const n of zH)pe(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(n,e,t,s){a(n),t=t??0,s=s??1,o(t,s);let i=0;const r=l=>(l.then(c=>{const u=t+ ++i/n.length*(s-t);return e(u),c}),l);function a(l){E(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function o(l,c){E(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),E(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),E(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(n.map(r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function sE(n,e){e==null&&(e={});const t=e.fetchFunc==null?ee().platform.fetch:e.fetchFunc,s=n.map(c=>t(c,e.requestInit,{isBinary:!0})),i=0,r=.5,a=(e.onProgress==null?await Promise.all(s):await wI(s,e.onProgress,i,r)).map(c=>c.arrayBuffer()),o=.5,l=1;return e.onProgress==null?await Promise.all(a):await wI(a,e.onProgress,o,l)}async function iE(n,e="",t,s){return rE(i=>sE(i,{requestInit:s}))(n,e,t)}function rE(n){return async(e,t="",s)=>{const i=e.map(()=>!1),r={},a=s!=null?s.map(()=>!1):[],o=[];if(e.forEach((p,f)=>{let y=0;p.weights.forEach(m=>{const g="quantization"in m?m.quantization.dtype:m.dtype,b=ex[g]*re(m.shape),x=()=>{i[f]=!0,r[f]==null&&(r[f]=[]),r[f].push({manifestEntry:m,groupOffset:y,sizeBytes:b})};s!=null?s.forEach((v,w)=>{v===m.name&&(x(),a[w]=!0)}):x(),o.push(m.name),y+=b})}),!a.every(p=>p)){const p=s.filter((f,y)=>!a[y]);throw new Error(`Could not find weights in manifest with names: ${p.join(", ")}. 
Manifest JSON has weights with names: ${o.join(", ")}.`)}const l=i.reduce((p,f,y)=>(f&&p.push(y),p),[]),c=[];l.forEach(p=>{e[p].paths.forEach(f=>{const y=t+(t.endsWith("/")?"":"/")+f;c.push(y)})});const u=await n(c),h={};let d=0;return l.forEach(p=>{const f=e[p].paths.length;let y=0;for(let x=0;x<f;x++)y+=u[d+x].byteLength;const m=new ArrayBuffer(y),g=new Uint8Array(m);let b=0;for(let x=0;x<f;x++){const v=new Uint8Array(u[d+x]);g.set(v,b),b+=v.byteLength}r[p].forEach(x=>{const v=m.slice(x.groupOffset,x.groupOffset+x.sizeBytes),w=b1(v,[x.manifestEntry]);for(const _ in w)h[_]=w[_]}),d+=f}),h}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WH="application/octet-stream",UH="application/json";class Pv{constructor(e,t){if(this.DEFAULT_METHOD="POST",t==null&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,t.fetchFunc!=null?(E(typeof t.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=t.fetchFunc):this.fetch=ee().platform.fetch,E(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&E(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,t.requestInit!=null&&t.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const s=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=_C(e,s);t.body.append("model.json",new Blob([JSON.stringify(i)],{type:UH}),"model.json"),e.weightData!=null&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:WH}),"model.weights.bin");const r=await this.fetch(this.path,t);if(r.ok)return{modelArtifactsInfo:Hd(e),responses:[r]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${r.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let t;try{t=await e.json()}catch{let r=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?r+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":r+=" Please make sure the server is serving valid JSON for this request.",new Error(r)}const s=t.modelTopology,i=t.weightsManifest;if(s==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return w1(t,r=>this.loadWeights(r))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[s,i]=BH(t),r=this.weightPathPrefix||s,a=S1(e),o=[],l=[];for(const u of e)for(const h of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(h)):o.push(r+h+i);this.weightUrlConverter&&o.push(...await Promise.all(l));const c=await sE(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[a,Wg(c)]}}Pv.URL_SCHEME_REGEX=/^https?:\/\//;function BH(n){const e=n.lastIndexOf("/"),t=n.lastIndexOf("?"),s=n.substring(0,e),i=t>e?n.substring(t):"";return[s+"/",i]}function ox(n){return n.match(Pv.URL_SCHEME_REGEX)!=null}const aE=(n,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let t=!0;if(Array.isArray(n)?t=n.every(s=>ox(s)):t=ox(n),t)return Dv(n,e)}return null};rn.registerSaveRouter(aE);rn.registerLoadRouter(aE);function Dv(n,e){return new Pv(n,e)}function oE(n,e){return Dv(n,e)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let ro;function lE(n,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(n==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let t=!1,s=!1,i=!1,r=!1,a=!1,o=!1;if(n.data instanceof Uint8Array)t=!0;else if(typeof ImageData<"u"&&n instanceof ImageData)s=!0;else if(typeof HTMLVideoElement<"u"&&n instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement)r=!0;else if(n.getContext!=null)a=!0;else if(typeof ImageBitmap<"u"&&n instanceof ImageBitmap)o=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${n.constructor.name}`);if(Qf(jf,W.backendName)!=null){const d={pixels:n},p={numChannels:e};return W.runKernel(jf,d,p)}const[l,c]=i?[n.videoWidth,n.videoHeight]:[n.width,n.height];let u;if(a)u=n.getContext("2d").getImageData(0,0,l,c).data;else if(s||t)u=n.data;else if(r||i||o){if(ro==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")ro=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else ro=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ro.canvas.width=l,ro.canvas.height=c,ro.drawImage(n,0,0,l,c),u=ro.getImageData(0,0,l,c).data}let h;if(e===4)h=new Int32Array(u);else{const d=l*c;h=new Int32Array(d*e);for(let p=0;p<d;p++)for(let f=0;f<e;++f)h[p*e+f]=u[p*4+f]}return yv(h,[c,l,e],"int32")}function $H(n){return n!=null&&n.data instanceof Uint8Array}function XH(){return typeof window<"u"&&typeof ImageBitmap<"u"&&window.hasOwnProperty("createImageBitmap")}function HH(n){return n!=null&&n.width!==0&&n.height!==0}function KH(n){return XH()&&!(n instanceof ImageBitmap)&&HH(n)&&!$H(n)}async function ZH(n,e=3){let t=null;if(ee().getBool("WRAP_TO_IMAGEBITMAP")&&KH(n)){let s;try{s=await createImageBitmap(n,{premultiplyAlpha:"none"})}catch{s=null}s!=null&&s.width===n.width&&s.height===n.height?t=s:t=n}else t=n;return lE(t,e)}async function YH(n,e){let t=N(n,"img","toPixels");if(!(n instanceof Et)){const c=t;t=Se(c,"int32"),c.dispose()}if(t.rank!==2&&t.rank!==3)throw new Error(`toPixels only supports rank 2 or 3 tensors, got rank ${t.rank}.`);const[s,i]=t.shape.slice(0,2),r=t.rank===2?1:t.shape[2];if(r>4||r===2)throw new Error(`toPixels only supports depth of size 1, 3 or 4 but got ${r}`);if(t.dtype!=="float32"&&t.dtype!=="int32")throw new Error(`Unsupported type for toPixels: ${t.dtype}. Please use float32 or int32 tensors.`);const a=await t.data(),o=t.dtype==="float32"?255:1,l=new Uint8ClampedArray(i*s*4);for(let c=0;c<s*i;++c){const u=[0,0,0,255];for(let d=0;d<r;d++){const p=a[c*r+d];if(t.dtype==="float32"){if(p<0||p>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${p}.`)}else if(t.dtype==="int32"&&(p<0||p>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${p}.`);r===1?(u[0]=p*o,u[1]=p*o,u[2]=p*o):u[d]=p*o}const h=c*4;l[h+0]=Math.round(u[0]),l[h+1]=Math.round(u[1]),l[h+2]=Math.round(u[2]),l[h+3]=Math.round(u[3])}if(e!=null){e.width=i,e.height=s;const c=e.getContext("2d"),u=new ImageData(l,i,s);c.putImageData(u,0,0)}return t!==n&&t.dispose(),l}const Fv=U({fromPixels_:lE}),jH=Object.freeze(Object.defineProperty({__proto__:null,fromPixels:Fv,fromPixelsAsync:ZH,toPixels:YH},Symbol.toStringTag,{value:"Module"}));function Ty(n,e){const t=n.shape.length,s=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(s<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${s}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[s-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[s-1]} vs. ${t}`);if(re(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,r=i[i.length-1];let a=1;for(let h=0;h<i.length-1;++h)a*=i[h];const o=n.shape,l=i.slice();l.pop();let c=1;for(let h=r;h<t;++h)c*=o[h],l.push(o[h]);const u=[...He(n.shape).map(h=>h/c),1].slice(0,r);return[l,a,c,u]}const QH=Object.freeze(Object.defineProperty({__proto__:null,prepareAndValidate:Ty},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lx=-2,JH=-1;function Ov(n,e,t){const s=n.shape.length;E(s===e.length,()=>`Error in slice${s}D: Length of begin ${e} must match the rank of the array (${s}).`),E(s===t.length,()=>`Error in slice${s}D: Length of size ${t} must match the rank of the array (${s}).`);for(let i=0;i<s;++i)E(e[i]+t[i]<=n.shape[i],()=>`Error in slice${s}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function qH(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function Gv(n,e,t){const s=[];for(let i=0;i<n.length;i++)s[i]=Math.ceil((e[i]-n[i])/t[i]);return s}function cE(n,e,t,s){const i=[...n];for(let r=i.length;r<s.length;r++)i.push(1);for(let r=0;r<t;r++)r===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function uE(n,e,t){return t<=n?t:t-(e-1)}function hE(n,e){const t=[];for(let s=0;s<n;s++)t.push(e+s);return t}function eK(n,e,t,s,i,r,a,o,l){const c=n.length;let u=new Array(c),h=new Array(c),d=new Array(c);if(e.length&&t>0){const p=e[0],f=t+1;u=dE(a,p,f,s,n),h=pE(o,p,f,i,n),d=cE(r,p,f,n)}else for(let p=0;p<c;p++)u[p]=mE(a,s,r,n,p,l),h[p]=gE(o,i,r,n,p,l),d[p]=fE(r,p,l);return{begin:u,end:h,strides:d}}function dE(n,e,t,s,i){const r=[...i],a=hE(t,e);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=0;else{const l=uE(e,t,o);let c=s[l];n&1<<l&&(c=0),r[o]=c}return r}function pE(n,e,t,s,i){const r=[...i],a=hE(t,e);for(let o=0;o<r.length;o++)if(a.indexOf(o)>-1)r[o]=Number.MAX_SAFE_INTEGER;else{const l=uE(e,t,o);let c=s[l];n&1<<l&&(c=Number.MAX_SAFE_INTEGER),r[o]=c}for(let o=0;o<r.length;o++){const l=i[o];r[o]<0&&(r[o]+=l),r[o]=Aa(0,r[o],i[o])}return r}function fE(n,e,t){let s=n[e];return(t&1<<e||s==null)&&(s=1),s}function mE(n,e,t,s,i,r){let a=e[i];const o=t[i]||1;(n&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const l=s[i];return a<0&&(a+=l),a=Aa(0,a,l-1),a}function gE(n,e,t,s,i,r){let a=e[i];const o=t[i]||1;(n&1<<i||r&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const l=s[i];return a<0&&(a+=l),o>0?a=Aa(0,a,l):a=Aa(-1,a,l-1),a}function zv(n,e,t){let s=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){s=i;break}for(let i=s+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function Vv(n,e){let t=n.length>0?n[n.length-1]:1;for(let s=0;s<n.length-1;s++)t+=n[s]*e[s];return t}function _y(n,e,t){let s;const i=n.shape.length;typeof e=="number"?s=[e,...new Array(i-1).fill(0)]:e.length<i?s=e.concat(new Array(i-e.length).fill(0)):s=e.slice(),s.forEach(a=>{E(a!==-1,()=>"slice() does not support negative begin indexing.")});let r;return t==null?r=new Array(i).fill(-1):typeof t=="number"?r=[t,...new Array(i-1).fill(-1)]:t.length<i?r=t.concat(new Array(i-t.length).fill(-1)):r=t,r=r.map((a,o)=>a>=0?a:(E(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-s[o])),[s,r]}function Wv(n,e,t,s,i,r,a,o,l){let c;if(s==null?(c=new Array(e.length),c.fill(1)):c=s,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:c.slice(),beginMask:i,endMask:r,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:l};for(let b=0;b<h.dims;b++)u&&1<<b&o&&h.numAddAxisAfterEllipsis++,1<<b&a&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};tK(h,d);let p=!0,f=!0,y=!0;const m=[],g=[];for(let b=0;b<n.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const x=!!(d.shrinkAxisMask&1<<b),v=n[b];if(v===-1){m.push(x?1:-1);continue}const w=[d.beginMask&1<<b,d.endMask&1<<b],_=[d.strides[b]>0?0:-1,d.strides[b]>0?v:v-1];if(x&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");y=y&&d.strides[b]===1;const I=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(x){const A=d.begin[b]<0?v+d.begin[b]:d.begin[b];if(d.begin[b]=A,d.end[b]=d.begin[b]+1,A<0||A>=v)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=SI(d.begin[b],0,d.strides[b],v,w,_),d.end[b]=SI(d.end[b],1,d.strides[b],v,w,_);const M=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===v;p=p&&M,f=f&&(b===0&&d.strides[b]===1||M)}else p=p&&d.strides[b]===1&&I,f=f&&(b===0&&d.strides[b]===1||I);let C,S=!1;if(d.beginValid&&d.endValid?(C=d.end[b]-d.begin[b],S=!0):x?(C=1,S=!0):I&&v>=0&&(d.strides[b]<0?C=-v:C=v,S=!0),S){let M;C===0||C<0!=d.strides[b]<0?M=0:M=Math.trunc(C/d.strides[b])+(C%d.strides[b]!==0?1:0),m.push(M)}else m.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const x=d.finalShapeGatherIndices[b];x>=0?g.push(m[x]):x===lx&&g.push(1)}return{finalShapeSparse:g.filter((b,x)=>d.finalShapeGatherIndices[x]!==lx),finalShape:g,isIdentity:p,sliceDim0:f,isSimpleSlice:y,begin:d.begin,end:d.end,strides:d.strides}}function tK(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let s=0;s<n.dims;s++)if(1<<s&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-s)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=s}else if(1<<s&n.newAxisMask)e.finalShapeGatherIndices.push(lx),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[s]),n.end!=null&&(e.end[t]=n.end[s]),e.strides[t]=n.strides[s],n.beginMask&1<<s&&(e.beginMask|=1<<t),n.endMask&1<<s&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<s?(e.finalShapeGatherIndices.push(JH),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(s)),e.inputShapeGatherIndicesSparse[t]=s,t++}}function SI(n,e,t,s,i,r){if(i[e])return t>0?r[e]:r[e+1&1];{const a=n<0?s+n:n;return a<r[0]?r[0]:a>r[1]?r[1]:a}}const yE=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:Ov,computeFlatOffset:Vv,computeOutShape:Gv,getNormalizedAxes:eK,isSliceContinous:zv,maskToAxes:qH,parseSliceParams:_y,sliceInfo:Wv,startForAxis:mE,startIndicesWithElidedDims:dE,stopForAxis:gE,stopIndicesWithElidedDims:pE,stridesForAxis:fE,stridesWithElidedDims:cE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bE{static sgd(e){return new Sy(e)}static momentum(e,t,s=!1){return new Av(e,t,s)}static rmsprop(e,t=.9,s=0,i=null,r=!1){return new Lv(e,t,s,i,r)}static adam(e=.001,t=.9,s=.999,i=null){return new Nv(e,t,s,i)}static adadelta(e=.001,t=.95,s=null){return new Ev(e,t,s)}static adamax(e=.002,t=.9,s=.999,i=null,r=0){return new Rv(e,t,s,i,r)}static adagrad(e,t=.1){return new kv(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const po=bE;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nK=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function up(){return new Promise(n=>nK(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n,e){const t=n[0].length;n.forEach((i,r)=>{E(i.length===t,()=>`Error in concat${t}D: rank of tensors[${r}] must be the same as the rank of the rest (${t})`)}),E(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const s=n[0];n.forEach((i,r)=>{for(let a=0;a<t;a++)E(a===e||i[a]===s[a],()=>`Error in concat${t}D: Shape of tensors[${r}] (${i}) does not match the shape of the rest (${s}) along the non-concatenated axis ${r}.`)})}function hr(n,e){const t=n[0].slice();for(let s=1;s<n.length;s++)t[e]+=n[s][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Li;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Li||(Li={}));function xE(n,e,t){let s=new Array;if(t==null&&e==null)return s;if(e==null)for(;s.length<n+t.length;)s.push(-1);else s=e.slice();if(t==null)return s;if(n+t.length!==s.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${s.length}`);for(let i=1;i<t.length;++i){const r=t[i],a=s[s.length-t.length+i],o=s[a];if(r>=0)if(o>=0){if(o!==r)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${r} but shape[${i+n}] = ${o}`)}else s[a]=r}return s}function vE(n){const e={FIRST_DIM_SIZE:Li.FIRST_DIM_SIZE,VALUE_ROWIDS:Li.VALUE_ROWIDS,ROW_LENGTHS:Li.ROW_LENGTHS,ROW_SPLITS:Li.ROW_SPLITS,ROW_LIMITS:Li.ROW_LIMITS,ROW_STARTS:Li.ROW_STARTS},t=[];for(const s of n)if(s in e)t.push(e[s]);else break;return t}function wE(n){return n.length===0?0:n[0]===Li.FIRST_DIM_SIZE?n.length-1:n.length}function SE(n,e){if(n==null||e==null)return;const t=n.length,s=e.length;if(t>=s)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${s})`);for(let i=0;i<Math.min(t,s-1);++i){const r=n[i],a=e[i+1];if(r>=0&&a>=0&&r!==1&&r!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${r} but ragged tensor input.flatValues.shape[${i-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bv=30;function Iy(n){return n<=Bv?n:Kf(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $v(n,e,t){const s=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[s,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hp(n,e,t,s=!0){let i=[];if(s)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const r=e.length;for(let a=0;a<r;++a)i=i.concat([n[a+1]/e[a],e[a]]);i=i.concat(n.slice(r+1))}return i}function dp(n,e,t=!0){const s=[];if(t){s.push(e);for(let i=e+1;i<n;++i)i<=2*e?(s.push(i),s.push(i-(e+1))):s.push(i)}else{const i=[],r=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?r.push(a):i.push(a);s.push(...i),s.push(0),s.push(...r)}return s}function pp(n,e,t,s=!0){const i=[];s?i.push(n[0]/t):i.push(n[0]*t);for(let r=1;r<n.length;++r)r<=e.length?s?i.push(e[r-1]*n[r]):i.push(n[r]/e[r-1]):i.push(n[r]);return i}function Xv(n,e){const t=[0];for(let s=0;s<e;++s)t.push(n[s][0]);return t}function Hv(n,e,t){const s=n.slice(0,1);for(let i=0;i<t;++i)s.push(n[i+1]-e[i][0]-e[i][1]);return s}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const My=1.7580993408473768,Cy=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kv=.3275911,Zv=.254829592,Yv=-.284496736,jv=1.421413741,Qv=-1.453152027,Jv=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zr(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let s=0;s<t.length;s+=2)t[s]=n[s/2],t[s+1]=e[s/2];return t}function TE(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let s=0;s<n.length;s+=2)e[s/2]=n[s],t[s/2]=n[s+1];return{real:e,imag:t}}function _E(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function IE(n){const e=Math.floor(n.length/4),t=new Float32Array(e),s=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],s[Math.floor(i/4)]=n[i+1];return{real:t,imag:s}}function qv(n,e){const t=n[e*2],s=n[e*2+1];return{real:t,imag:s}}function ME(n,e,t,s){n[s*2]=e,n[s*2+1]=t}function CE(n,e){const t=new Float32Array(n/2),s=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const r=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(r),s[i]=Math.sin(r)}return{real:t,imag:s}}function EE(n,e,t){const s=(t?2:-2)*Math.PI*(n/e),i=Math.cos(s),r=Math.sin(s);return{real:i,imag:r}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kb="->",sK=/->/g,TI=",",_I="...";function ew(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(sK,"").length)/Kb.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Kb}").`);const[s,i]=n.split(Kb);E(s.indexOf(_I)===-1,()=>`The ellipsis notation ("${_I}") is not supported yet.`);const r=s.split(TI),a=r.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<i.length;++d){const p=i[d];if(!r.some(f=>f.indexOf(p)!==-1))throw new Error(`Output subscripts contain the label ${p} not present in the input subscripts.`);o.indexOf(p)===-1&&o.push(p)}for(let d=0;d<s.length;++d){const p=s[d];o.indexOf(p)===-1&&p!==TI&&o.push(p)}const l=new Array(r.length);for(let d=0;d<a;++d){if(new Set(r[d].split("")).size!==r[d].length)throw new Error(`Found duplicate axes in input component ${r[d]}. Support for duplicate axes in input is not implemented yet.`);l[d]=[];for(let p=0;p<r[d].length;++p)l[d].push(o.indexOf(r[d][p]))}const c=o.length,u=i.length,h=[];for(let d=u;d<c;++d)h.push(d);return{allDims:o,summedDims:h,idDims:l}}function tw(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const s=[];for(let i=0;i<n;++i)t[i]===-1&&s.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:s}}function nw(n,e,t){const s=new Array(n);for(let i=0;i<t.length;++i){const r=t[i].shape;for(let a=0;a<e[i].length;++a)s[e[i][a]]===void 0?s[e[i][a]]=r[a]:E(s[e[i][a]]===r[a],()=>`Expected dimension ${s[e[i][a]]} at axis ${a} of input shaped ${JSON.stringify(r)}, but got dimension ${r[a]}`)}}function sw(n,e){const t=n,s=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let a=0;a<i;++a)s.push([]);const r=[];for(let a=0;a<t.length;++a){const o=t[a],l=iK(e,o);for(const c of l)r.indexOf(c)===-1&&(s[a].push(c),r.push(c))}return{path:t,steps:s}}function iw(n){return n.every((e,t)=>e===t)}function iK(n,e){const t=[];for(let s=0;s<n.length;++s)(n[s].length===0||n[s].indexOf(e)!==-1||e===-1)&&t.push(s);return t}function rw(n,e,t=0){let s=[];if(typeof e=="number")E(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),s=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);E(i<=1,()=>"There should be only one negative value in split array.");const r=e.indexOf(-1);if(r!==-1){const a=e.reduce((o,l)=>l>0?o+l:o);e[r]=n.shape[t]-a}E(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),s=e}return s}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kE(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function NE(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function RE(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AE(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function LE(n,e){return`size ${n} must be non-negative, not ${e}`}function PE(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function DE(n,e){const t=re(n),s=re(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${s}. inputShape=${n} outputShape= ${e}`}function FE(n,e){const t=re(n),s=re(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${s}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cx(){return"segment ids must be >= 0"}function OE(){return"segment ids are not increasing"}function GE(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function zE(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VE(n,e){let t=!1,s;for(n<=Bv?(s=n,t=!0):s=Kf(n,Math.floor(Math.sqrt(n)));!t;)s>e||s===n?t=!0:s=Kf(n,s+1);return s}function WE(n,e,t){const s=[],i=n.length;for(let r=0;r<i;r++)r!==e?s.push(n[r]):s.push(t);return s}function aw(n,e,t,s){const i=e.shape.length,r=n.shape.length;if(s!==0&&(s<-i||s>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${s}`);if(s<0&&(s+=i),s>r)throw new Error(`batchDims (${s}) must be less than rank(x) (
    ${r}).`);if(t<s)throw new Error(`batchDims (${s}) must be less than or equal to axis (${t}).`);for(let h=0;h<s;++h)if(n.shape[h]!==e.shape[h])throw new Error(`x.shape[${h}]: ${n.shape[h]} should be equal to indices.shape[${h}]: ${e.shape[h]}.`);const a=n.shape[t],o=[];let l=1,c=1,u=1;for(let h=0;h<s;++h)o.push(n.shape[h]),l*=n.shape[h];for(let h=s;h<t;h++)o.push(n.shape[h]),c*=n.shape[h];for(let h=s;h<i;h++)o.push(e.shape[h]);for(let h=t+1;h<r;h++)o.push(n.shape[h]),u*=n.shape[h];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:a,outputShape:o}}const rK=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:aw,computeOutShape:WE,segOpComputeOptimalWindowSize:VE},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wo(n){try{return n.map(e=>Br(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function UE(n){return n.map(e=>cr(e))}const BE=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:Zv,ERF_A2:Yv,ERF_A3:jv,ERF_A4:Qv,ERF_A5:Jv,ERF_P:Kv,PARALLELIZE_THRESHOLD:Bv,get RowPartitionType(){return Li},SELU_SCALE:Cy,SELU_SCALEALPHA:My,applyActivation:yy,assertAndGetBroadcastShape:st,assertAxesAreInnerMostDims:Jn,assertParamsConsistent:Uv,assignToTypedArray:ME,axesAreInnerMostDims:J1,calculateShapes:ku,checkEinsumDimSizes:nw,checkPadOnDimRoundingMode:ms,combineLocations:DC,combineRaggedTensorToTensorShapes:xE,complexWithEvenIndex:_E,complexWithOddIndex:IE,computeConv2DInfo:zn,computeConv3DInfo:$a,computeDefaultPad:L1,computeDilation2DInfo:Kd,computeOptimalWindowSize:Iy,computeOutAndReduceShapes:Vn,computeOutShape:hr,computePool2DInfo:_i,computePool3DInfo:qr,convertConv2DDataFormat:ea,decodeEinsumEquation:ew,eitherStridesOrDilationsAreOne:Qn,expandShapeToKeepDim:mn,exponent:EE,exponents:CE,fromStringArrayToUint8:UE,fromUint8ToStringArray:Wo,getAxesPermutation:un,getBroadcastDims:Go,getComplexWithIndex:qv,getEinsumComputePath:sw,getEinsumPermutation:tw,getFusedBiasGradient:gy,getFusedDyActivation:my,getImageCenter:$v,getInnerMostAxes:gn,getPermuted:dp,getRaggedRank:wE,getReductionAxes:Sn,getReshaped:hp,getReshapedPermuted:pp,getRowPartitionTypesHelper:vE,getSliceBeginCoords:Xv,getSliceSize:Hv,getSparseFillEmptyRowsIndicesDenseShapeMismatch:kE,getSparseFillEmptyRowsNegativeIndexErrorMessage:NE,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:RE,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:PE,getSparseReshapeInputOutputMismatchErrorMessage:FE,getSparseReshapeInputOutputMultipleErrorMessage:DE,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:AE,getSparseReshapeNegativeOutputDimErrorMessage:LE,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:zE,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:cx,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:OE,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:GE,getUndoAxesPermutation:Xa,isIdentityPermutation:iw,log:_V,mergeRealAndImagArrays:Zr,prepareAndValidate:Ty,prepareSplitSize:rw,segment_util:rK,shouldFuse:by,slice_util:yE,splitRealAndImagArrays:TE,stridesOrDilationsArePositive:Fo,tupleValuesAreOne:Pa,upcastType:Es,validateDefaultValueShape:SE,validateInput:Sv,validateUpdateShape:wv,warn:qs},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */VH();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $E={kernelName:$h,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,sl(Se(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aK={kernelName:Ic,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=zt(Se(t,"float32")),i=Yn(Fe(Ke(1),s));return Jt(Ue(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oK={kernelName:Mc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Yn(Fe(zt(Se(t,"float32")),1));return Ue(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lK={kernelName:Jo,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{let r=n;const a=Sn(t.shape,i);return a.length>0&&(r=ze(r,a)),K(r,t.shape)},b:()=>{let r=n;const a=Sn(s.shape,i);return a.length>0&&(r=ze(r,a)),K(r,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cK={kernelName:Xh,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((s,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uK={kernelName:Hh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_t(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hK={kernelName:Kh,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>_t(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK={kernelName:Cc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,Yn(Fe(Ke(1),zt(Se(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pK={kernelName:Ec,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=Yn(de(Ke(1),zt(Se(t,"float32"))));return Ue(n,s)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK={kernelName:Rc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{const r=de(zt(t),zt(s));let a=X(n,Ue(s,r));const o=Sn(t.shape,i);return o.length>0&&(a=ze(a,o)),K(a,t.shape)},b:()=>{const r=de(zt(t),zt(s));let a=Jt(X(n,Ue(t,r)));const o=Sn(s.shape,i);return o.length>0&&(a=ze(a,o)),K(a,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mK={kernelName:kc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,de(zt(Se(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gK={kernelName:Nc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,Fe(Ke(1),zt(Se(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(n,e,t,s,i,r){const a=N(n,"dy","avgPool3dGrad"),o=N(e,"input","avgPool3dGrad");let l=a,c=o,u=!1;o.rank===4&&(u=!0,l=K(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),c=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),E(l.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${l.rank}.`),E(c.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${c.rank}.`),ms("avgPool3dGrad",i,r);const h={dy:l,input:c},d={filterSize:t,strides:s,pad:i,dimRoundingMode:r},p=W.runKernel(zm,h,d);return u?K(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}const bK=U({avgPool3dGrad_:yK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xK={kernelName:Yh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:a,dimRoundingMode:o}=t;return{x:()=>bK(n,s,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n,e,t,s,i){const r=N(n,"dy","avgPoolGrad"),a=N(e,"input","avgPoolGrad");E(a.rank===r.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${r.rank})`);let o=a,l=r,c=!1;a.rank===3&&(c=!0,o=K(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=K(r,[1,r.shape[0],r.shape[1],r.shape[2]])),E(l.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${l.rank}.`),E(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const u={dy:l,input:o},h={filterSize:t,strides:s,pad:i},d=W.runKernel(Gm,u,h);return c?K(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const wK=U({avgPoolGrad_:vK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SK={kernelName:Zh,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{filterSize:i,strides:r,pad:a}=t;return{x:()=>wK(n,s,i,r,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TK={kernelName:jh,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[s,i]=e,{transposeA:r,transposeB:a}=t;return!r&&!a?{a:()=>ft(n,i,!1,!0),b:()=>ft(s,n,!0,!1)}:!r&&a?{a:()=>ft(n,i,!1,!1),b:()=>ft(n,s,!0,!1)}:r&&!a?{a:()=>ft(i,n,!1,!0),b:()=>ft(s,n,!1,!1)}:{a:()=>ft(i,n,!0,!0),b:()=>ft(n,s,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _K={kernelName:Qh,gradFunc:(n,e,t)=>{const{blockShape:s,crops:i}=t;return{x:()=>sp(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IK={kernelName:aC,gradFunc:(n,e,t)=>{const s=t,i=s.inputShape,r=s.shape,a=Array.from(r);for(let l=i.length-1;l>=0;l--)if(i[l]===r[l])a[l]=1;else if(i[l]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${r}].`);const o=[];for(let l=0;l<a.length;l++)a[l]>1&&o.push(l);return{x:()=>ze(n,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MK={kernelName:Ac,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CK={kernelName:Lc,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK={kernelName:Pc,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{clipValueMin:i,clipValueMax:r}=t;return{x:()=>rs(Ti(ta(s,i),Ha(s,r)),n,_t(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kK={kernelName:Jh,inputsToSave:["x"],gradFunc:$E.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NK={kernelName:qh,saveAllInputs:!0,gradFunc:(n,e,t)=>{const s=e.map(o=>o.shape),{axis:i}=t,r=mt(i,e[0].shape)[0],a=s.map(o=>o[r]);return Cs(n,a,r).map(o=>()=>o)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RK={kernelName:ed,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{dilations:r,strides:a,pad:o,dataFormat:l}=t;return E(Pa(r),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`),{x:()=>$1(s.shape,n,i,a,o,l),filter:()=>Iv(s,n,i.shape,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AK={kernelName:td,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,{strides:r,pad:a,dataFormat:o,dimRoundingMode:l}=t;return{dy:()=>Hr(n,i,r,a,o,1,l),filter:()=>Iv(n,s,i.shape,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LK(n,e,t,s,i){let r=n;n.rank===4&&(r=K(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=K(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),E(r.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${r.shape}.`),E(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),E(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),E(r.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${r.shape[4]}) must match input depth in filter (${t[3]}.`),E(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:r,dy:a},l={strides:s,pad:i,filterShape:t};return W.runKernel($m,o,l)}const PK=U({conv3DBackpropFilter_:LK});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK={kernelName:nd,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r}=t;E(Pa(s),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const[a,o]=e;return{x:()=>PC(a.shape,n,o,i,r),filter:()=>PK(a,n,o.shape,i,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FK={kernelName:Dc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(Jt(ay(Se(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OK={kernelName:Fc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(oy(Se(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GK={kernelName:sd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i,exclusive:r,reverse:a}=t;return{x:()=>{const o=un([i],s.rank);let l=Kg(n,i,r,!a);return o!=null&&(l=xt(l,o)),l}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zK={kernelName:id,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:s,strides:i,pad:r,dimRoundingMode:a}=t,o=s??[1,1];E(Pa(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[l,c]=e;return E(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${l.rank}.`),E(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${c.rank}.`),E(l.shape[3]===c.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${l.shape[3]}) must match the inChannels dimension in filter ${c.shape[2]}.`),E(Qn(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),ms("depthwiseConv2d",r,a),{x:()=>KC(l.shape,n,c,i,r,o,a),filter:()=>HC(l,n,c.shape,i,r,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VK={kernelName:rd,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[s,i]=e,r={x:s,filter:i,dy:n},a={x:s,filter:i,dy:n};return{x:()=>W.runKernel(Zf,r,t),filter:()=>W.runKernel(Yf,a,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WK={kernelName:Gc,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,s={dy:n,y:t};return{x:()=>W.runKernel(eg,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UK={kernelName:zc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=X(Bs(Jt(zt(t))),2/Math.sqrt(Math.PI));return{x:()=>X(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BK={kernelName:Vc,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $K={kernelName:od,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>K(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XK={kernelName:Wc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,Bs(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HK={kernelName:Uc,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KK={kernelName:Bc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{const r=Ue(n,Se(s,"float32")),a=Sn(t.shape,i);return a.length>0?K(ze(r,a),t.shape):r},b:()=>{let r=X(n,Se(t,"float32"));const a=Sn(s.shape,i);a.length>0&&(r=K(ze(r,a),s.shape));const o=zt(s);return Jt(Ue(r,Se(o,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZK={kernelName:ld,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:s}=t,[i,r,a,o]=e,l=o??Ke(1),c=Sn(r.shape,i.shape),u=[];if(r.rank===1){for(let y=0;y<i.shape.length-1;++y)u.push(i.shape[y]);u.push(1)}const h=Fe(i,r),d=X(n,l),p=sy(de(a,Ke(s))),f=X(X(X(p,p),p),Ke(-.5));return{x:()=>r.rank===1?K(X(X(n,ei(K(p,[1,1,1,r.shape[0]]),u)),l),i.shape):K(X(X(n,p),l),i.shape),mean:()=>{let y=X(X(p,Ke(-1)),d);return r.rank===1&&(y=ze(y,c)),K(y,r.shape)},variance:()=>{let y=X(X(f,h),d);return r.rank===1&&(y=ze(y,c)),K(y,r.shape)},scale:()=>{const y=X(h,p);let m=X(n,y);return r.rank===1&&(m=ze(m,c)),K(m,r.shape)},offset:()=>{let y=n;return r.rank===1&&(y=ze(y,c)),K(y,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YK={kernelName:cd,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[s,i]=e,{axis:r}=t,a=mt(r,s.shape)[0];return{x:()=>{const o=s.shape,l=i.size,c=o.slice(0,a),u=c.length,h=o.slice(r,o.length).slice(1),d=h.length,p=II(0,u),f=II(u+1,u+1+d),y=MI([c,[l],h]),m=K(n,y),g=K(i,[l]),b=MI([[u],p,f]),x=xt(m,b);let v=dy(x,g,s.shape[a]);const w=Xa(b);return v=xt(v,w),v},indices:()=>i}}};function II(n,e){const t=[];for(let s=n;s<e;++s)t.push(s);return t}function MI(n){const e=[];for(let t=0;t<n.length;++t)for(let s=0;s<n[t].length;++s)e.push(n[t][s]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jK={kernelName:$c,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>_t(t),b:()=>_t(s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QK={kernelName:Xc,gradFunc:n=>({x:()=>Se(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JK={kernelName:Hc,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qK={kernelName:Kc,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eZ={kernelName:Zc,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tZ={kernelName:hd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{alpha:i}=t,r=gs(s,0);return{x:()=>rs(r,n,X(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nZ={kernelName:jc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,de(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sZ={kernelName:Yc,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,Se(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iZ={kernelName:oC,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;return{logits:()=>{const r=Bs(s);return Fe(n,X(ze(n,i,!0),r))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rZ(n,e,t,s=5,i=1,r=1,a=.5){const o={x:n,y:e,dy:t},l={depthRadius:s,bias:i,alpha:r,beta:a};return W.runKernel(lg,o,l)}const aZ=U({localResponseNormalizationBackprop_:rZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oZ={kernelName:yd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{depthRadius:r,bias:a,alpha:o,beta:l}=t;return{x:()=>aZ(s,i,n,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XE(n,e,t,s){return e.rank<t.rank&&(e=K(e,mn(e.shape,s))),n.rank<t.rank&&(n=K(n,mn(n.shape,s))),{x:()=>X(n,Se(Us(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CI={kernelName:bd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{reductionIndices:i}=s,r=e[0],a=e[1],o=mt(i,r.shape),l=XE(n,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lZ={kernelName:Qc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>X(n,Se(ta(t,s),"float32")),b:()=>X(n,Se(Yg(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cZ(n,e,t,s,i,r,a){const o=N(n,"dy","maxPool3dGrad"),l=N(e,"input","maxPool3dGrad"),c=N(t,"output","maxPool3dGrad");let u=o,h=l,d=c,p=!1;l.rank===4&&(p=!0,u=K(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),h=K(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]]),d=K(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]])),E(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),E(h.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${h.rank}.`),E(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),ms("maxPool3dGrad",r,a);const f={dy:u,input:h,output:d},y={filterSize:s,strides:i,pad:r,dimRoundingMode:a},m=W.runKernel(ug,f,y);return p?K(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const uZ=U({maxPool3dGrad_:cZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hZ={kernelName:vd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=t;return{x:()=>uZ(n,s,i,r,a,o,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dZ(n,e,t,s,i,r,a){const o=N(n,"dy","maxPoolGrad"),l=N(e,"input","maxPoolGrad"),c=N(t,"output","maxPoolGrad");E(l.rank===o.rank,()=>`Rank of input (${l.rank}) does not match rank of dy (${o.rank})`),E(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),E(l.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${l.rank}.`),ms("maxPoolGrad",r,a);const u={dy:o,input:l,output:c},h={filterSize:s,strides:i,pad:r,dimRoundingMode:a};return W.runKernel(cg,u,h)}const pZ=U({maxPoolGrad_:dZ});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fZ={kernelName:xd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s,i]=e,{filterSize:r,strides:a,pad:o}=t;return{x:()=>pZ(n,s,i,r,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mZ={kernelName:wd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t,r=mt(i,s.shape),a=Vn(s.shape,r)[1],o=re(a);return{x:()=>{const l=s.shape.slice();r.forEach(u=>{l[u]=1});const c=K(n,l);return Ue(X(c,Vs(s.shape,"float32")),o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gZ={kernelName:Sd,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const s=t,{axis:i}=s,[r,a]=e,o=mt(i,r.shape),l=XE(n,a,r,o);return{x:()=>l.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yZ={kernelName:Jc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e;return{a:()=>X(n,Se(Ha(t,s),"float32")),b:()=>X(n,Se(gs(t,s),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bZ={kernelName:Td,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(a=>a[0]);return{x:()=>Tt(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xZ={kernelName:qc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{const r=Sn(t.shape,i);return r.length>0?K(ze(n,r),t.shape):n},b:()=>{const r=X(n,Jt(_u(Ue(t,s)))),a=Sn(s.shape,i);return a.length>0?K(ze(r,a),s.shape):r}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vZ={kernelName:eu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{const r=X(n,Se(s,"float32")),a=Sn(t.shape,i);return a.length>0?K(ze(r,a),t.shape):r},b:()=>{const r=X(n,Se(t,"float32")),a=Sn(s.shape,i);return a.length>0?K(ze(r,a),s.shape):r}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wZ={kernelName:_d,gradFunc:n=>({x:()=>Jt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SZ={kernelName:Cd,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>vn(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TZ={kernelName:Md,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _Z={kernelName:Ed,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:s}=t;return ai(n,s).map(i=>()=>i)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EI={kernelName:kd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const s=e[0],{paddings:i}=t,r=i.map(a=>a[0]);return{x:()=>Tt(n,r,s.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IZ={kernelName:tu,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,s,i]=e,r=t,a=s,o=st(r.shape,a.shape);return{a:()=>{const l=Se(a,"float32");let c=X(n,X(l,Kr(r,Fe(l,Ke(1)))));const u=Sn(r.shape,o);return u.length>0&&(c=ze(c,u)),K(c,r.shape)},b:()=>{const l=gs(r,0),c=rs(l,$s(r),_t(r));let u=X(n,X(i,c));const h=Sn(a.shape,o);return h.length>0&&(u=ze(u,h)),K(u,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MZ={kernelName:Nd,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,s]=e,i=gs(t,0);return{x:()=>rs(i,n,X(n,s)),alpha:()=>{let r=rs(i,_t(n),X(n,t));const a=Sn(s.shape,n.shape);return a.length>0&&(r=ze(r,a)),K(r,s.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CZ(n,e,t){const s=n.shape.slice();s[t]=1;const i=K(e,s),r=Ph(n,t,!0,!1),a=Ph(n,t,!0,!0),o=X(r,a);return X(i,o)}function EZ(n,e,t){const s=n.shape.length,i=s-t.length,r=un(t,s);let a=n;r!=null&&(a=xt(n,r));const o=a.shape.slice(),l=o.splice(s-t.length,t.length).reduce((h,d)=>h*d,1);o.push(l);const c=a.reshape(o);let u=CZ(c,e,i);if(u=u.reshape(a.shape),r!=null){const h=Xa(r);u=xt(u,h)}return u}const kZ={kernelName:Rd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{axis:i}=t;let r=[];return i==null?r=s.shape.map((a,o)=>o):typeof i=="number"?r=[i]:r=i,{x:()=>EZ(s,n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NZ={kernelName:Oc,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{const r=Ue(n,Se(s,"float32")),a=Sn(t.shape,i);return a.length>0?K(ze(r,a),t.shape):r},b:()=>{let r=X(n,Se(t,"float32"));const a=Sn(s.shape,i);a.length>0&&(r=K(ze(r,a),s.shape));const o=zt(s);return Jt(Ue(r,Se(o,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RZ={kernelName:nu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,Jt(zt(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AZ={kernelName:iu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,s=X(Ha(t,6),sl(t));return{x:()=>X(n,Se(s,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LZ={kernelName:su,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,Se(sl(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PZ={kernelName:Ad,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>K(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DZ={kernelName:Pd,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>W.runKernel(Sg,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FZ={kernelName:Ld,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[s]=e,i={dy:n,images:s};return{images:()=>W.runKernel(wg,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OZ={kernelName:Dd,gradFunc:(n,e,t)=>{const{dims:s}=t,i=mt(s,n.shape);return{x:()=>ri(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GZ={kernelName:ru,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zZ={kernelName:au,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Jt(Ue(n,X(Kr(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VZ={kernelName:Fd,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Se(_t(t),"float32"),t:()=>X(n,Se(t,n.dtype)),e:()=>X(n,Se(ep(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WZ={kernelName:ou,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const s=gs(t,Ke(0)),i=Ke(My),r=Ke(Cy),a=X(n,r),o=X(X(n,i),Bs(Se(t,"float32")));return rs(s,a,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UZ={kernelName:hu,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,X(t,Fe(Ke(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BZ={kernelName:uu,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Z={kernelName:lu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(jd(Se(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XZ={kernelName:cu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(Hg(Se(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HZ={kernelName:Od,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{begin:i,size:r}=t,a=s.shape,[o,l]=_y(s,i,r),c=[];for(let u=0;u<n.rank;u++)c.push([o[u],a[u]-o[u]-l[u]]);return{x:()=>na(n,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KZ={kernelName:Wd,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[s]=e,{dim:i}=t,r=!0,a=X(n,s);return{logits:()=>Fe(a,X(ze(a,[i],r),s))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZZ={kernelName:du,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,Gi(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kI={kernelName:zd,gradFunc:(n,e,t)=>{const{blockShape:s,paddings:i}=t;return{x:()=>Yd(n,s,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NI={kernelName:Vd,gradFunc:(n,e,t)=>{const{axis:s}=t;return{x:()=>fn(n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YZ={kernelName:pu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,X(Yn(Se(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jZ={kernelName:Ng,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(n,X(Se(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QZ={kernelName:fu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=Ke(2);return{a:()=>X(n,X(i,Fe(t,s))),b:()=>X(n,X(i,Fe(s,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JZ={kernelName:xu,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qZ={kernelName:mu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,s]=e,i=st(t.shape,s.shape);return{a:()=>{let r=n;const a=Sn(t.shape,i);return a.length>0&&(r=ze(r,a)),K(r,t.shape)},b:()=>{let r=n;const a=Sn(s.shape,i);return a.length>0&&(r=ze(r,a)),K(Jt(r),s.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e4={kernelName:Gd,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,i=s.shape.slice(),{axis:r}=t;mt(r,s.shape).forEach(l=>{i[l]=1});const a=K(n,i),o=X(a,Vs(s.shape,"float32"));return{x:()=>o}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t4={kernelName:gu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Ue(n,zt(jd(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n4={kernelName:yu,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>X(Fe(Ke(1),zt(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s4={kernelName:bu,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[s]=e,{reps:i}=t;return{x:()=>{let r=_t(s);if(s.rank===1)for(let a=0;a<i[0];++a)r=de(r,Tt(n,[a*s.shape[0]],[s.shape[0]]));else if(s.rank===2)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)r=de(r,Tt(n,[a*s.shape[0],o*s.shape[1]],[s.shape[0],s.shape[1]]));else if(s.rank===3)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)for(let l=0;l<i[2];++l)r=de(r,Tt(n,[a*s.shape[0],o*s.shape[1],l*s.shape[2]],[s.shape[0],s.shape[1],s.shape[2]]));else if(s.rank===4)for(let a=0;a<i[0];++a)for(let o=0;o<i[1];++o)for(let l=0;l<i[2];++l)for(let c=0;c<i[3];++c)r=de(r,Tt(n,[a*s.shape[0],o*s.shape[1],l*s.shape[2],c*s.shape[3]],[s.shape[0],s.shape[1],s.shape[2],s.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${s.rank} tensors yet.`);return r}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i4={kernelName:Io,gradFunc:(n,e,t)=>{const s=t,{perm:i}=s,r=Xa(i);return{x:()=>xt(n,r)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r4={kernelName:Ud,gradFunc:(n,e,t)=>{const s=t,{axis:i}=s;return{value:()=>ps(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a4={kernelName:Bd,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>o4(n,t)}}};function o4(n,e){const t=vr(e,_t(e)),s=Iu(n,t);let i=ta(e,Ke(0,"int32"));const r=s.rank-i.rank;for(let o=0;o<r;++o)i=ns(i,o+1);i=Ti(i,Vs(s.shape,"bool"));const a=_t(s);return rs(i,s,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l4={kernelName:$d,gradFunc:n=>({x:()=>_t(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c4=[$E,aK,oK,lK,cK,uK,hK,dK,pK,fK,mK,gK,xK,SK,TK,_K,IK,MK,CK,EK,kK,NK,AK,RK,DK,FK,OK,GK,zK,VK,NZ,WK,UK,BK,$K,XK,KK,HK,ZK,YK,jK,QK,JK,qK,eZ,tZ,nZ,sZ,iZ,oZ,CI,CI,lZ,hZ,fZ,mZ,gZ,yZ,bZ,xZ,vZ,wZ,SZ,TZ,_Z,EI,EI,IZ,MZ,kZ,RZ,AZ,LZ,PZ,DZ,FZ,OZ,GZ,zZ,VZ,WZ,UZ,BZ,$Z,XZ,HZ,KZ,ZZ,kI,kI,NI,NI,YZ,QZ,jZ,JZ,qZ,e4,t4,n4,s4,i4,r4,a4,l4];for(const n of c4)lC(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.abs=function(){return this.throwIfDisposed(),xn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.acos=function(){return this.throwIfDisposed(),I1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.acosh=function(){return this.throwIfDisposed(),M1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.add=function(n){return this.throwIfDisposed(),de(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.all=function(n,e){return this.throwIfDisposed(),Bg(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.any=function(n,e){return this.throwIfDisposed(),Rh(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.argMax=function(n){return this.throwIfDisposed(),Do(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.argMin=function(n){return this.throwIfDisposed(),C1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asScalar=function(){return this.throwIfDisposed(),E(this.size===1,()=>"The array must have only 1 element."),K(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asType=function(n){return this.throwIfDisposed(),Se(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as1D=function(){return this.throwIfDisposed(),K(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as2D=function(n,e){return this.throwIfDisposed(),K(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),K(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as4D=function(n,e,t,s){return this.throwIfDisposed(),K(this,[n,e,t,s])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.as5D=function(n,e,t,s,i){return this.throwIfDisposed(),K(this,[n,e,t,s,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asin=function(){return this.throwIfDisposed(),E1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.asinh=function(){return this.throwIfDisposed(),k1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atan=function(){return this.throwIfDisposed(),N1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atan2=function(n){return this.throwIfDisposed(),R1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.atanh=function(){return this.throwIfDisposed(),A1(this)};le().prototype.avgPool=function(n,e,t,s){return this.throwIfDisposed(),Zd(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),Yd(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.batchNorm=function(n,e,t,s,i){return this.throwIfDisposed(),vu(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.broadcastTo=function(n){return this.throwIfDisposed(),Mo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cast=function(n){return this.throwIfDisposed(),Se(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.ceil=function(){return this.throwIfDisposed(),z1(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),ks(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Et&&(n=[n]),fn([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv1d=function(n,e,t,s,i,r){return this.throwIfDisposed(),$g(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv2dTranspose=function(n,e,t,s,i){return this.throwIfDisposed(),Xg(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.conv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),Hr(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cos=function(){return this.throwIfDisposed(),jd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cosh=function(){return this.throwIfDisposed(),Hg(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),Ph(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),Kg(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),K1(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.depthwiseConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),wu(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.dilation2d=function(n,e,t,s,i){return this.throwIfDisposed(),Z1(this,n,e,t,s,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.divNoNan=function(n){return this.throwIfDisposed(),Y1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.div=function(n){return this.throwIfDisposed(),Ue(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.dot=function(n){return this.throwIfDisposed(),j1(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.elu=function(){return this.throwIfDisposed(),Su(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.equal=function(n){return this.throwIfDisposed(),Us(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.erf=function(){return this.throwIfDisposed(),Q1(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),q1(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.exp=function(){return this.throwIfDisposed(),Bs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.expandDims=function(n){return this.throwIfDisposed(),ns(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.expm1=function(){return this.throwIfDisposed(),ev(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.fft=function(){return this.throwIfDisposed(),lp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.flatten=function(){return this.throwIfDisposed(),K(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.floor=function(){return this.throwIfDisposed(),_u(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.floorDiv=function(n){return this.throwIfDisposed(),Ug(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.gather=function(n,e){return this.throwIfDisposed(),Iu(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.greaterEqual=function(n){return this.throwIfDisposed(),ta(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.greater=function(n){return this.throwIfDisposed(),gs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.ifft=function(){return this.throwIfDisposed(),hc(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.irfft=function(){return this.throwIfDisposed(),cy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isFinite=function(){return this.throwIfDisposed(),tv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isInf=function(){return this.throwIfDisposed(),nv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.isNaN=function(){return this.throwIfDisposed(),sv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Jd(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.lessEqual=function(n){return this.throwIfDisposed(),Ha(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.less=function(n){return this.throwIfDisposed(),Yg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.localResponseNormalization=function(n,e,t,s){return this.throwIfDisposed(),iv(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSigmoid=function(){return this.throwIfDisposed(),rv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSoftmax=function(n){return this.throwIfDisposed(),Qg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),Jg(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.log=function(){return this.throwIfDisposed(),$s(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.log1p=function(){return this.throwIfDisposed(),qd(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Ti(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalNot=function(){return this.throwIfDisposed(),ep(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalOr=function(n){return this.throwIfDisposed(),qg(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.logicalXor=function(n){return this.throwIfDisposed(),av(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),ft(this,n,e,t)};le().prototype.maxPool=function(n,e,t,s){return this.throwIfDisposed(),tp(this,n,e,t,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.max=function(n,e){return this.throwIfDisposed(),si(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.maximum=function(n){return this.throwIfDisposed(),vr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mean=function(n,e){return this.throwIfDisposed(),on(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.min=function(n,e){return this.throwIfDisposed(),oc(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.minimum=function(n){return this.throwIfDisposed(),Mu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),lv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mod=function(n){return this.throwIfDisposed(),cv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.mul=function(n){return this.throwIfDisposed(),X(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.neg=function(){return this.throwIfDisposed(),Jt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Tu(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.notEqual=function(n){return this.throwIfDisposed(),zo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),lc(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.onesLike=function(){return this.throwIfDisposed(),Xs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.pad=function(n,e){return this.throwIfDisposed(),na(this,n,e)};le().prototype.pool=function(n,e,t,s,i,r){return this.throwIfDisposed(),uv(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.pow=function(n){return this.throwIfDisposed(),Kr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.prelu=function(n){return this.throwIfDisposed(),ip(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.prod=function(n,e){return this.throwIfDisposed(),hv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reciprocal=function(){return this.throwIfDisposed(),pv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.relu=function(){return this.throwIfDisposed(),Xi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.relu6=function(){return this.throwIfDisposed(),ty(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reshapeAs=function(n){return this.throwIfDisposed(),K(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reshape=function(n){return this.throwIfDisposed(),K(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),jC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),QC(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.reverse=function(n){return this.throwIfDisposed(),ri(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.rfft=function(){return this.throwIfDisposed(),cp(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.round=function(){return this.throwIfDisposed(),ny(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.rsqrt=function(){return this.throwIfDisposed(),sy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.selu=function(){return this.throwIfDisposed(),iy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.separableConv2d=function(n,e,t,s,i,r){return this.throwIfDisposed(),ry(this,n,e,t,s,i,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sigmoid=function(){return this.throwIfDisposed(),Gi(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sign=function(){return this.throwIfDisposed(),fv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sin=function(){return this.throwIfDisposed(),ay(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sinh=function(){return this.throwIfDisposed(),oy(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.slice=function(n,e){return this.throwIfDisposed(),Tt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.softmax=function(n){return this.throwIfDisposed(),op(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.softplus=function(){return this.throwIfDisposed(),tl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),sp(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.split=function(n,e){return this.throwIfDisposed(),Cs(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sqrt=function(){return this.throwIfDisposed(),Yn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.square=function(){return this.throwIfDisposed(),zt(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.squaredDifference=function(n){return this.throwIfDisposed(),uy(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.squeeze=function(n){return this.throwIfDisposed(),Ka(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Et?[this,n]:[this,...n];return ps(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.step=function(n){return this.throwIfDisposed(),sl(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.stridedSlice=function(n,e,t,s,i,r,a,o){return this.throwIfDisposed(),mv(this,n,e,t,s,i,r,a,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sub=function(n){return this.throwIfDisposed(),Fe(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.sum=function(n,e){return this.throwIfDisposed(),ze(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tan=function(){return this.throwIfDisposed(),gv(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tanh=function(){return this.throwIfDisposed(),Oo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.tile=function(n){return this.throwIfDisposed(),ei(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toBool=function(){return this.throwIfDisposed(),Se(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toFloat=function(){return this.throwIfDisposed(),Se(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.toInt=function(){return this.throwIfDisposed(),Se(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.topk=function(n,e){return this.throwIfDisposed(),bv(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.transpose=function(n){return this.throwIfDisposed(),xt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unique=function(n){return this.throwIfDisposed(),xv(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),dy(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.unstack=function(n){return this.throwIfDisposed(),ai(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.where=function(n,e){return this.throwIfDisposed(),rs(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */le().prototype.zerosLike=function(){return this.throwIfDisposed(),_t(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let pa=class HE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,HE.prototype)}},ar=class KE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,KE.prototype)}};class Z extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Z.prototype)}}let ct=class ZE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,ZE.prototype)}},u4=class YE extends Error{constructor(e){super(e),Object.setPrototypeOf(this,YE.prototype)}};/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jE{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const s=this.cache.keys().next().value;this.cache.delete(s)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const s=this.cache.keys().next().value;this.cache.delete(s)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uo(n,e){if(Array.isArray(n)){let t=[];for(let s=0;s<e;s++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function tr(n,e){if(!n)throw new u4(e)}function RI(n,e){let t=0;for(const s of n)s===e&&t++;return t}function _s(n){return n.length===1?n[0]:n}function Yt(n){return Array.isArray(n)?n:[n]}function kr(n){const e=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return e[0]!=="_"?e:"private"+e}function yo(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let ui={};function ow(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function ux(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>ux(e));else{const e=Object.keys(n);for(const t of e){const s=n[t];s!=null&&typeof s=="object"&&(!Array.isArray(s)&&s.type==="ndarray"&&typeof s.value=="number"?n[t]=s.value:ux(s))}}}function fp(n,e={},t={},s="object",i=!1){if(typeof n=="string"){const r=n;let a;if(r in t)a=t[r];else if(r in ui)a=ui[r];else if(a=e[r],a==null)throw new Z(`Unknown ${s}: ${n}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const r=n;if(r.className==null||r.config==null)throw new Z(`${s}: Improper config format: ${JSON.stringify(r)}.
'className' and 'config' must set.`);const a=r.className;let o,l;if(a in t?[o,l]=t[a]:a in ui?[o,l]=ui.className:a in e&&([o,l]=e[a]),o==null)throw new Z(`Unknown ${s}: ${a}. This may be due to one of the following reasons:
1. The ${s} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${s} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(l!=null){const c={};for(const p of Object.keys(ui))c[p]=ui[p];for(const p of Object.keys(t))c[p]=t[p];const u=r.config;u.customObjects=c;const h=Object.assign({},ui);for(const p of Object.keys(t))ui[p]=t[p];ux(r.config);const d=l(o,r.config,t,i);return ui=Object.assign({},h),d}else{const c=Object.assign({},ui);for(const h of Object.keys(t))ui[h]=t[h];const u=new o(r.config);return ui=Object.assign({},c),u}}}function h4(n,e){return n<e?-1:n>e?1:0}function hf(n,e){return-1*h4(n,e)}function Ea(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function d4(n){if(n==null)throw new Z(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function al(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new Z(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function lw(n,e,t=0,s=1/0){return tr(t>=0),tr(s>=t),Array.isArray(n)&&n.length>=t&&n.length<=s&&n.every(i=>typeof i===e)}function Dn(n,e){Array.isArray(n)?(E(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,s)=>Dn(t,`element ${s+1} of ${e}`))):E(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${QE(n)}.`)}function QE(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>QE(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function p4(n,e,t){let s=t!=null?t():Xn(),i;return(...r)=>{const a=t!=null?t():Xn();return a-s<e||(s=a,i=n(...r)),i}}function JE(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let f4=0;function qE(){return f4++}const df={};function Ey(n=""){return n in df||(df[n]=0),df[n]+=1,n+df[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const m4=["channelsFirst","channelsLast"],g4=["nearest","bilinear"],y4=["valid","same","causal"],b4=["max","avg"],x4=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const kl=new Map;function yn(n){al(m4,"DataFormat",n)}function v4(n){al(g4,"InterpolationFormat",n)}function oi(n){al(y4,"PaddingMode",n)}function ek(n){al(b4,"PoolMode",n)}const xh=[],AI="/";function Co(n,e){xh.push(n);try{const t=e();return xh.pop(),t}catch(t){throw xh.pop(),t}}function w4(){return xh.length===0?"":xh.join(AI)+AI}function tk(n){if(!sk(n))throw new Error("Not a valid tensor name: '"+n+"'");return w4()+n}function nk(n){if(!sk(n))throw new Error("Not a valid tensor name: '"+n+"'");kl.has(n)||kl.set(n,0);const e=kl.get(n);if(kl.set(n,kl.get(n)+1),e>0){const t=`${n}_${e}`;return kl.set(t,1),t}else return n}const S4=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function sk(n){return!!n.match(S4)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function T4(n){return n===parseInt(n.toString(),10)}function ka(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let s=1;for(let i=e;i<t;++i)s*=n[i];return s}function dc(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s<e&&(e=s)}return e}function Da(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const s=n[t];s>e&&(e=s)}return e}function Wi(n,e){if(e<n)throw new Z(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let s=n;s<e;++s)t.push(s);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Zb;function Cn(){return Zb==null&&(Zb=Gr().epsilon()),Zb}function Ui(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Yr(n,e){return Se(n,e)}function mp(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),K(n,t)}function _4(n,e){return j(()=>{if(n.shape.length!==2)throw new Z(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=mp(n,1);return hx(t,[1,e,1])})}function I4(n){const e=[ka(n.shape)];return K(n,e)}function M4(n){if(n.rank<=1)throw new Z(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],ka(n.shape,1)];return K(n,e)}function Eo(n,e,t){return j(()=>{switch(n.rank){case 1:return rp(n,e,t);case 2:return ly(n,[e,0],[t,n.shape[1]]);case 3:return ap(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return uc(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Tt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Tt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new Z(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Yb(n,e,t){return j(()=>{switch(n.rank){case 1:return rp(n,e,t);case 2:return ly(n,[0,e],[n.shape[0],t]);case 3:return ap(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return uc(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function pf(n,e,t,s){return j(()=>{switch(n.rank){case 1:return rp(n,e,t);case 2:switch(s){case 1:return Eo(n,e,t);case 2:return Yb(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}case 3:switch(s){case 1:return Eo(n,e,t);case 2:return ap(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Yb(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}case 4:switch(s){case 1:return Eo(n,e,t);case 2:return uc(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return uc(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Yb(n,e,t);default:throw new Z(`The axis is not within the rank of the tensor ${s}`)}default:throw new Z(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function cw(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),fn(n,e)}function LI(n,e){switch(n.rank){case 1:return V1([n,e]);case 2:return W1([n,e],0);case 3:return U1([n,e],0);case 4:return B1([n,e],0);default:throw new Z(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function hx(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new Z(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return ei(n,e)}function ky(n,e=0,t=1,s,i){return ey(n,e,t,s,i)}function dr(n,e,t,s){if(n.rank<2||e.rank<2)throw new ct(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],r=e.shape.slice(-2)[0];if(i!==r)throw new ct(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return ax({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?dx(n.rank,s,Ui()):null,activation:t});{const i=n.shape.slice(),r=i.pop();n=K(n,[-1,r]);const a=e.shape.slice(),o=a.pop(),l=a.pop(),c=[...a,o],u=Array.from({length:e.rank},(d,p)=>p===0?e.rank-2:p<=e.rank-2?p-1:p);e=K(xt(e,u),[l,-1]);const h=[...i,...c];return K(ax({a:n,b:e,transposeA:!1,transposeB:!1,bias:s?dx(n.rank,s,Ui()):null,activation:t}),h)}}function ik(n,e,t){return j(()=>(Array.isArray(e)?e=ss(e,"int32"):e=Se(e,"int32"),Iu(n,e,t)))}function gp(n){return X(n,n)}function dx(n,e,t){const s=e.shape;if(e.rank!==1&&e.rank!==n)throw new Z(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return s.length===1?K(e,[1,s[0],1,1,1]):K(e,[1,s[3],s[0],s[1],s[2]]);if(t==="channelsLast")return s.length===1?K(e,[1,1,1,1,s[0]]):K(e,[1].concat(s))}else if(n===4){if(t==="channelsFirst")return s.length===1?K(e,[1,s[0],1,1]):K(e,[1,s[2],s[0],s[1]]);if(t==="channelsLast")return s.length===1?K(e,[1,1,1,s[0]]):K(e,[1].concat(s))}else if(n===3){if(t==="channelsFirst")return s.length===1?K(e,[1,s[0],1]):K(e,[1,s[1],s[0]]);if(t==="channelsLast")return s.length===1?K(e,[1,1,s[0]]):K(e,[1].concat(s))}else if(n<3)return e;throw new Z(`Unsupported input rank by biasAdd: ${e.rank}`)}function Hi(n,e,t){return j(()=>(t==null&&(t=Ui()),yn(t),de(n,dx(n.rank,e,t))))}function C4(n,e=1){if(e!==1)throw new ct(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return Su(n)}function E4(n){return j(()=>Ue(n,de(xn(n),1)))}function rk(n,e,t,s){return j(()=>Tv(n,e,t,s))}function k4(n){return j(()=>{const e=de(.5,X(.2,n));return ks(e,0,1)})}function yp(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const N4=["fanIn","fanOut","fanAvg"],R4=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function A4(n){al(N4,"FanMode",n)}function L4(n){al(R4,"Distribution",n)}let Ii=class extends il{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}};class uw extends Ii{apply(e,t){return vn(e,t)}}uw.className="Zeros";pe(uw);let Ny=class extends Ii{apply(e,t){return Vs(e,t)}};Ny.className="Ones";pe(Ny);class hw extends Ii{constructor(e){if(super(),typeof e!="object")throw new Z(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new Z(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return j(()=>X(Ke(this.value),Vs(e,t)))}getConfig(){return{value:this.value}}}hw.className="Constant";pe(hw);class dw extends Ii{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Eu(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}dw.className="RandomUniform";pe(dw);class pw extends Ii{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ct(`randomNormal does not support dType ${t}.`);return ky(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}pw.className="RandomNormal";pe(pw);class fw extends Ii{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ct(`truncatedNormal does not support dType ${t}.`);return hy(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}fw.className="TruncatedNormal";pe(fw);class mw extends Ii{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return j(()=>{if(e.length!==2||e[0]!==e[1])throw new Z("Identity matrix initializer can only be used for 2D square matrices.");return X(this.gain,Zg(e[0]))})}getConfig(){return{gain:this.gain}}}mw.className="Identity";pe(mw);function P4(n,e="channelsLast"){let t,s;if(yn(e),n.length===2)t=n[0],s=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=ka(n,2);t=n[1]*i,s=n[0]*i}else if(e==="channelsLast"){const i=ka(n,0,n.length-2);t=n[n.length-2]*i,s=n[n.length-1]*i}}else{const i=ka(n);t=Math.sqrt(i),s=Math.sqrt(i)}return[t,s]}let Ns=class extends Ii{constructor(e){if(super(),e.scale<0)throw new Z(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,A4(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,L4(this.distribution),this.seed=e.seed}apply(e,t){const s=P4(e),i=s[0],r=s[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,i):this.mode==="fanOut"?a/=Math.max(1,r):a/=Math.max(1,(i+r)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new ct(`${this.getClassName()} does not support dType ${t}.`);return hy(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Eu(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}};Ns.className="VarianceScaling";pe(Ns);let Ry=class extends Ns{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Ry.className="GlorotUniform";pe(Ry);let Ay=class extends Ns{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Ay.className="GlorotNormal";pe(Ay);let Ly=class extends Ns{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Ly.className="HeNormal";pe(Ly);let Py=class extends Ns{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Py.className="HeUniform";pe(Py);let Dy=class extends Ns{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Dy.className="LeCunNormal";pe(Dy);let Fy=class extends Ns{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Ns.className}};Fy.className="LeCunUniform";pe(Fy);class gw extends Ii{constructor(e){if(super(),this.DEFAULT_GAIN=1,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed,this.seed!=null)throw new ct("Random seed is not implemented for Orthogonal Initializer yet.")}apply(e,t){return j(()=>{if(e.length<2)throw new ct("Shape must be at least 2D.");e[0]*e[1]>2e3&&console.warn(`Orthogonal initializer is being called on a matrix with more than 2000 (${e[0]*e[1]}) elements: Slowness may result.`);const s=e[0]>e[1]?[e[1],e[0]]:e,i=ky(s,0,1,"float32");let r=Cv.gramSchmidt(i);return e[0]>e[1]&&(r=xt(r)),X(this.gain,r)})}getConfig(){return{gain:this.gain,seed:this.seed}}}gw.className="Orthogonal";pe(gw);const PI={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function DI(n,e={}){return fp(n,rl.getMap().classNameMap,e,"initializer")}function ln(n){return ow(n)}function tn(n){if(typeof n=="string"){const e=n in PI?PI[n]:n;if(e==="GlorotNormal")return new Ay;if(e==="GlorotUniform")return new Ry;if(e==="HeNormal")return new Ly;if(e==="HeUniform")return new Py;if(e==="LeCunNormal")return new Dy;if(e==="LeCunUniform")return new Fy;{const t={};return t.className=e,t.config={},DI(t)}}else return n instanceof Ii?n:DI(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function px(n){return Array.isArray(n)&&Array.isArray(n[0])}function nm(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function Qe(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new Z(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function At(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new Z(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function sm(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((s,i)=>s*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const FI="Variable";class ak{constructor(e,t="float32",s=FI,i=!0,r=null){this.dtype=t??"float32",this.shape=e.shape,this.id=qE(),s=s??FI,this.originalName=tk(s),this.name=nk(this.originalName),this.trainable_=i,this.constraint=r,this.val=vv(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),D4(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function D4(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function fx(n){return n.map(e=>e.read())}function yw(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class wn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}let Di=class{constructor(e,t,s,i,r,a,o){this.dtype=e,this.shape=t,this.sourceLayer=s,this.inputs=i,this.callArgs=r,this.outputTensorIndex=o,this.id=qE(),a!=null&&(this.originalName=tk(a),this.name=nk(this.originalName)),this.rank=t.length}},F4=0;class Oy{constructor(e,t){this.callArgs=t,this.id=F4++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const s of e.inboundLayers)s!=null&&s.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let O4=0,yt=class extends il{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=O4++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const s=this.getClassName();t=kr(s)+"_"+Ey(s)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let s;if(e.batchInputShape!=null)s=e.batchInputShape;else if(e.inputShape!=null){let r=null;e.batchSize!=null&&(r=e.batchSize),s=[r].concat(e.inputShape)}this.batchInputShape=s;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new ar(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new Z(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return _s(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return _s(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new pa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new pa(`Layer ${this.name} is not connected, no input to return.`);return _s(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new pa(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new pa(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return _s(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){if(e=Yt(e),this.inputSpec==null||this.inputSpec.length===0)return;const t=Yt(this.inputSpec);if(e.length!==t.length)throw new Z(`Layer ${this.name} expects ${t.length} inputs, but it received ${e.length} input tensors. Input received: ${e}`);for(let s=0;s<e.length;s++){const i=e[s],r=t[s];if(r==null)continue;const a=i.rank;if(r.ndim!=null&&a!==r.ndim)throw new Z(`Input ${s} is incompatible with layer ${this.name}: expected ndim=${r.ndim}, found ndim=${a}`);if(r.maxNDim!=null&&a>r.maxNDim)throw new Z(`Input ${s} is incompatible with layer ${this.name}: expected max_ndim=${r.maxNDim}, found ndim=${a}`);if(r.minNDim!=null&&a<r.minNDim)throw new Z(`Input ${s} is incompatible with layer ${this.name}: expected min_ndim=${r.minNDim}, found ndim=${a}.`);if(r.dtype!=null&&i.dtype!==r.dtype)throw new Z(`Input ${s} is incompatible with layer ${this.name} : expected dtype=${r.dtype}, found dtype=${i.dtype}.`);if(r.axes){const o=i.shape;for(const l in r.axes){const c=Number(l),u=r.axes[l],h=c>=0?o[c]:o[o.length+c];if(u!=null&&[u,null].indexOf(h)===-1)throw new Z(`Input ${s} is incompatible with layer ${this.name}: expected axis ${c} of input shape to have value ${u} but got shape ${o}.`)}}if(r.shape!=null)for(let o=0;o<r.shape.length;++o){const l=r.shape[o],c=i.shape[o];if(l!=null&&c!=null&&l!==c)throw new Z(`Input ${s} is incompatible with layer ${this.name}: expected shape=${r.shape}, found shape=${i.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const s=Yt(e);let i=!0;for(const a of s)if(!(a instanceof Di)){i=!1;break}let r=!0;for(const a of s)if(a instanceof Di){r=!1;break}if(i===r)throw new Z("Arguments to apply() must be all SymbolicTensors or all Tensors");return Co(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of Yt(e))a.push(o.shape);this.build(_s(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);const o=Yt(a),l=[];for(let c of o)s.indexOf(c)!==-1&&(c=c.clone()),l.push(c);if(a=_s(l),this.activityRegularizer!=null)throw new ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=G4(e),o=this.computeOutputShape(a);let l;const c=z4(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?l=o.map((u,h)=>new Di(c,u,this,Yt(e),t,this.name,h)):l=new Di(c,o,this,Yt(e),t,this.name),this.addInboundNode(e,l,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new ct("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return l}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((s,i)=>{s!=null&&e[i]!=null&&e[i]!==s&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new pa(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const s=JSON.stringify(t.outputShapes);e.indexOf(s)===-1&&e.push(s)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new pa(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new ar(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return sm(this.weights)}build(e){this.built=!0}getWeights(e=!1){return fx(e?this.trainableWeights:this.weights)}setWeights(e){j(()=>{const t=this.weights;if(t.length!==e.length)throw new Z(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const s=[],i=fx(t);for(let r=0;r<i.length;++r){const a=i[r],o=t[r],l=e[r];if(!St(a.shape,l.shape))throw new Z(`Layer weight shape ${a.shape} not compatible with provided weight shape ${l.shape}`);s.push([o,l])}yw(s)})}addWeight(e,t,s,i,r,a,o,l){if(this._addedWeightNames.indexOf(e)!==-1)throw new Z(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),s==null&&(s="float32"),this.fastWeightInitDuringBuild&&(i=l!=null?l():tn("zeros"));const c=i.apply(t,s),u=new ak(c,s,e,a,o);return c.dispose(),r!=null&&this.addLoss(()=>r.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Yt(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(s=>{if(s!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}addInboundNode(e,t,s,i,r,a,o=null){const l=Yt(e);t=Yt(t),s=Yt(s),i=Yt(i),r=nm(r),a=nm(a);const c=[],u=[],h=[];for(const d of l)c.push(d.sourceLayer),u.push(d.nodeIndex),h.push(d.tensorIndex);new Oy({outboundLayer:this,inboundLayers:c,nodeIndices:u,tensorIndices:h,inputTensors:l,outputTensors:t,inputMasks:s,outputMasks:i,inputShapes:r,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}};function G4(n){n=Yt(n);const e=[];for(const t of n)e.push(t.shape);return _s(e)}function z4(n){return"float32"}function ok(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const s=e.inboundNodes[t];if(s.inboundLayers.length===0)return s.inputTensors;{const i=[];for(let r=0;r<s.inboundLayers.length;r++){const a=s.inputTensors[r],o=s.inboundLayers[r],l=s.nodeIndices[r],c=ok(a,o,l);for(const u of c)i.indexOf(u)===-1&&i.push(u)}return i}}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Ru extends yt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Ey("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new Z("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new Z("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new Z("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const s=e.dtype||"float32";this.batchInputShape=t,this.dtype=s,this.inputSpec=[{shape:t}];const i=new Di(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new Oy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Z(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}Ru.className="InputLayer";pe(Ru);function lk(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new Z("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new Ru({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function V4(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Se(e,n.dtype)}catch{throw new Z(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class xa{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof xa)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,s){if(this.id2Value[e.id]==null)this.id2Value[e.id]=V4(e,t),this.name2Id[e.name]=e.id,s!=null&&(this.id2Mask[e.id]=s);else throw new Z(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof Di){if(this.id2Value[e.id]==null)throw new Z(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof Di){if(this.id2Value[e.id]==null)throw new Z(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new Z(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&nt(this.id2Mask)}}const im=new jE,rm=new jE;function W4(n){im!=null&&im.setMaxEntries(n),rm!=null&&rm.setMaxEntries(n)}function dh(n,e,t,s){const i=t==null?!1:t.training,r=Array.isArray(n),a=r?n:[n],o=a.map(f=>f.name),l=[],c=e.names();for(const f of o)c.indexOf(f)!==-1?l.push(e.getValue(f)):l.push(null);s!=null&&(s.maxNumTensors=-1/0,s.minNumTensors=1/0);const u=o.join(",")+"|"+e.names().sort().join(",");let h=im.get(u),d;if(h==null){const f=U4(a,e);h=f.sorted,d=f.recipientCounts,im.put(u,h),rm.put(u,d)}d={},i||Object.assign(d,rm.get(u));const p=new xa(e);for(let f=0;f<h.length;++f){if(s!=null){const S=Nh().numTensors;S>s.maxNumTensors&&(s.maxNumTensors=S),S<s.minNumTensors&&(s.minNumTensors=S)}const y=h[f],m=y.sourceLayer;if(m instanceof Ru)continue;const g=[],b=[],x=[];let v=!1;for(const S of y.inputs){const M=p.getValue(S),A=p.getMask(S);g.push(M),b.push(A),A!=null&&(v=!0),i||(d[S.name]--,d[S.name]===0&&!e.hasKey(S)&&o.indexOf(S.name)===-1&&!M.isDisposed&&S.sourceLayer.stateful!==!0&&x.push(M))}v&&(t=t||{},t.mask=b[0]);const w=Yt(m.apply(g,t));let _=null;m.supportsMasking&&(_=m.computeMask(g,b));const I=$4(y),C=Array.isArray(I)?I:[I];for(let S=0;S<C.length;++S){p.hasKey(C[S])||p.add(C[S],w[S],Array.isArray(_)?_[0]:_);const M=o.indexOf(C[S].name);M!==-1&&(l[M]=w[S])}i||nt(x)}return p.disposeMasks(),r?l:l[0]}function U4(n,e){E(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],s={};if(n.length===1){const i=OI(n[0],e);t=i.sorted,s=i.recipientMap}else{const i=new Set;for(const r of n){const{sorted:a,recipientMap:o}=OI(r,e);for(const l of a)i.has(l.name)||(t.push(l),i.add(l.name));for(const l in o)s[l]==null&&(s[l]=new Set),o[l].forEach(c=>s[l].add(c))}}return{sorted:t,recipientCounts:B4(s)}}function B4(n){const e={};for(const t in n)e[t]=n[t].size;return e}function OI(n,e){const t=new Set,s=[],i={};for(const o of e.names())t.add(o);const r=[],a=[];for(r.push(n);r.length>0;){const o=r[r.length-1];if(t.has(o.name)){r.pop();continue}const l=a[a.length-1]===r.length-1;if(o.inputs.length===0||l)r.pop(),s.push(o),t.add(o.name),l&&a.pop();else{a.push(r.length-1);for(const c of o.inputs)i[c.name]==null&&(i[c.name]=new Set),i[c.name].add(o.name),!t.has(c.name)&&r.push(c)}}return{sorted:s,recipientMap:i}}function $4(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let s=0;s<n.sourceLayer.inboundNodes.length;++s)for(const i of n.sourceLayer.inboundNodes[s].outputTensors)if(i.id===n.id){t=s;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X4=ee();X4.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,W4);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bw(n,e){return j(()=>Yn(ze(X(n,n),e,!0)))}class bp extends il{getConfig(){return{}}}class xw extends bp{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{const t=bw(e,this.axis),s=ks(t,0,this.maxValue);return X(e,Ue(s,de(Cn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}xw.className="MaxNorm";pe(xw);class vw extends bp{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>Ue(e,de(Cn(),bw(e,this.axis))))}getConfig(){return{axis:this.axis}}}vw.className="UnitNorm";pe(vw);class ww extends bp{apply(e){return Xi(e)}}ww.className="NonNeg";pe(ww);class Sw extends bp{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return j(()=>{const t=bw(e,this.axis),s=de(X(this.rate,ks(t,this.minValue,this.maxValue)),X(1-this.rate,t));return X(e,Ue(s,de(Cn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Sw.className="MinMaxNorm";pe(Sw);const GI={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function kn(n){return ow(n)}function zI(n,e={}){return fp(n,rl.getMap().classNameMap,e,"constraint")}function Nn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in GI?GI[n]:n,config:{}};return zI(e)}else return n instanceof bp?n:zI(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function da(n){if(n==null)return;const e=[],t=[],s=[];for(const i in n){const r=n[i];if(typeof r!="number"){const a=r;e.push(a.data()),t.push(i),s.push(a)}}if(e.length>0){const i=await Promise.all(e);for(let r=0;r<i.length;++r)n[t[r]]=i[r][0];nt(s)}}function ck(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var VI;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(VI||(VI={}));const H4=125;let pc=class{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}};class uk{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const s of this.callbacks)await s.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class K4 extends pc{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const s=t.size==null?0:t.size;this.seen+=s;for(const i in t){const r=t[i];if(typeof r=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+r*s;else{let a;i in this.totals?a=this.totals[i]:this.totals[i]=0;const o=j(()=>de(this.totals[i],X(r,s)));this.totals[i]=o,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const s of this.params.metrics)this.totals[s]!=null&&(typeof this.totals[s]=="number"?t[s]=this.totals[s]/this.seen:j(()=>{const i=X(Ue(1,this.seen),this.totals[s]);t[s]=i,this.totals[s].dispose(),hn(t[s])}))}}class hk extends pc{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const s in t)this.history[s]==null&&(this.history[s]=[]),this.history[s].push(t[s])}async syncData(){const e=[],t=[],s=[];for(const r in this.history){const a=this.history[r];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const l=a[o];e.push(l.data()),t.push(r),s.push(o)}}const i=await Promise.all(e);for(let r=0;r<i.length;++r)this.history[t[r]][s[r]].dispose(),this.history[t[r]][s[r]]=i[r][0]}}class dk extends pc{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||up,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=H4),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Hf(this.yieldEvery)&&(this.maybeWait=p4(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,s){const i=[];this.yield!=null&&(await da(s),i.push(this.yield(e,t,s))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await da(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const s=[];this.epochEnd!=null&&(await da(t),s.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&s.push(this.nextFrameFunc()),await Promise.all(s)}async onBatchBegin(e,t){this.batchBegin!=null&&(await da(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const s=[];this.batchEnd!=null&&(await da(t),s.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?s.push(this.nextFrameFunc()):Hf(this.yieldEvery)&&s.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(s)}async onTrainBegin(e){this.trainBegin!=null&&(await da(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await da(e),await this.trainEnd(e))}}function pk(n,e){return n==null&&(n={}),n instanceof pc?[n]:Array.isArray(n)&&n[0]instanceof pc?n:Yt(n).map(t=>new dk(t,e))}let Tw=class Qi{constructor(){}static registerCallbackConstructor(e,t){E(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),Qi.checkForDuplicate(t),Qi.constructors[e]==null&&(Qi.constructors[e]=[]),Qi.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Qi.constructors)Qi.constructors[+t].forEach(s=>{if(s===e)throw new Z("Duplicate callback constructor.")})}static clear(){Qi.constructors={}}static createCallbacks(e){const t=[];for(const s in Qi.constructors){const i=+s;e>=i&&t.push(...Qi.constructors[i])}return t.map(s=>new s)}};Tw.constructors={};function fk(n,e,t,s,i,r,a,o,l){const c=new hk,u=[new K4,...Tw.createCallbacks(e)];n!=null&&u.push(...n),u.push(c);const h=new uk(u);return h.setParams({epochs:t,initialEpoch:s,samples:i,steps:r,batchSize:a,verbose:e,doValidation:o,metrics:l}),{callbackList:h,history:c}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function zi(n,e={},t=!1){return fp(n,rl.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function am(n,e){return j(()=>{n.dtype!=="float32"&&(n=Se(n,"float32"));const t=ze(gp(n),e,!0),s=el(t.shape,Cn()),i=Yn(vr(t,s));return Ue(n,i)})}function ol(n,e){return j(()=>on(gp(Fe(e,n)),-1))}function Gy(n,e){return j(()=>on(xn(Fe(e,n)),-1))}function Au(n,e){return j(()=>{const t=Fe(n,e),s=ks(xn(n),Cn(),Number.MAX_VALUE),i=xn(Ue(t,s));return X(100,on(i,-1))})}function Z4(n,e){return j(()=>{const t=ks(e,Cn(),Number.MAX_VALUE),s=$s(de(1,t)),i=ks(n,Cn(),Number.MAX_VALUE),r=$s(de(1,i));return on(gp(Fe(s,r)),-1)})}function Y4(n,e){return j(()=>{const t=vr(0,Fe(1,X(n,e)));return on(gp(t),-1)})}function j4(n,e){return j(()=>{const t=vr(0,Fe(1,X(n,e)));return on(t,-1)})}function Q4(n,e){return j(()=>{const t=ze(X(n,e),-1),s=si(X(Fe(1,n),e),-1);return vr(0,de(1,Fe(s,t)))})}function J4(n,e){return j(()=>{const t=Math.log(2),s=Fe(e,n),i=Fe(de(s,tl(X(-2,s))),t);return on(i,-1)})}function Dh(n,e,t=!1){return j(()=>{if(t)e=op(e);else{const s=ze(e,e.shape.length-1,!0);e=Ue(e,s)}return e=ks(e,Cn(),1-Cn()),Jt(ze(X(Se(n,"float32"),$s(e)),e.shape.length-1))})}function om(n,e,t=!1){return j(()=>{const s=Se(_u(I4(n)),"int32");e=ks(e,Cn(),1-Cn());const i=e.shape,r=K(lc(s,i[i.length-1]),i);return Dh(r,e,t)})}function q4(n,e){if(!St(n.shape,e.shape))throw new Z(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return j(()=>{const t=Xi(e),s=Jt(xn(e));return de(Fe(t,X(e,n)),qd(Bs(s)))})}function zy(n,e){return j(()=>{let t;return t=ks(e,Cn(),1-Cn()),t=$s(Ue(t,Fe(1,t))),on(q4(n,t),-1)})}function e5(n,e){return j(()=>{const t=ks(n,Cn(),1),s=ks(e,Cn(),1);return ze(X(n,$s(Ue(t,s))),-1)})}function t5(n,e){return j(()=>{const t=$s(de(Cn(),e));return on(Fe(e,X(n,t)),-1)})}function _w(n,e){return j(()=>{const t=am(n,-1),s=am(e,-1),i=X(t,s);return Jt(ze(i,-1))})}const lm={meanSquaredError:ol,meanAbsoluteError:Gy,meanAbsolutePercentageError:Au,meanSquaredLogarithmicError:Z4,squaredHinge:Y4,hinge:j4,categoricalHinge:Q4,logcosh:J4,categoricalCrossentropy:Dh,sparseCategoricalCrossentropy:om,binaryCrossentropy:zy,kullbackLeiblerDivergence:e5,poisson:t5,cosineProximity:_w};function jb(n){if(typeof n=="string"){if(n in lm)return lm[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new Z(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Iw(n,e){return j(()=>{const t=X(.5,Xs(e)),s=Yr(gs(e,t),n.dtype);return on(Us(n,s),-1)})}function Mw(n,e){return j(()=>Yr(Us(Do(n,-1),Do(e,-1)),"float32"))}function mk(n,e){return j(()=>Se(ze(Ti(Us(n,1),Us(e,1))),"float32"))}function n5(n,e){return j(()=>Se(ze(Ti(Us(n,1),Us(e,0))),"float32"))}function s5(n,e){return j(()=>Se(ze(Ti(Us(n,0),Us(e,1))),"float32"))}function gk(n,e){return j(()=>{const t=mk(n,e),s=s5(n,e),i=de(t,s);return Se(rs(gs(i,0),Ue(t,i),0),"float32")})}function i5(n,e){return j(()=>{const t=mk(n,e),s=n5(n,e),i=de(t,s);return Se(rs(gs(i,0),Ue(t,i),0),"float32")})}function yk(n,e){return zy(n,e)}function bk(n,e){return n.rank===e.rank&&(n=Ka(n,[n.rank-1])),e=Do(e,-1),e.dtype!==n.dtype&&(e=Se(e,n.dtype)),Se(Us(n,e),"float32")}const r5=ol,a5=ol,o5=Gy,l5=Gy,c5=Au,u5=Au,Cw=Dh,h5=_w,xk=om,cm={binaryAccuracy:Iw,categoricalAccuracy:Mw,precision:gk,categoricalCrossentropy:Cw,sparseCategoricalCrossentropy:xk,mse:r5,MSE:a5,mae:o5,MAE:l5,mape:c5,MAPE:u5,cosine:h5};function d5(n){if(typeof n=="string"&&n in cm)return cm[n];if(typeof n!="string"&&n!=null)return n;throw new Z(`Unknown metric ${n}`)}function ff(n){if(tr(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(lm))if(lm[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(cm))if(cm[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function p5(n){const e={Adagrad:()=>po.adagrad(.01),Adadelta:()=>po.adadelta(1,.95,Cn()),Adam:()=>po.adam(.001,.9,.999,Cn()),Adamax:()=>po.adamax(.002,.9,.999,Cn(),0),RMSProp:()=>po.rmsprop(.001,.9,0,Cn()),SGD:()=>po.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new Z(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const WI=1*1024*1024;function UI(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!mx(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const s=JSON.stringify(n);s.length>WI&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${s.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${WI}.`)}}function mx(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!mx(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!mx(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function f5(n,e,t,s=console.log){const i=g5(n),r=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let a;if(!i){r.push("Receives inputs"),a=[];for(const u in n.nodesByDepth)a.push(...n.nodesByDepth[u])}s("_".repeat(e)),um(r,t,s),s("=".repeat(e));const o=n.layers;for(let u=0;u<o.length;++u)i?y5(o[u],t,s):b5(o[u],t,a,s),s((u===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const l=m5(n),c=sm(n.nonTrainableWeights);s(`Total params: ${l+c}`),s(`Trainable params: ${l}`),s(`Non-trainable params: ${c}`),s("_".repeat(e))}function m5(n){let e;return n.collectedTrainableWeights!=null?e=sm(n.collectedTrainableWeights):e=sm(n.trainableWeights),e}function g5(n){let e=!0;const t=[],s=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}s.push(...i)}if(e)for(const i of n.layers){let r=!1;for(const a of i.inboundNodes)if(s.indexOf(a)!==-1)if(r){e=!1;break}else r=!0;if(!e)break}return e}function um(n,e,t=console.log){let s="";for(let i=0;i<n.length;++i)i>0&&(s=s.slice(0,s.length-1)+" "),s+=n[i],s=s.slice(0,e[i]),s+=" ".repeat(e[i]-s.length);t(s)}function y5(n,e,t){let s,i;try{i=n.inboundNodes.map(l=>JSON.stringify(l.inputShapes)).join(",")}catch{i="multiple"}try{s=JSON.stringify(n.outputShape)}catch{s="multiple"}const r=n.name,a=n.getClassName(),o=[`${r} (${a})`,i,s,n.countParams().toString()];um(o,e,t)}function b5(n,e,t,s){let i,r;try{r=n.inboundNodes.map(h=>JSON.stringify(h.inputShapes)).join(",")}catch{r="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const a=[];for(const h of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(h)===-1))for(let d=0;d<h.inboundLayers.length;++d){const p=h.inboundLayers[d].name,f=h.nodeIndices[d],y=h.tensorIndices[d];a.push(`${p}[${f}][${y}]`)}const o=n.name,l=n.getClassName(),c=a.length===0?"":a[0],u=[`${o} (${l})`,r,i,n.countParams().toString(),c];um(u,e,s);for(let h=1;h<a.length;++h)um(["","","","",a[h]],e,s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function vk(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Fh(n,e){if(n===null)return null;if(typeof n=="string")return yo(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];vk(e,i,r)?t.push(r):t.push(Fh(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s];if(s==="name"&&typeof i=="string")t[s]=i;else{const r=yo(s);t[r]=Fh(i,r)}}return t}}function gx(n,e){if(n==null)return null;if(typeof n=="string")return kr(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],s=n.length;for(let i=0;i<s;++i){const r=n[i];vk(e,i,r)?t.push(r):t.push(gx(r,e))}return t}else{const t={};for(const s of Object.keys(n)){const i=n[s],r=kr(s);(s==="name"||s==="className")&&typeof i=="string"?t[r]=i:t[r]=gx(i,s)}return t}}/** @license See the LICENSE file. */const Vy="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let x5=class Ji extends yt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const b=this.getClassName().toLowerCase();this.name=Ey(b)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ea(this.inputs).length!==this.inputs.length)throw new Z(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(b=>b.name)}`);Ea(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(b=>b.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const b of this.outputs){const x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;this.outputLayers.push(x),this.outputLayersNodeIndices.push(v),this.outputLayersTensorIndices.push(w)}for(const b of this.inputs){const x=b.sourceLayer,v=b.nodeIndex,w=b.tensorIndex;tr(v===0,"input layer has >1 nodes"),tr(w===0,"input layer has >1 tensors"),this.inputLayers.push(x),this.inputLayersNodeIndices.push(v),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let b=0;b<this.inputLayers.length;b++){const x=this.inputLayers[b];if(!(x instanceof Ru))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${b} (0-based) originates from layer type ${x.getClassName()}.`);this.inputNames.push(x.name),this.feedInputShapes.push(x.batchInputShape),this.feedInputNames.push(x.name)}for(const b of this.outputLayers)this.outputNames.push(b.name);this.internalInputShapes=this.inputs.map(b=>b.shape),this.internalOutputShapes=this.outputs.map(b=>b.shape);const t={},s={},i={},r={},a={},o=[],l=(b,x,v,w,_,I)=>{(w==null||_==null||I==null)&&(w=b.sourceLayer,_=b.nodeIndex,I=b.tensorIndex);const C=w.inboundNodes[_];if(v.indexOf(C)!==-1)throw new ar(`The tensor ${b.name} at layer "${w.name}" is part of a cycle.`);if(x.indexOf(C)!==-1)return;this.containerNodes.add(Ji.nodeKey(w,_)),w.id in a||(a[w.id]=Object.keys(a).length),v.indexOf(C)===-1&&v.push(C);const S=C.inboundLayers.length;for(let M=0;M<S;M++){const A=C.inputTensors[M],D=C.inboundLayers[M],F=C.nodeIndices[M],k=C.tensorIndices[M];l(A,x,v,D,F,k)}for(x.push(C);v.indexOf(C)>=0;)v.splice(v.indexOf(C),1);o.push(C)},c=[],u=[];for(const b of this.outputs)l(b,c,u);const h=o.slice().reverse();for(const b of h){s[b.id]=b,b.id in t||(t[b.id]=0);let x=t[b.id];const v=i[b.outboundLayer.id]==null?0:i[b.outboundLayer.id];x=Math.max(x,v),i[b.outboundLayer.id]=x,r[b.outboundLayer.id]=b.outboundLayer,t[b.id]=x;for(let w=0;w<b.inboundLayers.length;w++){const _=b.inboundLayers[w],I=b.nodeIndices[w],C=_.inboundNodes[I],S=t[C.id]==null?0:t[C.id];t[C.id]=Math.max(x+1,S),s[C.id]=C}}const d={};for(const b in t){const x=t[b];x in d||(d[x]=[]),d[x].push(s[b])}const p={};for(const b in i){const x=i[b];x in p||(p[x]=[]),p[x].push(r[b])}let f=Object.keys(p).map(b=>parseInt(b,10)).sort(hf);this.layers=[];for(const b of f){const x=p[b];x.sort((v,w)=>{const _=a[v.id],I=a[w.id];return _<I?-1:_>I?1:0});for(const v of x)v instanceof Ji&&this.internalContainerRefs.push(v),this.layers.push(v)}this.layersByDepth=p,f=Object.keys(d).map(b=>parseInt(b,10)).sort(hf);const y=this.inputs.slice(),m=[];for(const b of f)for(const x of d[b]){const v=x.outboundLayer;if(v!=null){for(const w of x.inputTensors)if(y.indexOf(w)===-1)throw new ar(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${v.name}". The following previous layers were accessed without issue: ${m}`);for(const w of x.outputTensors)y.push(w);m.push(v.name)}}this.nodesByDepth=d;const g=this.layers.map(b=>b.name);for(const b of g){const x=g.filter(v=>v===b).length;if(x!==1)throw new ar(`The name "${b}" is used ${x} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new Oy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(b=>null),outputMasks:this.outputs.map(b=>null),inputShapes:this.inputs.map(b=>b.shape),outputShapes:this.outputs.map(b=>b.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(s=>s.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Z("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.layers)t.push(...s.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const s={};let i=0;for(const a of this.layers)for(const o of a.weights){if(s[o.originalName]!=null)throw new Z(`Duplicate weight name: ${o.originalName}`);s[o.originalName]=o,i++}const r=[];for(const a in e){let o=a;if(s[a]==null){const l=a.split("/");o=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(s[o]!=null)r.push([s[o],e[a]]);else if(t)throw new Z(`Provided weight data has no target variable: ${a}`);delete s[o]}if(t){const a=[];for(const o in s)a.push(o);if(a.length>0)throw new Z(`${a.length} of ${i} weights are not set: ${a}`)}yw(r)}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${Vy}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const s=gx(this.updatedConfig());return t?JSON.stringify(s):s}call(e,t){return j(()=>{e=Yt(e);const s=new xa;for(let i=0;i<this.inputs.length;++i)s.add(this.inputs[i],e[i]);return dh(this.outputs,s,t)})}computeMask(e,t){return j(()=>{e=Yt(e);let s;return t==null?s=Uo(null,e.length):s=Yt(t),this.runInternalGraph(e,s)[1]})}computeOutputShape(e){const t=nm(e);if(t.length!==this.inputLayers.length)throw new Z(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const s={};for(let o=0;o<t.length;o++){const l=this.inputLayers[o],c=t[o],u=l.name+"_0_0";s[u]=c}const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(hf);if(i.length>1)for(const o of i){const l=this.nodesByDepth[o];for(const c of l){const u=c.outboundLayer;if(this.inputLayers.map(y=>y.id).indexOf(u.id)!==-1)continue;const h=[];for(let y=0;y<c.inboundLayers.length;y++){const m=c.inboundLayers[y],g=c.nodeIndices[y],b=c.tensorIndices[y],x=`${m.name}_${g}_${b}`,v=s[x];h.push(v)}const d=u.computeOutputShape(_s(h)),p=nm(d),f=u.inboundNodes.indexOf(c);for(let y=0;y<p.length;y++){const m=`${u.name}_${f}_${y}`;s[m]=p[y]}}}const r=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const l=this.outputLayers[o],c=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],h=`${l.name}_${c}_${u}`;a.push(h)}for(let o=0;o<a.length;o++){const l=a[o];tr(l in s),r.push(s[l])}return _s(r)}runInternalGraph(e,t){t==null&&(t=Uo(null,e.length));const s={};for(let l=0;l<this.inputs.length;++l){const c=this.inputs[l],u=e[l],h=t[l];s[c.id]=[u,h]}const i=Object.keys(this.nodesByDepth).map(l=>parseInt(l,10)).sort(hf);for(const l of i){const c=this.nodesByDepth[l];for(const u of c){const h=u.outboundLayer,d=u.inputTensors,p=u.outputTensors,f=new Array;for(const y of d)y.id in s&&f.push(s[y.id]);if(f.length===d.length){let y={},m,g,b,x;if(u.callArgs!=null&&(y=u.callArgs),f.length===1){const[v,w]=f[0];y.mask==null&&(y.mask=w),b=Yt(h.call(v,y)),x=Yt(h.computeMask(v,w)),m=[v],g=[w]}else m=f.map(v=>v[0]),g=f.map(v=>v[1]),y.mask==null&&(y.mask=g),b=Yt(h.call(m,y)),x=Yt(h.computeMask(m,g));if(h.activityRegularizer)throw new ct("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let v=0;v<p.length;++v){const w=p[v],_=b[v],I=x[v];s[w.id]=[_,I]}}}}const r=[],a=[],o=[];for(const l of this.outputs){tr(l.id in s,`Could not compute output ${l.name} : ${l.id}`);const[c,u]=s[l.id];o.push(c.shape),r.push(c),a.push(u)}return[r,a,o]}buildNodeConversionMap(e){const t={};let s;for(const i of this.layers){s=i instanceof Ji?1:0;for(let r=0;r<i.inboundNodes.length;r++){const a=Ji.nodeKey(i,r);this.containerNodes.has(a)&&(t[a]=s,s+=1)}}return t}getLayer(e,t){if(t!=null){if(this.layers.length<=t)throw new Z(`Was asked to retrieve layer at index ${t}, but model only has ${this.layers.length} layer(s).`);return this.layers[t]}else if(e==null)throw new Z("Provide either a layer name or layer index");for(const s of this.layers)if(s.name===e)return s;throw new Z(`No such layer: ${e}`)}calculateLosses(){return j(()=>{const e=[];for(const t of this.layers)for(let s=0;s<t.inboundNodes.length;++s){const i=Ji.nodeKey(t,s);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),s=[];for(const a of this.layers){const o=a.getClassName(),l=a.getConfig(),c=[];for(let h=0;h<a.inboundNodes.length;h++){const d=a.inboundNodes[h],p=Ji.nodeKey(a,h);let f={};if(this.containerNodes.has(p)){if(d.callArgs)try{JSON.stringify(d.callArgs),f=d.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),f={}}if(d.inboundLayers.length>0){const y=[];for(let m=0;m<d.inboundLayers.length;m++){const g=d.inboundLayers[m],b=d.nodeIndices[m],x=d.tensorIndices[m],v=Ji.nodeKey(g,b);let w=t[v];w==null&&(w=0),y.push([g.name,w,x,f])}c.push(y)}}}const u={};u.name=a.name,u.className=o,u.config=l,u.inboundNodes=c,s.push(u)}e.layers=s;const i=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],l=this.inputLayersNodeIndices[a],c=Ji.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.inputLayersTensorIndices[a];i.push([o.name,u,h])}e.inputLayers=i;const r=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],l=this.outputLayersNodeIndices[a],c=Ji.nodeKey(o,l);if(!this.containerNodes.has(c))continue;let u=t[c];u==null&&(u=0);const h=this.outputLayersTensorIndices[a];r.push([o.name,u,h])}return e.outputLayers=r,e}static fromConfig(e,t,s={},i=!1){const r={},a={};function o(m,g){m.name in a?a[m.name].push(g):a[m.name]=[g]}function l(m,g){const b=[];let x;for(const v of g){const w=v[0],_=v[1],I=v[2];if(x=v[3]==null?{}:v[3],!(w in r)){o(m,g);return}const C=r[w];if(C.inboundNodes.length<=_){o(m,g);return}const S=C.inboundNodes[_];b.push(S.outputTensors[I])}b.length>0&&m.apply(_s(b),x)}function c(m){const g=m.name,b=zi(m,t.customObjects!=null?t.customObjects:{});b.setFastWeightInitDuringBuild(i),r[g]=b,m.inboundNodes.forEach(x=>{if(!(x instanceof Array))throw new Z(`Corrupted configuration, expected array for nodeData: ${x}`);o(b,x)})}const u=t.name,h=t.layers;for(const m of h)c(m);for(;!d4(a);)for(const m of h){const g=r[m.name];if(g.name in a){const b=a[g.name];delete a[g.name];for(const x of b)l(g,x)}}const d=[],p=[],f=t.inputLayers;for(const m of f){const g=m[0],b=m[1],x=m[2];tr(g in r);const v=r[g].inboundNodes[b].outputTensors;d.push(v[x])}const y=t.outputLayers;for(const m of y){const g=m[0],b=m[1],x=m[2];tr(g in r);const v=r[g].inboundNodes[b].outputTensors;p.push(v[x])}return new e({inputs:d,outputs:p,name:u})}get stateful(){if(this._stateful)throw new Z("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){j(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function v5(n,e,t){const s=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(s===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==s)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${s} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(r=>{r in n?i.push(n[r]):i.push(null)}),i}else throw new Error(`The model has multiple (${s}) outputs, so ${t} must be either an array with ${s} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function wk(n,e){return v5(n,e,"classWeight")}async function Sk(n,e,t,s){if(e!=null||s!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const i=j(()=>{if(n.shape.length===1)return ur(n);if(n.shape.length===2){if(n.shape[1]>1)return Do(n,1);if(n.shape[1]===1)return K(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),r=Array.from(await i.data());nt(i);const a=[];return r.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),ss(a,"float32")}else return null}function w5(n,e){return X(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const S5=32;function Tk(n,e){let t,s;const i=e;t=i.xs,s=i.ys,E(t!=null&&s!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const r=BI("input",n.inputNames,t),a=BI("output",n.outputNames,s),o=r[0].shape[0];E(r.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${r.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),E(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let l=0;l<r.length;l++)E(r[l].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[l]} has ${r[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let l=0;l<a.length;l++)E(a[l].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[l]} has ${a[l].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:r,ys:a}}function BI(n,e,t){if(t instanceof Et)return[t];if(Array.isArray(t))return E(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const s=[];for(const i of e){if(t[i]==null)throw new Z(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);s.push(t[i])}return s}}function T5(n){if(n.length===3)throw new ct("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function _5(n,e,t){const s=t.batchesPerEpoch!=null;if(E(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),E(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),E(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),E(!s||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),E(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let r,a;if(i)if($I(t.validationData))E(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const m=T5(t.validationData);r=m.xs,a=m.ys}const o=n.makeTrainFunction(),l=n.getDedupedMetricsNames();let c;i?c=l.slice().concat(l.map(m=>"val_"+m)):c=l.slice();const u=pk(t.callbacks,t.yieldEvery),h=t.verbose==null?1:t.verbose,{callbackList:d,history:p}=fk(u,h,t.epochs,null,null,I5(e,t),null,i,c);d.setModel(n),n.history=p,await d.onTrainBegin(),n.stopTraining_=!1;let f=t.initialEpoch==null?0:t.initialEpoch,y=await e.iterator();for(;f<t.epochs;){const m={};await d.onEpochBegin(f);let g=0,b=0;for(s||(y=await e.iterator());!s||g<t.batchesPerEpoch;){const x=await y.next();if(s&&x.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${g} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(x.value!=null){const{xs:v,ys:w}=Tk(n,x.value),_={};_.batch=b,_.size=v[0].shape[0],await d.onBatchBegin(b,_);const I=[];if(t.classWeight!=null){const M=wk(t.classWeight,n.outputNames);for(let A=0;A<M.length;++A)I.push(await Sk(w[A],null,M[A]))}const C=v.concat(w).concat(I),S=o(C);nt(C);for(let M=0;M<l.length;++M){const A=l[M],D=S[M];_[A]=D,hn(D)}await d.onBatchEnd(b,_),ck(_),b++,g++}if(s?g>=t.batchesPerEpoch:x.done){if(i){let v;$I(t.validationData)?v=Yt(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):v=Yt(n.evaluate(r,a,{batchSize:t.validationBatchSize==null?S5:t.validationBatchSize,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)m[`val_${n.metricsNames[w]}`]=v[w]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(f,m),f++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function I5(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function $I(n){return typeof n.iterator=="function"}function M5(n){return typeof n.next=="function"}async function C5(n,e,t){t=t||{};const s=t.batches!=null,i=n.testFunction;let r=[];if(t.verbose>0)throw new ct("Verbose mode is not implemented yet.");E(!s||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=M5(e)?e:await e.iterator();let o=0,l=0;for(;!s||l<t.batches;){const c=await a.next();if(r=j(()=>{if(c.value){const{xs:u,ys:h}=Tk(n,c.value),d=u.concat(h),p=j(()=>i(d));if(nt(d),l===0)for(let y=0;y<p.length;++y)r.push(Ke(0));const f=d[0].shape[0];for(let y=0;y<p.length;++y){const m=p[y],g=r[y];r[y]=j(()=>de(r[y],X(f,m))),l>0&&nt(g)}nt(p),o+=f,++l}return r}),c.done){s&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let c=0;c<r.length;++c){const u=r[c];r[c]=Ue(r[c],o),nt(u)}return _s(r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Qb(n){E(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function th(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(s=>Eo(s,e,t-e)):Eo(n,e,t-e)}function yx(n,e){return j(()=>n==null?null:Array.isArray(n)?n.map(t=>yx(t,e)):ik(n,e.dtype==="int32"?e:Se(e,"int32")))}function Jb(n,e){const t=[];let s=0,i=null;for(;s<n;)i=s+e,i>=n&&(i=n),t.push([s,i]),s=i;return t}function _k(n){const e=[];n instanceof Et&&(n=[n]);for(let t=0;t<n.length;++t){const s=n[t];if(s.rank===1)e.push(mp(s,1));else{if(s.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(s)}}return e}function Ni(n,e){if(n==null)return;const t=[];if(e instanceof Et)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const r=e[i];t.push(r.id)}const s=[];if(n instanceof Et)t.indexOf(n.id)===-1&&s.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&s.push(i)});else if(n!=null)for(const i in n){const r=n[i];t.indexOf(r.id)===-1&&s.push(r)}s.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function E5(n){return n instanceof Et}function bx(n){return Array.isArray(n)}function XI(n){return!E5(n)&&!bx(n)}function HI(n,e,t,s=!0,i=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(bx(n)&&n.length>0)a=!0;else if(XI(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new Z(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let r;if(XI(n)){n=n,r=[];for(const a of e){if(n[a]==null)throw new Z(`No data provided for "${a}". Need data for each key in: ${e}`);r.push(n[a])}}else if(bx(n)){if(n=n,n.length!==e.length)throw new Z(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);r=n}else{if(n=n,e.length>1)throw new Z(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);r=[n]}if(r=_k(r),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=r[a];if(o.shape.length!==t[a].length)throw new Z(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],u=t[a][l];if(u!=null&&u>=0&&c!==u)throw new Z(`${i} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return r}function k5(n,e,t){const s=Ea(n.map(r=>r.shape[0]));s.sort();const i=Ea(e.map(r=>r.shape[0]));if(i.sort(),s.length>1)throw new Z(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(r=>r.shape))}`);if(i.length>1)throw new Z(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(r=>r.shape))}`);if(s.length>0&&i.length>0&&!St(s,i))throw new Z(`Input Tensors should have the same number of samples as target Tensors. Found ${s[0]} input sample(s) and ${i[0]} target sample(s).`)}function N5(n,e,t){const s=[ol,zy,Dh];for(let i=0;i<n.length;++i){const r=n[i],a=e[i],o=t[i];if(a!=null){if(a===Dh&&r.shape[r.shape.length-1]===1)throw new Z(`You are passing a target array of shape ${r.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(s.indexOf(a)!==-1){const l=r.shape.slice(1),c=o.slice(1);for(let u=0;u<l.length;++u){const h=l[u],d=c[u];if(d!=null&&h!==d)throw new Z(`A target Tensor with shape ${r.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function KI(n,e,t,s=!0,i=""){let r;if(Array.isArray(n)){if(n.length!==e.length)throw new Z(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);r=n}else{if(e.length>1)throw new Z(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);r=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=r[a];if(o.shape.length!==t[a].length)throw new Z(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let l=0;l<t[a].length;++l){if(l===0&&!s)continue;const c=o.shape[l],u=t[a][l];if(u!=null&&u!==c)throw new Z(`Error when checking ${i}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function R5(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(s=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(s=>t);{const s=[];for(const i of e){let r=t.hasOwnProperty(i)?t[i]:[];Array.isArray(r)||(r=[r]),s.push(r)}return s}}const A5="layers-model";class Vr extends x5{constructor(e){super(e),this.isTraining=!1}summary(e,t,s=console.log){if(!this.built)throw new Z("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");f5(this,e,t,s)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=p5(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof ia))throw new Z("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new Z(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(jb(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Z(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(a=>jb(a))}else{const a=jb(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],l=this.outputNames[a];this.feedOutputNames.push(l),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const s=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],Co("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=R5(e.metrics,this.outputNames),r=(a,o,l)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([l,a])};Co("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(s.indexOf(a)!==-1)continue;const o=i[a];(l=>{const c="";let u,h,d;for(const p of l){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const y=this.internalOutputShapes[a];y[y.length-1]===1||this.lossFunctions[a]===zy?["accuracy","acc"].indexOf(p)!==-1?h=Iw:["crossentropy","ce"].indexOf(p)!==-1&&(h=yk):this.lossFunctions[a]===om?["accuracy","acc"].indexOf(p)!==-1?h=bk:["crossentropy","ce"].indexOf(p)!==-1&&(h=xk):["accuracy","acc"].indexOf(p)!==-1?h=Mw:["crossentropy","ce"].indexOf(p)!==-1&&(h=Cw);let m;["accuracy","acc"].indexOf(p)!==-1?m="acc":["crossentropy","ce"].indexOf(p)!==-1&&(m="ce"),d=h,u=c+m}else d=d5(p),u=c+ff(p);let f;Co(u,()=>{f=d}),r(a,u,f)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,s={}){const i=s.batchSize==null?32:s.batchSize;Qb(i);const r=!0,a=this.standardizeUserDataXY(e,t,r,i);try{const o=a[0].concat(a[1]);this.makeTestFunction();const l=this.testFunction,c=this.testLoop(l,o,i,s.verbose,s.steps);return _s(c)}finally{Ni(a[0],e),Ni(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),C5(this,e,t)}checkNumSamples(e,t,s,i="steps"){let r;if(s!=null){if(r=null,t!=null)throw new Z(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?r=e[0].shape[0]:r=e.shape[0];else throw new Z(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return r}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new Z("`outputs` is an empty Array, which is not allowed.");const s=Array.isArray(t),i=s?t:[t],r=this.retrieveSymbolicTensors(i),a=new xa;if(e instanceof Et&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Z(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let l=0;l<this.inputs.length;++l)a.add(this.inputs[l],e[l])}else for(const l of this.inputs){const c=e[l.name];if(c==null)throw new Z(`No value is provided for the model's input ${l.name}`);a.add(l,c)}const o=dh(r,a);return s?o:o[0]}retrieveSymbolicTensors(e){const t=Uo(null,e.length);let s=e.length;for(const i of this.layers){const r=Array.isArray(i.output)?i.output:[i.output],a=r.map(o=>o.name);for(let o=0;o<e.length;++o){const l=a.indexOf(e[o]);if(l!==-1&&(t[o]=r[l],s--),s===0)break}if(s===0)break}if(s>0){const i=[];throw t.forEach((r,a)=>{r==null&&i.push(e[a])}),new Z(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,s=!1){return j(()=>{const i=this.checkNumSamples(e);if(s)throw new ct("Verbose predictLoop() is not implemented yet.");const r=Jb(i,t),a=this.outputs.map(o=>[]);for(let o=0;o<r.length;++o)j(()=>{const l=r[o][0],c=r[o][1],u=th(e,l,c),h=[];if(Array.isArray(u))for(let p=0;p<u.length;++p)h.push({key:this.inputs[p],value:u[p]});else h.push({key:this.inputs[0],value:u});const d=new xa(h);return dh(this.outputs,d)}).forEach((l,c)=>a[c].push(l));return _s(a.map(o=>fn(o,0)))})}predict(e,t={}){const s=_k(e);KI(s,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return Qb(i),this.predictLoop(s,i)}finally{Ni(s,e)}}predictOnBatch(e){KI(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,s=!0,i){if(this.optimizer_==null)throw new ar("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const r=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===om?r.push(o.slice(0,o.length-1).concat([1])):r.push(o)}if(e=HI(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=HI(t,this.feedOutputNames,r,!1,"target"),k5(e,t),N5(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new Z(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,s,i,r=!0,a){const[o,l]=this.standardizeUserDataXY(e,t,r,a);if(s!=null)throw new Error("sample weight is not supported yet.");let c=null;if(i!=null){const u=wk(i,this.outputNames);c=[];for(let h=0;h<u.length;++h)c.push(await Sk(l[h],null,u[h]))}return[o,l,c]}testLoop(e,t,s,i=0,r){return j(()=>{const a=this.checkNumSamples(t,s,r,"steps"),o=[];if(i>0)throw new ct("Verbose mode is not implemented yet.");if(r!=null)throw new ct("steps mode in testLoop() is not implemented yet");{const l=Jb(a,s),c=ss(Wi(0,a));for(let u=0;u<l.length;++u){const h=l[u][0],d=l[u][1],p=Eo(c,h,d-h),f=yx(t,p),y=e(f);if(u===0)for(let m=0;m<y.length;++m)o.push(Ke(0));for(let m=0;m<y.length;++m){const g=y[m];o[m]=de(o[m],X(d-h,g))}}for(let u=0;u<o.length;++u)o[u]=Ue(o[u],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let s=0;s<e.length;++s){const i=e[s];let r=i;if(RI(e,i)>1){const a=RI(e.slice(0,s),i);r+=`_${a}`}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],s=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const u=[];for(let f=0;f<this.inputs.length;++f)u.push({key:this.inputs[f],value:s[f]});const h=new xa(u),d=dh(this.outputs,h,{training:!0});let p;for(let f=0;f<this.lossFunctions.length;++f){const y=this.lossFunctions[f];let m=y(i[f],d[f]);r[f]!=null&&(m=w5(m,r[f]));const g=on(m);t.push(g),f===0?p=m:p=de(p,m)}for(let f=0;f<this.metricsTensors.length;++f){let y;if(this.outputs.length>1&&f<this.outputs.length)y=t[f];else{const m=this.metricsTensors[f][0],g=this.metricsTensors[f][1];y=on(m(i[g],d[g]))}hn(y),a.push(y)}return p=on(p),this.calculateLosses().forEach(f=>{p=de(p,f)}),p},l=this.collectedTrainableWeights.map(u=>u.read()),c=!0;return[this.optimizer_.minimize(o,c,l)].concat(a)}}makeTestFunction(){this.testFunction=e=>j(()=>{const t=[];let s;const i=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let c=0;c<this.inputs.length;++c)a.push({key:this.inputs[c],value:i[c]});const o=new xa(a),l=dh(this.outputs,o);for(let c=0;c<this.lossFunctions.length;++c){const u=this.lossFunctions[c],h=on(u(r[c],l[c]));c===0?s=h:s=de(s,h),t.push(s)}for(let c=0;c<this.metricsTensors.length;++c){const u=this.metricsTensors[c][0],h=this.metricsTensors[c][1],d=on(u(r[h],l[h]));t.push(d)}return t})}async fit(e,t,s={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,r,a,o,l,c,u,h,d;try{const p=s.batchSize==null?32:s.batchSize;Qb(p);const f=!1,y=await this.standardizeUserData(e,t,s.sampleWeight,s.classWeight,f,p);i=y[0],r=y[1],d=y[2];let m=!1,g;if(s.validationData!=null&&s.validationData.length>0){if(m=!0,s.validationData.length===2)l=s.validationData[0],c=s.validationData[1];else throw s.validationData.length===3?new ct("validationData including sample weights is not supported yet."):new Z(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${s.validationData} is invalid.`);const C=!0,S=await this.standardizeUserData(l,c,null,null,C,p);u=S[0],h=S[1],g=u.concat(h)}else if(s.validationSplit!=null&&s.validationSplit>0&&s.validationSplit<1){m=!0;const C=Math.floor(i[0].shape[0]*(1-s.validationSplit)),S=i[0].shape[0];u=th(i,C,S),a=i,i=th(i,0,C),h=th(r,C,S),o=r,r=th(r,0,C),g=u.concat(h)}else s.validationSteps!=null&&(m=!0);const b=i.concat(r).concat(d);this.checkTrainableWeightsConsistency();const x=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let w,_;m?(this.makeTestFunction(),w=this.testFunction,_=v.slice().concat(v.map(C=>"val_"+C))):(w=null,g=[],_=v.slice());const I=pk(s.callbacks,s.yieldEvery);return await this.fitLoop(x,b,v,p,s.epochs,s.verbose,I,w,g,s.shuffle,_,s.initialEpoch,null,null)}finally{this.isTraining=!1,Ni(i,e),Ni(r,t),Ni(a,e),Ni(o,t),Ni(u,l),Ni(h,c),d!=null&&nt(d)}}async fitLoop(e,t,s,i,r,a,o,l,c,u,h,d,p,f){i==null&&(i=32),r==null&&(r=1),u==null&&(u=!0),d==null&&(d=0);let y=!1;if(l!=null&&c!=null&&(y=!0),f!=null&&(y=!0,p==null))throw new Z("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,i,p,"steps_per_epoch");let g;m!=null&&(g=Wi(0,m)),a==null&&(a=1);const{callbackList:b,history:x}=fk(o,a,r,d,m,p,i,y,h);b.setModel(this),this.history=x,await b.onTrainBegin(),this.stopTraining_=!1;for(let v=d;v<r;++v){await b.onEpochBegin(v);const w={};if(p!=null)throw new ct("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new ct("batch shuffling is not implemneted yet");u&&o1(g);const _=ss(g),I=Jb(m,i);for(let C=0;C<I.length;++C){const S={};if(await b.onBatchBegin(C,S),j(()=>{const M=I[C][0],A=I[C][1],D=Eo(_,M,A-M);S.batch=C,S.size=A-M;const F=yx(t,D),k=e(F);for(let P=0;P<s.length;++P){const O=s[P],V=k[P];S[O]=V,hn(V)}if(C===I.length-1&&y){const P=this.testLoop(l,c,i);for(let O=0;O<s.length;++O){const V=s[O],$=P[O];hn($),w["val_"+V]=$}}}),await b.onBatchEnd(C,S),ck(S),this.stopTraining_)break}_.dispose()}if(await b.onEpochEnd(v,w),this.stopTraining_)break}return await b.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return _5(this,e,t)}async trainOnBatch(e,t){const s=await this.standardizeUserData(e,t),i=s[0],r=s[1],a=this.makeTrainFunction()(i.concat(r)),o=[];for(const l of a){const c=await l.data();o.push(c[0])}return nt(a),Ni(s[0],e),Ni(s[1],t),_s(o)}getNamedWeights(e){const t=[],s=e!=null&&e.trainableOnly,i=s?this.trainableWeights:this.weights,r=this.getWeights(s);for(let a=0;a<i.length;++a)s&&!i[a].trainable||t.push({name:i[a].originalName,tensor:r[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=Nh().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Nh().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=kr(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>kr(t))}else{const t=Object.keys(this.loss);e={};const s=this.loss;for(const i of t)if(typeof s[i]=="string")e[i]=kr(s[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[kr(ff(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>kr(ff(e)));{const e={};for(const t in this.metrics)e[t]=kr(ff(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Fh(e.optimizer_config),s=zi(t);let i;if(typeof e.loss=="string")i=yo(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>yo(a));else if(e.loss!=null){i={};for(const a in e.loss)i[a]=yo(e.loss[a])}let r;if(Array.isArray(e.metrics))r=e.metrics.map(a=>yo(a));else if(e.metrics!=null){r={};for(const a in e.metrics)r[a]=yo(e.metrics[a])}this.compile({loss:i,metrics:r,optimizer:s})}async save(e,t){if(typeof e=="string"){const o=IC(e);if(o.length===0)throw new Z(`Cannot find any save handlers for URL '${e}'`);if(o.length>1)throw new Z(`Found more than one (${o.length}) save handlers for URL '${e}'`);e=o[0]}if(e.save==null)throw new Z("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const s=await tx(this.getNamedWeights(t)),i=!1,r=null,a={modelTopology:this.toJSON(r,i),format:A5,generatedBy:`TensorFlow.js tfjs-layers v${Vy}`,convertedBy:null};if(t!=null&&t.includeOptimizer&&this.optimizer!=null){a.trainingConfig=this.getTrainingConfig();const o="optimizer",{data:l,specs:c}=await tx(await this.optimizer.getWeights(),o);s.specs.push(...c),s.data=Wg([s.data,l])}return this.userDefinedMetadata!=null&&(UI(this.userDefinedMetadata,this.name,!0),a.userDefinedMetadata=this.userDefinedMetadata),a.weightData=s.data,a.weightSpecs=s.specs,e.save(a)}setUserDefinedMetadata(e){UI(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Vr.className="Model";pe(Vr);class Ik extends Vr{}Ik.className="Functional";pe(Ik);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function L5(n,e){"modelTopology"in n||(n={modelTopology:n}),n=n;let t=n.modelTopology;t.model_config!=null&&(t=t.model_config);const s=Fh(t),i=zi(s,e);if(n.weightsManifest!=null){const r=await iE(n.weightsManifest,n.pathPrefix,i.weights.map(o=>o.originalName)),a={};for(const o of i.weights)a[o.originalName]=r[o.originalName];i.loadWeights(a),nt(r)}return i}async function P5(n,e){if(e==null&&(e={}),typeof n=="string"){const t=MC(n,e);if(t.length===0)t.push(oE(n,e));else if(t.length>1)throw new Z(`Found more than one (${t.length}) load handlers for URL '${n}'`);n=t[0]}return D5(n,void 0,e)}async function D5(n,e,t){if(t==null&&(t={}),n.load==null)throw new Z("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const s=await n.load();let i=s.modelTopology;i.model_config!=null&&(i=i.model_config);const r=t.strict==null?!0:t.strict,a=s.weightData!=null&&s.weightSpecs!=null&&r,o=zi(Fh(i),e,a),l=s.trainingConfig;if(l!=null&&o.loadTrainingConfig(l),s.userDefinedMetadata!=null&&o.setUserDefinedMetadata(s.userDefinedMetadata),s.weightData!=null){if(s.weightSpecs==null)throw new Z("LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.");const{modelWeights:c,optimizerWeights:u}=F5(s.weightData,s.weightSpecs);o.loadWeights(c,r),o.optimizer!=null&&u.length>0&&await o.optimizer.setWeights(u),nt(c),nt(u.map(h=>h.tensor))}return o}function F5(n,e){const t=b1(n,e),s={},i=[];return e.forEach(r=>{r.group==="optimizer"?i.push({name:r.name,tensor:t[r.name]}):s[r.name]=t[r.name]}),{modelWeights:s,optimizerWeights:i}}let Wy=class xx extends Vr{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Ey("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(t=>t<0))throw new Z(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof xx||e instanceof Vr;let s;if(t){if(s=e,s.outputs.length!==1)throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(s.inputs.length!==1)throw new Z("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new Z("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=lk({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=s.outputs,this.inputs=s.inputs;else{if(e.inboundNodes.length!==1)throw new Z(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new Z("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=ok(this.outputs[0])}this.inboundNodes=[],new Oy({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Uo(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(At(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Vr({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,s=console.log){this.built||this.build(),super.summary(e,t,s)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,s={}){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.evaluate(e,t,s)}async evaluateDataset(e,t){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,s={}){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.fit(e,t,s)}async fitDataset(e,t){if(!this.built)throw new ar("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,s={},i=!1){let r,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new Z("Legacy serialization format not supported yet.");r=t}else E(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),r=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof xx))throw new ct(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const l of r){const c=zi(l,void 0,i);i&&c.setFastWeightInitDuringBuild(!0),o.add(c)}return o}set stopTraining(e){if(this.model==null)throw new Z("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new Z("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const s={};s.className=t.getClassName(),s.config=t.getConfig(),e.push(s)}return{name:this.name,layers:e}}};Wy.className="Sequential";pe(Wy);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ls=class extends il{getConfig(){return{}}};class Mk extends Ls{apply(e,t=1){return C4(e,t)}}Mk.className="elu";pe(Mk);class Ck extends Ls{apply(e){return iy(e)}}Ck.className="selu";pe(Ck);class Ek extends Ls{apply(e){return Xi(e)}}Ek.className="relu";pe(Ek);class kk extends Ls{apply(e){return j(()=>Mu(6,Xi(e)))}}kk.className="relu6";pe(kk);class Nk extends Ls{apply(e){return e}}Nk.className="linear";pe(Nk);class Rk extends Ls{apply(e){return Gi(e)}}Rk.className="sigmoid";pe(Rk);class Ak extends Ls{apply(e){return k4(e)}}Ak.className="hardSigmoid";pe(Ak);class Lk extends Ls{apply(e){return tl(e)}}Lk.className="softplus";pe(Lk);class Pk extends Ls{apply(e){return E4(e)}}Pk.className="softsign";pe(Pk);class Dk extends Ls{apply(e){return Oo(e)}}Dk.className="tanh";pe(Dk);let Ew=class extends Ls{apply(e,t=-1){return op(e,t)}};Ew.className="softmax";pe(Ew);class Fk extends Ls{apply(e,t=-1){return Qg(e,t)}}Fk.className="logSoftmax";pe(Fk);class Ok extends Ls{apply(e,t=1){return j(()=>X(Gi(X(e,t)),e))}}Ok.className="swish";pe(Ok);class Gk extends Ls{apply(e){return j(()=>X(e,Oo(tl(e))))}}Gk.className="mish";pe(Gk);function Fa(n){return n.getClassName()}function qb(n,e={}){return fp(n,rl.getMap().classNameMap,e,"activation")}function Oa(n){if(n==null){const e={};return e.className="linear",e.config={},qb(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},qb(e)}else return n instanceof Ls?n:qb(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function kw(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class zk extends il{}class xp extends zk{constructor(e){super(),kw(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return j(()=>{let t=vn([1]);return this.hasL1&&(t=de(t,ze(X(this.l1,xn(e))))),this.hasL2&&(t=de(t,ze(X(this.l2,gp(e))))),K(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}xp.className="L1L2";pe(xp);function O5(n){return kw(n),new xp({l1:n!=null?n.l1:null,l2:0})}function G5(n){return kw(n),new xp({l2:n!=null?n.l2:null,l1:0})}const ZI={l1l2:"L1L2"};function Bt(n){return ow(n)}function YI(n,e={}){return fp(n,rl.getMap().classNameMap,e,"regularizer")}function sn(n){if(n==null)return null;if(typeof n=="string"){const e={className:n in ZI?ZI[n]:n,config:{}};return YI(e)}else return n instanceof zk?n:YI(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Nw extends yt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=Qe(e);let s=Xi(e);return this.maxValue!=null&&(s=ks(s,0,this.maxValue)),s}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Nw.className="ReLU";pe(Nw);class Rw extends yt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const s=Qe(e);return Jd(s,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Rw.className="LeakyReLU";pe(Rw);class Aw extends yt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=tn(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=sn(e.alphaRegularizer),this.alphaConstraint=Nn(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new Z(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=At(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const s={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)s[i]=e[i];this.inputSpec=[new wn({ndim:e.length,axes:s})],this.built=!0}call(e,t){return e=Qe(e),ip(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ln(this.alphaInitializer),alphaRegularizer:Bt(this.alphaRegularizer),alphaConstraint:kn(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Aw.className="PReLU";pe(Aw);let Lw=class extends yt{constructor(n){if(super(n??{}),this.DEFAULT_ALPHA=1,n==null&&(n={}),n.alpha!=null&&n.alpha!==this.DEFAULT_ALPHA)throw new ct(`Non-default alpha value (${n.alpha}) is not supported by the ELU layer yet.`);this.alpha=n.alpha==null?this.DEFAULT_ALPHA:n.alpha}call(n,e){const t=Qe(n);return Su(t)}computeOutputShape(n){return n}getConfig(){const n={alpha:this.alpha},e=super.getConfig();return Object.assign(n,e),n}};Lw.className="ELU";pe(Lw);let Pw=class extends yt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const s=Qe(e);return X(s,Se(gs(s,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}};Pw.className="ThresholdedReLU";pe(Pw);let Dw=class extends yt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new Ew().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){const s=Qe(e);return this.softmax(s,this.axis)}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};Dw.className="Softmax";pe(Dw);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $l(n,e,t){if(typeof n=="number")return Uo(n,e);if(n.length!==e)throw new Z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let s=0;s<e;++s){const i=n[s];if(!T4(i))throw new Z(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function Vi(n,e,t,s,i=1){if(n==null)return n;const r=e+(e-1)*(i-1);let a;return t==="same"?a=n:a=n-r+1,Math.floor((a+s-1)/s)}function nr(n,e,t,s){if(n==null)return null;if(s==="valid")n=n*e+Da([t-e,0]);else if(s==="same")n=n*e;else throw new Z(`Unsupport padding mode: ${s}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fw(n,e){return j(()=>(yn(e),e==="channelsFirst"?xt(n,[0,2,3,1]):n))}function Vk(n,e){return j(()=>(yn(e),e==="channelsFirst"?xt(n,[0,2,3,4,1]):n))}function z5(n,e,t,s=1,i="valid",r,a=1){return j(()=>{if(r==null&&(r=Ui()),yn(r),n.shape.length!==3)throw new Z(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new Z(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new Z(`The bias for a conv1dWithBias operation should be 1, but is ${e.shape.length} instead`);if(r==="channelsFirst"&&(n=xt(n,[0,2,1])),i==="causal")throw new ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=$g(n,e,s,i==="same"?"same":"valid","NWC",a);return t!=null&&(o=Hi(o,t)),o})}function jI(n,e,t,s=[1,1],i="valid",r,a,o=null){return j(()=>{if(r==null&&(r=Ui()),yn(r),n.rank!==3&&n.rank!==4)throw new Z(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new Z(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let l=Fw(n,r);if(i==="causal")throw new ct("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return l=XC({x:l,filter:e,strides:s,pad:i==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),r==="channelsFirst"&&(l=xt(l,[0,3,1,2])),l})}function V5(n,e,t,s=[1,1,1],i="valid",r,a){return j(()=>{if(r==null&&(r=Ui()),yn(r),n.rank!==4&&n.rank!==5)throw new Z(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new Z(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=Vk(n,r);if(i==="causal")throw new ct("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=X1(o,e,s,i==="same"?"same":"valid","NDHWC",a),t!=null&&(o=Hi(o,t)),r==="channelsFirst"&&(o=xt(o,[0,4,1,2,3])),o})}class Uy extends yt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Uy.verifyArgs(t),this.rank=e,Dn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new ct(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=$l(t.kernelSize,e,"kernelSize"),this.strides=$l(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,oi(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,yn(this.dataFormat),this.activation=Oa(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=tn(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Nn(t.biasConstraint),this.biasRegularizer=sn(t.biasRegularizer),this.activityRegularizer=sn(t.activityRegularizer),this.dilationRate=$l(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new Z(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new Z(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new Z(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(tr("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!lw(e.kernelSize,"number",1,3))throw new Z(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Fa(this.activation),useBias:this.useBias,biasInitializer:ln(this.biasInitializer),biasRegularizer:Bt(this.biasRegularizer),activityRegularizer:Bt(this.activityRegularizer),biasConstraint:kn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Lu extends Uy{constructor(e,t){super(e,t),this.kernel=null,Lu.verifyArgs(t),this.filters=t.filters,Dn(this.filters,"filters"),this.kernelInitializer=tn(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Nn(t.kernelConstraint),this.kernelRegularizer=sn(t.kernelRegularizer)}build(e){e=At(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z(`The channel dimension of the input should be defined. Found ${e[t]}`);const s=e[t],i=this.kernelSize.concat([s,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:s}}],this.built=!0}call(e,t){return j(()=>{e=Qe(e);let s;const i=this.bias==null?null:this.bias.read(),r=JE(this.activation.getClassName());if(r!=null&&this.rank===2)s=jI(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,r);else{if(this.rank===1)s=z5(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)s=jI(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)s=V5(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new ct("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(s=this.activation.apply(s))}return s})}computeOutputShape(e){e=At(e);const t=[],s=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<s.length;++r){const a=Vi(s[r],this.kernelSize[r],this.padding,this.strides[r],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[r]);t.push(a)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:ln(this.kernelInitializer),kernelRegularizer:Bt(this.kernelRegularizer),kernelConstraint:kn(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new Z(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class Pu extends Lu{constructor(e){super(2,e),Pu.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!lw(e.kernelSize,"number",1,2))throw new Z(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}Pu.className="Conv2D";pe(Pu);class Du extends Lu{constructor(e){super(3,e),Du.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new Z(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}Du.className="Conv3D";pe(Du);let Ow=class extends Pu{constructor(e){if(super(e),this.inputSpec=[new wn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new Z(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=At(e),e.length!==4)throw new Z("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:4,axes:{[t]:s}})],this.built=!0}call(e,t){return j(()=>{let s=Qe(e);if(s.shape.length!==4)throw new Z(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const l=i[a],c=i[o],u=this.kernelSize[0],h=this.kernelSize[1],d=this.strides[0],p=this.strides[1],f=nr(l,d,u,this.padding),y=nr(c,p,h,this.padding),m=[r,f,y,this.filters];this.dataFormat!=="channelsLast"&&(s=xt(s,[0,2,3,1]));let g=Xg(s,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(g=xt(g,[0,3,1,2])),this.bias!=null&&(g=Hi(g,this.bias.read(),this.dataFormat)),this.activation!=null&&(g=this.activation.apply(g)),g})}computeOutputShape(e){e=At(e);const t=e.slice();let s,i,r;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3):(s=3,i=1,r=2);const a=this.kernelSize[0],o=this.kernelSize[1],l=this.strides[0],c=this.strides[1];return t[s]=this.filters,t[i]=nr(t[i],l,a,this.padding),t[r]=nr(t[r],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};Ow.className="Conv2DTranspose";pe(Ow);let Gw=class extends Du{constructor(e){if(super(e),this.inputSpec=[new wn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new Z(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=At(e),e.length!==5)throw new Z("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new Z("The channel dimension of the inputs should be defined. Found `None`.");const s=e[t],i=this.kernelSize.concat([this.filters,s]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new wn({ndim:5,axes:{[t]:s}})],this.built=!0}call(e,t){return j(()=>{let s=Qe(e);if(s.shape.length!==5)throw new Z(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${s.shape.length}`);const i=s.shape,r=i[0];let a,o,l;this.dataFormat==="channelsFirst"?(l=2,a=3,o=4):(l=1,a=2,o=3);const c=i[l],u=i[a],h=i[o],d=this.kernelSize[0],p=this.kernelSize[1],f=this.kernelSize[2],y=this.strides[0],m=this.strides[1],g=this.strides[2],b=nr(c,y,d,this.padding),x=nr(u,m,p,this.padding),v=nr(h,g,f,this.padding),w=[r,b,x,v,this.filters];this.dataFormat!=="channelsLast"&&(s=xt(s,[0,2,3,4,1]));let _=H1(s,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(_=xt(_,[0,4,1,2,3])),this.bias!==null&&(_=Hi(_,this.bias.read(),this.dataFormat)),this.activation!==null&&(_=this.activation.apply(_)),_})}computeOutputShape(e){e=At(e);const t=e.slice();let s,i,r,a;this.dataFormat==="channelsFirst"?(s=1,i=2,r=3,a=4):(s=4,i=1,r=2,a=3);const o=this.kernelSize[0],l=this.kernelSize[1],c=this.kernelSize[2],u=this.strides[0],h=this.strides[1],d=this.strides[2];return t[s]=this.filters,t[i]=nr(t[i],u,o,this.padding),t[r]=nr(t[r],h,l,this.padding),t[a]=nr(t[a],d,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}};Gw.className="Conv3DTranspose";pe(Gw);let Wk=class extends Lu{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new Z("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new Z("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new Z(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=tn(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=sn(t.depthwiseRegularizer),this.depthwiseConstraint=Nn(t.depthwiseConstraint),this.pointwiseInitializer=tn(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=sn(t.pointwiseRegularizer),this.pointwiseConstraint=Nn(t.pointwiseConstraint)}build(e){if(e=At(e),e.length<this.rank+2)throw new Z(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new Z(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const s=e[t],i=this.kernelSize.concat([s,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(s*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new wn({ndim:this.rank+2,axes:{[t]:s}})],this.built=!0}call(e,t){return j(()=>{e=Qe(e);let s;if(this.rank===1)throw new ct("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=xt(e,[0,2,3,1])),s=ry(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(s=Hi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),this.dataFormat==="channelsFirst"&&(s=xt(s,[0,3,1,2])),s})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ln(this.depthwiseInitializer),e.pointwiseInitializer=ln(this.pointwiseInitializer),e.depthwiseRegularizer=Bt(this.depthwiseRegularizer),e.pointwiseRegularizer=Bt(this.pointwiseRegularizer),e.depthwiseConstraint=kn(this.depthwiseConstraint),e.pointwiseConstraint=kn(this.pointwiseConstraint),e}};Wk.className="SeparableConv";let zw=class extends Wk{constructor(e){super(2,e)}};zw.className="SeparableConv2D";pe(zw);class vp extends Lu{constructor(e){super(1,e),vp.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!lw(e.kernelSize,"number",1,1))throw new Z(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}vp.className="Conv1D";pe(vp);let Vw=class extends yt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return j(()=>{if(e=Qe(e),this.dataFormat==="channelsLast"){const s=pf(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return pf(s,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const s=pf(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return pf(s,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};Vw.className="Cropping2D";pe(Vw);let Ww=class extends yt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,yn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,v4(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],s=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,s]}else{const t=e[1]==null?null:this.size[0]*e[1],s=e[2]==null?null:this.size[1]*e[2];return[e[0],t,s,e[3]]}}call(e,t){return j(()=>{let s=Qe(e);const i=s.shape;if(this.dataFormat==="channelsFirst"){s=xt(s,[0,2,3,1]);const r=this.size[0]*i[2],a=this.size[1]*i[3],o=this.interpolation==="nearest"?rr.resizeNearestNeighbor(s,[r,a]):rr.resizeBilinear(s,[r,a]);return xt(o,[0,3,1,2])}else{const r=this.size[0]*i[1],a=this.size[1]*i[2];return this.interpolation==="nearest"?rr.resizeNearestNeighbor(s,[r,a]):rr.resizeBilinear(s,[r,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}};Ww.className="UpSampling2D";pe(Ww);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function W5(n,e,t=[1,1],s="valid",i,r){return j(()=>{i==null&&(i=Ui()),yn(i);let a=Fw(n,i);if(n.rank!==4)throw new Z(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new Z(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=wu(a,e,t,s==="same"?"same":"valid","NHWC",r),i==="channelsFirst"&&(a=xt(a,[0,3,1,2])),a})}let Uw=class extends Uy{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=tn(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Nn(e.depthwiseConstraint),this.depthwiseRegularizer=sn(e.depthwiseRegularizer)}build(e){if(e=At(e),e.length<4)throw new Z(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new Z(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const s=e[t],i=[this.kernelSize[0],this.kernelSize[1],s,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[s*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{e=Qe(e);let s=W5(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(s=Hi(s,this.bias.read(),this.dataFormat)),this.activation!=null&&(s=this.activation.apply(s)),s})}computeOutputShape(e){e=At(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Vi(t,this.kernelSize[0],this.padding,this.strides[0]),a=Vi(s,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,r,a]:[e[0],r,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ln(this.depthwiseInitializer),e.depthwiseRegularizer=Bt(this.depthwiseRegularizer),e.depthwiseConstraint=kn(this.depthwiseRegularizer),e}};Uw.className="DepthwiseConv2D";pe(Uw);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Uk(n,e,t,s){if(Array.isArray(n)){if(e!=null||t!=null)throw new Z("When inputs is an array, neither initialState or constants should be provided");s!=null&&(t=n.slice(n.length-s,n.length),n=n.slice(0,n.length-s)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(r){return r==null||Array.isArray(r)?r:[r]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function Bk(n,e,t,s=!1,i,r,a=!1,o=!1){return j(()=>{const l=e.shape.length;if(l<3)throw new Z(`Input should be at least 3D, but is ${l}D.`);const c=[1,0].concat(Wi(2,l));if(e=xt(e,c),r!=null)throw new ct("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Se(Se(i,"bool"),"float32"),i.rank===l-1&&(i=ns(i,-1)),i=xt(i,c)),s&&(e=ri(e,0),i!=null&&(i=ri(i,0)));const u=[];let h,d=t;const p=e.shape[0],f=ai(e);let y;i!=null&&(y=ai(i));for(let g=0;g<p;++g){const b=f[g],x=j(()=>n(b,d));if(i==null)h=x[0],d=x[1];else{const v=j(()=>{const w=y[g],_=Fe(Xs(w),w),I=de(X(x[0],w),X(d[0],_)),C=d.map((S,M)=>de(X(x[1][M],w),X(S,_)));return{output:I,newStates:C}});h=v.output,d=v.newStates}o&&u.push(h)}let m;return o&&(m=ps(u,1)),[h,m,d]})}class Ki extends yt{constructor(e){super(e);let t;if(e.cell==null)throw new Z("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new Xy({cells:e.cell}):t=e.cell,t.stateSize==null)throw new Z("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new wn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return Wi(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){px(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const s=t[0];let i;if(this.returnSequences?i=[e[0],e[1],s]:i=[e[0],s],this.returnState){const r=[];for(const a of t)r.push([e[0],a]);return[i].concat(r)}else return i}computeMask(e,t){return j(()=>{Array.isArray(t)&&(t=t[0]);const s=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(r=>null);return[s].concat(i)}else return s})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let s=0;s<e;++s)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new ct("Constants support is not implemented in RNN yet.");px(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,s=e.slice(2);this.inputSpec[0]=new wn({shape:[t,null,...s]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let r;if(Array.isArray(this.cell.stateSize)?r=this.cell.stateSize:r=[this.cell.stateSize],this.stateSpec!=null){if(!St(this.stateSpec.map(a=>a.shape[a.shape.length-1]),r))throw new Z(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=r.map(a=>new wn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){j(()=>{if(!this.stateful)throw new pa("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape[0];if(s==null)throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>vn([s,i])):this.states_=[vn([s,this.cell.stateSize])];else if(e==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>vn([s,i])):this.states_[0]=vn([s,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let i=0;i<this.states_.length;++i){const r=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[s,a];if(!St(r.shape,o))throw new Z(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${r.shape}`);this.states_[i]=r}}this.states_=this.states_.map(i=>hn(i.clone()))})}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=Uk(e,s,i,this.numConstants);e=r.inputs,s=r.initialState,i=r.constants;let a=[],o=[];if(s!=null){t.initialState=s,a=a.concat(s),this.stateSpec=[];for(const l of s)this.stateSpec.push(new wn({shape:l.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(t.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof Di){const l=[e].concat(a),c=this.inputSpec.concat(o),u=this.inputSpec;this.inputSpec=c;const h=super.apply(l,t);return this.inputSpec=u,h}else return super.apply(e,t)}call(e,t){return j(()=>{const s=t==null?null:t.mask,i=t==null?null:t.training;let r=t==null?null:t.initialState;e=Qe(e),r==null&&(this.stateful?r=this.states_:r=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==a)throw new Z(`RNN Layer has ${a} state(s) but was passed ${r.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},l=Bk((p,f)=>{const y=this.cell.call([p].concat(f),o);return[y[0],y.slice(1)]},e,r,this.goBackwards,s,null,this.unroll,this.returnSequences),c=l[0],u=l[1],h=l[2];this.stateful&&this.resetStates(h,i);const d=this.returnSequences?u:c;return this.returnState?[d].concat(h):d})}getInitialState(e){return j(()=>{let t=vn(e.shape);return t=ze(t,[1,2]),t=mp(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(s=>s>1?hx(t,[1,s]):t):this.cell.stateSize>1?[hx(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const s=this.cell.getConfig();return this.getClassName()===Ki.className&&(t.cell={className:this.cell.getClassName(),config:s}),Object.assign(Object.assign(Object.assign({},s),e),t)}static fromConfig(e,t,s={}){const i=t.cell,r=zi(i,s);return new e(Object.assign(t,{cell:r}))}}Ki.className="RNN";pe(Ki);class wp extends yt{}let By=class extends wp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dn(this.units,"units"),this.activation=Oa(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sn(e.kernelRegularizer),this.recurrentRegularizer=sn(e.recurrentRegularizer),this.biasRegularizer=sn(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=dc([1,Da([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dc([1,Da([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=At(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new Z(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let s=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ga({ones:()=>Xs(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ga({ones:()=>Xs(s),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let r;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?r=dr(X(e,a),this.kernel.read()):r=dr(e,this.kernel.read()),this.bias!=null&&(r=Hi(r,this.bias.read())),o!=null&&(s=X(s,o));let l=de(r,dr(s,this.recurrentKernel.read()));return this.activation!=null&&(l=this.activation.apply(l)),[l,l]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fa(this.activation),useBias:this.useBias,kernelInitializer:ln(this.kernelInitializer),recurrentInitializer:ln(this.recurrentInitializer),biasInitializer:ln(this.biasInitializer),kernelRegularizer:Bt(this.kernelRegularizer),recurrentRegularizer:Bt(this.recurrentRegularizer),biasRegularizer:Bt(this.biasRegularizer),activityRegularizer:Bt(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}};By.className="SimpleRNNCell";pe(By);let Bw=class extends Ki{constructor(e){e.cell=new By(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return new e(t)}};Bw.className="SimpleRNN";pe(Bw);let $y=class extends wp{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Z("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Dn(this.units,"units"),this.activation=Oa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Oa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=sn(e.kernelRegularizer),this.recurrentRegularizer=sn(e.recurrentRegularizer),this.biasRegularizer=sn(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=dc([1,Da([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dc([1,Da([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=At(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return j(()=>{if(e=e,e.length!==2)throw new Z(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ga({ones:()=>Xs(e),rate:this.dropout,training:s,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ga({ones:()=>Xs(i),rate:this.recurrentDropout,training:s,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,a=this.recurrentDropoutMask;let o,l,c;0<this.dropout&&this.dropout<1&&(e=X(e,r[0]));let u=dr(e,this.kernel.read());this.useBias&&(u=Hi(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=X(i,a[0]));const h=this.recurrentKernel.read(),[d,p]=Cs(h,[2*this.units,this.units],h.rank-1),f=dr(i,d),[y,m,g]=Cs(u,3,u.rank-1),[b,x]=Cs(f,2,f.rank-1);o=this.recurrentActivation.apply(de(y,b)),l=this.recurrentActivation.apply(de(m,x));const v=dr(X(l,i),p);c=this.activation.apply(de(g,v));const w=de(X(o,i),X(de(1,Jt(o)),c));return[w,w]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fa(this.activation),recurrentActivation:Fa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ln(this.kernelInitializer),recurrentInitializer:ln(this.recurrentInitializer),biasInitializer:ln(this.biasInitializer),kernelRegularizer:Bt(this.kernelRegularizer),recurrentRegularizer:Bt(this.recurrentRegularizer),biasRegularizer:Bt(this.biasRegularizer),activityRegularizer:Bt(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}};$y.className="GRUCell";pe($y);let $w=class extends Ki{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new $y(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};$w.className="GRU";pe($w);class Sp extends wp{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Dn(this.units,"units"),this.activation=Oa(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=Oa(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=tn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=tn(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=tn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=sn(e.kernelRegularizer),this.recurrentRegularizer=sn(e.recurrentRegularizer),this.biasRegularizer=sn(e.biasRegularizer),this.kernelConstraint=Nn(e.kernelConstraint),this.recurrentConstraint=Nn(e.recurrentConstraint),this.biasConstraint=Nn(e.biasConstraint),this.dropout=dc([1,Da([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=dc([1,Da([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=At(e);const s=e[e.length-1];this.kernel=this.addWeight("kernel",[s,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const r=this.biasInitializer,a=this.units;i=new(t=class extends Ii{apply(o,l){const c=r.apply([a]),u=new Ny().apply([a]),h=r.apply([a*2]);return LI(LI(c,u),h)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return j(()=>{const s=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new Z(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ga({ones:()=>Xs(e),rate:this.dropout,training:s,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ga({ones:()=>Xs(i),rate:this.recurrentDropout,training:s,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let l,c,u,h;0<this.dropout&&this.dropout<1&&(e=X(e,a[0]));let d=dr(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=X(i,o[0])),d=de(d,dr(i,this.recurrentKernel.read())),this.useBias&&(d=Hi(d,this.bias.read()));const[p,f,y,m]=Cs(d,4,d.rank-1);l=this.recurrentActivation.apply(p),c=this.recurrentActivation.apply(f),u=de(X(c,r),X(l,this.activation.apply(y))),h=this.recurrentActivation.apply(m);const g=X(h,this.activation.apply(u));return[g,g,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Fa(this.activation),recurrentActivation:Fa(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ln(this.kernelInitializer),recurrentInitializer:ln(this.recurrentInitializer),biasInitializer:ln(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Bt(this.kernelRegularizer),recurrentRegularizer:Bt(this.recurrentRegularizer),biasRegularizer:Bt(this.biasRegularizer),activityRegularizer:Bt(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),recurrentConstraint:kn(this.recurrentConstraint),biasConstraint:kn(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Sp.className="LSTMCell";pe(Sp);let Xw=class extends Ki{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Sp(e),super(e)}call(e,t){return j(()=>{this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}};Xw.className="LSTM";pe(Xw);let Xy=class extends wp{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return j(()=>{e=e;let s=e.slice(1);const i=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?i.push(s.splice(0,o.stateSize.length)):i.push(s.splice(0,1));i.reverse();const r=[];let a;for(let o=0;o<this.cells.length;++o){const l=this.cells[o];s=i[o],o===0?a=[e[0]].concat(s):a=[a[0]].concat(s),a=l.call(a,t),r.push(a.slice(1))}s=[];for(const o of r.slice().reverse())s.push(...o);return[a[0]].concat(s)})}build(e){px(e)&&(e=e[0]),e=e;let t;this.cells.forEach((s,i)=>{Co(`RNNCell_${i}`,()=>{s.build(e),Array.isArray(s.stateSize)?t=s.stateSize[0]:t=s.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=i=>({className:i.getClassName(),config:i.getConfig()}),s={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),s)}static fromConfig(e,t,s={}){const i=[];for(const r of t.cells)i.push(zi(r,s));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const s of this.cells)t.push(...s.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return fx(e)}setWeights(e){const t=[];for(const s of this.cells){const i=s.weights.length,r=e.splice(i);for(let a=0;a<s.weights.length;++a)t.push([s.weights[a],r[a]])}yw(t)}};Xy.className="StackedRNNCells";pe(Xy);function Ga(n){const{ones:e,rate:t,training:s=!1,count:i=1,dropoutFunc:r}=n,a=()=>r!=null?r(e(),t):rk(e(),t),o=()=>yp(a,e,s);return!i||i<=1?hn(o().clone()):Array(i).fill(void 0).map(o).map(l=>hn(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var U5=globalThis&&globalThis.__rest||function(n,e){var t={};for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&e.indexOf(s)<0&&(t[s]=n[s]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,s=Object.getOwnPropertySymbols(n);i<s.length;i++)e.indexOf(s[i])<0&&Object.prototype.propertyIsEnumerable.call(n,s[i])&&(t[s[i]]=n[s[i]]);return t};let $k=class extends Ki{constructor(e){if(e.unroll)throw new ct("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new ct("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new wn({ndim:5})]}call(e,t){return j(()=>{if(this.cell.dropoutMask!=null&&(nt(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(nt(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Z("ConvRNN2D cell does not support constants");const s=t==null?null:t.mask,i=t==null?null:t.training,r=t==null?null:t.initialState;return super.call(e,{mask:s,training:i,initialState:r})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return j(()=>{const{stateSize:t}=this.cell,s=e.shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)],a=vn(r);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){j(()=>{if(!this.stateful)throw new pa("Cannot call resetStates() on an RNN Layer that is not stateful.");const s=this.inputSpec[0].shape,i=this.computeSingleOutputShape(s),r=[i[0],...i.slice(2)];if(s[0]==null)throw new Z("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>vn(r)):this.states_=[vn(r)];else if(e==null)nt(this.states_),this.keptStates!=null&&(nt(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>vn(r)):this.states_[0]=vn(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Z(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):nt(this.states_);for(let a=0;a<this.states_.length;++a){const o=e[a],l=r;if(!St(o.shape,l))throw new Z(`State ${a} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${o.shape}`);this.states_[a]=o}}this.states_=this.states_.map(a=>hn(a.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:s,kernelSize:i,padding:r,strides:a,dilationRate:o}=this.cell,l=t==="channelsFirst",c=e[l?3:2],u=e[l?4:3],h=Vi(c,i[0],r,a[0],o[0]),d=Vi(u,i[1],r,a[1],o[1]);return[...e.slice(0,2),...l?[s,h,d]:[h,d,s]]}};$k.className="ConvRNN2D";let Hy=class extends Sp{constructor(e){const{filters:t,kernelSize:s,strides:i,padding:r,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Dn(this.filters,"filters"),this.kernelSize=$l(s,2,"kernelSize"),this.kernelSize.forEach(l=>Dn(l,"kernelSize")),this.strides=$l(i||1,2,"strides"),this.strides.forEach(l=>Dn(l,"strides")),this.padding=r||"valid",oi(this.padding),this.dataFormat=a||"channelsLast",yn(this.dataFormat),this.dilationRate=$l(o||1,2,"dilationRate"),this.dilationRate.forEach(l=>Dn(l,"dilationRate"))}build(e){var t;e=At(e);const s=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[s]==null)throw new Z(`The channel dimension of the input should be defined. Found ${e[s]}`);const i=e[s],r=4,a=this.kernelSize.concat([i,this.filters*r]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*r]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let l;if(this.unitForgetBias){const c=this.biasInitializer,u=this.filters;l=new(t=class extends Ii{apply(h,d){const p=c.apply([u]),f=Vs([u]),y=c.apply([u*2]);return cw([p,f,y])}},t.className="CustomInit",t)}else l=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*r],null,l,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return j(()=>{if(e.length!==3)throw new Z(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const s=t.training||!1,i=e[0],r=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Ga({ones:()=>Xs(i),rate:this.dropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const l=this.dropoutMask,c=(Y,G,B)=>!G||!G[B]?Y:X(G[B],Y);let u=c(i,l,0),h=c(i,l,1),d=c(i,l,2),p=c(i,l,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Ga({ones:()=>Xs(r),rate:this.recurrentDropout,training:s,count:o,dropoutFunc:this.dropoutFunc}));const f=this.recurrentDropoutMask;let y=c(r,f,0),m=c(r,f,1),g=c(r,f,2),b=c(r,f,3);const x=3,[v,w,_,I]=Cs(this.kernel.read(),o,x),[C,S,M,A]=this.useBias?Cs(this.bias.read(),o):[null,null,null,null];u=this.inputConv(u,v,C,this.padding),h=this.inputConv(h,w,S,this.padding),d=this.inputConv(d,_,M,this.padding),p=this.inputConv(p,I,A,this.padding);const[D,F,k,P]=Cs(this.recurrentKernel.read(),o,x);y=this.recurrentConv(y,D),m=this.recurrentConv(m,F),g=this.recurrentConv(g,k),b=this.recurrentConv(b,P);const O=this.recurrentActivation.apply(de(u,y)),V=this.recurrentActivation.apply(de(h,m)),$=de(X(V,a),X(O,this.activation.apply(de(d,g)))),H=X(this.recurrentActivation.apply(de(p,b)),this.activation.apply($));return[H,H,$]})}getConfig(){const e=super.getConfig(),t=U5(e,["units"]),s={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),s)}inputConv(e,t,s,i){const r=Hr(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return s?Hi(r,s,this.dataFormat):r}recurrentConv(e,t){return Hr(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}};Hy.className="ConvLSTM2DCell";pe(Hy);let Hw=class extends $k{constructor(e){const t=new Hy(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}};Hw.className="ConvLSTM2D";pe(Hw);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Ky=class extends yt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,s=[];for(let i=0;i<this.noiseShape.length;++i)s.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return s}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,r=this.getNoiseShape(s);return yp(()=>rk(s,this.rate,r,this.seed),()=>s,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}};Ky.className="Dropout";pe(Ky);let Kw=class extends Ky{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}};Kw.className="SpatialDropout1D";pe(Kw);let Zw=class extends yt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Dn(this.units,"units"),this.activation=Oa(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=tn(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=tn(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Nn(e.kernelConstraint),this.biasConstraint=Nn(e.biasConstraint),this.kernelRegularizer=sn(e.kernelRegularizer),this.biasRegularizer=sn(e.biasRegularizer),this.activityRegularizer=sn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=At(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=At(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e),i=JE(this.activation.getClassName());let r;return i!=null?r=dr(s,this.kernel.read(),i,this.bias?this.bias.read():null):(r=dr(s,this.kernel.read()),this.bias!=null&&(r=Hi(r,this.bias.read())),this.activation!=null&&(r=this.activation.apply(r))),r})}getConfig(){const e={units:this.units,activation:Fa(this.activation),useBias:this.useBias,kernelInitializer:ln(this.kernelInitializer),biasInitializer:ln(this.biasInitializer),kernelRegularizer:Bt(this.kernelRegularizer),biasRegularizer:Bt(this.biasRegularizer),activityRegularizer:Bt(this.activityRegularizer),kernelConstraint:kn(this.kernelConstraint),biasConstraint:kn(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}};Zw.className="Dense";pe(Zw);let Yw=class extends yt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=At(e);for(const t of e.slice(1))if(t==null)throw new Z(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],ka(e,1)]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let s=Qe(e);if(this.dataFormat==="channelsFirst"&&s.rank>1){const i=[0];for(let r=2;r<s.rank;++r)i.push(r);i.push(1),s=xt(s,i)}return M4(s)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}};Yw.className="Flatten";pe(Yw);let jw=class extends yt{constructor(e){super(e),this.supportsMasking=!0,this.activation=Oa(e.activation)}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e);return this.activation.apply(s)})}getConfig(){const e={activation:Fa(this.activation)},t=super.getConfig();return Object.assign(e,t),e}};jw.className="Activation";pe(jw);let Qw=class extends yt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return j(()=>(e=Qe(e),_4(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}};Qw.className="RepeatVector";pe(Qw);let Jw=class extends yt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const s="Total size of new array must be unchanged.",i=t.slice();let r=1,a=null;for(let l=0;l<i.length;++l){const c=i[l];if(this.isUnknown(c))if(a===null)a=l;else throw new Z("Can only specifiy one unknown dimension.");else r*=c}const o=ka(e);if(a!==null){if(r===0||o%r!==0)throw new Z(s);i[a]=o/r}else if(o!==r)throw new Z(s);return i}computeOutputShape(e){let t=!1;for(let s=0;s<e.length;++s)if(this.isUnknown(e[s])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e),i=s.shape,r=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return K(s,r)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}};Jw.className="Reshape";pe(Jw);let qw=class extends yt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=Wi(1,e.dims.length+1);if(!St(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new wn({ndim:this.dims.length+1})]}computeOutputShape(e){e=At(e);const t=e.slice();return this.dims.forEach((s,i)=>{t[i+1]=e[s]}),t}call(e,t){return xt(Qe(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}};qw.className="Permute";pe(qw);let eS=class extends yt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const s=Qe(e),i=-1;return Rh(zo(s,this.maskValue),i)}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e),i=-1,r=!0,a=Rh(zo(s,this.maskValue),i,r);return X(s,Se(a,s.dtype))})}};eS.className="Masking";pe(eS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let tS=class extends yt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Yt(e.inputLength))}this.inputDim=e.inputDim,Dn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Dn(this.outputDim,"outputDim"),this.embeddingsInitializer=tn(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=sn(e.embeddingsRegularizer),this.activityRegularizer=sn(e.activityRegularizer),this.embeddingsConstraint=Nn(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return j(()=>this.maskZero?(e=Qe(e),zo(e,_t(e))):null)}computeOutputShape(e){if(e=At(e),this.inputLength==null)return[...e,this.outputDim];const t=Yt(this.inputLength);if(t.length!==e.length-1)throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let s=0;for(let i=0;i<t.length;++i){const r=t[i],a=e[i+1];if(r!=null&&a!=null&&r!==a)throw new Z(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);r==null&&(t[s]=a),s++}}return[e[0],...t,this.outputDim]}call(e,t){return j(()=>{this.invokeCallHook(e,t);let s=Qe(e);s.dtype!=="int32"&&(s=Yr(s,"int32"));const i=ik(this.embeddings.read(),K(s,[s.size]));return K(i,At(this.computeOutputShape(s.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ln(this.embeddingsInitializer),embeddingsRegularizer:Bt(this.embeddingsRegularizer),activityRegularizer:Bt(this.activityRegularizer),embeddingsConstraint:kn(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}};tS.className="Embedding";pe(tS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class ll extends yt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new ct}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const s=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const r=e[e.length-t.length+i],a=t[i];if(r==null||a==null||r<0||a<0)s.push(null);else if(r===1)s.push(a);else if(a===1)s.push(r);else{if(r!==a)throw new Z("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));s.push(r)}}return s}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[At(e)]),e=e,e.length<2)throw new Z(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const r of e)r!=null&&r[0]!==null&&t.push(r[0]);if(t=Ea(t),t.length>1)throw new Z(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let s=e[0]==null?null:e[0].slice(1);for(let r=1;r<e.length;++r){const a=e[r]==null?null:e[r].slice(1);s=this.computeElementwiseOpOutputShape(s,a)}const i=e.map(r=>r.length);e.indexOf(null)===-1&&Ea(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return j(()=>{if(e=e,this.reshapeRequired){const s=[],i=e.map(r=>r.rank);if(i.indexOf(null)===-1){const r=Da(i);for(let a of e){const o=a.rank;for(let l=0;l<r-o;++l)a=mp(a,1);s.push(a)}return this.mergeFunction(s)}else{let r=!1;for(const l of e){const c=l.rank;if(c==null){const u=l.shape,h=u[0],d=u.slice(1).concat([h]);let p=K(l,[h].concat(ka(u.slice(1))));p=xt(p,[1,0]),p=K(p,d),s.push(p),r=!0}else if(c>1){const u=Wi(1,c).concat([0]);s.push(xt(l,u)),r=!0}else s.push(l)}let a=this.mergeFunction(s);const o=a.rank;if(r){if(o==null){const l=a.shape,c=l.length,u=l[c-1],h=[u].concat(l.slice(0,l.length-1));a=K(xt(K(a,[-1,u]),[1,0]),h)}else if(o>1){const l=[o-1].concat(Wi(0,o-1));a=xt(a,l)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const r=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,r)}let s=[];for(const i of e)i!=null&&i[0]!==null&&s.push(i[0]);return s=Ea(s),s.length===1?t=s.concat(t):t=[null].concat(t),t}computeMask(e,t){return j(()=>{if(t==null)return null;if(!Array.isArray(t))throw new Z("`mask` should be an Array");if(!Array.isArray(e))throw new Z("`inputs` should be an Array");if(t.length!==e.length)throw new Z(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:ns(i,0));let s=t[0];for(let i=1;i<t.length-1;++i)s=Ti(s,t[i]);return s})}}let nS=class extends ll{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=de(t,e[s]);return t})}};nS.className="Add";pe(nS);let sS=class extends ll{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=X(t,e[s]);return t})}};sS.className="Multiply";pe(sS);let iS=class extends ll{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0].clone();for(let s=1;s<e.length;++s)t=de(t,e[s]);return X(1/e.length,t)})}};iS.className="Average";pe(iS);let rS=class extends ll{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=vr(t,e[s]);return t})}};rS.className="Maximum";pe(rS);let aS=class extends ll{constructor(e){super(e)}mergeFunction(e){return j(()=>{let t=e[0];for(let s=1;s<e.length;++s)t=Mu(t,e[s]);return t})}};aS.className="Minimum";pe(aS);let oS=class extends ll{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new Z("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const s=[];for(let i=0;i<e.length;++i){const r=e[i].slice();r.splice(this.axis,1);let a=!1;for(const o of s)if(St(o,r)){a=!0;break}a||s.push(r)}if(s.length>1)throw new Z("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return j(()=>cw(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new Z("A `Concatenate` layer should be called on a list of inputs.");const t=e,s=t[0].slice(),i=this.axis<0?s.length+this.axis:this.axis;for(const r of t.slice(1)){if(s[i]==null||r[i]==null){s[i]=null;break}s[i]+=r[i]}return s}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new Z("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Z("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Z(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return j(()=>{let s=!0;if(t.forEach(a=>{if(a!=null){s=!1;return}}),s)return null;const i=[];for(let a=0;a<e.length;++a)t[a]==null?i.push(Se(Xs(e[a]),"bool")):t[a].rank<e[a].rank?i.push(ns(t[a],-1)):i.push(t[a]);const r=fn(i,this.axis);return Bg(r,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}};oS.className="Concatenate";pe(oS);function nh(n,e){for(;n<0;)n+=e;return n}function B5(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new ct("batchDot is not implemented for tensors of 4D or higher rank yet");if(E(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),E(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new ct("batchDot is not implemented for complex64-type Tensors yet.");const s=n.shape.length,i=e.shape.length;t==null&&(t=[s-1,i-2]);const r=t;return j(()=>{let a;if(s>i){a=s-i;const l=[];for(let c=0;c<a;++c)l.push(1);e=K(e,e.shape.concat(l))}else if(i>s){a=i-s;const l=[];for(let c=0;c<a;++c)l.push(1);n=K(n,n.shape.concat(l))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)r[0]===r[1]?o=ze(X(n,e),r[0]):o=ze(X(xt(n,[1,0]),e),r[1]);else{const l=r[0]!==n.shape.length-1,c=r[1]===e.shape.length-1;o=ft(n,e,l,c)}if(a>0){let l;s>i?l=s+i-3:l=s-1;const c=[];for(let u=l;u<l+a;++u)c.push(u);o=Ka(o,c)}return o.shape.length===1&&(o=ns(o,1)),o})}let lS=class extends ll{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){E(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],s=e[1];if(t.length>3||s.length>3)throw new ct("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);if(t[i[0]]!==s[i[1]])throw new Z(`Dimension incompatibility: ${t[i[0]]} !== ${s[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new Z(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],s=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((r,a)=>nh(r,e[a].shape.length)):i=[nh(this.axes,t.shape.length),nh(this.axes,s.shape.length)],this.normalize&&(t=am(t,i[0]),s=am(s,i[1])),B5(t,s,i)}interpretAxes(e,t){let s;return Array.isArray(this.axes)?s=this.axes:s=[nh(this.axes,e.length),nh(this.axes,t.length)],s}computeOutputShape(e){E(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),s=e[1].slice();if(t.length>3||s.length>3)throw new ct("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,s);t.splice(i[0],1),s.splice(i[1],1),s.splice(0,1);const r=t.concat(s);return r.length===1&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}};lS.className="Dot";pe(lS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let cS=class extends yt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e);return yp(()=>de(ky(s.shape,0,this.stddev),s),()=>s,t.training||!1)})}};cS.className="GaussianNoise";pe(cS);let uS=class extends yt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{this.invokeCallHook(e,t);const s=Qe(e);return this.rate>0&&this.rate<1?yp(()=>{const i=Math.sqrt(this.rate/(1-this.rate));return X(s,ky(s.shape,1,i))},()=>s,t.training||!1):s})}};uS.className="GaussianDropout";pe(uS);let hS=class extends yt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||Qe(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return j(()=>{if(this.rate<1&&this.rate>0){const s=this._getNoiseShape(e);return yp(()=>{const i=Qe(e),r=1.6732632423543772,a=1.0507009873554805,o=-r*a;let l=ta(Eu(s),this.rate);l=Yr(l,"float32");const c=((1-this.rate)*(1+this.rate*o**2))**-.5,u=-c*o*this.rate,h=de(X(i,l),X(de(l,-1),o));return de(X(h,c),u)},()=>Qe(e),t.training||!1)}return e})}};hS.className="AlphaDropout";pe(hS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oh(n,e,t,s,i,r=.001){let a;if(n.rank===2)a=D1(n,e,t,s,i,r);else if(n.rank===3)a=F1(n,e,t,s,i,r);else if(n.rank===4)a=O1(n,e,t,s,i,r);else throw new ct(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function $5(n,e,t,s,i=.001){return j(()=>{const r=np(n,s),a=r.mean,o=r.variance;return[Oh(n,a,o,t,e,i),a,o]})}function X5(n,e,t,s,i=.001){return j(()=>{const r=np(n,s),a=r.mean,o=r.variance,l=[];for(const p of Wi(0,n.rank))s.indexOf(p)!==-1?l.push(1):l.push(n.shape[p]);const c=K(a,l),u=K(o,l),h=e==null?null:K(e,l),d=t==null?null:K(t,l);return[Oh(n,c,u,d,h,i),a,o]})}function H5(n,e,t,s,i=.001){return St(s.slice().sort(),Wi(0,n.rank-1))?$5(n,e,t,s,i):X5(n,e,t,s,i)}let dS=class extends yt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=tn(e.betaInitializer||"zeros"),this.gammaInitializer=tn(e.gammaInitializer||"ones"),this.movingMeanInitializer=tn(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=tn(e.movingVarianceInitializer||"ones"),this.betaConstraint=Nn(e.betaConstraint),this.gammaConstraint=Nn(e.gammaConstraint),this.betaRegularizer=sn(e.betaRegularizer),this.gammaRegularizer=sn(e.gammaRegularizer)}build(e){e=At(e);const t=this.axis>=0?this.axis:this.axis+e.length,s=e[t];if(s==null)throw new Z(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new wn({ndim:e.length,axes:{[t]:s}})];const i=[s];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return j(()=>{const s=t.training==null?!1:t.training,i=Qe(e),r=i.shape,a=r.length,o=Wi(0,a),l=this.axis>=0?this.axis:this.axis+a;o.splice(l,1);const c=Uo(1,a);c[l]=r[l];const u=o.slice();u.sort();const h=!St(u,Wi(0,a).slice(0,a-1)),d=()=>{if(h){const g=K(this.movingMean.read(),c),b=K(this.movingVariance.read(),c),x=this.center?K(this.beta.read(),c):null,v=this.scale?K(this.gamma.read(),c):null;return Oh(i,g,b,x,v,this.epsilon)}else return Oh(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!s)return d();const[p,f,y]=H5(i,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(g,b,x)=>{j(()=>{const v=1-x,w=g.read(),_=X(Fe(w,b),v);g.write(Fe(w,_))})};return m(this.movingMean,f,this.momentum),m(this.movingVariance,y,this.momentum),p})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ln(this.betaInitializer),gammaInitializer:ln(this.gammaInitializer),movingMeanInitializer:ln(this.movingMeanInitializer),movingVarianceInitializer:ln(this.movingVarianceInitializer),betaRegularizer:Bt(this.betaRegularizer),gammaRegularizer:Bt(this.gammaRegularizer),betaConstraint:kn(this.betaConstraint),gammaConstraint:kn(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}};dS.className="BatchNormalization";pe(dS);let pS=class extends yt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=tn(e.betaInitializer||"zeros"),this.gammaInitializer=tn(e.gammaInitializer||"ones"),this.betaRegularizer=sn(e.betaRegularizer),this.gammaRegularizer=sn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=At(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error(`Invalid axis: ${r}`);if(this.axis.length!==Ea(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const s=this.axis.map(r=>e[r]),i=!0;this.scale?this.gamma=this.addWeight("gamma",s,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",s,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const s=Qe(e),i=s.shape,r=i.length;return j(()=>{let{mean:a,variance:o}=np(s,this.axis,!0);const l=Uo(1,r);for(const f of this.axis)l[f]=i[f];const c=f=>f!=null&&f.shape.length!==r?K(f,l):f;let u=this.scale?c(this.gamma.read()):null,h=this.center?c(this.beta.read()):null;const d=[],p=[];for(let f=0;f<r;++f)this.axis.indexOf(f)!==-1?(d.push(i[f]),p.push(1)):(d.push(1),p.push(i[f]));return a=ei(a,d),o=ei(o,d),u!=null&&(u=ei(u,p)),h!=null&&(h=ei(h,p)),Oh(s,a,o,h,u,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ln(this.betaInitializer),gammaInitializer:ln(this.gammaInitializer),betaRegularizer:Bt(this.betaRegularizer),gammaRegularizer:Bt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}};pS.className="LayerNormalization";pe(pS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function K5(n,e,t){return j(()=>{if(n.rank!==4)throw new Z(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new Z("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Ui()),t!=="channelsLast"&&t!=="channelsFirst")throw new Z(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let s;return t==="channelsFirst"?s=[[0,0],[0,0],e[0],e[1]]:s=[[0,0],e[0],e[1],[0,0]],na(n,s)})}let fS=class extends yt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Ui():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new Z(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,s;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],s=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new Z(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new Z(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);s=e.padding[1]}this.padding=[t,s]}this.inputSpec=[new wn({ndim:4})]}computeOutputShape(e){e=At(e);let t,s;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?s=e[3]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],e[1],t,s]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?s=e[2]+this.padding[1][0]+this.padding[1][1]:s=null,[e[0],t,s,e[3]])}call(e,t){return j(()=>K5(Qe(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}};fS.className="ZeroPadding2D";pe(fS);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Zy(n,e,t,s,i,r){return j(()=>{yn(i),ek(r),oi(s),t==null&&(t=[1,1]),s==null&&(s="valid"),i==null&&(i=Ui()),r==null&&(r="max"),n=Fw(n,i);let a;const o=s==="same"?"same":"valid";return r==="max"?a=tp(n,e,t,o):a=Zd(n,e,t,o),i==="channelsFirst"&&(a=xt(a,[0,3,1,2])),a})}function Xk(n,e,t,s,i,r){return j(()=>{yn(i),ek(r),oi(s),t==null&&(t=[1,1,1]),s==null&&(s="valid"),i==null&&(i=Ui()),r==null&&(r="max"),n=Vk(n,i);let a;const o=s==="same"?"same":"valid";return r==="max"?a=ov(n,e,t,o):a=P1(n,e,t,o),i==="channelsFirst"&&(a=xt(a,[0,4,1,2,3])),a})}let Hk=class extends yt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new Z(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Dn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new Z(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,oi(this.padding),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(e){e=At(e);const t=Vi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return j(()=>{this.invokeCallHook(e,t),e=mp(Qe(e),2);const s=this.poolingFunction(Qe(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return Ka(s,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}},mS=class extends Hk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Zy(e,t,s,i,r,"max")}};mS.className="MaxPooling1D";pe(mS);let gS=class extends Hk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Zy(e,t,s,i,r,"avg")}};gS.className="AveragePooling1D";pe(gS);let Kk=class extends yt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new Z(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,yn(this.dataFormat),oi(this.padding),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(e){e=At(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=Vi(t,this.poolSize[0],this.padding,this.strides[0]),s=Vi(s,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s]:[e[0],t,s,e[3]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},yS=class extends Kk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Zy(e,t,s,i,r,"max")}};yS.className="MaxPooling2D";pe(yS);let bS=class extends Kk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Zy(e,t,s,i,r,"avg")}};bS.className="AveragePooling2D";pe(bS);let Zk=class extends yt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new Z(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Dn(this.poolSize,"poolSize"),Dn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,yn(this.dataFormat),oi(this.padding),this.inputSpec=[new wn({ndim:5})]}computeOutputShape(e){e=At(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],s=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=Vi(t,this.poolSize[0],this.padding,this.strides[0]),s=Vi(s,this.poolSize[1],this.padding,this.strides[1]),i=Vi(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,s,i]:[e[0],t,s,i,e[4]]}call(e,t){return j(()=>(this.invokeCallHook(e,t),this.poolingFunction(Qe(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},xS=class extends Zk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Xk(e,t,s,i,r,"max")}};xS.className="MaxPooling3D";pe(xS);let vS=class extends Zk{constructor(e){super(e)}poolingFunction(e,t,s,i,r){return yn(r),oi(i),Xk(e,t,s,i,r,"avg")}};vS.className="AveragePooling3D";pe(vS);let Yk=class extends yt{constructor(e){super(e),this.inputSpec=[new wn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new ct}},wS=class extends Yk{constructor(e){super(e||{})}call(e,t){return j(()=>{const s=Qe(e);return on(s,1)})}};wS.className="GlobalAveragePooling1D";pe(wS);let SS=class extends Yk{constructor(e){super(e||{})}call(e,t){return j(()=>{const s=Qe(e);return si(s,1)})}};SS.className="GlobalMaxPooling1D";pe(SS);let jk=class extends yt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,yn(this.dataFormat),this.inputSpec=[new wn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new ct}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}},TS=class extends jk{call(e,t){return j(()=>{const s=Qe(e);return this.dataFormat==="channelsLast"?on(s,[1,2]):on(s,[2,3])})}};TS.className="GlobalAveragePooling2D";pe(TS);class _S extends jk{call(e,t){return j(()=>{const s=Qe(e);return this.dataFormat==="channelsLast"?si(s,[1,2]):si(s,[2,3])})}}_S.className="GlobalMaxPooling2D";pe(_S);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Qk extends yt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,s={}){const i=t.layer,r=zi(i,s);delete t.layer;const a={layer:r};return Object.assign(a,t),new e(a)}}class IS extends Qk{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=At(e),e.length<3)throw new Z(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=At(e);const t=[e[0]].concat(e.slice(2)),s=this.layer.computeOutputShape(t),i=e[1];return[s[0],i].concat(s.slice(1))}call(e,t){return j(()=>(e=Qe(e),Bk((s,i)=>[Qe(this.layer.call(s,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}IS.className="TimeDistributed";pe(IS);function Z5(n){al(x4,"BidirectionalMergeMode",n)}const Y5="concat";class MS extends Qk{constructor(e){super(e);const t=e.layer.getConfig(),s={};s.className=e.layer.getClassName(),s.config=t,this.forwardLayer=zi(s),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=zi(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?Y5:e.mergeMode,Z5(this.mergeMode),e.weights)throw new ct("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,s=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,s)),this.backwardLayer.setWeights(e.slice(s))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let s,i,r;return this.returnState&&(r=t.slice(1)),s=t[0],s=s,this.mergeMode==="concat"?(s[s.length-1]*=2,i=[s]):this.mergeMode==null?i=[s,s.slice()]:i=[s],this.returnState?this.mergeMode==null?i.concat(r).concat(r.slice()):[s].concat(r).concat(r.slice()):_s(i)}apply(e,t){let s=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const r=Uk(e,s,i,this.numConstants);if(e=r.inputs,s=r.initialState,i=r.constants,Array.isArray(e)&&(s=e.slice(1),e=e[0]),(s==null||s.length===0)&&i==null)return super.apply(e,t);const a=[],o=[];if(s!=null){const c=s.length;if(c%2>0)throw new Z("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=s,a.push(...s);const u=s.map(h=>new wn({shape:h.shape}));this.forwardLayer.stateSpec=u.slice(0,c/2),this.backwardLayer.stateSpec=u.slice(c/2),o.push(...u)}if(i!=null)throw new ct("Support for constants in Bidirectional layers is not implemented yet.");const l=a[0]instanceof Di;for(const c of a)if(c instanceof Di!==l)throw new Z("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(l){const c=[e].concat(a),u=this.inputSpec.concat(o),h=this.inputSpec;this.inputSpec=u;const d=super.apply(c,t);return this.inputSpec=h,d}else return super.apply(e,t)}call(e,t){return j(()=>{const s=t.initialState;let i,r;if(s==null)i=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const l=s.slice(0,s.length/2),c=s.slice(s.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:l})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:c}))}let a;this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(r.slice(1))),i=i[0],r=r[0]),this.returnSequences&&(r=ri(r,1));let o;return this.mergeMode==="concat"?o=cw([i,r]):this.mergeMode==="sum"?o=de(i,r):this.mergeMode==="ave"?o=X(.5,de(i,r)):this.mergeMode==="mul"?o=X(i,r):this.mergeMode==null&&(o=[i,r]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){Co(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),Co(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let s;if(this.returnSequences?this.mergeMode==null?s=[t,t]:s=t:this.mergeMode==null?s=[null,null]:s=null,this.returnState){const i=this.forwardLayer.states.map(r=>null);return Array.isArray(s)?s.concat(i).concat(i):[s].concat(i).concat(i)}else return s}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const s=zi(t.layer);if(delete t.layer,t.numConstants!=null)throw new ct("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=s,new e(i)}}MS.className="Bidirectional";pe(MS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class CS extends yt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>(e=Qe(e),e.dtype!=="float32"&&(e=Yr(e,"float32")),de(X(e,this.scale),this.offset)))}}CS.className="Rescaling";pe(CS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:j5,cropAndResize:Q5}=rr;class ES extends yt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,s,i,r,a,o,l){return j(()=>{let c,u=!1;const h=t/a,d=s/o,p=(i+t)/a,f=(r+s)/o,y=[h,d,p,f],m=[];e.rank===3?(u=!0,c=ps([e])):c=e;for(let v=0;v<c.shape[0];v++)m.push(y);const g=en(m,[m.length,4]),b=Vo(0,m.length,1,"int32"),x=Q5(c,g,b,[i,r],"nearest");return Yr(u?Qe(ai(x)):x,l)})}upsize(e,t,s,i){return j(()=>{const r=j5(e,[t,s]);return Yr(r,i)})}call(e,t){return j(()=>{const s=Qe(e),i=s.dtype,r=s.shape,a=r[r.length-3],o=r[r.length-2];let l=0;a!==this.height&&(l=Math.floor((a-this.height)/2));let c=0;return o!==this.width&&(c=Math.floor((o-this.width)/2),c===0&&(c=1)),l>=0&&c>=0?this.centerCrop(s,l,c,this.height,this.width,a,o,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=At(e);const t=e.length-3,s=e.length-2;return e[t]=this.height,e[s]=this.width,e}}ES.className="CenterCrop";pe(ES);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function J5(n,e,t,s){let i=Qe(n);if(i.dtype!=="int32"&&(i=Yr(i,"int32")),e==="int")return i;const r=i.shape;if(i.rank===0&&(i=ns(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=ns(i,-1)),i.rank>2)throw new Z(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${r} which would result in output rank ${i.rank}.`);const a=["multiHot","oneHot"].includes(e),o=i;let l;if(typeof s<"u"&&e==="count"?l=tm(o,s,t,a):l=tm(o,[],t,a),e!=="tfIdf")return l;if(s)return X(l,s);throw new Z("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class kS extends yt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=At(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return j(()=>{e=Qe(e),e.dtype!=="int32"&&(e=Yr(e,"int32"));let s;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new Z(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);s=Qe(t.countWeights)}const i=si(e),r=oc(e),a=gs(this.numTokens,i).bufferSync().get(0),o=ta(r,0).bufferSync().get(0);if(!(a&&o))throw new Z(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return J5(e,this.outputMode,this.numTokens,s)})}}kS.className="CategoryEncoding";pe(kS);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const q5=["bilinear","nearest"],QI=new Set(q5);class NS extends yt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(QI.has(e.interpolation))this.interpolation=e.interpolation;else throw new Z(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=At(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return j(()=>{const s=[this.height,this.width];if(this.interpolation==="bilinear")return rr.resizeBilinear(e,s,!this.cropToAspectRatio);if(this.interpolation==="nearest")return rr.resizeNearestNeighbor(e,s,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...QI]} are supported`)})}}NS.className="Resizing";pe(NS);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e9=ee();e9.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var di;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(di||(di={}));var JI;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(JI||(JI={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function t9(n,e){return hm(n,e)}function hm(n,e,t=new Map,s=new Set){if(n==null)return null;if(typeof Blob=="function"&&n instanceof Blob)return n.slice();if(s.has(n))throw new Error("Circular references are not supported.");if(t.has(n))return t.get(n);const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep map function may not return both a value and recurse=true.");if(i.recurse)if(fc(n)){const r=Array.isArray(n)?[]:{};s.add(n);for(const a in n){const o=n[a],l=hm(o,e,t,s);r[a]=l}return s.delete(n),n.__proto__&&(r.__proto__=n.__proto__),r}else throw new Error(`Can't recurse into non-iterable type: ${n}`);else return t.set(n,i.value),i.value}function n9(n,e=qk){return Jk(n,e)}function Jk(n,e,t=new Set){const s=n[0];if(t.has(s))throw new Error("Circular references are not supported.");const i=e(n);if(i.recurse&&i.value!==null)throw new Error("A deep zip function may not return both a value and recurse=true.");if(i.recurse)if(fc(s)){const r=Array.isArray(s)?[]:{};t.add(s);for(const a in s){const o=n.map(c=>c[a]),l=Jk(o,e,t);r[a]=l}return t.delete(s),r}else throw new Error(`Can't recurse into non-iterable type: ${s}`);else return i.value}function qk(n){return n===null?null:fc(n[0])?{value:null,recurse:!0}:{value:n,recurse:!1}}async function eN(n,e){const t=new Map;hm(n,e,t);for(const s of Array.from(t.keys())){const i=t.get(s);if(Ur(i)){const r=await i;t.set(s,r)}}return hm(n,e,t)}function fc(n){let e=!1;if(ee().get("IS_BROWSER"))e=n instanceof TextDecoder;else{const{StringDecoder:t}=require("string_decoder");e=n instanceof t}return n!=null&&!ArrayBuffer.isView(n)&&(Array.isArray(n)||typeof n=="object"&&!(n instanceof Et)&&!(n instanceof Promise)&&!e)}function s9(n){return n==null||i9(n)||Array.isArray(n)||typeof n=="object"&&n instanceof Et||Pn(n)}function i9(n){return n===null||typeof n!="object"&&typeof n!="function"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function r9(n){return t9(n,a9)}function a9(n){return n instanceof Et?{value:n.clone(),recurse:!1}:fc(n)?{value:null,recurse:!0}:{value:n,recurse:!1}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class tN{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,e==null)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return this.length()===0}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),s=this.get(t);return this.set(t,this.pop()),s}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class Yy extends tN{constructor(){super(Yy.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=this.capacity*2,t=new Array(e),s=this.length();for(let i=0;i<s;i++)t[i]=this.get(this.wrap(this.begin+i));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=s}}Yy.INITIAL_CAPACITY=32;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function nN(n){return new c9(n)}function RS(n){return new u9(n)}function o9(n,e){return new sN(n,e)}function l9(n,e=va.FAIL){return new x9(n,e)}let Gn=class{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let s=await e.next();for(;!s.done;)t.push(s.value),s=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),s=e(t.value);for(;!t.done&&s;)t=await this.next(),s=e(t.value)}handleErrors(e){return new y9(this,e)}filter(e){return new m9(this,e)}map(e){return new g9(this,e)}mapAsync(e){return new qI(this,e)}serialMapAsync(e){return new qI(this,e).serial()}flatmap(e){return new b9(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile(t=>t===!0)}rowMajorBatch(e,t=!0){return new f9(this,e,t)}columnMajorBatch(e,t=!0,s=qk){return this.rowMajorBatch(e,t).map(i=>n9(i,s))}concatenate(e,t){return new sN(nN([this,e]),t)}take(e){return e<0||e==null?this:new p9(this,e)}skip(e){return e<0||e==null?this:new d9(this,e)}prefetch(e){return new iN(this,e)}shuffle(e,t){return new v9(this,e,t)}serial(){return new h9(this)}};class c9 extends Gn{constructor(e){super(),this.items=e,this.trav=0}summary(){return`Array of ${this.items.length} items`}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:r9(e),done:!1}}}class u9 extends Gn{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message=`Error thrown while iterating through a dataset: ${e.message}`,e}}}class h9 extends Gn{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Serial`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){return this.upstream.next()}}class d9 extends Gn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Skip`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;nt(e.value)}return this.upstream.next()}}class p9 extends Gn{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return`${this.upstream.summary()} -> Take`}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class f9 extends Gn{constructor(e,t,s=!0){super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=s,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> RowMajorBatch`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class m9 extends Gn{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> Filter`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;nt(e.value)}}}class g9 extends Gn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Map`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=$r(e.value),s=this.transform(e.value),i=$r(s);for(const r of t)Vg(r,i)||r.dispose();return{value:s,done:!1}}}class y9 extends Gn{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return`${this.upstream.summary()} -> handleErrors`}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class qI extends Gn{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> AsyncMap`}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=$r(e.value),s=await this.transform(e.value),i=$r(s);for(const r of t)Vg(r,i)||r.dispose();return{value:s,done:!1}}}class AS extends Gn{constructor(){super(),this.outputQueue=new Yy,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}async serialNext(){for(;this.outputQueue.length()===0;)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class b9 extends AS{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return`${this.upstream.summary()} -> Flatmap`}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=$r(e.value),s=this.transform(e.value),i=$r(s);this.outputQueue.pushAll(s);for(const r of t)Vg(r,i)||r.dispose();return!0}}class sN extends Gn{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"TODO: fill in upstream of chained summaries -> Chained"}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,this.iterator==null){const s=await this.moreIterators.next();if(s.done)return{value:null,done:!0};this.iterator=s.value,this.baseErrorHandler!=null&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var va;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(va||(va={}));class x9 extends Gn{constructor(e,t=va.FAIL){super(),this.iterators=e,this.mismatchMode=t,this.count=0,this.currentPromise=null}summary(){return"{TODO: fill in upstream of zip summaries} -> Zip"}async nextState(e){await e;let t=0,s=0;function i(a){return a instanceof Gn?{value:a.next().then(o=>(t++,o.done&&s++,o.value)),recurse:!1}:{value:null,recurse:!0}}const r=await eN(this.iterators,i);if(t===s)return{value:null,done:!0};if(s>0)switch(this.mismatchMode){case va.FAIL:throw new Error(`Zipped streams should have the same length. Mismatched at element ${this.count}.`);case va.SHORTEST:return{value:null,done:!0};case va.LONGEST:}return this.count++,{value:r,done:!1}}async next(){return this.currentPromise=this.nextState(this.currentPromise),this.currentPromise}}class iN extends Gn{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new tN(t)}summary(){return`${this.upstream.summary()} -> Prefetch`}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class v9 extends iN{constructor(e,t,s){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Cu.alea(s||Xn().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then(()=>this.serialNext()),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(t.done)this.upstreamExhausted=!0;else return this.refill(),t}return{value:null,done:!0}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */let Fu=class{constructor(){this.size=null}batch(e,t=!0){const s=this;E(e>0,()=>`batchSize needs to be positive, but it is
      ${e}`);let i;return this.size===1/0||this.size==null?i=this.size:t?i=Math.ceil(this.size/e):i=Math.floor(this.size/e),Ds(async()=>(await s.iterator()).columnMajorBatch(e,t,T9),i)}concatenate(e){const t=this;let s;return this.size===1/0||e.size===1/0?s=1/0:this.size!=null&&e.size!=null?s=this.size+e.size:s=null,Ds(async()=>(await t.iterator()).concatenate(await e.iterator()),s)}filter(e){const t=this;let s;return this.size===1/0?s=1/0:s=null,Ds(async()=>(await t.iterator()).filter(i=>j(()=>e(i))),s)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Ds(async()=>(await t.iterator()).map(s=>j(()=>e(s))),this.size)}mapAsync(e){const t=this;return Ds(async()=>(await t.iterator()).mapAsync(e),this.size)}prefetch(e){if(e==null)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Ds(async()=>(await t.iterator()).prefetch(e),this.size)}repeat(e){const t=this;let s;return this.size!=null&&e>0?s=this.size*e:e===0?s=0:this.size!=null&&(e===void 0||e<0)?s=1/0:s=null,Ds(async()=>{const i=RS(async()=>({value:await t.iterator(),done:!1}));return o9(i.take(e))},s)}skip(e){const t=this;let s;return this.size!=null&&e>=0&&this.size>=e?s=this.size-e:this.size!=null&&(this.size<e||e===void 0||e<0)?s=0:s=null,Ds(async()=>(await t.iterator()).skip(e),s)}shuffle(e,t,s=!0){if(e==null||e<0)throw this.size==null?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError(`\`Dataset.shuffle()\` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for \`tf.Tensor\`s), consider setting bufferSize to the dataset size (${this.size} elements)`);const i=this,r=Cu.alea(t||Xn().toString());return Ds(async()=>{let a=r.int32();return s&&(a+=r.int32()),(await i.iterator()).shuffle(e,a.toString())},this.size)}take(e){const t=this;let s;return this.size!=null&&this.size>e?s=e:this.size!=null&&this.size<=e?s=this.size:s=null,Ds(async()=>(await t.iterator()).take(e),s)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}};Fu.MAX_BUFFER_SIZE=1e4;function Ds(n,e=null){return new class extends Fu{constructor(){super(...arguments),this.size=e}async iterator(){return n()}}}function w9(n){return Ds(async()=>nN(n),n.length)}function S9(n){if(!fc(n))throw new Error("The argument to zip() must be an object or array.");let e;if(Array.isArray(n))for(let t=0;t<n.length;t++)e=e==null?n[t].size:Math.min(e,n[t].size);else if(n instanceof Object)for(const t in n)e=e==null?n[t].size:Math.min(e,n[t].size);return Ds(async()=>{const t=await eN(n,s=>{if(s instanceof Fu)return{value:s.iterator(),recurse:!1};if(fc(s))return{value:null,recurse:!0};throw new Error("Leaves of the structure passed to zip() must be Datasets, not primitives.")});return l9(t,va.SHORTEST)},e)}function T9(n){if(n===null)return null;const e=n[0];return s9(e)?{value:_9(n),recurse:!1}:{value:null,recurse:!0}}function _9(n){if(n.length===0)throw new Error("Can't make a batch of zero elements.");return n[0]instanceof Et?ps(n):en(n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ve(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&E(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I9=py;class jy extends Lm{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new a1(this,Ut())}nextDataId(){return jy.nextDataId++}write(e,t,s){this.firstUse&&(this.firstUse=!1,ee().get("IS_NODE")&&qs(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:s,refCount:1}),i}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&ir(s[0])){const r=s.map(a=>cr(a));i=this.write(r,e,t)}else i=this.write(s,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,s,i,r){this.data.set(e,{values:t,dtype:i,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:s}=this.data.get(e);if(t==="complex64"){const i=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return Zr(i,r)}return sC(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>Br(i));return ut(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ut(e.shape,e.dtype,t)}makeOutput(e,t,s){return Ut().makeTensorFromTensorInfo(this.makeTensorInfo(t,s,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:s}=this.data.get(e);s!=null&&(this.disposeData(s.real.dataId,!0),this.disposeData(s.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=Xn();return e(),{kernelMs:Xn()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ve([e],"where");const t=this.readSync(e.dataId);return I9(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}jy.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rN(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const M9=n=>{const{x:e}=n.inputs,t=n.backend;Ve(e,"abs");let s=new Float32Array(re(e.shape));const i=t.data.get(e.dataId).values;return s=rN(i),t.makeOutput(s,e.shape,e.dtype)},C9={kernelName:$h,backendName:"cpu",kernelFunc:M9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tn(n){return(e,t,s,i,r)=>{const a=st(e,t),o=a.length,l=He(a),c=re(a),u=Rn(r,c),h=e.length,d=t.length,p=He(e),f=He(t),y=Go(e,a),m=Go(t,a);if(y.length+m.length===0)for(let g=0;g<u.length;++g)u[g]=n(s[g%s.length],i[g%i.length]);else for(let g=0;g<u.length;++g){const b=Qo(g,o,l),x=b.slice(-h);y.forEach(I=>x[I]=0);const v=Oi(x,h,p),w=b.slice(-d);m.forEach(I=>w[I]=0);const _=Oi(w,d,f);u[g]=n(s[v],i[_])}return[u,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gs(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,o=t.makeTensorInfo(s.shape,"complex64"),l=t.data.get(o.dataId);return l.complexTensorInfos={real:t.makeTensorInfo(s.shape,"float32",r),imag:t.makeTensorInfo(i.shape,"float32",a)},o}const E9={kernelName:Um,backendName:"cpu",kernelFunc:Gs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dm(n,e,t="float32"){if(t==="complex64"){const i=dm(n,e,"float32"),r=dm(n,e,"float32");return Gs({inputs:{real:i,imag:r},backend:n})}const s=Zn(re(e),t);return n.makeTensorInfo(e,t,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gr(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const k9={kernelName:Xc,backendName:"cpu",kernelFunc:gr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bo(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.real,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const N9={kernelName:vg,backendName:"cpu",kernelFunc:Bo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aN(n,e,t,s){if(s==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(s==="bool"){const i=Ua([0],t),[r,a]=Tn((o,l)=>o!==l?1:0)(e,[],n,i,"bool");return[a,"bool",r]}throw new Error(`Error in Cast: failed to cast ${t} to ${s}`)}function za(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return gr({inputs:{x:i},backend:t});const u=dm(t,i.shape,i.dtype),h=za({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),d=Gs({inputs:{real:h,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),d}if(i.dtype==="complex64"){const u=Bo({inputs:{input:i},backend:t}),h=za({inputs:{x:u},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(u),h}if(!c1(i.dtype,r)){const u=gr({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:r}}const a=t.data.get(i.dataId).values,[o,l,c]=aN(a,i.shape,i.dtype,r);return t.makeTensorInfo(o,l,c)}const R9={kernelName:Ac,backendName:"cpu",kernelFunc:za};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wn(n,e,t,s){return t==null?({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;Ve([a,o],n);const c=l.data.get(a.dataId).values,u=l.data.get(o.dataId).values,h=a.dtype==="string"?Wo(c):c,d=a.dtype==="string"?Wo(u):u,p=s||a.dtype,[f,y]=e(a.shape,o.shape,h,d,p);return l.makeTensorInfo(y,p,f)}:({inputs:i,backend:r})=>{const{a,b:o}=i,l=r;if(a.dtype==="complex64"||o.dtype==="complex64"){const c=za({inputs:{x:a},backend:l,attrs:{dtype:"complex64"}}),u=l.data.get(c.dataId),h=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,p=l.data.get(h.dataId).values,f=l.data.get(d.dataId).values,y=za({inputs:{x:o},backend:l,attrs:{dtype:"complex64"}}),m=l.data.get(y.dataId),g=m.complexTensorInfos.real,b=m.complexTensorInfos.imag,x=l.data.get(g.dataId).values,v=l.data.get(b.dataId).values,[w,_,I]=t(a.shape,o.shape,p,f,x,v),C=l.makeTensorInfo(I,"float32",w),S=l.makeTensorInfo(I,"float32",_),M=Gs({inputs:{real:C,imag:S},backend:l});return l.disposeIntermediateTensorInfo(c),l.disposeIntermediateTensorInfo(y),l.disposeIntermediateTensorInfo(C),l.disposeIntermediateTensorInfo(S),M}else{const c=l.data.get(a.dataId).values,u=l.data.get(o.dataId).values,h=s||a.dtype,[d,p]=e(a.shape,o.shape,c,u,h);return l.makeTensorInfo(p,h,d)}}}function LS(n){return(e,t,s,i,r,a)=>{const o=st(e,t),l=re(o),c=o.length,u=He(o),h=Rn("float32",l),d=Rn("float32",l),p=Go(e,o),f=Go(t,o),y=Zr(s,i),m=Zr(r,a),g=e.length,b=He(e),x=t.length,v=He(t);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const _=w%y.length,I=w%m.length,C=n(y[_*2],y[_*2+1],m[I*2],m[I*2+1]);h[w]=C.real,d[w]=C.imag}else for(let w=0;w<h.length;w++){const _=Qo(w,c,u),I=_.slice(-g);p.forEach(D=>I[D]=0);const C=Oi(I,g,b),S=_.slice(-x);f.forEach(D=>S[D]=0);const M=Oi(S,x,v),A=n(y[C*2],y[C*2+1],m[M*2],m[M*2+1]);h[w]=A.real,d[w]=A.imag}return[h,d,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oN=Tn((n,e)=>n+e),A9=LS((n,e,t,s)=>({real:n+t,imag:e+s})),mc=Wn(Jo,oN,A9),L9={kernelName:Jo,backendName:"cpu",kernelFunc:mc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PS(n,e,t,s,i){const r=re(s),a=Zn(i,t);for(let o=0;o<n.length;o++){const l=n[o];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(r>0?a[l]+=e[o]:a[l]+=1)}return a}function lN(n,e,t,s=!1){const i=n.shape[0],r=n.shape[1],a=ut([i,t],e.dtype);for(let o=0;o<i;o++)for(let l=0;l<r;l++){const c=n.get(o,l);if(c<0)throw new Error("Input x must be non-negative!");c>=t||(s?a.set(1,o,c):e.size>0?a.set(a.get(o,c)+e.get(o,l),o,c):a.set(a.get(o,c)+1,o,c))}return a}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Za(n){return(e,t,s)=>{const i=Rn(t,e.length);for(let r=0;r<e.length;++r)i[r]=n(e[r],s);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gt(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:a}=s;if(Ve(a,n),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const o=r,l=o.data.get(a.dataId).values,c=re(a.shape),u=t||a.dtype,h=pn(u,c);for(let d=0;d<c;++d)h[d]=e(l[d],i);return o.makeTensorInfo(a.shape,u,h)}}function Ou(n,e,t){return({inputs:s,attrs:i,backend:r})=>{const{x:a}=s;if(Ve(a,n),a.dtype==="string"||t==="string")throw new Error("unaryKernelFunc does not support string input/output");const o=r,l=o.data.get(a.dataId).values,c=t||a.dtype,u=e(l,c,i);return o.makeTensorInfo(a.shape,c,u)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cN=Za(n=>Math.ceil(n)),P9=Ou(Lc,cN),D9={kernelName:Lc,backendName:"cpu",kernelFunc:P9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uN(n,e,t,s){const i=pn(t,re(e));if(s&&t!=="string"){let r=0;n.forEach(a=>{const o=re(a.shape);i.set(a.vals,r),r+=o})}else{let r=0;n.forEach(a=>{const o=t==="string"?Wo(a.vals):a.vals;let l=0;for(let c=0;c<a.shape[0];++c){const u=c*e[1]+r;for(let h=0;h<a.shape[1];++h)i[u+h]=o[l++]}r+=a.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hN=Tn((n,e)=>n===e?1:0),dN=Wn(ad,hN,null,"bool"),F9={kernelName:ad,backendName:"cpu",kernelFunc:dN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pN=Za(n=>Math.exp(n)),fN=Ou(Vc,pN,"float32"),O9={kernelName:Vc,backendName:"cpu",kernelFunc:fN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mN=Za(n=>Math.expm1(n)),G9=Ou(Wc,mN),z9={kernelName:Wc,backendName:"cpu",kernelFunc:G9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gN=Za(n=>Math.floor(n)),V9=Ou(Uc,gN),W9={kernelName:Uc,backendName:"cpu",kernelFunc:V9};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yN(n,e,t,s,i,r,a,o,l){const c=ut([s,r],t);for(let u=0;u<s;u++){const h=[];let d=0;for(let p=0;p<i;p++){const f=n[u*i+p];d+=f*a[p],h.push(f)}if(d<0||d>=l/r)throw new Error(`Invalid indices: ${h} does not index into ${o}`);for(let p=0;p<r;p++)c.values[u*r+p]=e.get(...e.indexToLoc(d*r+p))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bN(n,e,t){const s=ut(t,n.dtype);for(let i=0;i<s.size;++i){const r=s.indexToLoc(i).slice(),a=r[0],o=r[2],l=e.locToIndex([a,o]);r[2]=e.values[l];const c=n.locToIndex(r);0<=c&&c<n.values.length&&(s.values[i]=n.values[c])}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xN=Tn((n,e)=>n>e?1:0),U9=Wn(ud,xN,null,"bool"),B9={kernelName:ud,backendName:"cpu",kernelFunc:U9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vN=Tn((n,e)=>n>=e?1:0),$9=Wn($c,vN,null,"bool"),X9={kernelName:$c,backendName:"cpu",kernelFunc:$9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wN=Tn((n,e)=>n<e?1:0),H9=Wn(dd,wN,null,"bool"),K9={kernelName:dd,backendName:"cpu",kernelFunc:H9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SN=Tn((n,e)=>n<=e?1:0),Z9=Wn(pd,SN,null,"bool"),Y9={kernelName:pd,backendName:"cpu",kernelFunc:Z9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TN(n,e,t){const s=(e-n)/(t-1),i=Zn(t,"float32");i[0]=n;for(let r=1;r<i.length;r++)i[r]=i[r-1]+s;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _N=Za(n=>Math.log(n)),j9=Ou(Yc,_N),Q9={kernelName:Yc,backendName:"cpu",kernelFunc:j9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IN(n,e,t,s){const i=Rn(s,re(t));for(let r=0;r<i.length;++r){const a=r*e;let o=n[a];for(let l=0;l<e;++l){const c=n[a+l];(Number.isNaN(c)||c>o)&&(o=c)}i[r]=o}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MN=Tn((n,e)=>Math.max(n,e)),J9=Wn(Qc,MN),q9={kernelName:Qc,backendName:"cpu",kernelFunc:J9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CN=Tn((n,e)=>Math.min(n,e)),eY=Wn(Jc,CN),tY={kernelName:Jc,backendName:"cpu",kernelFunc:eY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DS=Tn((n,e)=>n*e),nY=LS((n,e,t,s)=>({real:n*t-e*s,imag:n*s+e*t})),Qy=Wn(eu,DS,nY),sY={kernelName:eu,backendName:"cpu",kernelFunc:Qy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EN(n,e,t){const s=Jr(-1,t);return DS([],e,s,n,t)}function iY(n){const{inputs:e,backend:t}=n,{x:s}=e;Ve(s,"neg");const i=t.data.get(s.dataId).values,[r,a]=EN(i,s.shape,s.dtype);return t.makeTensorInfo(a,s.dtype,r)}const rY={kernelName:_d,backendName:"cpu",kernelFunc:iY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kN=Tn((n,e)=>n!==e?1:0),aY=Wn(Id,kN,null,"bool"),oY={kernelName:Id,backendName:"cpu",kernelFunc:aY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FS(n,e,t,s,i){const r=e.length,a=re(e),o=He(e),l=He(i),c=Rn(t,re(i));for(let u=0;u<a;++u){const h=Qo(u,r,o),d=new Array(h.length);for(let f=0;f<d.length;f++)d[f]=h[s[f]];const p=Oi(d,r,l);c[p]=n[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rs(n){const{inputs:e,attrs:t,backend:s}=n,{x:i}=e,{perm:r}=t;Ve(i,"transpose");const a=i.shape.length,o=new Array(a);for(let u=0;u<o.length;u++)o[u]=i.shape[r[u]];const l=s.data.get(i.dataId).values,c=FS(l,i.shape,i.dtype,r,o);return{dataId:s.write(c,o,i.dtype),shape:o,dtype:i.dtype}}const lY={kernelName:Io,backendName:"cpu",kernelFunc:Rs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NN(n,e,t,s){const[i,r]=Vn(n,s),a=Es(e,"int32"),o=Zn(re(i),a),l=re(r);for(let c=0;c<o.length;++c){const u=c*l;let h=1;for(let d=0;d<l;++d)h*=t[u+d];o[c]=h}return{outVals:o,outShape:i,outDtype:a}}function cY(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;Ve(i,"prod");const o=i.shape.length,l=mt(r,i.shape),c=un(l,o);let u=l,h=i;const d=[];c!=null&&(h=Rs({inputs:{x:i},backend:t,attrs:{perm:c}}),d.push(h),u=gn(u.length,o));const p=t.data.get(h.dataId).values,{outVals:f,outShape:y,outDtype:m}=NN(h.shape,h.dtype,p,u);let g=y;return a&&(g=mn(y,l)),d.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.makeTensorInfo(g,m,f)}const uY={kernelName:Rd,backendName:"cpu",kernelFunc:cY};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hY(n,e,t){n.forEach((s,i)=>{if(s<0||s>=t){const r=Qo(i,e.length,He(e)).join(",");throw new Error(`indices[${r}] = ${s} is not in [0, ${t})`)}})}function dY(n,e){for(let t=0;t<n.length;++t){const s=n[t],i=t===n.length-1?e:n[t+1].length;if(s.length===0)throw new Error("Ragged splits may not be empty");if(s[0]<0)throw new Error("Ragged splits must be non-negative");if(s[s.length-1]>i)throw new Error("Ragged splits must not point past values");for(let r=1;r<s.length;++r)if(s[r-1]>s[r])throw new Error("Ragged splits must be sorted in ascending order")}}function pY(n,e,t,s){const i=[];let r=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);dY(t,s);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let h=1;h<l+1;++h)o[c].push(h*u)}for(let c=0;c<n.length;++c){let u=n[c],h=n[c]+1;for(let d=0;d<t.length;++d){const p=t[d],f=d+e.length-1;if(f>=0){const y=o[f],m=y[y.length-1]-p[u];for(let g=u;g<h;++g)o[f].push(p[g+1]+m)}u=p[u],h=p[h]}h!==u&&(i.push([u,h]),r+=h-u)}return{outSplits:o,valueSlices:i,numValues:r}}function fY(n){const e=[];for(let t=0;t<n.length;++t){const s=n[t].length,i=pn("int32",s);e.push(i),n[t].forEach((r,a)=>i[a]=r)}return e}function eM(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let s=e;s<n.length;s++)t[e-1]*=n[s];return t}function mY(n,e,t,s,i,r){const a=eM(e,2)[1],o=eM(r,2)[1];let l=0;for(const c of t)for(let u=c[0];u<c[1];++u){for(let h=0;h<s;++h)i[l*o+h]=n[u*a+h];++l}}function gY(n,e,t,s,i){const r=e.slice();r[0]=i;const a=pn(t,re(r)),o=n.length,l=o===0?0:o/e[0];return mY(n,e,s,l,a,r),[a,r]}function RN(n,e,t,s,i,r,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(hY(r,a,l),s.length===0)throw new Error("params.rank must be nonzero");const c=s[0],{outSplits:u,valueSlices:h,numValues:d}=pY(r,a,n,c),p=fY(u),f=gY(t,s,i,h,d);return[p,f[0],f[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tM=2147483647;function AN(n,e,t,s,i,r,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,l=i.length===0,c=a.length===0,u=[];o||u.push(e[0]),l||u.push(i[0]),c||u.push(a[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=u.length===0?1:u[0],d=pn("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const g=o?n[0]:n[m],b=l?s[0]:s[m],x=c?r[0]:r[m];if(x===0)throw new Error("Requires delta != 0");let v;if(x>0&&b<g||x<0&&b>g)v=0;else if(v=Math.ceil(Math.abs((b-g)/x)),v>tM)throw new Error(`Requires ((limit - start) / delta) <= ${tM}`);d[m+1]=d[m]+v}const p=d[h],f=pn(t,p);let y=0;for(let m=0;m<h;++m){const g=d[m+1]-d[m];let b=o?n[0]:n[m];const x=c?r[0]:r[m];for(let v=0;v<g;++v)f[y++]=b,b+=x}return[d,f]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var hi=Li;class pm{constructor(e,t,s,i,r,a,o,l,c,u){this.shape=e,this.shapeShape=t,this.values=s,this.valuesShape=i,this.valuesDType=r,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=vE(u),this.raggedRank=wE(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===hi.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===hi.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case hi.VALUE_ROWIDS:return pm.getMaxWidthValueRowID(t);case hi.ROW_SPLITS:return pm.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${hi[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let s=0;for(let i=0;i<t-1;++i){const r=e[i+1]-e[i];r>s&&(s=r)}return s}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let s=0,i=e[0],r=0;for(let a=1;a<t;++a){const o=e[a];o!==i&&(i=o,r=Math.max(a-s,r),s=a)}return Math.max(t-s,r)}tensorShapeFromTensor(e,t,s=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return sM(e,s)}calculateOutputSize(e){const t=this.valuesShape,s=this.defaultValueShape;SE(s,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),r=xE(this.raggedRank,i,t);r[0]<0&&(r[0]=e);for(let a=1;a<=this.raggedRank;++a)r[a]<0&&(r[a]=this.getMaxWidth(a));return r}calculateFirstParentOutputIndex(e,t,s){const i=Math.min(e,s),r=[];let a=0;for(let o=0;o<i;++o,a+=t)r.push(a);for(let o=i;o<e;++o)r.push(-1);return E(r.length===e,()=>"Final length of result must be equal to firstDimension."),r}calculateOutputIndexRowSplit(e,t,s,i){const r=e.length,a=[];for(let o=0;o<r-1;++o){const l=e[o+1]-e[o];let c=Math.min(i,l),u=t[o];u===-1&&(c=0);for(let h=0;h<c;++h)a.push(u),u+=s;for(let h=0;h<l-c;++h)a.push(-1)}if(r>0&&a.length!==e[r-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,s,i){const r=e.length,a=[];if(r===0)return[];let o=0,l=e[0];if(l>=t.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${t.length}`);let c=t[l];a.push(c);for(let u=1;u<r;++u){const h=e[u];if(h===l)c>=0&&(++o,o<i?c+=s:c=-1);else{if(o=0,l=h,h>=t.length)throw new Error(`Got nextValueRowId=${h} which is not less than ${t.length}`);c=t[h]}a.push(c)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,s,i){const r=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case hi.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,s,i);case hi.ROW_SPLITS:if(r.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${r.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(r,t,s,i);default:throw new Error(`Unsupported partition type: ${hi[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case hi.FIRST_DIM_SIZE:return e[0];case hi.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case hi.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${hi[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),s=new Array(this.raggedRank+1);s[s.length-1]=1;for(let a=s.length-2;a>=0;--a)s[a]=s[a+1]*t[a+1];const i=sM(t,!1),r=pn(this.valuesDType,re(i));if(s[0]*t[0]>0){let a=this.calculateFirstParentOutputIndex(e,s[0],t[0]);for(let o=1;o<=this.raggedRank;++o)a=this.calculateOutputIndex(o-1,a,s[o],t[o]);this.setOutput(this.raggedRank,a,r,i)}return[i,r]}setOutput(e,t,s,i){if(s.length===0)return;const r=this.values,a=s;let o=i.slice();o=o.slice(e+1);const l=re(o),c=t.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const f=this.defaultValueShape;j(()=>{const y=K(u,f);u=Mo(y,o).dataSync()})}let h=0,d=0,p=0;for(let f=0;f<=c;++f){let y=f<c?t[f]:-1;if(y===p){++p;continue}if(d<p){const m=r.subarray(h*l),g=a.subarray(d*l),b=(p-d)*l;nM(g,m,b)}if(f>=c){const m=s.length;y=Math.floor(m/l)}if(y>p)if(this.defaultValue.length===1)a.subarray(p*l,y*l).fill(this.defaultValue[0]),p=y;else for(;y>p;){const m=a.slice(p*l);nM(m,u,l),++p}y<0?(h=f+1,d=p):(h=f,d=p,p=d+1)}}}function nM(n,e,t){for(let s=0;s<t;s++)n[s]=e[s]}function sM(n,e){const t=[];for(let s of n){if(s<0){if(!e)throw new Error(`Dimension ${s} must be >= 0`);if(s<-1)throw new Error(`Dimension ${s} must be >= -1`);s=-1}t.push(s)}return t}function LN(n,e,t,s,i,r,a,o,l,c){return new pm(n,e,t,s,i,r,a,o,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PN(n,e,t,s){const i=n===e,r=n<e&&t<0,a=e<n&&t>1;if(i||r||a)return Zn(0,s);const o=Math.abs(Math.ceil((e-n)/t)),l=Zn(o,s);e<n&&t===1&&(t=-1),l[0]=n;for(let c=1;c<l.length;c++)l[c]=l[c-1]+t;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DN=Za(n=>1/Math.sqrt(n)),yY=Ou(au,DN),bY={kernelName:au,backendName:"cpu",kernelFunc:yY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zl(n,e,t,s,i,r,a,o,l,c){const u=[s/i,i],h=n.values,d=e.values;if(s===0)return ut(t,e.dtype);const p=ut(u,e.dtype);typeof l=="string"||typeof l=="number"?p.values.fill(l):typeof l=="boolean"&&p.values.fill(+l);for(let f=0;f<r;f++){const y=[];let m=0;for(let g=0;g<a;g++){const b=h[f*a+g];y.push(b),m+=b*o[g]}if(m<0||m>=s/i)throw new Error(`Invalid indices: ${y} does not index into ${t}`);for(let g=0;g<i;g++)c?p.values[m*i+g]+=d[f*i+g]:p.values[m*i+g]=e.rank===0?d[0]:d[f*i+g]}return p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xY=Za(n=>1/(1+Math.exp(-n))),FN=Gt(hu,n=>1/(1+Math.exp(-n))),vY={kernelName:hu,backendName:"cpu",kernelFunc:FN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ON(n,e,t,s,i){const r=zv(s,e,t),a=re(t),o=He(s);if(r){const h=Vv(e,o);return i==="string"?n.slice(h,h+a):n.subarray(h,h+a)}const l=i==="string"?Wo(n):n,c=ut(s,i,l),u=ut(t,i);for(let h=0;h<u.size;++h){const d=u.indexToLoc(h),p=d.map((f,y)=>f+e[y]);u.set(c.get(...p),...d)}return i==="string"?UE(u.values):u.values}function $o(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:a}=s;Ve(i,"slice");const[o,l]=_y(i,r,a);Ov(i,o,l);const c=t.data.get(i.dataId).values,u=ON(c,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,u)}const wY={kernelName:Od,backendName:"cpu",kernelFunc:$o};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GN(n,e,t,s,i,r,a){const o=e[0],l=r[0],c=new Array(l),u=new Array(o),h=e[1];if(l===0){if(o!==0)throw new Error(kE(o));const m=pn(t,0),g=pn(i,0);return[m,[0,h],g,c,u]}let d=!0,p=0;const f=new Array(l).fill(0);for(let m=0;m<o;++m){const g=n[m*h];if(g<0)throw new Error(NE(m,g));if(g>=l)throw new Error(RE(m,g,l));++f[g],d=d&&g>=p,p=g}let y=!0;for(let m=0;m<l;++m){const g=f[m]===0;c[m]=g,y=y&&!g,f[m]=Math.max(f[m],1),m>0&&(f[m]+=f[m-1])}if(y&&d){const m=n,g=s;for(let b=0;b<o;++b)u[b]=b;return[m,[o,h],g,c,u]}else{const m=f[l-1],g=pn(t,m*h),b=pn(i,m),x=new Array(l).fill(0);for(let v=0;v<o;++v){const w=n[v*h],_=x[w],I=(w===0?0:f[w-1])+_;x[w]++;for(let C=0;C<h;++C)g[I*h+C]=n[v*h+C];b[I]=s[v],u[v]=I}for(let v=0;v<l;++v)if(x[v]===0){const w=v===0?0:f[v-1];g[w*h+0]=v;for(let _=1;_<h;++_)g[w*h+_]=0;b[w]=a}return[g,[m,h],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zN(n,e,t,s,i){const r=re(s),a=e[0],o=i.length,l=[];let c=1,u=-1;for(let y=0;y<o;++y){const m=i[y];if(m===-1){if(u!==-1)throw new Error(AE(u,y));u=y,l.push(1)}else{if(m<0)throw new Error(LE(y,m));c*=m,l.push(m)}}if(u!==-1){if(c<=0)throw new Error(PE());const y=Math.trunc(r/c);if(c*y!==r)throw new Error(DE(s,l));l[u]=y}if(re(l)!==r)throw new Error(FE(s,l));const h=s.length,d=[];if(h>0){d[h-1]=1;for(let y=h-2;y>=0;--y)d[y]=d[y+1]*s[y+1]}const p=[];if(o>0){p[o-1]=1;for(let y=o-2;y>=0;--y)p[y]=p[y+1]*l[y+1]}const f=pn(t,a*o);for(let y=0;y<a;++y){let m=0;for(let g=0;g<h;++g)m+=n[y*h+g]*d[g];for(let g=0;g<o;++g)f[y*o+g]=Math.trunc(m/p[g]),m%=p[g]}return[f,[a,o],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OS(n,e,t,s,i,r=!1,a=0){const o=s.length,l=[e[0],n.length/e[0]],c=l[1],u=o>0?i[o-1]+1:0;if(u<0)throw new Error(cx());const h=e.slice();h[0]=u;const d=h.reduce((b,x)=>b*x,1),p=pn(t,d);if(o===0)return u>0&&p.fill(a),[p,h];if(u<=0)throw new Error(cx());let f=0,y=1,m=0,g=i[f];for(;;){let b=0;if(y<o){if(b=i[y],g===b){++y;continue}if(g>=b)throw new Error(OE())}if(g<0||g>=u)throw new Error(GE(g,u));g>m&&p.fill(a,m*c,g*c);for(let x=f;x<y;++x){const v=s[x];if(v<0||v>=l[0])throw new Error(zE(x,s[x],l[0]));for(let w=0;w<c;w++)p[g*c+w]+=n[v*c+w]}if(r)for(let x=0;x<c;x++)p[g*c+x]/=y-f;if(f=y,++y,m=g+1,g=b,y>o)break}return m<u&&p.fill(a,m*c,u*c),[p,h]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SY=Za(n=>Math.sqrt(n)),TY=Gt(pu,n=>Math.sqrt(n)),_Y={kernelName:pu,backendName:"cpu",kernelFunc:TY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VN=Tn((n,e)=>{const t=n-e;return t*t}),IY=Wn(fu,VN),MY={kernelName:fu,backendName:"cpu",kernelFunc:IY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WN(n,e,t,s){const i=ut(n,e.dtype);for(let r=0;r<i.size;r++){const a=i.indexToLoc(r),o=new Array(a.length);for(let l=0;l<o.length;l++)o[l]=a[l]*t[l]+s[l];i.set(e.get(...o),...a)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CY{constructor(e,t,s,i,r,a){this.separator=cr(e),this.nGramWidths=t,this.leftPad=cr(s),this.rightPad=cr(i),this.padWidth=r,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const s=this.getPadWidth(t);return Math.max(0,e+2*s-t+1)}createNGrams(e,t,s,i,r,a){for(let o=0;o<r;++o){const l=this.getPadWidth(a),c=Math.max(0,l-o),u=Math.max(0,l-(r-(o+1))),h=a-(c+u),d=t+(c>0?0:o-l);let p=0;p+=c*this.leftPad.length;for(let b=0;b<h;++b)p+=e[d+b].length;p+=u*this.rightPad.length;const f=c+u+h-1;p+=f*this.separator.length,s[i+o]=new Uint8Array(p);const y=s[i+o];let m=0;const g=b=>b.forEach(x=>y[m++]=x);for(let b=0;b<c;++b)g(this.leftPad),g(this.separator);for(let b=0;b<h-1;++b)g(e[d+b]),g(this.separator);if(h>0){g(e[d+h-1]);for(let b=0;b<u;++b)g(this.separator),g(this.rightPad)}else{for(let b=0;b<u-1;++b)g(this.rightPad),g(this.separator);g(this.rightPad)}}}compute(e,t){const s=e.length,i=t.length;if(i>0){let l=t[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=t[c]>=l;if(u=u&&t[c]<=s,!u)throw new Error(`Invalid split value ${t[c]}, must be in [${l}, ${s}]`);l=t[c]}if(l!==s)throw new Error(`Last split value must be data size. Expected ${s}, got ${l}`)}const r=i-1,a=pn("int32",i);if(s===0||i===0){const l=new Array(s);for(let c=0;c<=r;++c)a[c]=0;return[l,a]}a[0]=0;for(let l=1;l<=r;++l){const c=t[l]-t[l-1];let u=0;this.nGramWidths.forEach(h=>{u+=this.getNumNGrams(c,h)}),this.preserveShort&&c>0&&u===0&&(u=1),a[l]=a[l-1]+u}const o=new Array(a[r]);for(let l=0;l<r;++l){const c=t[l];let u=a[l];if(this.nGramWidths.forEach(h=>{const d=t[l+1]-t[l],p=this.getNumNGrams(d,h);this.createNGrams(e,c,o,u,p,h),u+=p}),this.preserveShort&&u===a[l]){const h=t[l+1]-t[l];if(h===0)continue;const d=h+2*this.padWidth,p=1;this.createNGrams(e,c,o,u,p,d)}}return[o,a]}}function UN(n,e,t,s,i,r,a,o){return new CY(t,s,i,r,a,o).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EY(n,e,t,s){if(!n.length)return;if(e.length===0){for(let r=0;r<n.length;++r)s.push(n.subarray(r,r+1));return}if(e.length===1){const r=e[0];let a=n.indexOf(r);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&s.push(o),n=n.subarray(a+1),a=n.indexOf(r)}(!t||n.length!==0)&&s.push(n);return}let i=0;for(let r=0;r<n.length+1;r++)if(r===n.length||e.indexOf(n[r])!==-1){const a=n.subarray(i,r);(!t||a.length!==0)&&s.push(a),i=r+1}}function BN(n,e,t){const s=n.length,i=[];let r=0,a=0;const o=new Array(s);for(let d=0;d<s;++d){const p=i.length;EY(n[d],e,t,i);const f=i.length-p;o[d]=f,r+=f,a=Math.max(a,f)}const l=pn("int32",r*2),c=new Array(r),u=[s,a];let h=0;for(let d=0;d<s;++d)for(let p=0;p<o[d];++p)l[h*2]=d,l[h*2+1]=p,c[h]=i[h],++h;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $N(n,e){const t=pn("int32",n.length);for(let s=0;s<n.length;++s)t[s]=yC(n[s]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XN=Tn((n,e)=>n-e),kY=LS((n,e,t,s)=>({real:n-t,imag:e-s})),GS=Wn(mu,XN,kY),NY={kernelName:mu,backendName:"cpu",kernelFunc:GS};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HN(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const s=ut(t,n.dtype);for(let i=0;i<s.values.length;++i){const r=s.indexToLoc(i),a=new Array(n.rank);for(let l=0;l<a.length;l++)a[l]=r[l]%n.shape[l];const o=n.locToIndex(a);s.values[i]=n.values[o]}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ph=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function KN(n,e,t=0,s=n.length-1){for(;s>t;){if(s-t>600){const o=s-t+1,l=e-t+1,c=Math.log(o),u=.5*Math.exp(2*c/3),h=.5*Math.sqrt(c*u*(o-u)/o)*Math.sign(l-o/2),d=Math.max(t,Math.floor(e-l*u/o+h)),p=Math.min(s,Math.floor(e+(o-l)*u/o+h));KN(n,e,d,p)}const i=n[e];let r=t,a=s;for(Lr(n,t,e),ph(n[s],i)>0&&Lr(n,t,s);r<a;){for(Lr(n,r,a),r++,a--;ph(n[r],i)<0;)r=r+1;for(;ph(n[a],i)>0;)a=a-1}ph(n[t],i)===0?Lr(n,t,a):(a=a+1,Lr(n,a,s)),a<=e&&(t=a+1),e<=a&&(s=a-1)}}function ZN(n,e,t,s,i){const r=e[e.length-1],[a,o]=[n.length/r,r],l=Rn(t,a*s),c=Rn("int32",a*s);for(let h=0;h<a;h++){const d=h*o,p=n.subarray(d,d+o);let f=new Array(p.length);p.forEach((b,x)=>f[x]={value:b,index:x}),s<f.length&&(KN(f,s),f=f.slice(0,s)),i&&f.sort(ph);const y=h*s,m=l.subarray(y,y+s),g=c.subarray(y,y+s);for(let b=0;b<s;b++)m[b]=f[b].value,g[b]=f[b].index}const u=e.slice();return u[u.length-1]=s,[ut(u,t,l),ut(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YN(n,e,t,s){const i=mt(e,t)[0],r=[1,t[0],1];for(let f=0;f<i;f++)r[0]*=t[f];r[1]=t[i];for(let f=i+1;f<t.length;f++)r[2]*=t[f];const a={},o=new Int32Array(t[i]),l=new En(r,s,n),c=[],u=r[0]===1&&r[2]===1;for(let f=0;f<t[i];f++){let y;if(u)y=n[f].toString();else{const m=[];for(let g=0;g<r[0];g++)for(let b=0;b<r[2];b++)m.push(l.get(g,f,b));y=m.join(",")}if(a[y]!==void 0)o[f]=a[y];else{const m=Object.keys(a).length;a[y]=m,o[f]=m,c.push(f)}}const h=r.slice();h[1]=Object.keys(a).length;const d=new En(h,s);c.forEach((f,y)=>{for(let m=0;m<r[0];m++)for(let g=0;g<r[2];g++)d.set(l.get(m,f,g),m,y,g)});const p=t.slice();return p[i]=h[1],{outputValues:d.values,outputShape:p,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RY=Object.freeze(Object.defineProperty({__proto__:null,addImpl:oN,bincountImpl:PS,bincountReduceImpl:lN,castImpl:aN,ceilImpl:cN,concatImpl:uN,equalImpl:hN,expImpl:pN,expm1Impl:mN,floorImpl:gN,gatherNdImpl:yN,gatherV2Impl:bN,greaterEqualImpl:vN,greaterImpl:xN,lessEqualImpl:SN,lessImpl:wN,linSpaceImpl:TN,logImpl:_N,maxImpl:IN,maximumImpl:MN,minimumImpl:CN,multiplyImpl:DS,negImpl:EN,notEqualImpl:kN,prodImpl:NN,raggedGatherImpl:RN,raggedRangeImpl:AN,raggedTensorToTensorImpl:LN,rangeImpl:PN,rsqrtImpl:DN,scatterImpl:zl,sigmoidImpl:xY,simpleAbsImpl:rN,sliceImpl:ON,sparseFillEmptyRowsImpl:GN,sparseReshapeImpl:zN,sparseSegmentReductionImpl:OS,sqrtImpl:SY,squaredDifferenceImpl:VN,stridedSliceImpl:WN,stringNGramsImpl:UN,stringSplitImpl:BN,stringToHashBucketFastImpl:$N,subImpl:XN,tileImpl:HN,topKImpl:ZN,transposeImpl:FS,uniqueImpl:YN},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */_1("cpu",()=>new jy,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jN=Gt(Gc,n=>n>=0?n:Math.exp(n)-1),AY={kernelName:Gc,backendName:"cpu",kernelFunc:jN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QN(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s;Ve([i],"leakyRelu");const a=re(i.shape),o=t.data.get(i.dataId).values,l=Rn("float32",a);for(let c=0;c<o.length;c++)l[c]=o[c]<0?r*o[c]:o[c];return t.makeTensorInfo(i.shape,"float32",l)}const LY={kernelName:hd,backendName:"cpu",kernelFunc:QN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PY=Tn((n,e)=>n<0?e*n:n);function JN(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e;Ve([s,i],"prelu");const r=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,[o,l]=PY(s.shape,i.shape,r,a,"float32");return t.makeTensorInfo(l,"float32",o)}const DY={kernelName:Nd,backendName:"cpu",kernelFunc:JN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qN=Gt(su,n=>Math.max(0,n)),FY={kernelName:su,backendName:"cpu",kernelFunc:qN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eR=Gt(iu,n=>Math.min(Math.max(0,n),6)),OY={kernelName:iu,backendName:"cpu",kernelFunc:eR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fm(n,e,t,s,i){if(t==="linear")return gr({inputs:{x:e},backend:n});if(t==="relu")return qN({inputs:{x:e},backend:n});if(t==="elu")return jN({inputs:{x:e},backend:n});if(t==="relu6")return eR({inputs:{x:e},backend:n});if(t==="prelu")return JN({inputs:{x:e,alpha:s},backend:n});if(t==="leakyrelu")return QN({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return FN({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ht(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,a=re(i.shape),o=l1(r,a),l=re(o);E(a===l,()=>`The new shape (${o}) has ${l} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const c=t.data.get(i.dataId);if(c.complexTensorInfos!=null){const u=c.complexTensorInfos.real,h=c.complexTensorInfos.imag;u.shape=o,h.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const GY={kernelName:Ad,backendName:"cpu",kernelFunc:Ht};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tR(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:a,transposeB:o}=s;Ve([i,r],"matMul");const l=i.shape.length,c=r.shape.length,u=a?i.shape[l-2]:i.shape[l-1],h=o?r.shape[c-1]:r.shape[c-2],d=a?i.shape[l-1]:i.shape[l-2],p=o?r.shape[c-2]:r.shape[c-1],f=i.shape.slice(0,-2),y=r.shape.slice(0,-2),m=re(f),g=re(y),b=st(i.shape.slice(0,-2),r.shape.slice(0,-2)).concat([d,p]);E(u===h,()=>`Error in matMul: inner shapes (${u}) and (${h}) of Tensors with shapes ${i.shape} and ${r.shape} and transposeA=${a} and transposeB=${o} must match.`);const x=a?[m,u,d]:[m,d,u],v=o?[g,p,h]:[g,h,p],w=Ht({inputs:{x:i},backend:t,attrs:{shape:x}}),_=Ht({inputs:{x:r},backend:t,attrs:{shape:v}}),I=a?w.shape[1]:w.shape[2],C=a?w.shape[2]:w.shape[1],S=o?_.shape[1]:_.shape[2],M=Math.max(m,g),A=t.data.get(w.dataId).values,D=t.data.get(_.dataId).values,F=He(w.shape),k=He(_.shape),[P,O,V]=a?[F[0],1,F[1]]:[F[0],F[1],1],[$,H,Y]=o?[1,k[1],k[0]]:[k[1],1,k[0]],G=C*S,B=ut([M,C,S],w.dtype),te=B.values,se=t.blockSize;for(let ae=0;ae<M;ae++){const fe=ae%m,be=ae%g;for(let ge=0;ge<C;ge+=se){const ve=Math.min(ge+se,C);for(let Oe=0;Oe<S;Oe+=se){const Ce=Math.min(Oe+se,S);for(let q=0;q<I;q+=se){const vt=Math.min(q+se,I);for(let Ee=ge;Ee<ve;Ee++)for(let Le=Oe;Le<Ce;Le++){let Ae=0;for(let Ye=q;Ye<vt;Ye++){const $e=A[fe*P+Ee*O+Ye*V],Je=D[Ye*$+Le*H+be*Y];Ae+=$e*Je}te[ae*G+(Ee*S+Le)]+=Ae}}}}}return t.disposeIntermediateTensorInfo(w),t.disposeIntermediateTensorInfo(_),t.makeTensorInfo(b,B.dtype,B.values)}const zY={kernelName:jh,backendName:"cpu",kernelFunc:tR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VY(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;let d,p,f;const y=[];d=tR({inputs:{a:i,b:r},attrs:{transposeA:l,transposeB:c},backend:t}),a&&(p=mc({inputs:{a:d,b:a},backend:t}),y.push(d),d=p),u&&(f=fm(t,d,u,o,h),y.push(d),d=f);for(const m of y)t.disposeIntermediateTensorInfo(m);return d}const WY={kernelName:_h,backendName:"cpu",kernelFunc:VY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UY=Gt(Ic,n=>Math.acos(n)),BY={kernelName:Ic,backendName:"cpu",kernelFunc:UY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Y=Gt(Mc,n=>Math.acosh(n)),XY={kernelName:Mc,backendName:"cpu",kernelFunc:$Y};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HY(n){const{inputs:e,backend:t}=n,s=e;Ve(e,"addN");const i=s.map(o=>t.data.get(o.dataId).values),r=ut(s[0].shape,s[0].dtype),a=r.values;for(let o=0;o<s.length;o++){const l=i[o];for(let c=0;c<a.length;c++)a[c]+=l[c]}return t.makeTensorInfo(r.shape,r.dtype,r.values)}const KY={kernelName:Xh,backendName:"cpu",kernelFunc:HY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZY(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;Ve(i,"all");const o=mt(r,i.shape);let l=o;const c=un(l,i.shape.length);let u=i;c!=null&&(u=Rs({inputs:{x:i},backend:t,attrs:{perm:c}}),l=gn(l.length,i.shape.length)),Jn("all",l,u.shape.length);const[h,d]=Vn(u.shape,l),p=re(d),f=Zn(re(h),u.dtype),y=t.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let x=y[b];for(let v=0;v<p;++v){const w=y[b+v];x=x&&w}f[g]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(a){const g=mn(h,o),b=Ht({inputs:{x:m},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(m),b}return m}const YY={kernelName:Fm,backendName:"cpu",kernelFunc:ZY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jY(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;Ve(i,"any");const o=mt(r,i.shape);let l=o;const c=un(l,i.shape.length);let u=i;c!=null&&(u=Rs({inputs:{x:i},backend:t,attrs:{perm:c}}),l=gn(l.length,i.shape.length)),Jn("any",l,u.shape.length);const[h,d]=Vn(u.shape,l),p=re(d),f=Zn(re(h),u.dtype),y=t.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let x=y[b];for(let v=0;v<p;++v){const w=y[b+v];x=x||w}f[g]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(a){const g=mn(h,o),b=Ht({inputs:{x:m},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(m),b}return m}const QY={kernelName:Om,backendName:"cpu",kernelFunc:jY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JY(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;Ve(i,"argMax");let a=mt(r,i.shape);const o=un(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Rs({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),a=gn(a.length,l.shape.length)),a=[a[0]],Jn("argMax",a,l.shape.length);const[u,h]=Vn(l.shape,a),d=re(u),p=Zn(d,"int32"),f=re(h),y=t.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const g=m*f;let b=y[g],x=0;for(let v=0;v<f;++v){const w=y[g+v];w>b&&(b=w,x=v)}p[m]=x}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",p)}const qY={kernelName:Hh,backendName:"cpu",kernelFunc:JY};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ej(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;Ve(i,"argMin");let a=mt(r,i.shape);const o=un(a,i.shape.length);let l=i;const c=[];o!=null&&(l=Rs({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),a=gn(a.length,l.shape.length)),a=[a[0]],Jn("argMin",a,l.shape.length);const[u,h]=Vn(l.shape,a),d=re(u),p=Zn(d,"int32"),f=re(h),y=t.data.get(l.dataId).values;for(let m=0;m<p.length;++m){const g=m*f;let b=y[g],x=0;for(let v=0;v<f;++v){const w=y[g+v];w<b&&(b=w,x=v)}p[m]=x}return c.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",p)}const tj={kernelName:Kh,backendName:"cpu",kernelFunc:ej};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nj=Gt(Cc,n=>Math.asin(n)),sj={kernelName:Cc,backendName:"cpu",kernelFunc:nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ij=Gt(Ec,n=>Math.asinh(n)),rj={kernelName:Ec,backendName:"cpu",kernelFunc:ij};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aj=Gt(kc,n=>Math.atan(n)),oj={kernelName:kc,backendName:"cpu",kernelFunc:aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lj=Tn((n,e)=>Math.atan2(n,e)),cj=Wn(Rc,lj),uj={kernelName:Rc,backendName:"cpu",kernelFunc:cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hj=Gt(Nc,n=>Math.atanh(n)),dj={kernelName:Nc,backendName:"cpu",kernelFunc:hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zS(n,e,t,s,i,r){const a=i.strideHeight,o=i.strideWidth,l=i.dilationHeight,c=i.dilationWidth,u=i.effectiveFilterHeight,h=i.effectiveFilterWidth,d=i.padInfo.top,p=i.padInfo.left,f=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,y=ut(i.outShape,t),m=y.values,g=i.outShape[1]*i.outShape[2]*i.outShape[3],b=i.outShape[2]*i.outShape[3],x=i.outShape[3];for(let v=0;v<i.batchSize;++v){const w=v*g,_=v*s[0];for(let I=0;I<i.inChannels;++I)for(let C=0;C<i.outHeight;++C){const S=C*a-d,M=Math.max(0,S),A=Math.min(i.inHeight,u+S),D=w+C*b;for(let F=0;F<i.outWidth;++F){const k=F*o-p,P=Math.max(0,k),O=Math.min(i.inWidth,h+k);let V=f,$=0,H=0;for(let G=M;G<A;G+=l){const B=_+G*s[1];for(let te=P;te<O;te+=c){const se=B+te*s[2],ae=n[se+I];r==="max"&&ae>V?V=ae:r==="avg"&&($+=ae,H++)}if(isNaN(V))break}const Y=D+F*x+I;m[Y]=r==="avg"?$/H:V}}}return y}function nR(n,e,t,s,i=!1,r=!1){const a=ut(s.outShape,"int32"),o=s.strideHeight,l=s.strideWidth,c=s.dilationHeight,u=s.dilationWidth,h=s.effectiveFilterHeight,d=s.effectiveFilterWidth,p=s.padInfo.top,f=s.padInfo.left,y=ut(e,t,n);for(let m=0;m<s.batchSize;++m)for(let g=0;g<s.inChannels;++g)for(let b=0;b<s.outHeight;++b){const x=b*o-p;let v=x;for(;v<0;)v+=c;const w=Math.min(s.inHeight,h+x);for(let _=0;_<s.outWidth;++_){const I=_*l-f;let C=I;for(;C<0;)C+=u;const S=Math.min(s.inWidth,d+I);let M=Number.NEGATIVE_INFINITY,A=-1;for(let D=v;D<w;D+=c){const F=D-x;for(let k=C;k<S;k+=u){const P=k-I,O=y.get(m,D,k,g);O>M&&(M=O,i?A=r?((m*s.inHeight+D)*s.inWidth+k)*s.inChannels+g:(D*s.inWidth+k)*s.inChannels+g:A=F*d+P)}}a.set(A,m,b,_,g)}}return a}function sR(n,e,t,s,i,r){const a=i.strideDepth,o=i.strideHeight,l=i.strideWidth,c=i.dilationDepth,u=i.dilationHeight,h=i.dilationWidth,d=i.effectiveFilterDepth,p=i.effectiveFilterHeight,f=i.effectiveFilterWidth,y=i.padInfo.front,m=i.padInfo.top,g=i.padInfo.left,b=r==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,x=ut(i.outShape,t),v=x.values,w=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],_=i.outShape[2]*i.outShape[3]*i.outShape[4],I=i.outShape[3]*i.outShape[4],C=i.outShape[4];for(let S=0;S<i.batchSize;++S){const M=S*w,A=S*s[0];for(let D=0;D<i.inChannels;++D)for(let F=0;F<i.outDepth;++F){const k=F*a-y;let P=k;for(;P<0;)P+=c;const O=Math.min(i.inDepth,d+k),V=M+F*_;for(let $=0;$<i.outHeight;++$){const H=$*o-m;let Y=H;for(;Y<0;)Y+=u;const G=Math.min(i.inHeight,p+H),B=V+$*I;for(let te=0;te<i.outWidth;++te){const se=te*l-g;let ae=se;for(;ae<0;)ae+=h;const fe=Math.min(i.inWidth,f+se),be=B+te*C;let ge=b,ve=0,Oe=0;for(let q=P;q<O;q+=c){const vt=A+q*s[1];for(let Ee=Y;Ee<G;Ee+=u){const Le=vt+Ee*s[2];for(let Ae=ae;Ae<fe;Ae+=h){const Ye=Le+Ae*s[3],$e=n[Ye+D];if(r==="max"&&$e>ge?ge=$e:r==="avg"&&(ve+=$e,Oe++),isNaN(ge))break}if(isNaN(ge))break}if(isNaN(ge))break}const Ce=be+D;v[Ce]=r==="avg"?ve/Math.max(Oe,1):ge}}}}return x}function pj(n,e){const t=ut(e.outShape,"int32"),s=e.strideDepth,i=e.strideHeight,r=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,l=e.dilationWidth,c=e.effectiveFilterDepth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.front,p=e.padInfo.top,f=e.padInfo.left;for(let y=0;y<e.batchSize;++y)for(let m=0;m<e.inChannels;++m)for(let g=0;g<e.outDepth;++g){const b=g*s-d;let x=b;for(;x<0;)x+=a;const v=Math.min(e.inDepth,c+b);for(let w=0;w<e.outHeight;++w){const _=w*i-p;let I=_;for(;I<0;)I+=o;const C=Math.min(e.inHeight,u+_);for(let S=0;S<e.outWidth;++S){const M=S*r-f;let A=M;for(;A<0;)A+=l;const D=Math.min(e.inWidth,h+M);let F=Number.NEGATIVE_INFINITY,k=-1;for(let P=x;P<v;P+=a){const O=P-b;for(let V=I;V<C;V+=o){const $=V-_;for(let H=A;H<D;H+=l){const Y=H-M,G=n.get(y,P,V,H,m);G>=F&&(F=G,k=O*u*h+$*u+Y)}}}t.set(k,y,g,w,S,m)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Ve(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;E(Qn(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=_i(i.shape,r,a,c,o,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&St(u.inShape,u.outShape))h=gr({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,p=He(i.shape),f=zS(d,i.shape,i.dtype,p,u,"avg");h=t.makeTensorInfo(u.outShape,i.dtype,f.values)}return h}const mj={kernelName:Zh,backendName:"cpu",kernelFunc:fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ve(i,"avgPool3d");const u=qr(i.shape,r,a,1,o,l,c),h=t.data.get(i.dataId).values,d=sR(h,i.shape,i.dtype,He(i.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const yj={kernelName:Yh,backendName:"cpu",kernelFunc:gj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;Ve([i,r],"avgPool3DGrad");const u=qr(r.shape,a,o,1,l,c),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,y=u.filterHeight,m=u.filterWidth,g=u.dilationDepth,b=u.dilationHeight,x=u.dilationWidth,v=u.effectiveFilterDepth,w=u.effectiveFilterHeight,_=u.effectiveFilterWidth,I=v-1-u.padInfo.front,C=_-1-u.padInfo.left,S=w-1-u.padInfo.top,M=ut(r.shape,"float32"),A=1/(f*y*m),D=t.bufferSync(i);for(let F=0;F<u.batchSize;++F)for(let k=0;k<u.inChannels;++k)for(let P=0;P<u.inDepth;++P)for(let O=0;O<u.inHeight;++O)for(let V=0;V<u.inWidth;++V){const $=P-I,H=O-S,Y=V-C;let G=0;for(let B=0;B<v;B+=g){const te=($+B)/h;if(!(te<0||te>=u.outDepth||Math.floor(te)!==te))for(let se=0;se<w;se+=b){const ae=(H+se)/d;if(!(ae<0||ae>=u.outHeight||Math.floor(ae)!==ae))for(let fe=0;fe<_;fe+=x){const be=(Y+fe)/p;if(be<0||be>=u.outWidth||Math.floor(be)!==be)continue;const ge=D.get(F,te,ae,be,k);G+=ge}}}M.set(G*A,F,P,O,V,k)}return t.makeTensorInfo(M.shape,M.dtype,M.values)}const xj={kernelName:zm,backendName:"cpu",kernelFunc:bj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,a=r;Ve([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,u=_i(a.shape,o,l,1,c),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,y=u.dilationHeight,m=u.dilationWidth,g=u.effectiveFilterHeight,b=u.effectiveFilterWidth,x=b-1-u.padInfo.left,v=g-1-u.padInfo.top,w=ut(a.shape,"float32"),_=1/(p*f),I=t.data.get(i.dataId).values,C=ut(i.shape,"float32",I);for(let S=0;S<u.batchSize;++S)for(let M=0;M<u.inChannels;++M)for(let A=0;A<u.inHeight;++A)for(let D=0;D<u.inWidth;++D){const F=A-v,k=D-x;let P=0;for(let O=0;O<g;O+=y){const V=(F+O)/h;if(!(V<0||V>=u.outHeight||Math.floor(V)!==V))for(let $=0;$<b;$+=m){const H=(k+$)/d;if(H<0||H>=u.outWidth||Math.floor(H)!==H)continue;const Y=C.get(S,V,H,M);P+=Y}}w.set(P*_,S,A,D,M)}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const wj={kernelName:Gm,backendName:"cpu",kernelFunc:vj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,scale:r,offset:a,mean:o,variance:l}=e;E(o.shape.length===l.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(r==null||o.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ve([i,o,l,r,a],"batchNorm");let{varianceEpsilon:c}=s;c==null&&(c=.001);const u=t.data.get(i.dataId).values,h=t.data.get(o.dataId).values,d=t.data.get(l.dataId).values,p=r?t.data.get(r.dataId).values:new Float32Array([1]),f=a?t.data.get(a.dataId).values:new Float32Array([0]),y=new Float32Array(u.length),m=f.length,g=p.length,b=d.length,x=h.length;let v=0,w=0,_=0,I=0;for(let C=0;C<u.length;++C)y[C]=f[v++]+(u[C]-h[w++])*p[_++]/Math.sqrt(d[I++]+c),v>=m&&(v=0),w>=x&&(w=0),_>=g&&(_=0),I>=b&&(I=0);return t.makeTensorInfo(i.shape,i.dtype,y)}const Tj={kernelName:ld,backendName:"cpu",kernelFunc:Sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _j(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:a}=s;Ve([i],"batchToSpaceND");const o=r.reduce((g,b)=>g*b),l=hp(i.shape,r,o),c=dp(l.length,r.length),u=pp(i.shape,r,o),h=Xv(a,r.length),d=Hv(u,a,r.length),p=Ht({inputs:{x:i},backend:t,attrs:{shape:l}}),f=Rs({inputs:{x:p},backend:t,attrs:{perm:c}}),y=Ht({inputs:{x:f},backend:t,attrs:{shape:u}}),m=$o({inputs:{x:y},backend:t,attrs:{begin:h,size:d}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),m}const Ij={kernelName:Qh,backendName:"cpu",kernelFunc:_j};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:a}=s,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=PS(o,l,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,c)}const Cj={kernelName:Vm,backendName:"cpu",kernelFunc:Mj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ej(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.data.get(s.dataId).values,a=t.data.get(i.dataId).values,o=st(Array.from(r),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const kj={kernelName:Wm,backendName:"cpu",kernelFunc:Ej};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nj=Gt(Pc,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),Rj={kernelName:Pc,backendName:"cpu",kernelFunc:Nj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aj=n=>{const{x:e}=n.inputs,t=n.backend,s=new Float32Array(re(e.shape)),i=t.data.get(e.dataId),r=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values;for(let c=0;c<o.length;c++){const u=o[c],h=l[c];s[c]=Math.hypot(u,h)}return t.makeOutput(s,e.shape,"float32")},Lj={kernelName:Jh,backendName:"cpu",kernelFunc:Aj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gc(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.data.get(s.dataId).complexTensorInfos.imag,r=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,r)}const Pj={kernelName:ag,backendName:"cpu",kernelFunc:gc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yc(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=mt(i,e[0].shape)[0],a=e.map(y=>y.shape);Uv(a,r);let o=hr(e.map(y=>y.shape),r);if(re(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(y=>re(y.shape)>0);if(l.length===1)return gr({inputs:{x:l[0]},backend:t});if(l[0].dtype==="complex64"){const y=l.map(v=>Bo({inputs:{input:v},backend:t})),m=l.map(v=>gc({inputs:{input:v},backend:t})),g=yc({inputs:y,backend:t,attrs:{axis:r}}),b=yc({inputs:m,backend:t,attrs:{axis:r}}),x=Gs({inputs:{real:g,imag:b},backend:t});return y.forEach(v=>t.disposeIntermediateTensorInfo(v)),m.forEach(v=>t.disposeIntermediateTensorInfo(v)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),x}const c=l.map(y=>{const m=[-1,re(y.shape.slice(r))];return Ht({inputs:{x:y},backend:t,attrs:{shape:m}})}),u=c.map(y=>({vals:t.data.get(y.dataId).values,shape:y.shape}));o=hr(c.map(y=>y.shape),1);const h=c[0].shape[0]===1,d=uN(u,o,e[0].dtype,h),p=hr(l.map(y=>y.shape),r),f=t.makeTensorInfo(p,e[0].dtype,d);return c.forEach(y=>t.disposeIntermediateTensorInfo(y)),f}const Dj={kernelName:qh,backendName:"cpu",kernelFunc:yc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iR(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=s;Ve([i,r],"conv2d");const h=ea(l),d=zn(i.shape,r.shape,a,c,o,u,!1,h),p=d.filterHeight,f=d.filterWidth,y=d.dilationHeight,m=d.dilationWidth,g=d.padInfo.left,b=d.padInfo.top,x=d.dataFormat==="channelsLast",v=new En(d.outShape,i.dtype),w=He(i.shape),_=He(r.shape),I=w[0],C=x?w[1]:w[2],S=x?w[2]:1,M=x?1:w[1],A=v.strides[0],D=x?v.strides[1]:v.strides[2],F=x?v.strides[2]:1,k=x?1:v.strides[1],P=t.data.get(i.dataId).values,O=t.data.get(r.dataId).values,V=v.values;for(let $=0;$<d.batchSize;++$){const H=$*I,Y=$*A;for(let G=0;G<d.outHeight;++G){const B=Y+G*D,te=G*d.strideHeight-b;for(let se=0;se<p;++se){const ae=te+se*y;if(ae<0||ae>=d.inHeight)continue;const fe=se*_[0],be=H+ae*C;for(let ge=0;ge<d.outWidth;++ge){const ve=B+ge*F,Oe=ge*d.strideWidth-g;for(let Ce=0;Ce<f;++Ce){const q=Oe+Ce*m;if(q<0||q>=d.inWidth)continue;const vt=fe+Ce*_[1],Ee=be+q*S;let Le=vt;for(let Ae=0;Ae<d.inChannels;++Ae){const Ye=P[Ee+Ae*M];for(let $e=0;$e<d.outChannels;++$e)V[ve+$e*k]+=Ye*O[Le+$e];Le+=d.outChannels}}}}}}return t.makeTensorInfo(v.shape,v.dtype,V)}const Fj={kernelName:ed,backendName:"cpu",kernelFunc:iR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=s;Ve([i,r],"conv2dBackpropFilter");const h=ea(l),d=zn(i.shape,u,a,1,o,c,!1,h),{strideHeight:p,strideWidth:f,filterHeight:y,filterWidth:m}=d,g=d.dataFormat==="channelsLast",b=new En(d.filterShape,"float32"),x=d.padInfo.left,v=d.padInfo.top,w=t.data.get(i.dataId).values,_=t.data.get(r.dataId).values,I=new En(i.shape,i.dtype,w),C=new En(r.shape,r.dtype,_);for(let S=0;S<y;++S){const M=Math.max(0,Math.ceil((v-S)/p)),A=Math.min(d.outHeight,(d.inHeight+v-S)/p);for(let D=0;D<m;++D){const F=Math.max(0,Math.ceil((x-D)/f)),k=Math.min(d.outWidth,(d.inWidth+x-D)/f);for(let P=0;P<d.inChannels;++P)for(let O=0;O<d.outChannels;++O){let V=0;for(let $=0;$<d.batchSize;++$)for(let H=M;H<A;++H){const Y=S+H*p-v;for(let G=F;G<k;++G){const B=D+G*f-x;g?V+=I.get($,Y,B,P)*C.get($,H,G,O):V+=I.get($,P,Y,B)*C.get($,O,H,G)}}b.set(V,S,D,P,O)}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const Gj={kernelName:Bm,backendName:"cpu",kernelFunc:Oj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=s;Ve([i,r],"conv2dBackpropInput");const h=He(r.shape),d=He(i.shape);let p=ea(c);const f=zn(a,r.shape,o,1,l,u,!1,p),y=new En(f.inShape,"float32"),m=y.values,g=t.data.get(i.dataId).values,b=t.data.get(r.dataId).values,[x,v,w]=h,{batchSize:_,filterHeight:I,filterWidth:C,inChannels:S,inHeight:M,inWidth:A,outChannels:D,outHeight:F,outWidth:k,strideHeight:P,strideWidth:O}=f;p=f.dataFormat;const V=I-1-f.padInfo.top,$=C-1-f.padInfo.left,H=p==="channelsLast",Y=y.strides[0],G=H?y.strides[1]:y.strides[2],B=H?y.strides[2]:1,te=H?1:y.strides[1],se=d[0],ae=H?d[1]:d[2],fe=H?d[2]:1,be=H?1:d[1];for(let ge=0;ge<_;++ge)for(let ve=0;ve<S;++ve)for(let Oe=0;Oe<M;++Oe){const Ce=Oe-V,q=Math.max(0,Math.ceil(Ce/P)),vt=Math.min(F,(I+Ce)/P);for(let Ee=0;Ee<A;++Ee){const Le=Ee-$,Ae=Math.max(0,Math.ceil(Le/O)),Ye=Math.min(k,(C+Le)/O);let $e=0;for(let at=q;at<vt;++at){const Vt=at*P-Ce;for(let Dt=Ae;Dt<Ye;++Dt){const z=Dt*O-Le,R=se*ge+ae*at+fe*Dt,ie=x*(I-1-Vt)+v*(C-1-z)+w*ve;for(let ye=0;ye<D;++ye){const me=g[R+be*ye],xe=b[ie+ye];$e+=me*xe}}}const Je=Y*ge+G*Oe+B*Ee+te*ve;m[Je]=$e}}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const Vj={kernelName:td,backendName:"cpu",kernelFunc:zj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=s;Ve([i,r],"conv3d");const c=$a(i.shape,r.shape,a,l,o),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:y,padInfo:m}=c,g=m.front,b=m.left,x=m.top,v=new En(c.outShape,i.dtype),w=t.data.get(i.dataId).values,_=t.data.get(r.dataId).values,I=v.values,C=He(i.shape),S=He(r.shape);for(let M=0;M<c.batchSize;++M){const A=M*C[0],D=M*v.strides[0];for(let F=0;F<c.outDepth;++F){const k=D+F*v.strides[1],P=F*c.strideDepth-g;for(let O=0;O<u;++O){const V=P+O*p;if(V<0||V>=c.inDepth)continue;const $=O*S[0],H=A+V*C[1];for(let Y=0;Y<c.outHeight;++Y){const G=k+Y*v.strides[2],B=Y*c.strideHeight-x;for(let te=0;te<h;++te){const se=B+te*f;if(se<0||se>=c.inHeight)continue;const ae=$+te*S[1],fe=H+se*C[2];for(let be=0;be<c.outWidth;++be){const ge=G+be*c.outChannels,ve=be*c.strideWidth-b;for(let Oe=0;Oe<d;++Oe){const Ce=ve+Oe*y;if(Ce<0||Ce>=c.inWidth)continue;const q=ae+Oe*S[2],vt=fe+Ce*c.inChannels;let Ee=q;for(let Le=0;Le<c.inChannels;++Le){const Ae=w[vt+Le];for(let Ye=0;Ye<c.outChannels;++Ye)I[ge+Ye]+=Ae*_[Ee+Ye];Ee+=c.outChannels}}}}}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const Uj={kernelName:nd,backendName:"cpu",kernelFunc:Wj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,pad:o,filterShape:l}=s;Ve([i,r],"conv3dBackpropFilterV2");const c=He(i.shape),u=He(r.shape),h=$a(i.shape,l,a,1,o),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,y=h.filterDepth,m=h.filterHeight,g=h.filterWidth,b=new En(h.filterShape,"float32"),x=b.values,[v,w,_,I]=b.strides,C=t.data.get(r.dataId).values,[S,M,A,D]=u,F=t.data.get(i.dataId).values,[k,P,O,V]=c,$=h.padInfo.front,H=h.padInfo.left,Y=h.padInfo.top;for(let G=0;G<y;++G){const B=Math.max(0,Math.ceil(($-G)/d)),te=Math.min(h.outDepth,(h.inDepth+$-G)/d),se=G*v;for(let ae=0;ae<m;++ae){const fe=Math.max(0,Math.ceil((Y-ae)/p)),be=Math.min(h.outHeight,(h.inHeight+Y-ae)/p),ge=ae*w+se;for(let ve=0;ve<g;++ve){const Oe=Math.max(0,Math.ceil((H-ve)/f)),Ce=Math.min(h.outWidth,(h.inWidth+H-ve)/f),q=ve*_+ge;for(let vt=0;vt<h.inChannels;++vt){const Ee=vt*I+q;for(let Le=0;Le<h.outChannels;++Le){let Ae=0;for(let Ye=0;Ye<h.batchSize;++Ye){const $e=Ye*k,Je=Ye*S;for(let at=B;at<te;++at){const Vt=(G+at*d-$)*P+$e,Dt=at*M+Je;for(let z=fe;z<be;++z){const R=(ae+z*p-Y)*O+Vt,ie=z*A+Dt;for(let ye=Oe;ye<Ce;++ye){const me=(ve+ye*f-H)*V+R,xe=ye*D+ie;Ae+=F[me+vt]*C[xe+Le]}}}}x[Ee+Le]=Ae}}}}}return t.makeTensorInfo(b.shape,b.dtype,b.values)}const $j={kernelName:$m,backendName:"cpu",kernelFunc:Bj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xj(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:a,strides:o,inputShape:l}=s;Ve([i],"conv3dBackpropInputV2");const c=He(i.shape),u=He(r.shape),h=$a(l,r.shape,o,1,a),d=new En(h.inShape,"float32"),p=d.values,[f,y,m,g]=d.strides,b=t.data.get(i.dataId).values,[x,v,w,_]=c,I=t.data.get(r.dataId).values,[C,S,M,A]=u,{batchSize:D,filterDepth:F,filterHeight:k,filterWidth:P,inChannels:O,inDepth:V,inHeight:$,inWidth:H,outChannels:Y,outDepth:G,outHeight:B,outWidth:te,strideDepth:se,strideHeight:ae,strideWidth:fe}=h,be=F-1-h.padInfo.front,ge=k-1-h.padInfo.top,ve=P-1-h.padInfo.left;for(let Oe=0;Oe<D;++Oe)for(let Ce=0;Ce<O;++Ce)for(let q=0;q<V;++q){const vt=q-be,Ee=Math.max(0,Math.ceil(vt/se)),Le=Math.min(G,(F+vt)/se);for(let Ae=0;Ae<$;++Ae){const Ye=Ae-ge,$e=Math.max(0,Math.ceil(Ye/ae)),Je=Math.min(B,(k+Ye)/ae);for(let at=0;at<H;++at){const Vt=at-ve,Dt=Math.max(0,Math.ceil(Vt/fe)),z=Math.min(te,(P+Vt)/fe);let R=0;for(let ie=Ee;ie<Le;++ie){const ye=ie*se-vt;for(let me=$e;me<Je;++me){const xe=me*ae-Ye;for(let Xe=Dt;Xe<z;++Xe){const _e=Xe*fe-Vt,De=x*Oe+v*ie+w*me+_*Xe,tt=C*(F-1-ye)+S*(k-1-xe)+M*(P-1-_e)+A*Ce;for(let It=0;It<Y;++It){const we=b[De+It],Ft=I[tt+It];R+=we*Ft}}}}p[f*Oe+y*q+m*Ae+g*at+Ce]=R}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const Hj={kernelName:Xm,backendName:"cpu",kernelFunc:Xj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kj=Gt(Dc,n=>Math.cos(n)),Zj={kernelName:Dc,backendName:"cpu",kernelFunc:Kj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yj=Gt(Fc,n=>Math.cosh(n)),jj={kernelName:Fc,backendName:"cpu",kernelFunc:Yj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qj(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:c}=s,[u,h,d,p]=i.shape,f=r.shape[0],[y,m]=o,g=ut([f,y,m,p],"float32"),b=t.data.get(r.dataId).values,x=t.data.get(a.dataId).values,v=t.data.get(i.dataId).values,w=He(i.shape),_=He(g.shape);for(let I=0;I<f;I++){const C=I*4,S=b[C],M=b[C+1],A=b[C+2],D=b[C+3],F=x[I];if(F>=u)continue;const k=y>1?(A-S)*(h-1)/(y-1):0,P=m>1?(D-M)*(d-1)/(m-1):0;for(let O=0;O<y;O++){const V=y>1?S*(h-1)+O*k:.5*(S+A)*(h-1);if(V<0||V>h-1){for(let $=0;$<m;$++)for(let H=0;H<p;H++){const Y=H+$*_[2]+O*_[1]+I*_[0];g.values[Y]=c}continue}if(l==="bilinear"){const $=Math.floor(V),H=Math.ceil(V),Y=V-$;for(let G=0;G<m;G++){const B=m>1?M*(d-1)+G*P:.5*(M+D)*(d-1);if(B<0||B>d-1){for(let fe=0;fe<p;fe++){const be=fe+G*_[2]+O*_[1]+I*_[0];g.values[be]=c}continue}const te=Math.floor(B),se=Math.ceil(B),ae=B-te;for(let fe=0;fe<p;fe++){let be=fe+te*w[2]+$*w[1]+F*w[0];const ge=v[be];be=fe+se*w[2]+$*w[1]+F*w[0];const ve=v[be];be=fe+te*w[2]+H*w[1]+F*w[0];const Oe=v[be];be=fe+se*w[2]+H*w[1]+F*w[0];const Ce=v[be],q=ge+(ve-ge)*ae,vt=Oe+(Ce-Oe)*ae;be=fe+G*_[2]+O*_[1]+I*_[0],g.values[be]=q+(vt-q)*Y}}}else for(let $=0;$<m;++$){const H=m>1?M*(d-1)+$*P:.5*(M+D)*(d-1);if(H<0||H>d-1){for(let B=0;B<p;B++){const te=B+$*_[2]+O*_[1]+I*_[0];g.values[te]=c}continue}const Y=Math.round(H),G=Math.round(V);for(let B=0;B<p;B++){const te=B+Y*w[2]+G*w[1]+F*w[0],se=B+$*_[2]+O*_[1]+I*_[0];g.values[se]=v[te]}}}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const Jj={kernelName:Km,backendName:"cpu",kernelFunc:Qj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qj(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:a,reverse:o}=s;Ve(i,"cumprod");const l=un([r],i.shape.length);let c=i;l!=null&&(c=Rs({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=gn(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Es(c.dtype,"int32"),d=Dm(re(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],y=o?(g,b)=>g+f-b-1:(g,b)=>g+b;for(let g=0;g<p.length;g+=f)for(let b=0;b<f;b++){const x=y(g,b);if(b===0)d[x]=a?1:p[x];else{const v=y(g,b-1);d[x]=a?p[v]*d[v]:p[x]*d[v]}}const m=t.makeTensorInfo(c.shape,h,d);if(l!=null){const g=Xa(l),b=Rs({inputs:{x:m},backend:t,attrs:{perm:g}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),b}return m}const eQ={kernelName:Hm,backendName:"cpu",kernelFunc:qj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:a,reverse:o}=s;Ve(i,"cumsum");const l=un([r],i.shape.length);let c=i;l!=null&&(c=Rs({inputs:{x:i},backend:t,attrs:{perm:l}}));const u=gn(1,i.shape.length)[0];if(u!==c.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${c.shape.length-1} but got axis=${u}`);const h=Es(c.dtype,"int32"),d=Zn(re(c.shape),h),p=t.data.get(c.dataId).values,f=c.shape[c.shape.length-1],y=o?(g,b)=>g+f-b-1:(g,b)=>g+b;for(let g=0;g<p.length;g+=f)for(let b=0;b<f;b++){const x=y(g,b);if(b===0)d[x]=a?0:p[x];else{const v=y(g,b-1);d[x]=a?p[v]+d[v]:p[x]+d[v]}}const m=t.makeTensorInfo(c.shape,h,d);if(l!=null){const g=Xa(l),b=Rs({inputs:{x:m},backend:t,attrs:{perm:g}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(c),b}return m}const nQ={kernelName:sd,backendName:"cpu",kernelFunc:tQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:a,binaryOutput:o}=s;if(i.shape.length===1){const l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=PS(l,c,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=lN(l,c,a,o);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const iQ={kernelName:Zm,backendName:"cpu",kernelFunc:sQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:a}=s;E(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=i.shape[0],l=i.shape[1],c=i.shape[2],u=i.shape[3],h=l*r,d=c*r,p=u/(r*r),f=t.data.get(i.dataId).values,y=new Float32Array(o*h*d*p);let m=0;for(let g=0;g<o;++g)for(let b=0;b<h;++b){const x=Math.floor(b/r),v=b%r;for(let w=0;w<d;++w){const _=Math.floor(w/r),I=w%r,C=(v*r+I)*p;for(let S=0;S<p;++S){const M=S+C+u*(_+c*(x+l*g));y[m++]=f[M]}}}return t.makeTensorInfo([o,h,d,p],i.dtype,y)}const aQ={kernelName:Ym,backendName:"cpu",kernelFunc:rQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rR(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;Ve([i,r],"depthwiseConv2DNative");const u=He(i.shape),h=He(r.shape);let d=l;d==null&&(d=[1,1]),E(Qn(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const p=zn(i.shape,r.shape,a,d,o,c,!0),{filterHeight:f,filterWidth:y,dilationHeight:m,dilationWidth:g,padInfo:b}=p,x=b.left,v=b.top,w=p.outChannels/p.inChannels,_=new En(p.outShape,i.dtype),I=t.data.get(i.dataId).values,C=t.data.get(r.dataId).values,S=_.values;for(let M=0;M<p.batchSize;++M){const A=M*u[0],D=M*_.strides[0];for(let F=0;F<p.outHeight;++F){const k=D+F*_.strides[1],P=F*p.strideHeight-v;for(let O=0;O<f;++O){const V=P+O*m;if(V<0||V>=p.inHeight)continue;const $=O*h[0],H=A+V*u[1];for(let Y=0;Y<p.outWidth;++Y){const G=k+Y*_.strides[2],B=Y*p.strideWidth-x;for(let te=0;te<y;++te){const se=B+te*g;if(se<0||se>=p.inWidth)continue;const ae=$+te*h[1],fe=H+se*p.inChannels;let be=G,ge=ae;for(let ve=0;ve<p.inChannels;++ve){const Oe=I[fe+ve];for(let Ce=0;Ce<w;++Ce)S[be+Ce]+=Oe*C[ge+Ce];be+=w,ge+=w}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const oQ={kernelName:id,backendName:"cpu",kernelFunc:rR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=s;Ve([i,r],"depthwiseConv2dNativeBackpropFilter");const h=zn(i.shape,u,a,o,l,c,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:y}=h,m=new En(h.filterShape,"float32"),g=h.padInfo.left,b=h.padInfo.top,x=h.outChannels/h.inChannels,v=t.data.get(i.dataId).values,w=new En(i.shape,i.dtype,v),_=t.data.get(r.dataId).values,I=new En(r.shape,r.dtype,_);for(let C=0;C<f;++C){const S=Math.max(0,Math.ceil((b-C)/d)),M=Math.min(h.outHeight,(h.inHeight+b-C)/d);for(let A=0;A<y;++A){const D=Math.max(0,Math.ceil((g-A)/p)),F=Math.min(h.outWidth,(h.inWidth+g-A)/p);for(let k=0;k<h.outChannels;++k){const P=Math.trunc(k/x),O=k%x;let V=0;for(let $=0;$<h.batchSize;++$)for(let H=S;H<M;++H){const Y=C+H*d-b;for(let G=D;G<F;++G){const B=A+G*p-g;V+=w.get($,Y,B,P)*I.get($,H,G,k)}}m.set(V,C,A,P,O)}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const cQ={kernelName:jm,backendName:"cpu",kernelFunc:lQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uQ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=s;Ve([i,r],"depthwiseConv2DNativeBackpropInput");const h=He(i.shape),d=He(r.shape),p=zn(u,r.shape,a,o,l,c,!0),f=new En(p.inShape,"float32"),y=f.values,[m,g,b]=f.strides,x=t.data.get(i.dataId).values,[v,w,_]=h,I=t.data.get(r.dataId).values,[C,S,M]=d,{batchSize:A,filterHeight:D,filterWidth:F,inChannels:k,inHeight:P,inWidth:O,outChannels:V,outHeight:$,outWidth:H,strideHeight:Y,strideWidth:G}=p,B=D-1-p.padInfo.top,te=F-1-p.padInfo.left,se=V/k;for(let ae=0;ae<A;++ae)for(let fe=0;fe<k;++fe)for(let be=0;be<P;++be){const ge=be-B,ve=Math.max(0,Math.ceil(ge/Y)),Oe=Math.min($,(D+ge)/Y);for(let Ce=0;Ce<O;++Ce){const q=Ce-te,vt=Math.max(0,Math.ceil(q/G)),Ee=Math.min(H,(F+q)/G);let Le=0;for(let Ae=ve;Ae<Oe;++Ae){const Ye=Ae*Y-ge;for(let $e=vt;$e<Ee;++$e){const Je=$e*G-q,at=v*ae+w*Ae+_*$e,Vt=C*(D-1-Ye)+S*(F-1-Je)+M*fe;for(let Dt=0;Dt<se;++Dt){const z=fe*se+Dt,R=x[at+z],ie=I[Vt+Dt];Le+=R*ie}}}y[m*ae+g*be+b*Ce+fe]=Le}}return t.makeTensorInfo(f.shape,f.dtype,f.values)}const hQ={kernelName:Qm,backendName:"cpu",kernelFunc:uQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dQ(n){const{inputs:e,backend:t}=n,{x:s}=e,i=re(s.shape),r=t.data.get(s.dataId).values,a=ut([i,i],s.dtype),o=a.values;for(let c=0;c<r.length;c++)o[c*i+c]=r[c];const l=[...s.shape,...s.shape];return t.makeTensorInfo(l,a.dtype,a.values)}const pQ={kernelName:Jm,backendName:"cpu",kernelFunc:dQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fQ={kernelName:rd,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i}=n,{strides:r,pad:a,dilations:o}=t,l=e,c=l.data.get(s.dataId).values,u=s.shape.length,h=l.data.get(i.dataId).values,d=i.shape.length,{batchSize:p,inHeight:f,inWidth:y,inChannels:m,outHeight:g,outWidth:b,padInfo:x,strideHeight:v,strideWidth:w,filterHeight:_,filterWidth:I,dilationHeight:C,dilationWidth:S,outShape:M}=Kd(s.shape,i.shape,r,a,"NHWC",o),A=re(M),D=M.length,F=pn(s.dtype,A);for(let k=0;k<p;++k)for(let P=0;P<g;++P){const O=P*v-x.top;for(let V=0;V<b;++V){const $=V*w-x.left;for(let H=0;H<m;++H){let Y=Number.MIN_SAFE_INTEGER;for(let B=0;B<_;++B){const te=O+B*C;if(te>=0&&te<f)for(let se=0;se<I;++se){const ae=$+se*S;if(ae>=0&&ae<y){const fe=Oi([k,te,ae,H],u,He(s.shape)),be=Oi([B,se,H],d,He(i.shape)),ge=c[fe]+h[be];ge>Y&&(Y=ge)}}}const G=Oi([k,P,V,H],D,He(M));F[G]=Y}}}return{dataId:l.write(Ua(F,s.dtype),M,s.dtype),shape:M,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mQ={kernelName:Yf,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:a,pad:o,dilations:l}=t,c=e,u=ni(s.shape,c.data.get(s.dataId).values),h=ni(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:y,outHeight:m,outWidth:g,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:_,dilationHeight:I,dilationWidth:C,outShape:S}=Kd(s.shape,i.shape,a,o,"NHWC",l);E(r.rank===S.length,()=>`Error in ${Yf}, dy must have the same rank as output ${S.length}, but got ${r.rank}`);const M=ni(S,c.data.get(r.dataId).values),A=u1(i.shape,i.dtype);for(let D=0;D<d;++D)for(let F=0;F<m;++F){const k=F*x-b.top;for(let P=0;P<g;++P){const O=P*v-b.left;for(let V=0;V<y;++V){let $=Number.MIN_SAFE_INTEGER,H=0,Y=0;for(let G=0;G<w;++G){const B=k+G*I;if(B>=0&&B<p)for(let te=0;te<_;++te){const se=O+te*C;if(se>=0&&se<f){const ae=u[D][B][se][V]+h[G][te][V];ae>$&&($=ae,H=G,Y=te)}}}A[H][Y][V]+=M[D][F][P][V]}}}return{dataId:c.write(Ua(A,s.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gQ={kernelName:Zf,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:s,filter:i,dy:r}=n,{strides:a,pad:o,dilations:l}=t,c=e,u=ni(s.shape,c.data.get(s.dataId).values),h=ni(i.shape,c.data.get(i.dataId).values),{batchSize:d,inHeight:p,inWidth:f,inChannels:y,outHeight:m,outWidth:g,padInfo:b,strideHeight:x,strideWidth:v,filterHeight:w,filterWidth:_,dilationHeight:I,dilationWidth:C,outShape:S}=Kd(s.shape,i.shape,a,o,"NHWC",l);E(r.rank===S.length,()=>`Error in ${Zf}, dy must have the same rank as output ${S.length}, but got ${r.rank}`);const M=ni(S,c.data.get(r.dataId).values),A=u1(s.shape,s.dtype);for(let D=0;D<d;++D)for(let F=0;F<m;++F){const k=F*x-b.top;for(let P=0;P<g;++P){const O=P*v-b.left;for(let V=0;V<y;++V){let $=Number.MIN_SAFE_INTEGER,H=k<0?0:k,Y=O<0?0:O;for(let G=0;G<w;++G){const B=k+G*I;if(B>=0&&B<p)for(let te=0;te<_;++te){const se=O+te*C;if(se>=0&&se<f){const ae=u[D][B][se][V]+h[G][te][V];ae>$&&($=ae,H=B,Y=se)}}}A[D][H][Y][V]+=M[D][F][P][V]}}}return{dataId:c.write(Ua(A,s.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tp(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;Ve(i,"sum");let o;i.dtype==="bool"?o=za({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):o=gr({inputs:{x:i},backend:t});const l=o.shape.length,c=mt(r,o.shape),u=un(c,l);let h=c,d=o;u!=null&&(d=Rs({inputs:{x:o},backend:t,attrs:{perm:u}}),h=gn(h.length,l)),Jn("sum",h,d.shape.length);const[p,f]=Vn(d.shape,h),y=Es(d.dtype,"int32");let m=dm(t,p,y);const g=re(f),b=t.data.get(m.dataId).values,x=t.data.get(d.dataId).values;for(let v=0;v<b.length;++v){const w=v*g;let _=0;for(let I=0;I<g;++I)_+=x[w+I];b[v]=_}if(a){const v=mn(m.shape,c),w=m;m=Ht({inputs:{x:m},backend:t,attrs:{shape:v}}),t.disposeIntermediateTensorInfo(w)}return t.disposeIntermediateTensorInfo(o),u!=null&&t.disposeIntermediateTensorInfo(d),m}const yQ={kernelName:Gd,backendName:"cpu",kernelFunc:Tp};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bQ(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:a,summedDims:o,idDims:l}=ew(i,r.length);nw(a.length,l,r);const{path:c,steps:u}=sw(o,l),h=u.length;let d=null,p=a.length;const f=[];for(let y=0;y<h;++y){for(const m of u[y]){const{permutationIndices:g,expandDims:b}=tw(p,l[m]);let x;iw(g)?x=r[m]:(x=Rs({inputs:{x:r[m]},backend:t,attrs:{perm:g}}),f.push(x));const v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);St(x.shape,v)||(x=Ht({inputs:{x},backend:t,attrs:{shape:v}}),f.push(x)),d===null?d=x:(d=Qy({inputs:{a:x,b:d},backend:t}),f.push(d))}y<h-1&&(c[y]>=0&&(d=Tp({inputs:{x:d},backend:t,attrs:{axis:c[y]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const y of f)y!==d&&t.disposeIntermediateTensorInfo(y);return d}const xQ={kernelName:qm,backendName:"cpu",kernelFunc:bQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vQ(n){const{inputs:e,backend:t}=n,{dy:s,y:i}=e;Ve([s,i],"eluGrad");const r=new Float32Array(re(i.shape)),a=t.data.get(i.dataId).values,o=t.data.get(s.dataId).values;for(let l=0;l<a.length;++l){const c=a[l];c>=1?r[l]=o[l]:r[l]=o[l]*(c+1)}return t.makeTensorInfo(i.shape,"float32",r)}const wQ={kernelName:eg,backendName:"cpu",kernelFunc:vQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SQ=Kv,TQ=Zv,_Q=Yv,IQ=jv,MQ=Qv,CQ=Jv,EQ=Gt(zc,n=>{const e=Math.sign(n),t=Math.abs(n),s=1/(1+SQ*t);return e*(1-((((CQ*s+MQ)*s+IQ)*s+_Q)*s+TQ)*s*Math.exp(-t*t))}),kQ={kernelName:zc,backendName:"cpu",kernelFunc:EQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mm(n){const{inputs:e,backend:t,attrs:s}=n,{input:i}=e,{dim:r}=s,a=i.shape.length,o=i.shape.slice();let l=r;return r<0&&(E(-(a+1)<=r,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+r+1),o.splice(l,0,1),Ht({inputs:{x:i},backend:t,attrs:{shape:o}})}const NQ={kernelName:od,backendName:"cpu",kernelFunc:mm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RQ=Tn((n,e)=>n/e),VS=Wn(Oc,RQ),vx={kernelName:Oc,backendName:"cpu",kernelFunc:VS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aR(n,e,t){const s=n.shape,i=s[0],r=s[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,l=a.complexTensorInfos.imag,c=[i,r],u=re(c),h=Rn("float32",u),d=Rn("float32",u);for(let m=0;m<i;m++){const g=$o({inputs:{x:o},backend:t,attrs:{begin:[m,0],size:[1,r]}}),b=$o({inputs:{x:l},backend:t,attrs:{begin:[m,0],size:[1,r]}}),x=Gs({inputs:{real:g,imag:b},backend:t}),{real:v,imag:w}=AQ(x,e,t),_=Zr(v,w);for(let I=0;I<r;I++){const C=qv(_,I);h[m*r+I]=C.real,d[m*r+I]=C.imag}t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(b),t.disposeIntermediateTensorInfo(x)}const p=t.makeTensorInfo(c,"float32",h),f=t.makeTensorInfo(c,"float32",d),y=Gs({inputs:{real:p,imag:f},backend:t});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),y}function AQ(n,e,t){const s=re(n.shape),i=t.data.get(n.dataId),r=t.data.get(i.complexTensorInfos.real.dataId).values,a=t.data.get(i.complexTensorInfos.imag.dataId).values;if(LQ(s)){const o=wx(r,a,s,e,t),l=[n.shape[0],n.shape[1]];if(e){const c=t.makeTensorInfo(l,"float32",o.real),u=t.makeTensorInfo(l,"float32",o.imag),h=t.makeTensorInfo([],"float32",Jr(s,"float32")),d=gr({inputs:{x:h},backend:t}),p=vx.kernelFunc({inputs:{a:c,b:h},backend:t}),f=vx.kernelFunc({inputs:{a:u,b:d},backend:t}),y=t.data.get(p.dataId).values,m=t.data.get(f.dataId).values;return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),{real:y,imag:m}}return o}else{const o=Zr(r,a),l=PQ(o,s,e);return TE(l)}}function LQ(n){return(n&n-1)===0}function wx(n,e,t,s,i){if(t===1)return{real:n,imag:e};const r=Zr(n,e),a=t/2,o=_E(r),l=o.real,c=o.imag,u=[l.length],h=i.makeTensorInfo(u,"float32",l),d=i.makeTensorInfo(u,"float32",c),p=Gs({inputs:{real:h,imag:d},backend:i}),f=IE(r),y=f.real,m=f.imag,g=[y.length],b=i.makeTensorInfo(g,"float32",y),x=i.makeTensorInfo(g,"float32",m),v=Gs({inputs:{real:b,imag:x},backend:i}),w=wx(l,c,a,s,i),_=w.real,I=w.imag,C=[_.length],S=i.makeTensorInfo(C,"float32",_),M=i.makeTensorInfo(C,"float32",I),A=Gs({inputs:{real:S,imag:M},backend:i}),D=wx(y,m,a,s,i),F=D.real,k=D.imag,P=[F.length],O=i.makeTensorInfo(P,"float32",F),V=i.makeTensorInfo(P,"float32",k),$=Gs({inputs:{real:O,imag:V},backend:i}),H=CE(t,s),Y=[H.real.length],G=i.makeTensorInfo(Y,"float32",H.real),B=i.makeTensorInfo(Y,"float32",H.imag),te=Gs({inputs:{real:G,imag:B},backend:i}),se=Qy({inputs:{a:te,b:$},backend:i}),ae=mc({inputs:{a:A,b:se},backend:i}),fe=GS({inputs:{a:A,b:se},backend:i}),be=Bo({inputs:{input:ae},backend:i}),ge=Bo({inputs:{input:fe},backend:i}),ve=gc({inputs:{input:ae},backend:i}),Oe=gc({inputs:{input:fe},backend:i}),Ce=yc({inputs:[be,ge],backend:i,attrs:{axis:0}}),q=yc({inputs:[ve,Oe],backend:i,attrs:{axis:0}}),vt=i.data.get(Ce.dataId).values,Ee=i.data.get(q.dataId).values;return i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(p),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(v),i.disposeIntermediateTensorInfo(S),i.disposeIntermediateTensorInfo(M),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(V),i.disposeIntermediateTensorInfo($),i.disposeIntermediateTensorInfo(G),i.disposeIntermediateTensorInfo(B),i.disposeIntermediateTensorInfo(te),i.disposeIntermediateTensorInfo(se),i.disposeIntermediateTensorInfo(ae),i.disposeIntermediateTensorInfo(fe),i.disposeIntermediateTensorInfo(be),i.disposeIntermediateTensorInfo(ve),i.disposeIntermediateTensorInfo(ge),i.disposeIntermediateTensorInfo(Oe),i.disposeIntermediateTensorInfo(Ce),i.disposeIntermediateTensorInfo(q),{real:vt,imag:Ee}}function PQ(n,e,t){const s=new Float32Array(e*2);for(let i=0;i<e;i++){let r=0,a=0;for(let o=0;o<e;o++){const l=EE(i*o,e,t),c=qv(n,o);r+=c.real*l.real-c.imag*l.imag,a+=c.real*l.imag+c.imag*l.real}t&&(r/=e,a/=e),ME(s,r,a,i)}return s}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DQ(n){const{inputs:e,backend:t}=n,{input:s}=e,i=re(s.shape),r=s.shape[s.shape.length-1],a=i/r,o=Ht({inputs:{x:s},backend:t,attrs:{shape:[a,r]}}),l=aR(o,!1,t),c=Ht({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const FQ={kernelName:tg,backendName:"cpu",kernelFunc:DQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WS(n){const{backend:e,attrs:t}=n,{shape:s,value:i,dtype:r}=t,a=r||_c(i),o=pn(a,re(s));return GQ(o,i),e.makeTensorInfo(s,a,o)}const OQ={kernelName:ng,backendName:"cpu",kernelFunc:WS};function GQ(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zQ={kernelName:sg,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,i=t,r=Rn(s.dtype,re(s.shape)),[a,o,l,c]=s.shape,u=i.data.get(s.dataId).values;for(let h=0;h<a;h++){const d=h*l*o*c;for(let p=0;p<o;p++){const f=p*(l*c);for(let y=0;y<l;y++){const m=y*c;for(let g=0;g<c;g++){const b=Math.round(l-y-1),x=d+f+m+g;let v=u[x];if(b>=0&&b<l){const w=b*c,_=d+f+w+g;v=u[_]}r[x]=v}}}}return{dataId:i.write(r,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VQ=Tn((n,e)=>Math.floor(n/e)),WQ=Wn(Bc,VQ,null,"int32"),UQ={kernelName:Bc,backendName:"cpu",kernelFunc:WQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let y=iR({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){const m=y;if(u==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const g=Ht({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});y=mc({inputs:{a:y,b:g},backend:t}),t.disposeIntermediateTensorInfo(g)}else y=mc({inputs:{a:y,b:a},backend:t});t.disposeIntermediateTensorInfo(m)}if(p){const m=y;if(u==="NCHW"&&p==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const g=Ht({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});y=fm(t,y,p,g,f),t.disposeIntermediateTensorInfo(g)}else y=fm(t,y,p,o,f);t.disposeIntermediateTensorInfo(m)}return y}const $Q={kernelName:Ih,backendName:"cpu",kernelFunc:BQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s;let y=rR({inputs:{x:i,filter:r},backend:t,attrs:{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d}});if(a){const m=y;y=mc({inputs:{a:y,b:a},backend:t}),t.disposeIntermediateTensorInfo(m)}if(p){const m=y;y=fm(t,y,p,o,f),t.disposeIntermediateTensorInfo(m)}return y}const HQ={kernelName:Mh,backendName:"cpu",kernelFunc:XQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KQ(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=re(s.shape),a=i.shape,o=a[a.length-1],[l,c,u,h]=Ty(s,i);if(c===0)return t.makeTensorInfo(l,s.dtype,[]);const d=t.data.get(i.dataId).values,p=t.bufferSync(s),f=yN(d,p,s.dtype,c,o,u,h,s.shape,r);return t.makeTensorInfo(l,s.dtype,f.values)}const ZQ={kernelName:ig,backendName:"cpu",kernelFunc:KQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YQ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:a,batchDims:o}=s;Ve([i,r],"gatherV2");const l=mt(a,i.shape)[0],c=t.data.get(r.dataId).values,u=i.shape[l];for(let v=0;v<c.length;++v){const w=c[v];E(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let h=o;o==null&&(h=0);const d=re(r.shape),p=aw(i,r,l,h),f=Ht({inputs:{x:i},backend:t,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),y=Ht({inputs:{x:r},backend:t,attrs:{shape:[p.batchSize,d/p.batchSize]}}),m=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],g=t.bufferSync(y),b=t.bufferSync(f),x=bN(b,g,m);return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),t.makeTensorInfo(p.outputShape,x.dtype,x.values)}const jQ={kernelName:cd,backendName:"cpu",kernelFunc:YQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QQ(n){const{inputs:e,backend:t}=n,{input:s}=e,i=re(s.shape),r=s.shape[s.shape.length-1],a=i/r,o=Ht({inputs:{x:s},backend:t,attrs:{shape:[a,r]}}),l=aR(o,!0,t),c=Ht({inputs:{x:l},backend:t,attrs:{shape:s.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),c}const JQ={kernelName:rg,backendName:"cpu",kernelFunc:QQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qQ=Gt(Hc,n=>Number.isFinite(n)?1:0,"bool"),eJ={kernelName:Hc,backendName:"cpu",kernelFunc:qQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tJ=Gt(Kc,n=>Math.abs(n)===1/0?1:0,"bool"),nJ={kernelName:Kc,backendName:"cpu",kernelFunc:tJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sJ=Gt(Zc,n=>Number.isNaN(n)?1:0,"bool"),iJ={kernelName:Zc,backendName:"cpu",kernelFunc:sJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rJ(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,a=TN(s,i,r);return e.makeTensorInfo([a.length],"float32",a)}const aJ={kernelName:og,backendName:"cpu",kernelFunc:rJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oJ=Gt(jc,n=>Math.log1p(n)),lJ={kernelName:jc,backendName:"cpu",kernelFunc:oJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cJ=Tn((n,e)=>n&&e),uJ=Wn(fd,cJ,null,"bool"),hJ={kernelName:fd,backendName:"cpu",kernelFunc:uJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dJ=Gt(md,n=>n?0:1,"bool"),pJ={kernelName:md,backendName:"cpu",kernelFunc:dJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fJ=Tn((n,e)=>n||e),mJ=Wn(gd,fJ,null,"bool"),gJ={kernelName:gd,backendName:"cpu",kernelFunc:mJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:a,alpha:o,beta:l}=s;Ve(i,"LRN");const c=i.shape[3],u=c-1,h=t.data.get(i.dataId).values,d=re(i.shape),p=new Float32Array(d);function f(y){const m=y%c;let g=y-m+Math.max(0,m-r);const b=y-m+Math.min(m+r,u);let x=0;for(;g<=b;g++){const v=h[g];x+=v*v}return x}for(let y=0;y<d;y++){const m=f(y),g=h[y]*Math.pow(a+o*m,-l);p[y]=g}return t.makeTensorInfo(i.shape,i.dtype,p)}const bJ={kernelName:yd,backendName:"cpu",kernelFunc:yJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:a}=e,{depthRadius:o,bias:l,alpha:c,beta:u}=s;Ve(a,"LRNGrad");const h=re(a.shape),d=a.shape[3],p=t.data.get(a.dataId).values,f=t.data.get(i.dataId).values,y=t.data.get(r.dataId).values,m=new Float32Array(h),g=h;for(let b=0;b<g;b++){const x=b%d,v=b-x+Math.max(0,x-o),w=b-x+Math.min(d,x+o+1);let _=0;for(let I=v;I<w;I++)_+=Math.pow(f[I],2);_=c*_+l;for(let I=v;I<w;I++){let C=-2*c*u*f[I]*y[b]/_;b===I&&(C+=Math.pow(_,-u)),C*=p[b],m[I]+=C}}return t.makeTensorInfo(a.shape,i.dtype,m)}const vJ={kernelName:lg,backendName:"cpu",kernelFunc:xJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oR(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:a}=s,o=t;let l=i.shape;const c=l.length,u=mt(r,l);let h=u;const d=un(h,c);let p=o.data.get(i.dataId).values;if(d!=null){const v=new Array(c);for(let w=0;w<v.length;w++)v[w]=l[d[w]];p=FS(p,l,i.dtype,d,v),h=gn(h.length,c),l=v}Ve(i,"max"),Jn("max",h,c);const[f,y]=Vn(l,h),m=re(y),g=IN(p,m,f,i.dtype),b=o.write(g,f,i.dtype);let x=f;return a&&(x=mn(f,u)),{dataId:b,shape:x,dtype:i.dtype}}const wJ={kernelName:bd,backendName:"cpu",kernelFunc:oR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Ve(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;E(Qn(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=_i(i.shape,r,a,c,o,l);let h;if(u.filterWidth===1&&u.filterHeight===1&&St(u.inShape,u.outShape))h=gr({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,p=He(i.shape),f=zS(d,i.shape,i.dtype,p,u,"max");h=t.makeTensorInfo(u.outShape,i.dtype,f.values)}return h}const TJ={kernelName:xd,backendName:"cpu",kernelFunc:SJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _J(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s;Ve(i,"maxPool3d");const u=qr(i.shape,r,a,1,o,l,c),h=t.data.get(i.dataId).values,d=sR(h,i.shape,i.dtype,He(i.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const IJ={kernelName:vd,backendName:"cpu",kernelFunc:_J};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,{filterSize:a,strides:o,pad:l,dimRoundingMode:c}=s;Ve([i,r],"maxPool3DGrad");const u=qr(r.shape,a,o,1,l,c),h=t.bufferSync(r),d=pj(h,u),p=u.strideDepth,f=u.strideHeight,y=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,b=u.dilationWidth,x=u.effectiveFilterDepth,v=u.effectiveFilterHeight,w=u.effectiveFilterWidth,_=x-1-u.padInfo.front,I=w-1-u.padInfo.left,C=v-1-u.padInfo.top,S=ut(r.shape,"float32"),M=t.bufferSync(i);for(let A=0;A<u.batchSize;++A)for(let D=0;D<u.inChannels;++D)for(let F=0;F<u.inDepth;++F)for(let k=0;k<u.inHeight;++k)for(let P=0;P<u.inWidth;++P){const O=F-_,V=k-C,$=P-I;let H=0;for(let Y=0;Y<x;Y+=m){const G=(O+Y)/p;if(!(G<0||G>=u.outDepth||Math.floor(G)!==G))for(let B=0;B<v;B+=g){const te=(V+B)/f;if(!(te<0||te>=u.outHeight||Math.floor(te)!==te))for(let se=0;se<w;se+=b){const ae=($+se)/y;if(ae<0||ae>=u.outWidth||Math.floor(ae)!==ae)continue;const fe=x*v*w-1-d.get(A,G,te,ae,D),be=Y*v*w+B*w+se,ge=fe===be?1:0;if(ge===0)continue;const ve=M.get(A,G,te,ae,D);H+=ve*ge}}}S.set(H,A,F,k,P,D)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const CJ={kernelName:ug,backendName:"cpu",kernelFunc:MJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EJ(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:a}=e,o=r;Ve([r,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=_i(o.shape,l,c,1,u,h),p=t.data.get(o.dataId).values,f=ut(d.outShape,o.dtype,nR(p,o.shape,o.dtype,d).values),y=d.strideHeight,m=d.strideWidth,g=d.dilationHeight,b=d.dilationWidth,x=d.effectiveFilterHeight,v=d.effectiveFilterWidth,w=v-1-d.padInfo.left,_=x-1-d.padInfo.top,I=ut(o.shape,"float32"),C=t.data.get(i.dataId).values,S=ut(i.shape,"float32",C);for(let M=0;M<d.batchSize;++M)for(let A=0;A<d.inChannels;++A)for(let D=0;D<d.inHeight;++D)for(let F=0;F<d.inWidth;++F){const k=D-_,P=F-w;let O=0;for(let V=0;V<x;V+=g){const $=(k+V)/y;if(!($<0||$>=d.outHeight||Math.floor($)!==$))for(let H=0;H<v;H+=b){const Y=(P+H)/m;if(Y<0||Y>=d.outWidth||Math.floor(Y)!==Y)continue;const G=x*v-1-f.get(M,$,Y,A),B=V*v+H,te=G===B?1:0;if(te===0)continue;const se=S.get(M,$,Y,A);O+=se*te}}I.set(O,M,D,F,A)}return t.makeTensorInfo(I.shape,I.dtype,I.values)}const kJ={kernelName:cg,backendName:"cpu",kernelFunc:EJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NJ(n,e,t,s,i){const r=He(e),a=zS(n,e,t,r,i,"max"),o=nR(n,e,t,i,!0,s);return[a.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RJ={kernelName:hg,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=e,l=t;Ve(s,"MaxPoolWithArgmax");const c=l.data.get(s.dataId).values,u=_i(s.shape,i,r,[1,1],a),[h,d]=NJ(c,s.shape,s.dtype,o,u),p=l.write(h,u.outShape,s.dtype),f=l.write(d,u.outShape,s.dtype);return[{dataId:p,shape:u.outShape,dtype:s.dtype},{dataId:f,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s,o=mt(r,i.shape),l=Vn(i.shape,o)[1],c=re(l),u=[],h=t.makeTensorInfo([],"float32",new Float32Array([c]));u.push(h);const d=za({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});u.push(d);const p=VS({inputs:{a:d,b:h},backend:t});u.push(p);const f=Tp({inputs:{x:p},backend:t,attrs:{axis:r,keepDims:a}});return u.forEach(y=>t.disposeIntermediateTensorInfo(y)),f}const LJ={kernelName:wd,backendName:"cpu",kernelFunc:AJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;Ve(i,"min");const o=mt(r,i.shape);let l=o;const c=un(l,i.shape.length);let u=i;c!=null&&(u=Rs({inputs:{x:i},backend:t,attrs:{perm:c}}),l=gn(l.length,i.shape.length)),Jn("min",l,u.shape.length);const[h,d]=Vn(u.shape,l),p=re(d),f=Zn(re(h),u.dtype),y=t.data.get(u.dataId).values;for(let g=0;g<f.length;++g){const b=g*p;let x=y[b];for(let v=0;v<p;++v){const w=y[b+v];(Number.isNaN(w)||w<x)&&(x=w)}f[g]=x}c!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(h,u.dtype,f);if(a){const g=mn(h,o),b=Ht({inputs:{x:m},backend:t,attrs:{shape:g}});return t.disposeIntermediateTensorInfo(m),b}return m}const DJ={kernelName:Sd,backendName:"cpu",kernelFunc:PJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FJ(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,mode:a}=s;Ve(i,"mirrorPad");const o=r.map((b,x)=>b[0]+i.shape[x]+b[1]),l=r.map(b=>b[0]),c=r.map((b,x)=>b[0]+i.shape[x]),u=a==="reflect"?0:1,h=t.data.get(i.dataId).values,d=i.shape.length,p=He(i.shape),f=re(o),y=o.length,m=He(o),g=Rn(i.dtype,f);for(let b=0;b<f;b++){let x=Qo(b,y,m);for(let w=0;w<y;w++)x[w]<l[w]?x[w]=l[w]*2-x[w]-u:x[w]>=c[w]&&(x[w]=(c[w]-1)*2-x[w]+u);x=x.map((w,_)=>w-l[_]);const v=Oi(x,d,p);g[b]=h[v]}return{dataId:t.write(g,o,i.dtype),shape:o,dtype:i.dtype}}const OJ={kernelName:Td,backendName:"cpu",kernelFunc:FJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GJ=Tn((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),zJ=Wn(qc,GJ),VJ={kernelName:qc,backendName:"cpu",kernelFunc:zJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lR(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,a=i.shape.length;let o=r;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const l=mt([o],i.shape),c=oR({inputs:{x:i},backend:t,attrs:{reductionIndices:l,keepDims:!1}}),u=mn(c.shape,l),h=Ht({inputs:{x:c},backend:t,attrs:{shape:u}}),d=GS({inputs:{a:i,b:h},backend:t}),p=fN({inputs:{x:d},backend:t}),f=Tp({inputs:{x:p},backend:t,attrs:{axis:l,keepDims:!1}}),y=Ht({inputs:{x:f},backend:t,attrs:{shape:u}}),m=VS({inputs:{a:p,b:y},backend:t});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(y),m}const WJ={kernelName:Wd,backendName:"cpu",kernelFunc:lR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UJ(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:a,normalized:o}=s;Ve(i,"multinomial");const l=o?i:lR({inputs:{logits:i},backend:t,attrs:{dim:-1}}),c=l.shape[0],u=l.shape[1],h=t.data.get(l.dataId).values,d=[c,r],p=Zn(re(d),"int32");for(let f=0;f<c;++f){const y=f*u,m=new Float32Array(u-1);m[0]=h[y];for(let x=1;x<m.length;++x)m[x]=m[x-1]+h[y+x];const g=Cu.alea(a.toString()),b=f*r;for(let x=0;x<r;++x){const v=g();p[b+x]=m.length;for(let w=0;w<m.length;w++)if(v<m[w]){p[b+x]=w;break}}}return o||t.disposeIntermediateTensorInfo(l),t.makeTensorInfo(d,"int32",p)}const BJ={kernelName:dg,backendName:"cpu",kernelFunc:UJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $J=xy;function XJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s;Ve(i,"NonMaxSuppression");const c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,{selectedIndices:h}=$J(c,u,a,o,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const HJ={kernelName:pg,backendName:"cpu",kernelFunc:XJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KJ=vy;function ZJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s;Ve(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,{selectedIndices:d,validOutputs:p}=KJ(u,h,a,o,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const YJ={kernelName:fg,backendName:"cpu",kernelFunc:ZJ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jJ=wy;function QJ(n){const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s;Ve(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,h=t.data.get(r.dataId).values,d=a,p=o,f=l,y=c,{selectedIndices:m,selectedScores:g}=jJ(u,h,d,p,f,y);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const JJ={kernelName:mg,backendName:"cpu",kernelFunc:QJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qJ(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:a,onValue:o,offValue:l}=s;Ve(i,"oneHot");const c=re(i.shape),u=new Float32Array(c*a);u.fill(l);const h=t.data.get(i.dataId).values;for(let d=0;d<c;++d)h[d]>=0&&h[d]<a&&(u[d*a+h[d]]=o);return t.makeTensorInfo([...i.shape,a],r,u)}const e7={kernelName:Cd,backendName:"cpu",kernelFunc:qJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gm(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Bo({inputs:{input:s},backend:t}),r=gm({inputs:{x:i},backend:t}),a=gc({inputs:{input:s},backend:t}),o=gm({inputs:{x:a},backend:t}),l=Gs({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return WS({backend:t,attrs:{shape:s.shape,value:0,dtype:s.dtype}})}const t7={kernelName:$d,backendName:"cpu",kernelFunc:gm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cR(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(s.dtype==="complex64"){const i=Bo({inputs:{input:s},backend:t}),r=cR({inputs:{x:i},backend:t}),a=gc({inputs:{input:s},backend:t}),o=gm({inputs:{x:a},backend:t}),l=Gs({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return WS({backend:t,attrs:{shape:s.shape,value:1,dtype:s.dtype}})}const n7={kernelName:Md,backendName:"cpu",kernelFunc:cR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uR(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return mm({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(u=>{jn(r,u.shape,"All tensors passed to stack must have matching shapes"),E(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(u=>{const h=mm({inputs:{input:u},backend:t,attrs:{dim:i}});return o.push(h),h}),c=yc({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const s7={kernelName:Ed,backendName:"cpu",kernelFunc:uR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i7(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:a}=s;Ve(i,"pad");const o=r.map((g,b)=>g[0]+i.shape[b]+g[1]),l=r.map(g=>g[0]),c=t.data.get(i.dataId).values,u=re(i.shape),h=i.shape.length,d=He(i.shape),p=re(o),f=o.length,y=He(o),m=Rn(i.dtype,p);a!==0&&m.fill(a);for(let g=0;g<u;g++){const b=Qo(g,h,d).map((v,w)=>v+l[w]),x=Oi(b,f,y);m[x]=c[g]}return{dataId:t.write(m,o,i.dtype),shape:o,dtype:i.dtype}}const hR={kernelName:kd,backendName:"cpu",kernelFunc:i7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r7=Tn((n,e)=>Math.pow(n,e)),a7=Wn(tu,r7),o7={kernelName:tu,backendName:"cpu",kernelFunc:a7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=e,o=i.map(m=>t.data.get(m.dataId).values),l=i.map(m=>m.shape),c=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values,[h,d,p]=RN(o,l,c,r.shape,r.dtype,u,a.shape),f=h.map(m=>t.makeTensorInfo([m.length],"int32",m)),y=t.makeTensorInfo(p,r.dtype,d);return f.concat([y])}const c7={kernelName:gg,backendName:"cpu",kernelFunc:l7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u7(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,a=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=AN(a,s.shape,s.dtype,o,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const h7={kernelName:yg,backendName:"cpu",kernelFunc:u7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d7(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.data.get(i.dataId).values,u=t.data.get(r.dataId).values,h=t.data.get(a.dataId).values,d=o.map(m=>t.data.get(m.dataId).values),p=o.map(m=>m.shape),[f,y]=LN(c,i.shape,u,r.shape,r.dtype,h,a.shape,d,p,l);return t.makeTensorInfo(f,r.dtype,y)}const p7={kernelName:bg,backendName:"cpu",kernelFunc:d7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(n){const{backend:e,attrs:t}=n,{start:s,stop:i,dtype:r,step:a}=t,o=PN(s,i,a,r);return e.makeTensorInfo([o.length],r,o)}const m7={kernelName:xg,backendName:"cpu",kernelFunc:f7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g7=Gt(nu,n=>1/n),y7={kernelName:nu,backendName:"cpu",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=s;Ve(i,"resizeBilinear");const l=He(i.shape),[c,u]=o,[h,d,p,f]=i.shape,y=t.data.get(i.dataId).values,m=new Float32Array(re([h,c,u,f])),g=[r&&c>1?d-1:d,r&&u>1?p-1:p],b=[r&&c>1?c-1:c,r&&u>1?u-1:u];let x=0;const v=g[0]/b[0],w=g[1]/b[1];for(let _=0;_<h;_++)for(let I=0;I<c;I++){let C;a?C=v*(I+.5)-.5:C=v*I;const S=Math.max(0,Math.floor(C)),M=C-S,A=Math.min(d-1,Math.ceil(C)),D=_*l[0]+S*l[1],F=_*l[0]+A*l[1];for(let k=0;k<u;k++){let P;a?P=w*(k+.5)-.5:P=w*k;const O=Math.max(0,Math.floor(P)),V=P-O,$=Math.min(p-1,Math.ceil(P)),H=D+O*l[2],Y=F+O*l[2],G=D+$*l[2],B=F+$*l[2];for(let te=0;te<f;te++){const se=y[H+te],ae=y[Y+te],fe=y[G+te],be=y[B+te],ge=se+(fe-se)*V,ve=ae+(be-ae)*V,Oe=ge+(ve-ge)*M;m[x++]=Oe}}}return t.makeTensorInfo([h,c,u,f],"float32",m)}const x7={kernelName:Pd,backendName:"cpu",kernelFunc:b7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v7(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:a}=s;Ve([r,i],"resizeBilinearGrad");const o=He(i.shape),[l,c,u,h]=i.shape,[,d,p]=r.shape,f=new Float32Array(l*c*u*h),y=[a&&d>1?c-1:c,a&&p>1?u-1:u],m=[a&&d>1?d-1:d,a&&p>1?p-1:p],g=y[0]/m[0],b=y[1]/m[1],x=t.data.get(r.dataId).values;let v=0;for(let w=0;w<l;w++){const _=w*o[0];for(let I=0;I<d;I++){const C=I*g,S=Math.floor(C),M=Math.min(Math.ceil(C),c-1),A=_+S*o[1],D=_+M*o[1],F=C-S,k=1-F;for(let P=0;P<p;P++){const O=P*b,V=Math.floor(O),$=Math.min(Math.ceil(O),u-1),H=O-V,Y=1-H,G=A+V*o[2],B=A+$*o[2],te=D+V*o[2],se=D+$*o[2],ae=k*Y,fe=k*H,be=F*Y,ge=F*H;for(let ve=0;ve<h;ve++){const Oe=x[v++];f[G+ve]+=Oe*ae,f[B+ve]+=Oe*fe,f[te+ve]+=Oe*be,f[se+ve]+=Oe*ge}}}}return t.makeTensorInfo([l,u,c,h],"float32",f)}const w7={kernelName:Sg,backendName:"cpu",kernelFunc:v7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S7(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=s;Ve(i,"resizeNearestNeighbor");const l=He(i.shape),[c,u]=o,[h,d,p,f]=i.shape,y=t.data.get(i.dataId).values,m=new Float32Array(h*c*u*f),g=[r&&c>1?d-1:d,r&&u>1?p-1:p],b=[r&&c>1?c-1:c,r&&u>1?u-1:u],x=g[0]/b[0],v=g[1]/b[1];let w=0;for(let _=0;_<h;_++){const I=_*l[0];for(let C=0;C<c;C++){const S=a?x*(C+.5):x*C;let M=Math.min(d-1,r?Math.round(S):Math.floor(S));a&&(M=Math.max(0,M));const A=I+M*l[1];for(let D=0;D<u;D++){const F=a?v*(D+.5):v*D;let k=Math.min(p-1,r?Math.round(F):Math.floor(F));a&&(k=Math.max(0,k));const P=A+k*l[2];for(let O=0;O<f;O++){const V=y[P+O];m[w++]=V}}}}return t.makeTensorInfo([h,c,u,f],i.dtype,m)}const T7={kernelName:Ld,backendName:"cpu",kernelFunc:S7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:a}=s;Ve([r,i],"resizeNearestNeighborGrad");const o=He(i.shape),l=He(r.shape),[c,u,h,d]=i.shape,[,p,f]=r.shape,y=new Float32Array(c*u*h*d),m=t.data.get(r.dataId).values,g=[a&&p>1?u-1:u,a&&f>1?h-1:h],b=[a&&p>1?p-1:p,a&&f>1?f-1:f],x=g[0]/b[0],v=g[1]/b[1],w=1/x,_=1/v,I=Math.ceil(w)*2+2,C=Math.ceil(_)*2+2;for(let S=0;S<c;S++){const M=S*o[0];for(let A=0;A<u;A++){const D=M+A*o[1],F=Math.floor(A*w),k=Math.floor(F-I/2);for(let P=0;P<h;P++){const O=D+P*o[2],V=Math.floor(P*_),$=Math.floor(V-C/2);for(let H=0;H<d;H++){let Y=0;for(let G=0;G<I;G++){const B=G+k;if(B<0||B>=p)continue;const te=M+B*l[1],se=B*x,ae=Math.min(u-1,a?Math.round(se):Math.floor(se));if(A===ae)for(let fe=0;fe<C;fe++){const be=fe+$;if(be<0||be>=f)continue;const ge=te+be*l[2],ve=be*v,Oe=Math.min(h-1,a?Math.round(ve):Math.floor(ve));P===Oe&&(Y+=m[ge+H])}}y[O+H]=Y}}}}return t.makeTensorInfo(i.shape,i.dtype,y)}const I7={kernelName:wg,backendName:"cpu",kernelFunc:_7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s;Ve(i,"reverse");const a=i.shape.length,o=mt(r,i.shape);if(a===0)return gr({inputs:{x:i},backend:t});const l=new En(i.shape,i.dtype),c=t.bufferSync(i);for(let u=0;u<l.size;u++){const h=l.indexToLoc(u),d=h.slice();o.forEach(p=>d[p]=i.shape[p]-1-d[p]),l.set(c.get(...d),...h)}return t.makeTensorInfo(l.shape,l.dtype,l.values)}const C7={kernelName:Dd,backendName:"cpu",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E7={kernelName:Gg,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:a}=e,o=t,l=Rn(s.dtype,re(s.shape)),[c,u,h,d]=s.shape,[p,f]=$v(a,u,h),y=255,m=Math.sin(i),g=Math.cos(i),b=o.data.get(s.dataId).values;for(let x=0;x<c;x++){const v=x*h*u*d;for(let w=0;w<u;w++){const _=w*(h*d);for(let I=0;I<h;I++){const C=I*d;for(let S=0;S<d;S++){const M=[c,w,I,S],A=M[2],D=M[1];let F=(A-p)*g-(D-f)*m,k=(A-p)*m+(D-f)*g;F=Math.round(F+p),k=Math.round(k+f);let P=r;if(typeof r!="number"&&(S===3?P=y:P=r[S]),F>=0&&F<h&&k>=0&&k<u){const V=k*(h*d),$=F*d,H=v+V+$+S;P=b[H]}const O=v+_+C+S;l[O]=P}}}}return{dataId:o.write(l,s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7=Gt(ru,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),N7={kernelName:ru,backendName:"cpu",kernelFunc:k7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R7(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=ku(r,i,a),d=!0,p=t.bufferSync(i),f=t.bufferSync(r),y=zl(p,f,a,h,c,l,o,u,0,d);return t.makeTensorInfo(a,y.dtype,y.values)}const A7={kernelName:Tg,backendName:"cpu",kernelFunc:R7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<e?t=i+1:s=i;return s}function P7(n,e){let t=0,s=n.length,i=0;for(;t<s;)i=Math.floor((t+s)/2),n[i]<=e?t=i+1:s=i;return s}function D7(n,e,t,s,i,r){const a=pn("int32",t*i);for(let o=0;o<t;++o){const l=n.slice(o*s,(o+1)*s),c=o*i;for(let u=0;u<i;++u)a[c+u]=r==="left"?L7(l,e[u+c]):P7(l,e[u+c])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F7(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:a}=s,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,c=D7(o,l,i.shape[0],i.shape[1],r.shape[1],a);return t.makeTensorInfo(r.shape,"int32",c)}const O7={kernelName:_g,backendName:"cpu",kernelFunc:F7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G7(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e;Ve([s,i,r],"select");const a=s.shape.length,o=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=Es(i.dtype,r.dtype),h=Zn(re(i.shape),u);let d=0;const p=a===0||a>1||i.shape.length===1?1:re(i.shape.slice(1));for(let f=0;f<o.length;f++)for(let y=0;y<p;y++)o[f]===1?h[d++]=l[f]:h[d++]=c[f];return t.makeTensorInfo(i.shape,u,h)}const z7={kernelName:Fd,backendName:"cpu",kernelFunc:G7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7=My,W7=Cy,U7=Gt(ou,n=>n>=0?W7*n:V7*(Math.exp(n)-1)),B7={kernelName:ou,backendName:"cpu",kernelFunc:U7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $7=Gt(uu,n=>n<0?-1:n>0?1:0),X7={kernelName:uu,backendName:"cpu",kernelFunc:$7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H7=Gt(lu,n=>Math.sin(n)),K7={kernelName:lu,backendName:"cpu",kernelFunc:H7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z7=Gt(cu,n=>Math.sinh(n)),Y7={kernelName:cu,backendName:"cpu",kernelFunc:Z7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j7=11920928955078125e-23,iM=Math.log(j7)+2,Q7=Gt(du,n=>{const e=n>-iM,t=n<iM,s=Math.exp(n);let i;return t?i=s:e?i=n:i=Math.log(1+s),i}),J7={kernelName:du,backendName:"cpu",kernelFunc:Q7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q7(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:a}=s;Ve([i],"spaceToBatchND");const o=re(r),l=[[0,0]];l.push(...a);for(let m=1+r.length;m<i.shape.length;++m)l.push([0,0]);const c=hR.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),u=hp(c.shape,r,o,!1),h=dp(u.length,r.length,!1),d=pp(c.shape,r,o,!1),p=Ht({inputs:{x:c},backend:t,attrs:{shape:u}}),f=Rs({inputs:{x:p},backend:t,attrs:{perm:h}}),y=Ht({inputs:{x:f},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),y}const e8={kernelName:zd,backendName:"cpu",kernelFunc:q7};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t8(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:a}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(s.dataId).values,l=t.data.get(i.dataId).values,c=t.data.get(r.dataId).values,u=t.data.get(a.dataId).values[0],[h,d,p,f,y]=GN(o,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const n8={kernelName:Ig,backendName:"cpu",kernelFunc:t8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s8(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(t.data.get(i.dataId).values),o=t.data.get(s.dataId).values,l=Array.from(t.data.get(r.dataId).values),[c,u,h]=zN(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const i8={kernelName:Mg,backendName:"cpu",kernelFunc:s8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r8(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=OS(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const a8={kernelName:Cg,backendName:"cpu",kernelFunc:r8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o8(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${r.shape}`);if(i.shape[0]!==r.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(s.dataId).values,o=t.data.get(i.dataId).values,l=t.data.get(r.dataId).values,[c,u]=OS(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(u,s.dtype,c)}const l8={kernelName:Eg,backendName:"cpu",kernelFunc:o8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c8(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=ku(r,i,o),p=!1,f=t.bufferSync(i);let y;switch(r.dtype){case"bool":{const m=t.bufferSync(r),g=!!t.data.get(a.dataId).values[0];y=zl(f,m,o,d,u,c,l,h,g,p);break}case"float32":{const m=t.bufferSync(r),g=t.data.get(a.dataId).values[0];y=zl(f,m,o,d,u,c,l,h,g,p);break}case"int32":{const m=t.bufferSync(r),g=t.data.get(a.dataId).values[0];y=zl(f,m,o,d,u,c,l,h,g,p);break}case"string":{const m=t.bufferSync(r),g=Br(t.data.get(a.dataId).values[0]);y=zl(f,m,o,d,u,c,l,h,g,p);break}default:throw new Error(`Unsupported type ${r.dtype}`)}return t.makeTensorInfo(o,y.dtype,y.values)}const u8={kernelName:kg,backendName:"cpu",kernelFunc:c8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:a}=s,o=mt(a,i.shape)[0],l=rw(i,r,o),c=new Array(i.shape.length).fill(0),u=i.shape.slice();return l.map(h=>{const d=[...u];d[o]=h;const p=$o({inputs:{x:i},backend:t,attrs:{begin:c,size:d}});return c[o]+=h,p})}const d8={kernelName:Vd,backendName:"cpu",kernelFunc:h8};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p8={kernelName:Ng,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,s=e;Ve(t,"square");const i=s.data.get(t.dataId).values,r=new Float32Array(i.length);for(let a=0;a<i.length;++a){const o=i[a];r[a]=o*o}return{dataId:s.write(r,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f8=Gt(xu,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),m8={kernelName:xu,backendName:"cpu",kernelFunc:f8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s;Ve(i,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:y,sliceDim0:m,isSimpleSlice:g,begin:b,end:x,strides:v}=Wv(i.shape,r,a,o,l,c,u,h,d);let w;if(y)w=Ht({inputs:{x:i},backend:t,attrs:{shape:f}});else if(m||g){E(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const _=Gv(b,x,v),I=$o({inputs:{x:i},backend:t,attrs:{begin:b,size:_}});w=Ht({inputs:{x:I},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(I)}else{const _=t.bufferSync(i),I=WN(p,_,v,b);w=t.makeTensorInfo(f,I.dtype,I.values)}return w}const y8={kernelName:Rg,backendName:"cpu",kernelFunc:g8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b8(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.data.get(u.dataId).values,p=t.data.get(h.dataId).values,[f,y]=UN(d,p,i,r,a,o,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",y)]}const x8={kernelName:Ag,backendName:"cpu",kernelFunc:b8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v8(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:a}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(r.dataId).values,l=t.data.get(a.dataId).values[0],[c,u,h]=BN(o,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const w8={kernelName:Lg,backendName:"cpu",kernelFunc:v8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S8(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(r.dataId).values,o=$N(a,i);return t.makeTensorInfo(r.shape,"int32",o)}const T8={kernelName:Pg,backendName:"cpu",kernelFunc:S8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _8=Gt(gu,n=>Math.tan(n)),I8={kernelName:gu,backendName:"cpu",kernelFunc:_8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M8=Gt(yu,n=>Math.tanh(n)),C8={kernelName:yu,backendName:"cpu",kernelFunc:M8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;Ve(i,"tile");const a=HN(t.bufferSync(i),r);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const k8={kernelName:bu,backendName:"cpu",kernelFunc:E8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:a}=s;Ve(i,"topk");const o=t.data.get(i.dataId).values,[l,c]=ZN(o,i.shape,i.dtype,r,a);return[t.makeTensorInfo(l.shape,l.dtype,l.values),t.makeTensorInfo(c.shape,c.dtype,c.values)]}const R8={kernelName:Dg,backendName:"cpu",kernelFunc:N8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A8(n){const{inputs:e,attrs:t,backend:s}=n,{image:i,transforms:r}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=t,[u,h,d,p]=i.shape,[f,y]=c??[h,d],m=[u,f,y,p],g=He(i.shape),b=g[0],x=g[1],v=g[2],w=He(m),_=w[0],I=w[1],C=w[2],S=Rn(i.dtype,re(m));S.fill(l);const M=s.data.get(i.dataId).values,A=s.data.get(r.dataId).values;for(let D=0;D<u;++D){const F=r.shape[0]===1?A:A.subarray(D*8,D*8+8);for(let k=0;k<f;++k)for(let P=0;P<y;++P)for(let O=0;O<p;++O){let V;const $=F[6]*P+F[7]*k+1;if($===0)continue;const H=(F[0]*P+F[1]*k+F[2])/$,Y=(F[3]*P+F[4]*k+F[5])/$,G=rM(H,d,o),B=rM(Y,h,o);switch(a){case"nearest":V=G8(M,h,d,b,x,v,D,B,G,O,l);break;case"bilinear":V=z8(M,h,d,b,x,v,D,B,G,O,l);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const te=D*_+k*I+P*C+O;S[te]=V}return s.makeTensorInfo(m,i.dtype,S)}return{dataId:s.write(S,m,i.dtype),shape:i.shape,dtype:i.dtype}}const L8={kernelName:Fg,backendName:"cpu",kernelFunc:A8};function rM(n,e,t){switch(t){case"reflect":return P8(n,e);case"wrap":return D8(n,e);case"nearest":return O8(n,e);case"constant":default:return F8(n)}}function P8(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=2*e;t<s&&(t=s*Math.trunc(-t/s)+t),t=t<-e?t+s:-t-1}else if(t>e-1)if(e<=1)t=0;else{const s=2*e;t-=s*Math.trunc(t/s),t>=e&&(t=s-t-1)}return Aa(0,t,e-1)}function D8(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const s=e-1;t+=e*(Math.trunc(-t/s)+1)}else if(t>e-1)if(e<=1)t=0;else{const s=e-1;t-=e*Math.trunc(t/s)}return Aa(0,t,e-1)}function F8(n,e){return n}function O8(n,e){return Aa(0,n,e-1)}function fh(n,e,t,s,i,r,a,o,l,c,u){const h=a*s+o*i+l*r+c;return 0<=o&&o<e&&0<=l&&l<t?n[h]:u}function G8(n,e,t,s,i,r,a,o,l,c,u){const h=Math.round(o),d=Math.round(l);return fh(n,e,t,s,i,r,a,h,d,c,u)}function z8(n,e,t,s,i,r,a,o,l,c,u){const h=Math.floor(o),d=Math.floor(l),p=h+1,f=d+1,y=(f-l)*fh(n,e,t,s,i,r,a,h,d,c,u)+(l-d)*fh(n,e,t,s,i,r,a,h,f,c,u),m=(f-l)*fh(n,e,t,s,i,r,a,p,d,c,u)+(l-d)*fh(n,e,t,s,i,r,a,p,f,c,u);return(p-o)*y+(o-h)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V8(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;Ve(r,"unique");const a=s.data.get(r.dataId).values,{outputValues:o,outputShape:l,indices:c}=YN(a,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const W8={kernelName:Og,backendName:"cpu",kernelFunc:V8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U8(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const a=i.shape.length,o=i.shape[r],l=new Array(a-1);let c=0;for(let p=0;p<a;p++)p!==r&&(l[c++]=i.shape[p]);const u=new Array(a).fill(0),h=i.shape.slice();h[r]=1;const d=new Array(o);for(let p=0;p<d.length;p++){u[r]=p;const f=$o({inputs:{x:i},backend:t,attrs:{begin:u,size:h}});d[p]=Ht({inputs:{x:f},backend:t,attrs:{shape:l}}),t.disposeIntermediateTensorInfo(f)}return d}const B8={kernelName:Ud,backendName:"cpu",kernelFunc:U8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $8(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:a}=s;Ve(i,"unsortedSegmentSum");const o=i.shape.length,l=r.shape.length,c=[],u=[],h=o-l;let d=r;for(let f=0;f<h;++f){const y=mm({inputs:{input:d},backend:t,attrs:{dim:f+1}});d=y,u.push(y)}for(let f=0;f<a;++f){const y=Jr(f,"int32"),m=t.makeTensorInfo([],"int32",y),g=dN({inputs:{a:m,b:d},backend:t}),b=za({inputs:{x:g},backend:t,attrs:{dtype:"float32"}}),x=Qy({inputs:{a:b,b:i},backend:t}),v=Tp({inputs:{x},backend:t,attrs:{axis:0,keepDims:!1}});c.push(v),u.push(m),u.push(g),u.push(b),u.push(x),u.push(v)}const p=uR({inputs:c,backend:t,attrs:{axis:0}});return u.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const X8={kernelName:Bd,backendName:"cpu",kernelFunc:$8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H8=[WY,C9,BY,XY,L9,KY,YY,QY,qY,tj,sj,rj,oj,uj,dj,mj,yj,xj,wj,zY,Tj,Ij,Cj,kj,R9,D9,Rj,E9,Lj,Dj,Fj,Gj,Vj,Uj,$j,Hj,Zj,jj,Jj,eQ,nQ,iQ,aQ,oQ,cQ,hQ,pQ,fQ,mQ,gQ,xQ,AY,wQ,F9,kQ,O9,NQ,z9,FQ,OQ,zQ,W9,UQ,$Q,HQ,ZQ,jQ,B9,X9,k9,JQ,Pj,eJ,nJ,iJ,LY,K9,Y9,aJ,Q9,lJ,hJ,pJ,gJ,bJ,vJ,wJ,q9,TJ,IJ,CJ,kJ,RJ,LJ,DJ,tY,OJ,VJ,BJ,sY,rY,HJ,YJ,JJ,oY,e7,n7,s7,hR,o7,DY,uY,c7,h7,p7,m7,N9,vx,y7,FY,OY,GY,x7,w7,T7,I7,C7,E7,N7,bY,A7,O7,z7,B7,vY,X7,K7,Y7,wY,WJ,J7,e8,n8,i8,a8,l8,u8,d8,_Y,p8,MY,m8,y8,x8,w8,T8,NY,yQ,I8,C8,k8,R8,L8,lY,W8,B8,X8,t7];for(const n of H8)As(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bo={},mf={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function K8(n,e){bo[n]=e}function Bi(n,e){if(!(n in bo)||e!=null){const s=Y8(n,e);if(s!==null)bo[n]=s;else return console.log("Could not get context for WebGL version",n),null}const t=bo[n];return t==null||t.isContextLost()?(delete bo[n],Bi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),bo[n])}function Z8(n){if(typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Y8(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Z8(n);return t.addEventListener("webglcontextlost",s=>{s.preventDefault(),delete bo[n]},!1),ee().getBool("SOFTWARE_WEBGL_ENABLED")&&(mf.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",mf)||t.getContext("experimental-webgl",mf):t.getContext("webgl2",mf)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Gh;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Gh||(Gh={}));var ti;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(ti||(ti={}));var Hn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Hn||(Hn={}));function _p(n,e){return[e,n]}function j8(n,e){return n*e}function gf(n){const e=re(n),t=Math.ceil(e/4);return Xf(t)}function Gu(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function Q8(n,e){const[t,s]=Gu(n,e);return t*s*4}function US(n,e){const t=n;let s,i,r,a,o,l,c,u,h,d;return ee().getNumber("WEBGL_VERSION")===2?(s=t.R32F,i=t.R16F,r=t.RGBA16F,a=t.RGBA32F,o=t.RED,c=4,u=1,h=t.HALF_FLOAT,d=t.FLOAT,l=t.RGBA8):(s=n.RGBA,i=n.RGBA,r=n.RGBA,a=t.RGBA,o=n.RGBA,c=4,u=4,h=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,l=n.RGBA),{internalFormatFloat:s,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:r,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Re(n,e){const t=e();return ee().getBool("DEBUG")&&J8(n),t}function J8(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+n6(n,e))}const q8=596e-10,e6=65504;function t6(n){return!!(ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||q8<Math.abs(n)&&Math.abs(n)<e6)}function n6(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function yf(n,e){return ra(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function s6(n,e){const t=ra(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Re(n,()=>n.shaderSource(t,e)),Re(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function i6(n,e){const t=ra(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Re(n,()=>n.shaderSource(t,e)),Re(n,()=>n.compileShader(t)),ee().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw dR(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const r6=/ERROR: [0-9]+:([0-9]+):/g;function dR(n,e){const t=r6.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const s=+t[1],i=n.split(`
`),r=i.length.toString().length+2,a=i.map((h,d)=>_o((d+1).toString(),r)+h);let o=0;for(let h=0;h<a.length;h++)o=Math.max(a[h].length,o);const l=a.slice(0,s-1),c=a.slice(s-1,s),u=a.slice(s);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${_o(c[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function a6(n){return ra(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function o6(n,e){if(Re(n,()=>n.linkProgram(e)),!ee().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function e0(n,e){if(Re(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function l6(n,e){const t=ra(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Re(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function c6(n,e){const t=ra(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Re(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Re(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function u6(n){return ra(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function h6(n,e){const t=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const s=`[${n}x${e}]`;throw new Error("Requested texture size "+s+" is invalid.")}if(n>t||e>t){const s=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+s+" greater than WebGL maximum on this browser / GPU "+i+".")}}function d6(n){return ra(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function aM(n,e,t,s,i,r,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,s)),Re(n,()=>n.vertexAttribPointer(o,i,n.FLOAT,!1,r,a)),Re(n,()=>n.enableVertexAttribArray(o)),!0)}function p6(n,e,t){b6(n,t),Re(n,()=>n.activeTexture(n.TEXTURE0+t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function f6(n,e,t){return ra(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function m6(n,e,t){return n.getUniformLocation(e,t)}function g6(n,e,t,s){Re(n,()=>p6(n,e,s)),Re(n,()=>n.uniform1i(t,s))}function t0(n,e,t){Re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function oM(n,e){Re(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Re(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function bf(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+y6(n,e))}function y6(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ra(n,e,t){const s=Re(n,()=>e());if(s==null)throw new Error(t);return s}function b6(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,s=e+n.TEXTURE0;if(s<n.TEXTURE0||s>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function bc(n,e=2){return re(n.slice(0,n.length-e))}function xc(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function xf(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[bc(n),...xc(n)]),e}function x6(n,e=!1){let t=ee().getNumber("WEBGL_MAX_TEXTURE_SIZE"),s=ee().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");s===1/0&&ee().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(s=t/2),e&&(t=t*2,s=s*2,n=n.map((o,l)=>l>=n.length-2?Pm(n[l]):n[l]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=Qr(n).newShape);let i=re(n),r=null;n.length<=1&&i<=t?r=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?r=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?r=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?r=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?r=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(r=[n[0],n[1]*n[2]*n[3]]);const a=r!=null&&Math.max(...r)>s&&Math.min(...r)<=(e?2:1)&&Math.min(...r)>0;if(r==null||a)if(e){const o=bc(n);let l=2,c=2;n.length&&([l,c]=xc(n)),i=o*(l/2)*(c/2),r=Xf(i).map(u=>u*2)}else r=Xf(i);return r}function vf(n){return n%2===0}function ym(n,e){if(n=n.slice(-2),e=e.slice(-2),St(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n.slice(-1)[0],s=e.slice(-1)[0];if(t===s||vf(t)&&vf(s)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&vf(n[0])&&vf(e[0])}let n0,s0;function v6(n){if(n0==null){const e=Bi(n);n0=e.getParameter(e.MAX_TEXTURE_SIZE)}return n0}function w6(n){if(s0==null){const e=Bi(n);s0=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,s0)}function S6(n){if(n===0)return 0;let e;const t=Bi(n);return Si(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:Si(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function Si(n,e){return n.getExtension(e)!=null}function lM(n){try{if(Bi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function T6(n){if(n===0)return!1;const e=Bi(n);if(n===1){if(!Si(e,"OES_texture_float"))return!1}else if(!Si(e,"EXT_color_buffer_float"))return!1;return Sx(e)}function _6(n){if(n===0)return!1;const e=Bi(n);if(n===1){if(!Si(e,"OES_texture_float")||!Si(e,"WEBGL_color_buffer_float"))return!1}else{if(Si(e,"EXT_color_buffer_float"))return Sx(e);const t="EXT_color_buffer_half_float";if(Si(e,t)){const s=e.getExtension(t);return I6(e,s)}return!1}return Sx(e)}function Sx(n){const e=US(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const s=1,i=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,s,i,0,e.textureFormatFloat,e.textureTypeFloat,null);const r=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,r),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(r),a}function I6(n,e){const t=US(n,e),s=n.createTexture();n.bindTexture(n.TEXTURE_2D,s);const i=1,r=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,i,r,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,s,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(s),n.deleteFramebuffer(a),o}function M6(n){return n!==2?!1:Bi(n).fenceSync!=null}function Ip(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&E(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Be=ee();Be.registerFlag("HAS_WEBGL",()=>Be.getNumber("WEBGL_VERSION")>0);Be.registerFlag("WEBGL_VERSION",()=>lM(2)?2:lM(1)?1:0);Be.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);Be.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>Be.get("WEBGL_VERSION")===2);Be.registerFlag("WEBGL_CPU_FORWARD",()=>!0);Be.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);Be.registerFlag("WEBGL_PACK",()=>Be.getBool("HAS_WEBGL"));Be.registerFlag("WEBGL_PACK_NORMALIZATION",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_CLIP",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_PACK_REDUCE",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_LAZILY_UNPACK",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_CONV_IM2COL",()=>Be.getBool("WEBGL_PACK"));Be.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>v6(Be.getNumber("WEBGL_VERSION")));Be.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>w6(Be.getNumber("WEBGL_VERSION")));Be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=Be.getNumber("WEBGL_VERSION");return n===0?0:S6(n)});Be.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>Be.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!m1());Be.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>T6(Be.getNumber("WEBGL_VERSION")));Be.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>Be.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:Be.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));Be.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>_6(Be.getNumber("WEBGL_VERSION")));Be.registerFlag("WEBGL_FENCE_API_ENABLED",()=>M6(Be.getNumber("WEBGL_VERSION")));Be.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>Be.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);Be.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});Be.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>m1()?1:-1,n=>{if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});Be.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);Be.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);Be.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);Be.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);Be.registerFlag("WEBGL_EXP_CONV",()=>!1);Be.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>Be.getBool("IS_TEST"));Be.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);Be.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);Be.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);Be.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ys(){let n,e,t,s,i,r,a,o,l,c;return ee().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",s="in",i="texture",r="outputColor",a="out vec4 outputColor;",o=ee().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",s="varying",i="texture2D",r="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:s,texture2D:i,output:r,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(n,e,t="index"){const s=He(e);return s.map((i,r)=>{const a=`int ${n[r]} = ${t} / ${i}`,o=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * ${i}`:`index -= ${n[r]} * ${i}`;return`${a}; ${o};`}).join("")}function Jy(n,e,t="index"){const s=He(e);return s.map((i,r)=>{const a=`int ${n[r]} = ${t} / outShapeStrides[${r}]`,o=r===s.length-1?`int ${n[r+1]} = ${t} - ${n[r]} * outShapeStrides[${r}]`:`index -= ${n[r]} * outShapeStrides[${r}]`;return`${a}; ${o};`}).join("")}function C6(n,e){const t=n.length,s=n.map(r=>`${e}[${r}]`),i=new Array(t-1);i[t-2]=s[t-1];for(let r=t-3;r>=0;--r)i[r]=`(${i[r+1]} * ${s[r+1]})`;return i}function E6(n,e,t="index"){const s=n.map((r,a)=>a),i=C6(s,e);return i.map((r,a)=>{const o=`int ${n[a]} = ${t} / ${i[a]}`,l=a===i.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${i[a]}`:`index -= ${n[a]} * ${i[a]}`;return`${o}; ${l};`}).join("")}function BS(n){const e=He(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function $S(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const pR=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:fR}=BE;function k6(n,e,t){const s=[];if(n.forEach(d=>{const p=re(d.shapeInfo.logicalShape);if(d.shapeInfo.isUniform?s.push(`uniform float ${d.name}${p>1?`[${p}]`:""};`):(s.push(`uniform sampler2D ${d.name};`),s.push(`uniform int offset${d.name};`)),t.enableShapeUniforms){const{uniformShape:f}=XS(t.packedInputs,d.shapeInfo.logicalShape,d.shapeInfo.texShape);switch(f.length){case 1:s.push(`uniform int ${d.name}Shape;`);break;case 2:s.push(`uniform ivec2 ${d.name}Shape;`);break;case 3:s.push(`uniform ivec3 ${d.name}Shape;`);break;case 4:s.push(`uniform ivec4 ${d.name}Shape;`);break}s.push(`uniform ivec2 ${d.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:s.push("uniform int outShape;");break;case 2:s.push("uniform ivec2 outShape;"),s.push("uniform int outShapeStrides;");break;case 3:s.push("uniform ivec3 outShape;"),s.push("uniform ivec2 outShapeStrides;");break;case 4:s.push("uniform ivec4 outShape;"),s.push("uniform ivec3 outShapeStrides;");break}s.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(d=>{s.push(`uniform ${d.type} ${d.name}${d.arrayIndex?`[${d.arrayIndex}]`:""};`)});const i=s.join(`
`),r=n.map(d=>N6(d,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=ys(),l=L6(o);let c,u,h=F6(o);return e.isPacked?(c=R6(e.logicalShape,a,t.enableShapeUniforms),u=D6(o)):(c=A6(e.logicalShape,a,t.enableShapeUniforms),u=P6(o)),t.packedInputs&&(h+=V6),[h,l,u,i,c,r,t.userCode].join(`
`)}function zu(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return J6(n,e);case 1:return eq(n,e);case 2:return nq(n,e);case 3:return iq(n,e);case 4:return aq(n,e);case 5:return oq(n);case 6:return lq(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function mR(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return Q6(n);case 1:return q6(n,e);case 2:return tq(n,e);case 3:return sq(n,e);default:return rq(n,e)}}function N6(n,e,t=!1,s){let i="";t?i+=mR(n,s):i+=zu(n,s);const r=n.shapeInfo.logicalShape,a=e.logicalShape;return r.length<=a.length&&(t?i+=cq(n,e):i+=uq(n,e)),i}function R6(n,e,t){switch(n.length){case 0:return gR();case 1:return W6(n,e,t);case 2:return Y6(n,e,t);case 3:return B6(n,e,t);default:return X6(n,e,t)}}function A6(n,e,t){switch(n.length){case 0:return gR();case 1:return U6(n,e,t);case 2:return j6(n,e,t);case 3:return $6(n,e,t);case 4:return H6(n,e,t);case 5:return K6(n,e);case 6:return Z6(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function L6(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function P6(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function D6(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function F6(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${O6}
    ${G6}
    ${z6}
  `}const O6=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,G6=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,z6=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,V6=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function gR(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function W6(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return s[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${s[1]}.0);
      }
    `:s[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${s[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      return 2 * (resTexRC.x * ${s[1]} + resTexRC.y);
    }
  `}function U6(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function B6(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),r=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function $6(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Jy(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const s=cl(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec3(r, c, d);
    }
  `}function X6(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),r=i*Math.ceil(n[n.length-2]/2);let a=r,o="",l="b, r, c";for(let c=2;c<n.length-1;c++)a*=n[n.length-c-1],o=`
      int b${c} = index / ${a};
      index -= b${c} * ${a};
    `+o,l=`b${c}, `+l;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));
      int index = resTexRC.x * ${s[1]} + resTexRC.y;

      ${o}

      int b = index / ${r};
      index -= b * ${r};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${l});
    }
  `}function H6(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Jy(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const s=cl(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${s}
      return ivec4(r, c, d, d2);
    }
  `}function K6(n,e){const t=cl(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function Z6(n,e){const t=cl(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function Y6(n,e,t){const s=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(St(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${s[0]}, ${s[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${s[0]}, ${s[1]}));

      int index = resTexRC.x * ${s[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function j6(n,e,t){return St(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function ul(n){return`offset${n}`}function Q6(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),s=ys();return`
    vec4 ${t}() {
      return ${s.texture2D}(${e}, halfCR);
    }
  `}function J6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${s}() {return ${t};}`;const[i,r]=n.shapeInfo.texShape;if(i===1&&r===1)return`
      float ${s}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=ul(t);if(e)return`
    float ${s}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,l]=n.shapeInfo.texShape;return`
    float ${s}() {
      vec2 uv = uvFromFlat(${o}, ${l}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function q6(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,r=ys();if(e)return`
    vec4 ${s}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${r.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${s}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${r.texture2D}(${t}, uv);
    }
  `}function eq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${s}(int index) {
        ${Vu(n)}
      }
    `;const i=n.shapeInfo.texShape,r=i[0],a=i[1];if(a===1&&r===1)return`
      float ${s}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=ul(t);return a===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${r}.0);
        return sampleTexture(${t}, uv);
      }
    `:r===1?e?`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${s}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${s}(int index) {
      vec2 uv = uvFromFlat(${r}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function tq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,a=r[0],o=r[1],l=ys();if(r!=null&&St(t,r))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);

        return ${l.texture2D}(${s}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${l.texture2D}(${s}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `;const c=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${s}, uv);
    }
  `}function nq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape;if(r!=null&&St(t,r)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `;const d=r[0],p=r[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${p}.0, ${d}.0);
      return sampleTexture(${s}, uv);
    }
  `}const{newShape:a,keptDims:o}=Qr(t),l=a;if(l.length<t.length){const d=Wu(n,l),p=["row","col"];return`
      ${zu(d,e)}
      float ${i}(int row, int col) {
        return ${i}(${Uu(p,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${Vu(n)}
      }
    `;const c=r[0],u=r[1],h=ul(s);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${s}TexShape[0]));
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${s}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${h}), vec3(${s}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${s}TexShape[1]), 0.5);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${h}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${s}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s}Shape[1] + col + ${h};
        vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
        return sampleTexture(${s}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${h};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${s}, uv);
  }
`}function sq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=n.shapeInfo.texShape,a=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];if(t[0]===1){const d=t.slice(1),p=[1,2],f=Wu(n,d),y=["b","row","col"];return`
        ${mR(f,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Uu(y,p)});
        }
      `}const o=ys();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${s}TexShape[0]) / 2.0), ceil(float(${s}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${s}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${s}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `;const l=a[0],c=a[1],u=Math.ceil(t[2]/2),h=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${h}, ${u}, b, row, col);
      return ${o.texture2D}(${s}, uv);
    }
  `}function iq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[1]*t[2],a=t[2],{newShape:o,keptDims:l}=Qr(t),c=o;if(c.length<t.length){const y=Wu(n,c),m=["row","col","depth"];return`
        ${zu(y,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Uu(m,l)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${r}, ${a}, 1)));
        ${Vu(n)}
      }
    `;const u=n.shapeInfo.texShape,h=u[0],d=u[1],p=n.shapeInfo.flatOffset;if(d===r&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${s}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${h}.0);
          return sampleTexture(${s}, uv);
        }
      `;if(d===a&&p==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${s}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${h}.0);
      return sampleTexture(${s}, uv);
    }
  `;const f=ul(s);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${s}Shape[1] * ${s}Shape[2];
      int stride1 = ${s}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${f};
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index);
      return sampleTexture(${s}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r} + col * ${a} + depth + ${f};
        vec2 uv = uvFromFlat(${h}, ${d}, index);
        return sampleTexture(${s}, uv);
      }
  `}function rq(n,e){const t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=ys();if(e)return`
    vec4 ${s}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const r=n.shapeInfo.logicalShape,a=r.length,o=n.shapeInfo.texShape,l=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=l[0],u=l[1],h=Math.ceil(r[a-1]/2);let d=h*Math.ceil(r[a-2]/2),p="int b, int row, int col",f=`b * ${d} + (row / 2) * ${h} + (col / 2)`;for(let y=2;y<a-1;y++)p=`int b${y}, `+p,d*=r[a-y-1],f=`b${y} * ${d} + `+f;return`
    vec4 ${s}(${p}) {
      int index = ${f};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${t}, uv);
    }
  `}function aq(n,e){const t=n.shapeInfo.logicalShape,s=n.name,i="get"+s.charAt(0).toUpperCase()+s.slice(1),r=t[3],a=t[2]*r,o=t[1]*a,{newShape:l,keptDims:c}=Qr(t);if(l.length<t.length){const b=Wu(n,l),x=["row","col","depth","depth2"];return`
      ${zu(b,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Uu(x,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${r}, 1)));
        ${Vu(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1],f=`int stride2 = ${s}Shape[3];`,y=`int stride1 = ${s}Shape[2] * stride2;`,m=`int stride0 = ${s}Shape[1] * stride1;`;if(p===o&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${f}
        ${y}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${r}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;if(p===r&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${s}Shape[1] * ${s}Shape[2], ${s}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${s}TexShape[1], ${s}TexShape[0]);
        return sampleTexture(${s}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${s}, uv);
      }
    `;const g=ul(s);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${f}
      ${y}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${s}TexShape[0], ${s}TexShape[1], index + ${g});
      return sampleTexture(${s}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${r} + depth2;
      vec2 uv = uvFromFlat(${d}, ${p}, index + ${g});
      return sampleTexture(${s}, uv);
    }
  `}function oq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],r=e[3]*i,a=e[2]*r,o=e[1]*a,{newShape:l,keptDims:c}=Qr(e);if(l.length<e.length){const y=Wu(n,l),m=["row","col","depth","depth2","depth3"];return`
      ${zu(y)}
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        return ${s}(${Uu(m,c)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${r}, ${i})) +
          depth3;
        ${Vu(n)}
      }
    `;const u=n.shapeInfo.flatOffset,h=n.shapeInfo.texShape,d=h[0],p=h[1];if(p===o&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${r}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===i&&u==null)return`
      float ${s}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const f=ul(t);return`
    float ${s}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${r} +
          depth2 * ${i} + depth3 + ${f};
      vec2 uv = uvFromFlat(${d}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function lq(n){const e=n.shapeInfo.logicalShape,t=n.name,s="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:r}=Qr(e);if(i.length<e.length){const m=Wu(n,i),g=["row","col","depth","depth2","depth3","depth4"];return`
      ${zu(m)}
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${s}(${Uu(g,r)});
      }
    `}const a=e[5],o=e[4]*a,l=e[3]*o,c=e[2]*l,u=e[1]*c;if(n.shapeInfo.isUniform)return`
      float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${Vu(n)}
      }
    `;const h=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(f===a&&h==null)return`
      float ${s}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${f}.0, ${p}.0);
        return sampleTexture(${t}, uv);
      }
    `;const y=ul(t);return`
    float ${s}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${y};
      vec2 uv = uvFromFlat(${p}, ${f}, index);
      return sampleTexture(${t}, uv);
    }
  `}function Vu(n){const e=n.name,t=re(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function cq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=fR(n.shapeInfo.logicalShape,e.logicalShape),l=Kt(a),c=a-r;let u;const h=["x","y","z","w","u","v"];r===0?u="":a<2&&o.length>=1?u="coords = 0;":u=o.map(m=>`coords.${h[m+c]} = 0;`).join(`
`);let d="";a<2&&r>0?d="coords":d=n.shapeInfo.logicalShape.map((m,g)=>`coords.${h[g+c]}`).join(", ");let p="return outputValue;";const f=re(n.shapeInfo.logicalShape)===1,y=re(e.logicalShape)===1;if(r===1&&!f&&!y)p=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(f&&!y)a===1?p=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:p=`
        return vec4(outputValue.x);
      `;else if(o.length){const m=r-2,g=r-1;o.indexOf(m)>-1&&o.indexOf(g)>-1?p="return vec4(outputValue.x);":o.indexOf(m)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(g)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${s}(${d});
      ${p}
    }
  `}function uq(n,e){const t=n.name,s=t.charAt(0).toUpperCase()+t.slice(1),i="get"+s+"AtOutCoords",r=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===l&&n.shapeInfo.flatOffset==null&&St(a,r))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const c=Kt(l),u=fR(n.shapeInfo.logicalShape,e.logicalShape),h=l-o;let d;const p=["x","y","z","w","u","v"];o===0?d="":l<2&&u.length>=1?d="coords = 0;":d=u.map(y=>`coords.${p[y+h]} = 0;`).join(`
`);let f="";return l<2&&o>0?f="coords":f=n.shapeInfo.logicalShape.map((y,m)=>`coords.${p[m+h]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${d}
      return get${s}(${f});
    }
  `}function Kt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function XS(n,e,t){const{newShape:s,keptDims:i}=Qr(e),r=e.length,a=n&&r===3&&e[0]===1,o=a?e.slice(1):s,l=!n&&r>1&&!St(e,t)&&s.length<r||a;return{useSqueezeShape:l,uniformShape:l?o:e,keptDims:i}}function Wu(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Uu(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hq(n,e,t,s){const i=t.map((u,h)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[h],shapeInfo:d}}),r=i.map(u=>u.shapeInfo),a={logicalShape:s.shape,texShape:s.texData.texShape,isUniform:!1,isPacked:s.texData.isPacked,flatOffset:null},o=k6(i,a,e),l=i6(n.gl,o),c=n.createProgram(l);return ee().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:r,outShapeInfo:a,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:o,webGLProgram:c,inShapeInfos:r,outShapeInfo:a},yR(n,e,c))}function yR(n,e,t){const s={},i={},r={},a=[];let o,l,c,u=null,h=null;h=n.getUniformLocation(t,"NAN",!1),ee().getNumber("WEBGL_VERSION")===1&&(u=n.getUniformLocation(t,"INFINITY",!1));const d=!1;for(let p=0;p<e.variableNames.length;p++){const f=e.variableNames[p];s[f]=n.getUniformLocation(t,f,d),s[`offset${f}`]=n.getUniformLocation(t,`offset${f}`,d),e.enableShapeUniforms&&(i[`${f}Shape`]=n.getUniformLocation(t,`${f}Shape`,d),r[`${f}TexShape`]=n.getUniformLocation(t,`${f}TexShape`,d))}return e.enableShapeUniforms&&(o=n.getUniformLocation(t,"outShape",d),c=n.getUniformLocation(t,"outShapeStrides",d),l=n.getUniformLocation(t,"outTexShape",d)),e.customUniforms&&e.customUniforms.forEach((p,f)=>{a[f]=n.getUniformLocation(t,p.name,d)}),{uniformLocations:s,customUniformLocations:a,infLoc:u,nanLoc:h,inShapesLocations:i,inTexShapesLocations:r,outShapeLocation:o,outShapeStridesLocation:c,outTexShapeLocation:l}}function cM(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,s)=>{const i=t.logicalShape,r=e[s],a=r.shape;if(!St(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(t.isUniform&&r.isUniform)return;const o=t.texShape,l=r.isUniform?null:r.texData.texShape;if(!St(o,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${l} must match`)})}function dq(n,e,t,s,i){e.program.enableShapeUniforms||(cM(e.inShapeInfos,t),cM([e.outShapeInfo],[s]));const r=s.texData.texture,a=s.texData.texShape;s.texData.isPacked?n.setOutputPackedMatrixTexture(r.texture,a[0],a[1]):n.setOutputMatrixTexture(r.texture,a[0],a[1]),n.setProgram(e.webGLProgram),ee().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN),t.forEach((l,c)=>{const u=e.program.variableNames[c],h=e.uniformLocations[u],d=e.uniformLocations[`offset${u}`],p=e.inShapesLocations[`${u}Shape`],f=e.inTexShapesLocations[`${u}TexShape`];if(p){const{uniformShape:y}=XS(e.program.packedInputs,l.shape,l.texData.texShape);switch(y.length){case 1:n.gl.uniform1iv(p,new Int32Array(y));break;case 2:n.gl.uniform2iv(p,new Int32Array(y));break;case 3:n.gl.uniform3iv(p,new Int32Array(y));break;case 4:n.gl.uniform4iv(p,new Int32Array(y));break}}if(f&&n.gl.uniform2i(f,l.texData.texShape[0],l.texData.texShape[1]),h!=null){if(l.isUniform){if(re(l.shape)<2)n.gl.uniform1f(h,l.uniformValues[0]);else{let y=l.uniformValues;y instanceof Float32Array||(y=new Float32Array(y)),n.gl.uniform1fv(h,y)}return}l.texData.slice!=null&&d!=null&&n.gl.uniform1i(d,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,h,c)}});const o=e.outShapeLocation;if(o)switch(s.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(s.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(s.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(s.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(s.shape));break}if(e.outShapeStridesLocation){const l=He(s.shape);switch(s.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,s.texData.texShape[0],s.texData.texShape[1]),e.program.customUniforms&&i&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],h=i[c];if(l.type==="float")n.gl.uniform1fv(u,h);else if(l.type==="vec2")n.gl.uniform2fv(u,h);else if(l.type==="vec3")n.gl.uniform3fv(u,h);else if(l.type==="vec4")n.gl.uniform4fv(u,h);else if(l.type==="int")n.gl.uniform1iv(u,h);else if(l.type==="ivec2")n.gl.uniform2iv(u,h);else if(l.type==="ivec3")n.gl.uniform3iv(u,h);else if(l.type==="ivec4")n.gl.uniform4iv(u,h);else throw Error(`uniform type ${l.type} is not supported yet.`)}),n.executeProgram()}function pq(n,e,t){let s="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const l=a.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:h}=XS(n.packedInputs,a.shape,l);let d="",p="",f="";if(u.length===1&&n.packedInputs){const w=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];d=`${w[0]>1}_${w[1]>1}`}else if(u.length===2&&!n.packedInputs)p=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const w=He(u);f=`${w[0]===l[1]}_${w[w.length-1]===l[1]}`}const y=a.shape.length,m=u.length===2&&St(a.shape,l),g=re(a.shape)===1,b=Go(a.shape,t.shape),x=!n.packedInputs&&y===t.shape.length&&St(l,t.texData.texShape),v=n.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;s+=`${y}_${x}_${c?h:""}_${u.length}_${g}_${b}_${m}_${d}_${p}_${f}_${v}_${o}`}else{const l=a.isUniform?"uniform":a.texData.texShape;s+=`${a.shape}_${l}_${o}`}});const i=n.userCode;let r=n.constructor.name;return r+="_"+s+"_"+i+`${ee().getNumber("WEBGL_VERSION")}`,r}function bs(n){return ee().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fq{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Gh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ys();this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Jy(["r","c","d"],e):cl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mq{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Gh.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=ys();this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Jy(["r","c","d"],e):cl(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gq{constructor(e){this.variableNames=["A"],this.outTexUsage=ti.DOWNLOAD;const t=ys();this.outputShape=e,this.userCode=`
      ${pR}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yq{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ti.DOWNLOAD;const t=ys();this.outputShape=e,this.userCode=`
      ${pR}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bq={R:0,G:1,B:2,A:3};let uM=class{constructor(e,t=!1,s="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=ys();this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let a="";for(let o=0;o<s.length;o++){const l=s[o];a+=`
          if(offset == ${o}) {
            result = values[${bq[l]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?$S():BS(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${s.length});

        flatIndex = idiv(flatIndex, ${s.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${a}
        }
        ${i.output} = vec4(${r}, 0., 0., 0.);
      }
    `}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xq{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const s=ys();this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length);let i="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const l=a*2+o;i+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${s.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?$S():BS(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${s.output} = ${r};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vq(n){const e=ys(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return s6(n,t)}function wq(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return l6(n,e)}function Sq(n){const e=new Uint16Array([0,1,2,2,1,3]);return c6(n,e)}function Mp(n,e,t,s,i,r){h6(e,t);const a=u6(n),o=n.TEXTURE_2D;return Re(n,()=>n.bindTexture(o,a)),Re(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Re(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Re(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Re(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),ee().getNumber("WEBGL_VERSION")===1?Re(n,()=>n.texImage2D(o,0,s,e,t,0,i,r,null)):Re(n,()=>n.texStorage2D(o,1,s,e,t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function bR(n){return n.internalFormatFloat}function Tq(n,e,t,s){const[i,r]=_p(e,t);return Mp(n,i,r,bR(s),s.textureFormatFloat,n.FLOAT)}function xR(n){return n.internalFormatHalfFloat}function _q(n,e,t,s){const[i,r]=_p(e,t);return Mp(n,i,r,xR(s),s.textureFormatFloat,s.textureTypeHalfFloat)}function vR(n){return n.downloadTextureFormat}function Iq(n,e,t,s){const[i,r]=_p(e,t);return Mp(n,i,r,vR(s),n.RGBA,n.UNSIGNED_BYTE)}function wR(n){return n.internalFormatPackedFloat}function Mq(n,e,t,s){const[i,r]=Gu(e,t);return Mp(n,i,r,wR(s),n.RGBA,n.FLOAT)}function SR(n){return n.internalFormatPackedHalfFloat}function Cq(n,e,t,s){const[i,r]=Gu(e,t);return Mp(n,i,r,SR(s),n.RGBA,s.textureTypeHalfFloat)}function Eq(n,e,t){return Re(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),aM(n,e,"clipSpacePos",t,3,20,0)&&aM(n,e,"uv",t,2,20,12)}function kq(n,e,t,s,i,r){Re(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,l;i instanceof Uint8Array?(a=new Uint8Array(t*s*4),o=n.UNSIGNED_BYTE,l=n.RGBA):(a=new Float32Array(t*s*4),o=n.FLOAT,l=r.internalFormatPackedFloat),a.set(i),ee().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,s,n.RGBA,o,a)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,l,t,s,0,n.RGBA,o,a)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Nq(n,e,t){Re(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ee().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ee().getNumber("WEBGL_VERSION")===2?Re(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Re(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Re(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function Rq(n,e,t,s){const i=n.createBuffer();Re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const r=4*4*e*t;return Re(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,r,n.STREAM_READ)),Re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Re(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function Aq(n,e,t){const s=n,i=new Float32Array(t);return s.bindBuffer(s.PIXEL_PACK_BUFFER,e),s.getBufferSubData(s.PIXEL_PACK_BUFFER,0,i),s.bindBuffer(s.PIXEL_PACK_BUFFER,null),i}function Lq(n,e,t,s){const[i,r]=_p(e,t),a=4,o=new Uint8Array(j8(e*t,a));return Re(n,()=>n.readPixels(0,0,i,r,s.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function Pq(n,e,t,s,i,r,a,o){const l=n,c=new Float32Array(Q8(r,a));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function Dq(n,e,t){const s=new Float32Array(e*t*4);return Re(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,s)),s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class i0{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ee().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,K8(t,e)):this.gl=Bi(t),e=this.gl,ee().getNumber("WEBGL_VERSION")===2){const r=e;this.createVertexArray=()=>Re(r,()=>r.createVertexArray()),this.bindVertexArray=a=>Re(r,()=>r.bindVertexArray(a)),this.deleteVertexArray=a=>Re(r,()=>r.deleteVertexArray(a)),this.getVertexArray=()=>Re(r,()=>r.getParameter(r.VERTEX_ARRAY_BINDING))}else if(e!=null){const r=e.getExtension("OES_vertex_array_object");if(r==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Re(e,()=>r.createVertexArrayOES()),this.bindVertexArray=a=>Re(e,()=>r.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Re(e,()=>r.deleteVertexArrayOES(a)),this.getVertexArray=()=>Re(e,()=>e.getParameter(r.VERTEX_ARRAY_BINDING_OES))}let s="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ee().getNumber("WEBGL_VERSION")===1){const r="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=yf(this.gl,r),Si(this.gl,a))this.textureHalfFloatExtension=yf(this.gl,a);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(s),Si(this.gl,i))this.colorBufferHalfFloatExtension=yf(this.gl,i);else if(ee().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(s="EXT_color_buffer_float",Si(this.gl,s))this.colorBufferFloatExtension=this.gl.getExtension(s);else if(Si(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=wq(this.gl),this.indexBuffer=Sq(this.gl),this.framebuffer=d6(this.gl),this.textureConfig=US(this.gl,this.textureHalfFloatExtension)}get debug(){return ee().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Re(e,()=>e.finish()),Re(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Re(e,()=>e.deleteFramebuffer(this.framebuffer)),Re(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Re(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Re(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),Tq(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),_q(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),Iq(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),Nq(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,s,i){this.throwIfDisposed(),kq(this.gl,e,t,s,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),Cq(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),Mq(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(oM(this.gl,this.framebuffer),this.outputTexture=null),Re(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Lq(this.gl,t,s,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,s,i,r,a){return Pq(this.gl,e,t,s,i,r,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return Aq(this.gl,e,t)}createBufferFromTexture(e,t,s){this.bindTextureToFrameBuffer(e);const i=Rq(this.gl,t,s,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,s;if(ee().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,r=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),s=()=>{const a=i.clientWaitSync(r,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},t=r}else ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),s=()=>this.isQueryAvailable(t,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):s=()=>!0;return{query:t,isFencePassed:s}}downloadMatrixFromPackedTexture(e,t,s){return this.downloadMatrixDriver(e,()=>Dq(this.gl,t,s))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=vq(t));const s=a6(t);Re(t,()=>t.attachShader(s,this.vertexShader)),Re(t,()=>t.attachShader(s,e)),o6(t,s);let i;return i=Object.assign(s,{vao:this.createVertexArray()}),this.bindVertexArray(i.vao),Re(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),console.assert(Eq(t,i,this.vertexBuffer),"gpgpu_util.bindVertexProgramAttributeStreams not fully successful."),this.debug&&e0(t,i),this.setProgram(i),i}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Re(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&(this.bindVertexArray(this.program.vao),this.debug&&e0(this.gl,this.program)),Re(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,s=!0){return this.throwIfDisposed(),s?f6(this.gl,e,t):m6(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Re(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,s){this.throwIfDisposed(),this.throwIfNoProgram(),g6(this.gl,e,t,s)}setOutputMatrixTexture(e,t,s){this.setOutputMatrixTextureDriver(e,s,t)}setOutputPackedMatrixTexture(e,t,s){this.throwIfDisposed();const[i,r]=Gu(t,s);this.setOutputMatrixTextureDriver(e,i,r)}setOutputMatrixWriteRegion(e,t,s,i){this.setOutputMatrixWriteRegionDriver(s,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,s,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&e0(this.gl,this.program),bf(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Re(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Re(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yf(this.gl,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.createQuery();return s.beginQuery(i.TIME_ELAPSED_EXT,r),r}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,s=this.getQueryTimerExtensionWebGL2();t.endQuery(s.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await $0(()=>this.disposed||this.isQueryAvailable(e,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const s=this.gl;return s.getQueryParameter(e,s.QUERY_RESULT)/1e6}else{const s=this.getQueryTimerExtensionWebGL1();return s.getQueryObjectEXT(e,s.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const s=this.gl,i=this.getQueryTimerExtensionWebGL2(),r=s.getQueryParameter(e,s.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),r&&!this.disjoint}else{const s=this.getQueryTimerExtensionWebGL1(),i=s.getQueryObjectEXT(e,s.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(s.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=Fq(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:s}=this.itemsToPoll[t];s()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let s;"setTimeoutCustom"in ee().platform&&(s=ee().platform.setTimeoutCustom.bind(ee().platform)),$0(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,s)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),t0(this.gl,e,this.framebuffer),this.debug&&bf(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(t0(this.gl,this.outputTexture,this.framebuffer),this.debug&&bf(this.gl)):oM(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const s=t();return this.unbindTextureToFrameBuffer(),s}setOutputMatrixTextureDriver(e,t,s){this.throwIfDisposed();const i=this.gl;t0(i,e,this.framebuffer),this.debug&&bf(i),this.outputTexture=e,Re(i,()=>i.viewport(0,0,t,s)),Re(i,()=>i.scissor(0,0,t,s))}setOutputMatrixWriteRegionDriver(e,t,s,i){this.throwIfDisposed(),Re(this.gl,()=>this.gl.scissor(e,t,s,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function Fq(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:Oq,bincountImpl:TR,bincountReduceImpl:Gq,castImpl:zq,ceilImpl:Vq,concatImpl:Wq,equalImpl:Uq,expImpl:Bq,expm1Impl:$q,floorImpl:Xq,gatherNdImpl:Hq,gatherV2Impl:Kq,greaterImpl:Zq,greaterEqualImpl:Yq,lessImpl:jq,lessEqualImpl:Qq,linSpaceImpl:Jq,logImpl:qq,maxImpl:eee,maximumImpl:tee,minimumImpl:nee,multiplyImpl:see,negImpl:iee,notEqualImpl:ree,prodImpl:aee,raggedGatherImpl:oee,raggedRangeImpl:lee,raggedTensorToTensorImpl:cee,rangeImpl:uee,rsqrtImpl:hee,scatterImpl:dee,sigmoidImpl:pee,simpleAbsImpl:_R,sliceImpl:fee,sparseFillEmptyRowsImpl:mee,sparseReshapeImpl:gee,sparseSegmentReductionImpl:IR,sqrtImpl:yee,stridedSliceImpl:bee,stringNGramsImpl:xee,stringSplitImpl:vee,stringToHashBucketFastImpl:wee,subImpl:See,tileImpl:Tee,topKImpl:_ee,transposeImpl:HS,uniqueImpl:Iee}=RY;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MR(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function hs(n,e){return e===1?[n]:MR(n,e)}function Mee(n,e){if(n===1)return"rc";let t="";for(let s=0;s<n;s++)t+=e[s],s<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cee{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=bs(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=hs("rc",this.rank),s=Kt(this.rank),i=this.getOutOfBoundsCondition(t),r=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${s} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${r}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){let r=`${s===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)r=`${e[e.length-1-a]},`+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let s=this.rank-2;s<this.rank;s++)t+=`${e[s]} >= ${this.enableShapeUniforms?`outShape[${s}]`:this.outputShape[s]}`,s<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),s=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${s};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CR{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length);let s="";for(let i=0;i<4;i++){let r="thisRC = rc;";i%2===1&&(r+="thisRC.z += 1;"),i>1&&(r+="thisRC.y += 1;"),s+=`
        ${r}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${Eee(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?$S():BS(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${s}

        setOutput(result);
      }
    `}}function Eee(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?E6(["r","c","d"],"inputShape"):cl(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kee{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,t,s){const i=dM(t,s),r=pM(e,i,s);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const a=hM(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,s);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const l=this.freeTextures[r].shift();return this.usedTextures[r].push(l),l}let o;return i===Hn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Hn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Hn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Hn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Hn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,s,i){if(this.freeTextures==null)return;const r=dM(s,i),a=pM(t,r,i);a in this.freeTextures||(this.freeTextures[a]=[]);const o=hM(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=ee().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[a],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function Nee(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F||e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function hM(n,e,t,s,i){const r=Ree(e,s);let a;if(i){const[l,c]=Gu(n[0],n[1]);a=l*c}else{const[l,c]=_p(n[0],n[1]);a=l*c}const o=Nee(t,r);return a*o}function Ree(n,e){switch(n){case Hn.PACKED_2X2_FLOAT32:return wR(e);case Hn.PACKED_2X2_FLOAT16:return SR(e);case Hn.UNPACKED_FLOAT32:return bR(e);case Hn.UNPACKED_FLOAT16:return xR(e);case Hn.PACKED_4X1_UNSIGNED_BYTE:return vR(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function Aee(n){return ee().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Hn.PACKED_2X2_FLOAT32:Hn.UNPACKED_FLOAT32:n?Hn.PACKED_2X2_FLOAT16:Hn.UNPACKED_FLOAT16}function dM(n,e){if(n===ti.UPLOAD)return Hn.PACKED_2X2_FLOAT32;if(n===ti.RENDER||n==null)return Aee(e);if(n===ti.DOWNLOAD||n===ti.PIXELS)return Hn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function pM(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let or=class{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}};const Mi="if (isnan(x)) return x;",Lee="return x;",fM="return abs(x);",Pee="return (x >= 0.0) ? x : (exp(x) - 1.0);",Dee=Mi+`
  return (x < 0.0) ? 0.0 : x;
`,Fee=Mi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,fa="return x;",Oee="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gee="return x;",zee=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Vee=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Wee=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,Uee="return 1.0 / (1.0 + exp(-1.0 * x));";class wa{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length);const t=e.length,s=hs("rc",t),i=Kt(t),r=Mee(t,s),a=s.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${r});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ee=py,Xee=1e-7,Hee=1e-4,r0={};function Kee(n){return n in r0||(r0[n]={}),r0[n]}const Zee=ee().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),Yee=600;function jee(){return ee().global.screen==null?1024:ee().global.screen.height*ee().global.screen.width*window.devicePixelRatio*Yee/1024/1024}class qy extends Lm{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ee().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof i0)t=e;else{const s=Bi(ee().getNumber("WEBGL_VERSION"),e);t=new i0(s)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const s=Bi(ee().getNumber("WEBGL_VERSION"));t=new i0(s),this.binaryCache=Kee(ee().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new kee(this.gpgpu),this.numMBBeforeWarning=jee(),this.texData=new a1(this,Ut())}nextDataId(){return qy.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,s,i,r,a){const o=this.makeTensorInfo(t,s),l=this.texData.get(o.dataId);l.isPacked=!1,l.texture={texture:e,texShape:[i,r]},l.texShape=[i,r];const c=xf(t),u=new uM(c,!1,a),h=this.runWebGLProgram(u,[o],s,[[i,r]]);return h.shape=t,l.texture=null,this.disposeIntermediateTensorInfo(o),h.dataId}write(e,t,s){if((ee().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ee().getBool("DEBUG"))&&this.checkNumericalProblems(e),s==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:s,values:e,usage:ti.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,s,i,r){if(ee().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:s,dtype:i,values:t,usage:ti.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:s,dtype:i,complexTensorInfos:r,slice:a,shape:o,isPacked:l}=t;if(a!=null){let d;l?d=new wa(o,fa):d=new or(o,fa);const p=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:i}],i),f=this.readSync(p.dataId);return this.disposeIntermediateTensorInfo(p),f}if(s!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return s;const c=this.activeTimers!=null;let u;c&&(u=Xn());let h;if(i==="complex64"){const d=this.readSync(r.real.dataId),p=this.readSync(r.imag.dataId);h=Zr(d,p)}else h=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Xn()-u),this.convertAndCacheOnCPU(e,h)}async read(e){if(this.pendingRead.has(e)){const f=this.pendingRead.get(e);return new Promise(y=>f.push(y))}const t=this.texData.get(e),{values:s,shape:i,slice:r,dtype:a,complexTensorInfos:o,isPacked:l}=t;if(r!=null){let f;l?f=new wa(i,fa):f=new or(i,fa);const y=this.runWebGLProgram(f,[{dataId:e,shape:i,dtype:a}],a),m=this.read(y.dataId);return this.disposeIntermediateTensorInfo(y),m}if(s!=null)return this.convertAndCacheOnCPU(e);if(ee().getBool("DEBUG")&&!ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ee().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(a!=="complex64"&&ee().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const f=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(f.texture.texture,...gf(i))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let h;if(a==="complex64"){const f=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),y=f[0],m=f[1];h=Zr(y,m)}else if(c==null)h=this.getValuesFromTexture(e);else{const f=re(i);h=this.gpgpu.downloadFloat32MatrixFromBuffer(c,f)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const f=this.gpgpu.gl;Re(f,()=>f.deleteBuffer(c))}const d=this.convertAndCacheOnCPU(e,h),p=this.pendingRead.get(e);return this.pendingRead.delete(e),p.forEach(f=>f(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ut().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const s=this.texData.get(e),{values:i,shape:r,slice:a,dtype:o,isPacked:l,texture:c}=s;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let p;l?p=new wa(r,fa):p=new or(r,fa);const f=this.runWebGLProgram(p,[{dataId:e,shape:r,dtype:o}],o),y=this.readToGPU(f,t);return this.disposeIntermediateTensorInfo(f),y}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),h=Ut().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:h},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const s=t.map(i=>Br(i));return ut(e.shape,e.dtype,s)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return ut(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const s=e[t];if(!t6(s))throw ee().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${s} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${s} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:s,isPacked:i}=this.texData.get(e),r=re(t);if(ee().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),p=this.texData.get(d.dataId),f=this.gpgpu.downloadMatrixFromPackedTexture(p.texture.texture,...gf(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(d),f}const a=ee().getBool("WEBGL_PACK")&&i===!0,o=a?xf(t):t,l=a?new yq(o):new gq(o),c=this.runWebGLProgram(l,[{shape:o,dtype:s,dataId:e}],"float32"),u=this.texData.get(c.dataId),h=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),h}timerAvailable(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,s=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=s,i=!0):this.activeTimers.push(s),this.activeTimers=s,e();const r=pr(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),a=pr(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(r);o.kernelMs=Q2(l),o.getExtraProfileInfo=()=>l.map((c,u)=>({name:a[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Xn(),endMs:null}}endTimer(e){return ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Xn(),e)}async getQueryTime(e){if(ee().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:s}=this.texData.get(e);return s!=null&&(this.disposeData(s.real.dataId,t),this.disposeData(s.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:s,texShape:i,usage:r,isPacked:a,slice:o}=this.texData.get(e),l=o&&o.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,s),this.textureManager.releaseTexture(t,i,r,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=Zee){return ee().getBool("WEBGL_CPU_FORWARD")&&e.every(s=>this.texData.get(s.dataId).texture==null&&re(s.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){qs("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return $ee(e.shape,t)}packedUnaryOp(e,t,s){const i=new wa(e.shape,t),r=this.compileAndRun(i,[e],s);return Ut().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=_R(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ee().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,fM,e.dtype);const t=new or(e.shape,fM),s=this.compileAndRun(t,[e]);return Ut().makeTensorFromTensorInfo(s)}makeTensorInfo(e,t,s){let i;if(t==="string"&&s!=null&&s.length>0&&ir(s[0])){const r=s.map(a=>cr(a));i=this.write(r,e,t)}else i=this.write(s,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,s){return Ut().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,s),this)}unpackTensor(e){const t=new Bee(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new Cee(e.shape),s=!0;return this.runWebGLProgram(t,[e],e.dtype,null,s)}packedReshape(e,t){const s=[bc(e.shape),...xc(e.shape)],i={dtype:e.dtype,shape:s,dataId:e.dataId},r=[bc(t),...xc(t)],a=new CR(r,s),o=!0,l=[s],c=this.runWebGLProgram(a,[i],e.dtype,l,o);return{dataId:c.dataId,shape:t,dtype:c.dtype}}decode(e,t){const s=this.texData.get(e),{isPacked:i,shape:r,dtype:a}=s;if(t!=null){const d=re(r),p=t[0]*t[1]*4;E(d<=p,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=xf(r);let l;i?l=new mq(o):l=new fq(o);const c=!0,u=[t??gf(o)],h=this.runWebGLProgram(l,[{shape:o,dtype:a,dataId:e}],a,u,c,t);return{dtype:a,shape:r,dataId:h.dataId}}runWebGLProgram(e,t,s,i,r=!1,a){const o=this.makeTensorInfo(e.outputShape,s),l=this.texData.get(o.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===Gh.DENSE){const g=a??gf(e.outputShape);l.texShape=g.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),re(o.shape)===0)return l.values=Rn(o.dtype,0),o;const c=[],u=t.map(g=>{if(g.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(g.dataId);if(b.texture==null){if(!e.packedInputs&&re(g.shape)<=ee().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:g.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=g.shape)}if(this.uploadToGPU(g.dataId),!!b.isPacked!=!!e.packedInputs)g=b.isPacked?this.unpackTensor(g):this.packTensor(g),c.push(g),b=this.texData.get(g.dataId);else if(b.isPacked&&!ym(b.shape,g.shape)){const x=g,v=g.shape;g.shape=b.shape,g=this.packedReshape(g,v),c.push(g),b=this.texData.get(g.dataId),x.shape=v}return{shape:g.shape,texData:b,isUniform:!1}});this.uploadToGPU(o.dataId);const h={shape:o.shape,texData:l,isUniform:!1},d=pq(e,u,h),p=this.getAndSaveBinary(d,()=>hq(this.gpgpu,e,u,h)),f=this.activeTimers!=null;let y;f&&(y=this.startTimer()),ee().get("ENGINE_COMPILE_ONLY")||dq(this.gpgpu,p,u,h,i),c.forEach(g=>this.disposeIntermediateTensorInfo(g)),f&&(y=this.endTimer(y),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(y)}));const m=ee().get("WEBGL_FLUSH_THRESHOLD");if(m>0){const g=Xn();g-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=g)}if(!ee().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&r===!1){const g=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),g}return o}compileAndRun(e,t,s,i,r=!1){return s=s||t[0].dtype,this.runWebGLProgram(e,t,s,i,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ee().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=j(()=>{if(!ee().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ee().getBool("DEBUG");ee().set("DEBUG",!1);const t=this.abs(Ke(1e-8)).dataSync()[0];if(ee().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?Xee:Hee}uploadToGPU(e){const t=this.texData.get(e),{shape:s,dtype:i,values:r,texture:a,usage:o,isPacked:l}=t;if(a!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Xn());let h=t.texShape;if(h==null&&(h=x6(s,l),t.texShape=h),r!=null){const d=xf(s);let p,f=h[1],y=h[0];const m=r instanceof Uint8Array||r instanceof Uint8ClampedArray;(l||!m)&&([f,y]=Gu(h[0],h[1])),l?p=new xq(d,m):p=new uM(d,m);const g=m?[y,f]:h,b=this.makeTensorInfo(g,i),x=this.texData.get(b.dataId);m?x.usage=ti.PIXELS:x.usage=ti.UPLOAD,x.texShape=g,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),f,y,r);const v=[[y,f]],w=!0,_=this.runWebGLProgram(p,[b],i,v,w),I=this.texData.get(_.dataId);t.texShape=I.texShape,t.isPacked=I.isPacked,t.usage=I.usage,ee().get("ENGINE_COMPILE_ONLY")?this.disposeData(_.dataId):(t.texture=I.texture,t.values=null,this.texData.delete(_.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=Xn()-u)}else{const d=this.acquireTexture(h,o,i,l);t.texture=d}}convertAndCacheOnCPU(e,t){const s=this.texData.get(e),{dtype:i}=s;return t!=null&&(s.values=Qee(t,i)),s.values}acquireTexture(e,t,s,i){if(this.numBytesInGPU+=this.computeBytes(e,s),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const r=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${r} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*Th(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const s=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(r){throw r}});e.push(s)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await up(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(dR(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:t,customUniformLocations:s,infLoc:i,nanLoc:r,inShapesLocations:a,inTexShapesLocations:o,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:u}=yR(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=t,e.customUniformLocations=s,e.infLoc=i,e.nanLoc=r,e.inShapesLocations=a,e.inTexShapesLocations=o,e.outShapeLocation=l,e.outShapeStridesLocation=c,e.outTexShapeLocation=u}}createTensorFromGPUData(e,t,s){e.channels=e.channels||"RGBA";const{texture:i,height:r,width:a,channels:o}=e,l=Ut().backend;if(!l.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=l.writeTexture(i,t,s,r,a,o);return Ut().makeTensorFromDataId(c,t,s,l)}}qy.nextDataId=0;function Qee(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let s=0;s<t.length;++s)t[s]=Math.round(n[s]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */g1()&&_1("webgl",()=>new qy,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KS=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class vc{constructor(e,t,s){this.variableNames=["A","B"],this.outputShape=st(t,s),this.enableShapeUniforms=bs(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cp=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ep{constructor(e,t,s,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=st(t,s);const r=this.outputShape.length;this.enableShapeUniforms=bs(r);let a="";if(i)if(r===0||re(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${Kt(r)} coords = getOutputCoords();
        `,r===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const o=hs("coords",r);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${o[r-2]} + 1) >= outShape[${r} - 2];
            bool nextColOutOfBounds =
              (${o[r-1]} + 1) >= outShape[${r} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${o[r-2]} + 1) >= ${this.outputShape[r-2]};
            bool nextColOutOfBounds =
              (${o[r-1]} + 1) >= ${this.outputShape[r-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hs(n){const{inputs:e,backend:t}=n,{x:s}=e;return t.incRef(s.dataId),{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}const Jee={kernelName:Xc,backendName:"webgl",kernelFunc:Hs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ya(n){const{inputs:e,backend:t}=n,{real:s,imag:i}=e,r=t.makeTensorInfo(s.shape,"complex64"),a=t.texData.get(r.dataId),o=Hs({inputs:{x:s},backend:t}),l=Hs({inputs:{x:i},backend:t});return a.complexTensorInfos={real:o,imag:l},r}const qee={kernelName:Um,backendName:"webgl",kernelFunc:Ya};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ER="return (a < 0.) ? b * a : a;",kR=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function ete(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{alpha:r}=s,a=t.makeTensorInfo([],"float32",Jr(r,"float32")),o=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ep(kR,i.shape,a.shape):new vc(ER,i.shape,a.shape),l=t.runWebGLProgram(o,[i,a],"float32");return t.disposeIntermediateTensorInfo(a),l}const tte={kernelName:hd,backendName:"webgl",kernelFunc:ete};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NR="return (a < 0.) ? b * a : a;",RR=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function nte(n){const{inputs:e,backend:t}=n,{x:s,alpha:i}=e,r=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ep(RR,s.shape,i.shape):new vc(NR,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],"float32")}const ste={kernelName:Nd,backendName:"webgl",kernelFunc:nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bu="if (isnan(x)) return x;";function kt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:s}){return({inputs:i,backend:r})=>{const{x:a}=i,o=r,l=s||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const h=o.texData.get(a.dataId),d=t(h.values,l);return o.makeTensorInfo(a.shape,l,d)}const c=ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new wa(a.shape,e):u=new or(a.shape,n),o.runWebGLProgram(u,[a],l)}}function qn({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:s=!1,cpuKernelImpl:i,dtype:r}){return({inputs:a,backend:o})=>{const{a:l,b:c}=a,u=o;if(s&&l.dtype==="complex64"){const f=u.texData.get(l.dataId),y=u.texData.get(c.dataId),[m,g]=[[f.complexTensorInfos.real,y.complexTensorInfos.real],[f.complexTensorInfos.imag,y.complexTensorInfos.imag]].map(x=>{const[v,w]=x,_={dataId:v.dataId,dtype:v.dtype,shape:l.shape},I={dataId:w.dataId,dtype:w.dtype,shape:c.shape},C=new vc(n,l.shape,c.shape);return u.runWebGLProgram(C,[_,I],Es(v.dtype,w.dtype))}),b=Ya({inputs:{real:m,imag:g},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(g),b}const h=r||Es(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const f=u.texData.get(l.dataId).values,y=u.texData.get(c.dataId).values,m=l.dtype==="string"?Wo(f):f,g=l.dtype==="string"?Wo(y):y,[b,x]=i(l.shape,c.shape,m,g,h),v=u.makeTensorInfo(x,h),w=u.texData.get(v.dataId);return w.values=b,v}const d=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let p;return d?p=new Ep(e,l.shape,c.shape,t):p=new vc(n,l.shape,c.shape),u.runWebGLProgram(p,[l,c],h)}}function zh(n,e=!1){if(n==="linear")return e?Gee:Lee;if(n==="relu")return e?Vee:Dee;if(n==="elu")return e?zee:Pee;if(n==="relu6")return e?Wee:Fee;if(n==="prelu")return e?RR:NR;if(n==="leakyrelu")return e?kR:ER;if(n==="sigmoid")return e?Uee:Oee;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AR{constructor(e,t,s,i=!1,r=!1,a=!1,o=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s,this.enableShapeUniforms=bs(this.outputShape.length);const u=i?e[1]:e[2],h=Math.ceil(u/2),d=i?"i * 2, rc.y":"rc.y, i * 2",p=r?"rc.z, i * 2":"i * 2, rc.z",f=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],y=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(l?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:c?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:m=`vec4 activation(vec4 x) {
          ${o}
        }`,g="result = activation(result);");const b=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let x="rc.x",v="rc.x";e[0]<t[0]?x=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(v=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${h}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${x};
        int batchB = ${v};
        for (int i = 0; i < ${h}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${p});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${f[0]} * ${y[0]});
          result += (${f[1]} * ${y[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${g}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mM={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};let gM=class{constructor(e,t,s){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=st(t,s),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM="return a * b;";function ZS(n){const{inputs:e,backend:t}=n,{a:s,b:i}=e,r=Es(s.dtype,i.dtype);if(s.dtype==="complex64"){const o=t.texData.get(s.dataId),l=t.texData.get(i.dataId),c=new gM(mM.REAL,s.shape,i.shape),u=new gM(mM.IMAG,s.shape,i.shape),h=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:s.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:s.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=Ya({inputs:{real:d,imag:p},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}if(t.shouldExecuteOnCPU([s,i])){const o=t.texData.get(s.dataId),l=t.texData.get(i.dataId),[c,u]=see(s.shape,i.shape,o.values,l.values,r),h=t.makeTensorInfo(u,r),d=t.texData.get(h.dataId);return d.values=c,h}let a;return ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ep(yM,s.shape,i.shape):a=new vc(yM,s.shape,i.shape),t.runWebGLProgram(a,[s,i],r)}const ite={kernelName:eu,backendName:"webgl",kernelFunc:ZS};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rte(n,e,t){const s=[bc(n.shape),...xc(n.shape)],i={dtype:n.dtype,shape:s,dataId:n.dataId},r=[bc(e),...xc(e)],a=new CR(r,s),o=!0,l=[s],c=t.runWebGLProgram(a,[i],n.dtype,l,o);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{shape:r}=s,a=t,o=re(i.shape),l=l1(r,o),c=re(l);E(o===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const u=a.texData.get(i.dataId);return u.isPacked&&!ym(i.shape,l)&&!(u.texture!==null&&ym(u.shape,l))?rte(i,l,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const ate={kernelName:Ad,backendName:"webgl",kernelFunc:Ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let bM=class{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];const o=Math.floor(s/4)*4,l=s%4;let c="sumValue += dot(values, ones);";if(t!=null){const h=1/t;c=`sumValue += dot(values * ${Ao(h)?h.toPrecision(2):h}, ones);`}let u="";r%s>0&&(u=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${o};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ote{constructor(e,t){this.variableNames=["x"];const{windowSize:s,batchSize:i,inSize:r,outSize:a}=e;this.outputShape=[i,a];let o="0.0",l="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",l="min"):t==="max"&&(o="-1.0 / 1e-20",l="max");let c=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?c="sumValue":t==="prod"?c="prodValue":t==="all"?c="allValue":t==="any"&&(c="anyValue");const u=Math.floor(s/4)*4,h=s%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,p="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,p="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,p="bvec4");let f="";r%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${f}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${s};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===2}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${h===3}) {
          ${p} values = ${p}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lte(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],s=Iy(t);e.push({inSize:t,windowSize:s,outSize:Math.ceil(t/s)})}return e}function hl(n,e,t,s){const i=lte(n.shape);let r=n;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:l,outSize:c}=i[a];let u,h;t==="mean"?u=a===0?new bM({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},o):new bM({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c}):u=new ote({windowSize:l,inSize:o,batchSize:n.shape[0],outSize:c},t),h=r,r=s.runWebGLProgram(u,[r],e),h.dataId!==n.dataId&&s.disposeIntermediateTensorInfo(h)}return r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cte{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[t[a]];this.outputShape=s,this.rank=s.length;const i=Kt(this.rank),r=ute(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${r}));
    }
    `}}function ute(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],s=new Array(e);for(let i=0;i<n.length;i++)s[n[i]]=t[i];return s.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hte{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const s=new Array(e.length);for(let u=0;u<s.length;u++)s[u]=e[t[u]];if(this.outputShape=s,this.rank=s.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=Kt(this.rank),r=MR("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=r[u];const o=`vec2(${a.slice(-2).join()})`,l=`++${r[this.rank-1]} < ${s[this.rank-1]}`,c=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${r[this.rank-1]};
      if(++${r[this.rank-2]} < ${s[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eb(n,e,t){const s=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new hte(n.shape,e):new cte(n.shape,e);return t.runWebGLProgram(s,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dte(n,e,t,s){const i=e,r=n.shape.length,a=mt(i,n.shape);let o=a;const l=un(o,r),c=l!=null;let u=n;c&&(u=eb(n,l,s),o=gn(o.length,r)),Jn("sum",o,r);const[h,d]=Vn(u.shape,o);let p=h;t&&(p=mn(h,a));const f=re(d),y=re(n.shape)/f,m=Ne({inputs:{x:u},attrs:{shape:[y,f]},backend:s}),g=zg(n.dtype),b=hl(m,g,"sum",s),x=Ne({inputs:{x:b},attrs:{shape:p},backend:s});return s.disposeIntermediateTensorInfo(m),s.disposeIntermediateTensorInfo(b),c&&s.disposeIntermediateTensorInfo(u),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tb(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s;return dte(i,r,a,t)}const pte={kernelName:Gd,backendName:"webgl",kernelFunc:tb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fs(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{perm:r}=s,a=t,o=i.shape.length,l=new Array(o);for(let u=0;u<l.length;u++)l[u]=i.shape[r[u]];let c;if(a.shouldExecuteOnCPU([i])){const u=a.texData.get(i.dataId).values,h=HS(u,i.shape,i.dtype,r,l);c=a.makeTensorInfo(l,i.dtype);const d=a.texData.get(c.dataId);d.values=h}else c=eb(i,r,a);return c}const fte={kernelName:Io,backendName:"webgl",kernelFunc:fs};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LR=1e3;function bm({a:n,b:e,transposeA:t,transposeB:s,backend:i,bias:r=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:l=null}){const c=n.shape.length,u=e.shape.length,h=t?n.shape[c-2]:n.shape[c-1],d=s?e.shape[u-1]:e.shape[u-2],p=t?n.shape[c-1]:n.shape[c-2],f=s?e.shape[u-2]:e.shape[u-1],y=n.shape.slice(0,-2),m=e.shape.slice(0,-2),g=re(y),b=re(m),x=st(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([p,f]);E(h===d,()=>`Error in matMul: inner shapes (${h}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${s} must match.`);const v=t?[g,h,p]:[g,p,h],w=s?[b,f,d]:[b,d,f],_=Ne({inputs:{x:n},backend:i,attrs:{shape:v}}),I=Ne({inputs:{x:e},backend:i,attrs:{shape:w}}),C=[_,I],S=Math.max(g,b),M=t?_.shape[1]:_.shape[2],A=r!=null,D=a!=null,F=l==="leakyrelu",k=l!=null?zh(l,!0):null,P=A||D||F||k!=null;let O;if((p===1||f===1)&&M>LR&&P===!1){let $=_,H=I;t&&($=fs({inputs:{x:_},backend:i,attrs:{perm:[0,2,1]}}),C.push($)),s&&(H=fs({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),C.push(H));const Y=f!==1,G=f===1;let B=$;Y&&(B=Ne({inputs:{x:$},backend:i,attrs:{shape:[S,M,1]}}),C.push(B));const te=f===1?2:1;let se=H;G&&(se=Ne({inputs:{x:H},backend:i,attrs:{shape:[S,1,M]}}),C.push(se));const ae=ZS({inputs:{a:B,b:se},backend:i});O=tb({inputs:{x:ae},backend:i,attrs:{axis:te,keepDims:!0}}),C.push(ae)}else{const $=Es(n.dtype,e.dtype),H=new AR(v,w,[S,p,f],t,s,A,k,D,F),Y=[_,I];if(r!=null&&Y.push(r),D&&Y.push(a),F){const G=i.makeTensorInfo([],"float32",Jr(o,"float32"));Y.push(G),C.push(G)}O=i.runWebGLProgram(H,Y,$)}const V=Ne({inputs:{x:O},backend:i,attrs:{shape:x}});C.push(O);for(const $ of C)i.disposeIntermediateTensorInfo($);return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r,bias:a,preluActivationWeights:o}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:h}=s;return bm({a:i,b:r,transposeA:l,transposeB:c,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:h,activation:u})}const gte={kernelName:_h,backendName:"webgl",kernelFunc:mte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xM="return abs(x);";function yte(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])&&s.dtype!=="complex64"){const r=t.texData.get(s.dataId),a=_R(r.values);return t.makeTensorInfo(s.shape,s.dtype,a)}let i;return ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new wa(s.shape,xM):i=new or(s.shape,xM),t.runWebGLProgram(i,[s],s.dtype)}const bte={kernelName:$h,backendName:"webgl",kernelFunc:yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xte=Mi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,vte=kt({opSnippet:xte}),wte={kernelName:Ic,backendName:"webgl",kernelFunc:vte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ste=Mi+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,Tte=kt({opSnippet:Ste}),_te={kernelName:Mc,backendName:"webgl",kernelFunc:Tte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vM="return a + b;",Ite=qn({opSnippet:vM,packedOpSnippet:vM,supportsComplex:!0,cpuKernelImpl:Oq}),Mte={kernelName:Jo,backendName:"webgl",kernelFunc:Ite};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cte{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((r,a)=>`T${a}`);const s=[];this.variableNames.forEach(r=>{s.push(`float v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ete{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((r,a)=>`T${a}`);const s=[];this.variableNames.forEach(r=>{s.push(`vec4 v${r} = get${r}AtOutCoords();`)});const i=this.variableNames.map(r=>`v${r}`).join(" + ");this.userCode=`
      void main() {
        ${s.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pf(n){const{inputs:e,backend:t}=n,s=e;if(s.length===1)return Hs({inputs:{x:s[0]},backend:t});if(s.length>ee().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const o=Math.floor(s.length/2),l=Pf({inputs:s.slice(0,o),backend:t}),c=Pf({inputs:s.slice(o),backend:t});return Pf({inputs:[l,c],backend:t})}const i=s.map(o=>o.dtype).reduce((o,l)=>Es(o,l)),r=s.map(o=>o.shape),a=ee().getBool("WEBGL_PACK")?new Ete(s[0].shape,r):new Cte(s[0].shape,r);return t.runWebGLProgram(a,s,i)}const kte={kernelName:Xh,backendName:"webgl",kernelFunc:Pf};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nte(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s,o=i.shape.length,l=mt(r,i.shape);let c=l;const u=un(c,o);let h=i;u!=null&&(h=fs({inputs:{x:i},backend:t,attrs:{perm:u}}),c=gn(c.length,o)),Jn("all",c,o);const[d,p]=Vn(h.shape,c),f=re(p),y=Ne({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=hl(y,y.dtype,"all",t);let g;if(a){const b=mn(d,l);g=Ne({inputs:{x:m},backend:t,attrs:{shape:b}})}else g=Ne({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),g}const Rte={kernelName:Fm,backendName:"webgl",kernelFunc:Nte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ate(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s,o=i.shape.length,l=mt(r,i.shape);let c=l;const u=un(c,o);let h=i;u!=null&&(h=fs({inputs:{x:i},backend:t,attrs:{perm:u}}),c=gn(c.length,o)),Jn("any",c,o);const[d,p]=Vn(h.shape,c),f=re(p),y=Ne({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=hl(y,y.dtype,"any",t);let g;if(a){const b=mn(d,l);g=Ne({inputs:{x:m},backend:t,attrs:{shape:b}})}else g=Ne({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),g}const Lte={kernelName:Om,backendName:"webgl",kernelFunc:Ate};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pte{constructor(e,t,s){this.variableNames=["A"];const{windowSize:i,batchSize:r,outSize:a}=e;s||this.variableNames.push("bestIndicesA"),this.outputShape=[r,a];const o=t==="max"?">":"<",l=s?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Dte{constructor(e,t,s,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,E(e.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const r=e[e.length-1],a=Math.ceil(r/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,l=o.length,c=Kt(l),u=hs("coords",l);let h,d;if(a===1){d=l+1;const C=Kt(d);h=`
        ${C} sourceLocR = ${C}(${u.join()}, 0);
        ++${u[l-1]};
        ${C} sourceLocG = ${C}(${u.join()}, 0);
        ++${u[l-2]};
        ${C} sourceLocA = ${C}(${u.join()}, 0);
        --${u[l-1]};
        ${C} sourceLocB = ${C}(${u.join()}, 0);
        --${u[l-2]};`}else d=l,h=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const p=["x","y","z","w","u","v"].slice(0,d),f="."+p[d-1],y=p.map(C=>"int "+C),m=hs("sourceLocR",d-1).concat("inIdx.r"),g=hs("sourceLocG",d-1).concat("inIdx.g"),b=hs("sourceLocB",d-1).concat("inIdx.b"),x=hs("sourceLocA",d-1).concat("inIdx.a"),v=s==="max"?"greaterThan":"lessThan",w=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${g.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${x.join()})));`,_=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${g.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${x.join()}) : 0.)`,I=i?"":`
      float getBestIndicesAChannel(${y.join()}) {
        return getChannel(getBestIndicesA(${p.join()}),
                                          vec2(${p.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${y.join()}) {
        return getChannel(getA(${p.join()}),
                               vec2(${p.slice(-2).join()}));
      }
      ${I}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${o[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${o[l-2]-1};
        ${h}
        ivec4 srcIdx = ivec4(sourceLocR${f}, sourceLocG${f},
          sourceLocB${f}, sourceLocA${f}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${_};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${_};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${v}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PR(n,e,t,s=null){let i=e.shape[0],r=e.shape[1];s!=null&&(i=s.shape[0],r=s.shape[1]);const a=Iy(r),o={windowSize:a,inSize:r,batchSize:i,outSize:Math.ceil(r/a)},l=new Pte(o,t,s==null),c=[e];s!=null&&c.push(s);const u=n.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const h=PR(n,e,t,u);return n.disposeIntermediateTensorInfo(u),h}function DR(n,e,t,s=null){const i=s!=null?s.shape:e.shape,r=i[i.length-1],a=Iy(r),o=new Dte(i,a,t,s==null),l=s==null?[e]:[e,s],c=n.runWebGLProgram(o,l,"int32");if(c.shape.length===e.shape.length){const u=DR(n,e,t,c);return n.disposeIntermediateTensorInfo(c),u}return c}function FR(n,e,t,s){const i=[t];if(Jn("arg"+s.charAt(0).toUpperCase()+s.slice(1),i,e.shape.length),!ee().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const r=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let l=e;o&&(l=n.unpackTensor(e),r.push(l));const[c,u]=Vn(l.shape,i),h=re(u),d=Ne({inputs:{x:l},backend:n,attrs:{shape:[-1,h]}});r.push(d);const p=PR(n,d,s);r.push(p);const f=Ne({inputs:{x:p},backend:n,attrs:{shape:c}});return r.forEach(y=>n.disposeIntermediateTensorInfo(y)),f}return DR(n,e,s)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let a=mt(r,i.shape);const o=un(a,i.shape.length);let l=i;const c=[];o!=null&&(l=fs({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),a=gn(a.length,l.shape.length)),Jn("argMax",[a[0]],l.shape.length);const u=FR(t,l,a[0],"max");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const Ote={kernelName:Hh,backendName:"webgl",kernelFunc:Fte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gte(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r}=s;let a=mt(r,i.shape);const o=un(a,i.shape.length);let l=i;const c=[];o!=null&&(l=fs({inputs:{x:i},backend:t,attrs:{perm:o}}),c.push(l),a=gn(a.length,l.shape.length)),Jn("argMin",[a[0]],l.shape.length);const u=FR(t,l,a[0],"min");return c.forEach(h=>t.disposeIntermediateTensorInfo(h)),u}const zte={kernelName:Kh,backendName:"webgl",kernelFunc:Gte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vte=Mi+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,Wte=kt({opSnippet:Vte}),Ute={kernelName:Cc,backendName:"webgl",kernelFunc:Wte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Bte=Mi+"return log(x + sqrt(x * x + 1.0));",$te=kt({opSnippet:Bte}),Xte={kernelName:Ec,backendName:"webgl",kernelFunc:$te};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hte=Mi+`
  return atan(x);
`,Kte=kt({opSnippet:Hte}),Zte={kernelName:kc,backendName:"webgl",kernelFunc:Kte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yte=KS+`
  return atan(a, b);
`,jte=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Cp+`
  return result;
`,Qte=qn({opSnippet:Yte,packedOpSnippet:jte}),Jte={kernelName:Rc,backendName:"webgl",kernelFunc:Qte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qte=Mi+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,ene=kt({opSnippet:qte}),tne={kernelName:Nc,backendName:"webgl",kernelFunc:ene};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vh{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=e.padInfo.top,f=e.padInfo.left;this.outputShape=e.outShape;const y=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,g=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(y||(b="-1.0 / 1e-20"),s){const C=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${l});
        const ivec2 pads = ivec2(${p}, ${f});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${h};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${C} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?r?m:g:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const x="max";let v=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(v="avgValue / max(count, 1.0)");const w=Math.floor(a/4)*4,_=a%4,I=`
      if (${y}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${x}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${l});
      const ivec2 pads = ivec2(${p}, ${f});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${h};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${I}
          }

          int xC = xCCorner + ${w};
          if (${_===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${_===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${I}
          } else if (${_===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${I}
          }
        }
        setOutput(${v});
      }
    `}}let YS=class{constructor(e,t,s,i=!1,r=!1){if(this.variableNames=["x"],t==="avg"&&s)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,h=e.dilationHeight,d=e.dilationWidth,p=e.effectiveFilterDepth,f=e.effectiveFilterHeight,y=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const x=t==="avg";let v="0.0";if(x||(v="-1.0 / 1e-20"),s){const M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${l}, ${c});
        const ivec3 pads = ivec3(${m}, ${g}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${p};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${f};
                wR += ${h}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${y};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?r?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${f} * ${y} +
                      wR * ${y} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const I=Math.floor(a/4)*4,C=a%4,S=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${l}, ${c});
      const ivec3 pads = ivec3(${m}, ${g}, ${b});
      const float initializationValue = ${v};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${v});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${p};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f};
            wR += ${h}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${I}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${S}
            }

            int xC = xCCorner + ${I};
            if (${C===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${C===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${S}
            } else if (${C===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${S}
            }
          }
        }
        setOutput(${_});
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Ip(i,"avgPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;E(Qn(a,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=_i(i.shape,r,a,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&St(u.inShape,u.outShape))return Hs({inputs:{x:i},backend:t});const h=new Vh(u,"avg",!1);return t.runWebGLProgram(h,[i],"float32")}const sne={kernelName:Zh,backendName:"webgl",kernelFunc:nne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ine(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:a,pad:o,dimRoundingMode:l,dataFormat:c}=s,u=[1,1,1],h=qr(i.shape,r,a,u,o,l,c),d=new YS(h,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const rne={kernelName:Yh,backendName:"webgl",kernelFunc:ine};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ane{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,h=c-1-e.padInfo.left,d=1/(t*s);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${h});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class one{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.effectiveFilterDepth,d=e.effectiveFilterHeight,p=e.effectiveFilterWidth,f=h-1-e.padInfo.front,y=d-1-e.padInfo.top,m=p-1-e.padInfo.left,g=1/(t*s*i);this.userCode=`
      const ivec3 pads = ivec3(${f}, ${y}, ${m});
      const float avgMultiplier = float(${g});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${r}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${p};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lne(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,a=r,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=qr(a.shape,o,l,h,c,u),p=new one(d);return t.runWebGLProgram(p,[i],a.dtype)}const cne={kernelName:zm,backendName:"webgl",kernelFunc:lne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function une(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,a=r;Ip([i,r],"avgPoolGrad");const{filterSize:o,strides:l,pad:c}=s,u=_i(a.shape,o,l,1,c),h=new ane(u);return t.runWebGLProgram(h,[i],a.dtype)}const hne={kernelName:Gm,backendName:"webgl",kernelFunc:une};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dne(n){const{inputs:e,backend:t,attrs:s}=n,{a:i,b:r}=e,{transposeA:a,transposeB:o}=s;return bm({a:i,b:r,transposeA:a,transposeB:o,backend:t})}const pne={kernelName:jh,backendName:"webgl",kernelFunc:dne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fne{constructor(e,t,s,i,r,a){this.outputShape=[],this.variableNames=["x","mean","variance"],st(e,t),st(e,s);let o="0.0";i!=null&&(st(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="1.0";r!=null&&(st(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mne{constructor(e,t,s,i,r,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],st(e,t),st(e,s);let o="vec4(0.0)";i!=null&&(st(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let l="vec4(1.0)";r!=null&&(st(e,r),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gne=({inputs:n,backend:e,attrs:t})=>{const{x:s,mean:i,variance:r,offset:a,scale:o}=n;E(i.shape.length===r.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),E(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),E(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=t;l==null&&(l=.001);const c=[s,i,r];let u=null;a!=null&&(u=a.shape,c.push(a));let h=null;o!=null&&(h=o.shape,c.push(o));const d=ee().getBool("WEBGL_PACK_NORMALIZATION")?new mne(s.shape,i.shape,r.shape,u,h,l):new fne(s.shape,i.shape,r.shape,u,h,l);return e.runWebGLProgram(d,c,c[0].dtype)},yne={kernelName:ld,backendName:"webgl",kernelFunc:gne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bne{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=Kt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const s=xne(this.rank);let i;const r=e.map((a,o)=>`sourceLoc.${Tx[o]} = start[${o}] + coords.${Tx[o]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${r.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${s}));
      }
    `}}const Tx=["x","y","z","w","u","v"];function xne(n){if(n===1)return"sourceLoc";if(n<=6)return Tx.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vne{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=Kt(this.rank),s=hs("coords",this.rank),i=hs("sourceLoc",this.rank),r=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${r})`,o=`
      result.x = ${a};
      if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${a};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${s[this.rank-1]};
      if (++${s[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${a};
        if (++${s[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${a};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,h)=>`start[${h}]`).join()});`:e.map((u,h)=>`${i[h]} = ${s[h]} + start[${h}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${o}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wne(n,e,t,s){const i=s.texData.get(n.dataId),r=s.makeTensorInfo(t,n.dtype),a=s.texData.get(r.dataId);Object.assign(a,i),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=Vv(e,He(n.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||n.dataId};const l=s.dataRefCount.get(a.slice.origDataId)||1;return s.dataRefCount.set(a.slice.origDataId,l+1),r}function $u(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,size:a}=s,[o,l]=_y(i,r,a);if(Ov(i,o,l),re(l)===0)return t.makeTensorInfo(l,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const h=t.texData.get(i.dataId),d=fee(h.values,o,l,i.shape,i.dtype);return t.makeTensorInfo(l,i.dtype,d)}const{isPacked:c}=t.texData.get(i.dataId),u=zv(i.shape,o,l);if(c||!u){const h=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vne(l):new bne(l),d=[o];return t.runWebGLProgram(h,[i],i.dtype,d)}return t.uploadToGPU(i.dataId),wne(i,o,l,t)}const Sne={kernelName:Od,backendName:"webgl",kernelFunc:$u};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tne=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,crops:a}=s;E(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((b,x)=>b*x),l=hp(i.shape,r,o),c=dp(l.length,r.length),u=pp(i.shape,r,o),h=Xv(a,r.length),d=Hv(u,a,r.length),p=[],f=Ne({inputs:{x:i},backend:t,attrs:{shape:l}}),y=fs({inputs:{x:f},backend:t,attrs:{perm:c}}),m=Ne({inputs:{x:y},backend:t,attrs:{shape:u}}),g=$u({inputs:{x:m},backend:t,attrs:{begin:h,size:d}});return p.push(f),p.push(y),p.push(m),p.forEach(b=>t.disposeIntermediateTensorInfo(b)),g},_ne={kernelName:Qh,backendName:"webgl",kernelFunc:Tne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ine(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:a}=s,o=t.readSync(i.dataId),l=t.readSync(r.dataId),c=TR(o,l,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,c)}const Mne={kernelName:Vm,backendName:"webgl",kernelFunc:Ine};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cne(n){const{inputs:e,backend:t}=n,{s0:s,s1:i}=e,r=t.readSync(s.dataId),a=t.readSync(i.dataId),o=st(Array.from(r),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const Ene={kernelName:Wm,backendName:"webgl",kernelFunc:Cne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kne="return float(a != b);",OR=qn({opSnippet:kne,cpuKernelImpl:ree,dtype:"bool"}),Nne={kernelName:Id,backendName:"webgl",kernelFunc:OR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kp(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return Hs({inputs:{x:i.complexTensorInfos.real},backend:t})}const Rne={kernelName:vg,backendName:"webgl",kernelFunc:kp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ane="return float(int(x));";function Lne(n,e){const t=new or(n.shape,Ane),s=e.runWebGLProgram(t,[n],"int32");return{dataId:s.dataId,shape:s.shape,dtype:s.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dtype:r}=s;if(r==="complex64"){if(i.dtype==="complex64")return Hs({inputs:{x:i},backend:t});const a=vn(i.shape),o=_x({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),l=Ya({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),l}if(i.dtype==="complex64"){const a=kp({inputs:{input:i},backend:t}),o=_x({inputs:{x:a},backend:t,attrs:{dtype:r}});return t.disposeIntermediateTensorInfo(a),o}if(!c1(i.dtype,r)){const a=Hs({inputs:{x:i},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:r}}if(t.shouldExecuteOnCPU([i])){const a=t.texData.get(i.dataId).values,[o,l,c]=zq(a,i.shape,i.dtype,r);return t.makeTensorInfo(o,l,c)}if(r==="int32")return Lne(i,t);if(r==="bool"){const a=t.makeTensorInfo([],"bool",Rn("bool",1)),o=OR({inputs:{a:i,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),o}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${r}`)}const Pne={kernelName:Ac,backendName:"webgl",kernelFunc:_x};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wM="return ceil(x);",Dne=kt({opSnippet:wM,packedOpSnippet:wM,cpuKernelImpl:Vq}),Fne={kernelName:Lc,backendName:"webgl",kernelFunc:Dne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class One{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gne{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{clipValueMin:r,clipValueMax:a}=s;let o;ee().getBool("WEBGL_PACK_CLIP")?o=new Gne(i.shape):o=new One(i.shape);const l=[[r],[a]];return t.runWebGLProgram(o,[i],i.dtype,l)}const Vne={kernelName:Pc,backendName:"webgl",kernelFunc:zne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wne{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SM(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Une(n){const{inputs:e,backend:t}=n,{x:s}=e,i=t.texData.get(s.dataId),r=new Wne(s.shape),a=[SM(s,i.complexTensorInfos.real),SM(s,i.complexTensorInfos.imag)];return t.runWebGLProgram(r,a,a[0].dtype)}const Bne={kernelName:Jh,backendName:"webgl",kernelFunc:Une};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ne{constructor(e){this.outputShape=[],this.outputShape=hr(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const s=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];s.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const i=t.length,r=t[t.length-1];s.push(`else setOutput(getT${i}(yR, yC-${r}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${s.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Xne{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=hr(e,t);const s=this.outputShape,i=s.length,r=Kt(i),a=hs("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((y,m)=>`T${m}`);const l=new Array(e.length-1);l[0]=e[0][t];for(let y=1;y<l.length;y++)l[y]=l[y-1]+e[y][t];const c=o[t],u=o.slice(-2),h=o.join();let d=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${h}), vec2(${u.join()}));
        }`;for(let y=1;y<l.length;y++){const m=l[y-1];d+=`
        if (${c} < ${l[y]}  && ${c} >= ${l[y-1]}) {
          return getChannel(
            getT${y}(${wf(o,c,m)}),
            vec2(${wf(u,c,m)}));
        }`}const p=l.length,f=l[l.length-1];d+=`
        return getChannel(
          getT${p}(${wf(o,c,f)}),
          vec2(${wf(u,c,f)}));`,this.userCode=`
      float getValue(${o.map(y=>"int "+y)}) {
        ${d}
      }

      void main() {
        ${r} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[i-1]} = ${a[i-1]} + 1;
        if (${a[i-1]} < ${s[i-1]}) {
          result.g = getValue(${a});
        }

        ${a[i-2]} = ${a[i-2]} + 1;
        if (${a[i-2]} < ${s[i-2]}) {
          result.a = getValue(${a});
        }

        ${a[i-1]} = ${a[i-1]} - 1;
        if (${a[i-2]} < ${s[i-2]} &&
            ${a[i-1]} < ${s[i-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function wf(n,e,t){const s=n.indexOf(e);return n.map((i,r)=>r===s?`${i} - ${t}`:i).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nb(n){const{inputs:e,backend:t}=n,{input:s}=e,i=t.texData.get(s.dataId);return Hs({inputs:{x:i.complexTensorInfos.imag},backend:t})}const Hne={kernelName:ag,backendName:"webgl",kernelFunc:nb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mh(n,e,t){const s=n[0].dtype;if(s==="complex64"){const p=n.map(b=>kp({inputs:{input:b},backend:t})),f=n.map(b=>nb({inputs:{input:b},backend:t})),y=mh(p,e,t),m=mh(f,e,t),g=Ya({inputs:{real:y,imag:m},backend:t});return p.forEach(b=>t.disposeIntermediateTensorInfo(b)),f.forEach(b=>t.disposeIntermediateTensorInfo(b)),t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),g}let i=t.shouldExecuteOnCPU(n);if(s==="string"&&(i=!0),i){const p=n.map(v=>{const w=[-1,re(v.shape.slice(e))];return Ne({inputs:{x:v},backend:t,attrs:{shape:w}})}),f=p.map(v=>({vals:t.readSync(v.dataId),shape:v.shape})),y=hr(p.map(v=>v.shape),1),m=p[0].shape[0]===1,g=Wq(f,y,s,m),b=hr(n.map(v=>v.shape),e),x=t.makeTensorInfo(b,s,g);return p.forEach(v=>t.disposeIntermediateTensorInfo(v)),x}const r=n.filter(p=>re(p.shape)>0),a=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&r[0].shape.length>1;if(r.length===1){const p=a?new or(n[0].shape,fa):new wa(n[0].shape,fa);return t.runWebGLProgram(p,n,s)}const o=ee().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(r.length>o){const p=[];for(let y=0;y<r.length;y+=o){const m=r.slice(y,y+o);p.push(mh(m,e,t))}const f=mh(p,e,t);for(const y of p)t.disposeIntermediateTensorInfo(y);return f}if(a){const p=new Xne(r.map(f=>f.shape),e);return t.runWebGLProgram(p,r,s)}const{tensors2D:l,outShape:c}=Kne(r,e,t),u=new $ne(l.map(p=>p.shape)),h=t.runWebGLProgram(u,l,s);l.forEach(p=>t.disposeIntermediateTensorInfo(p));const d=Ne({inputs:{x:h},attrs:{shape:c},backend:t});return t.disposeIntermediateTensorInfo(h),d}function Kne(n,e,t){const s=hr(n.map(i=>i.shape),e);return{tensors2D:n.map(i=>Ne({inputs:{x:i},attrs:{shape:[-1,re(i.shape.slice(e))]},backend:t})),outShape:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GR(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s,r=mt(i,e[0].shape)[0],a=e.map(c=>c.shape);Uv(a,r);const o=hr(e.map(c=>c.shape),r);if(re(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const l=e.filter(c=>re(c.shape)>0);return l.length===1?Hs({inputs:{x:l[0]},backend:t}):mh(l,r,t)}const Zne={kernelName:qh,backendName:"webgl",kernelFunc:GR};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zR{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,h=e.dilationWidth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,y=e.inChannels%4,m=e.dataFormat==="channelsLast",g=m?1:2,b=m?2:3,x=m?3:1;let v="",w="";s&&(i?v=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?v=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:v=`
          float activation(float x) {
            ${s}
          }
        `,w="result = activation(result);");const _=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${v}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${x}];

        ivec2 xRCCorner =
            ivec2(coords[${g}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${p}; wC++) {
            int xC = xCCorner + wC * ${h};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${f}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${y===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${f}) *
                    getW(wR, wC, ${f}, d2);
              } else {
                dotProd +=
                    getX(batch, ${f}, xR, xC) *
                    getW(wR, wC, ${f}, d2);
              }

            } else if (${y===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${y===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${f}, d2),
                getW(wR, wC, ${f} + 1, d2),
                getW(wR, wC, ${f} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${f}),
                  getX(batch, xR, xC, ${f} + 1),
                  getX(batch, xR, xC, ${f} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${f}, xR, xC),
                  getX(batch, ${f} + 1, xR, xC),
                  getX(batch, ${f} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${_}
        ${w}
        setOutput(result);
      }
    `}}class Yne{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,s=e.padInfo.top,i=e.padInfo.left,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,h=e.filterDepth,d=e.filterHeight,p=e.filterWidth,f=Math.floor(e.inChannels/4)*4,y=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${r}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${s}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${h}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${p}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${f}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${y===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${f}) *
                  getW(wF, wR, wC, ${f}, d2);
              } else if (${y===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${y===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${f}),
                  getX(batch, xF, xR, xC, ${f} + 1),
                  getX(batch, xF, xR, xC, ${f} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${f}, d2),
                  getW(wF, wR, wC, ${f} + 1, d2),
                  getW(wF, wR, wC, ${f} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VR{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bs(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,h=u;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(h+1)/2;m++){const g=m*2;if(d+=`
           xC = xCCorner + ${g*l};
           `,o===1){if(g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }
               `,l===1&&g>0?d+=`
                 xC${g} = vec4(xTexelC${g-2}.zw, xTexelC${g}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${g} = vec4(previous.zw, xTexelC${g}.xy);
                   } else {
                     xC${g} = vec4(0.0, 0.0, xTexelC${g}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xC${g} = xTexelC${g};
                 `,g+1<u)){const b=a%2===0?Pm(l):l;l%2===0&&a%2===1||l%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                     xTexelC${g+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${g+1}.zw = vec2(0.0);
                     }
                     xTexelC${g+1}Ready = 1;
                   }
                   `,l>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${g+1} = vec4(previous.zw, xTexelC${g+1}.xy);
                     } else {
                      xC${g+1} = vec4(0.0, 0.0, xTexelC${g+1}.xy);
                     }
                     `:d+=`
                     xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.xy);
                     `):b===1?d+=`
                     xC${g+1} = xTexelC${g};
                     `:d+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                       xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${g+1}.zw = vec2(0.0);
                       }
                       xTexelC${g+1}Ready = 1;
                     }

                     xC${g+1} = xTexelC${g+1};
                     `}}else g<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.0);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
               `,g+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${g+1} = vec4(xTexelC${g+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${g}Ready == 0) {
                   xTexelC${g} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${g}.zw = vec2(0.0);
                   }
                   xTexelC${g}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${g+1}Ready == 0) {
                   xTexelC${g+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${g+1}.zw = vec2(0.);
                   }
                   xTexelC${g+1}Ready = 1;
                 }

                 xC${g} = vec4(
                   xTexelC${g}.xy, xTexelC${g+1}.xy);
               `,g+1<u&&(d+=`
                   xC${g+1} = vec4(xTexelC${g}.zw, xTexelC${g+1}.zw);
                 `)));g<u&&(d+=`
             wTexel = getW(r, ${g}, d1, d2);
             dotProd += xC${g}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${g}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,g+1<u&&(d+=`
               wTexel = getW(r, ${g+1}, d1, d2);
               dotProd += xC${g+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${g+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let p="",f="";s&&(i?p=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${s}
         }`:r?p=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${s}
         }`:p=`vec4 activation(vec4 x) {
           ${s}
         }`,f="result = activation(result);");const y=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${p}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${y}
         ${f}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jne{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=bs(this.outputShape.length);const{dataFormat:s}=t,i=ys(),r=s==="channelsLast",a=r?1:2,o=r?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let h=0;h<=1;h++)c+=`
          blockIndex = rc.z + ${h};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${r}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+h}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xm(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function WR({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const l=n.shape,c=s.texData.get(n.dataId),u=t.inChannels,h=l[0]*l[1]*l[2],d=t.outChannels,p=t.dataFormat==="channelsLast",f=!1,y=!1;let m;const g=[];if(r!=null){const b=xm(r.shape,p);b!=null&&(r=Ne({inputs:{x:r},backend:s,attrs:{shape:b}}),g.push(r))}if(i!=null){const b=xm(i.shape,p);b!=null&&(i=Ne({inputs:{x:i},backend:s,attrs:{shape:b}}),g.push(i))}if(!((h===1||d===1)&&u>LR)&&c.isPacked&&p&&c.texture!=null&&l[2]%2!==0&&St(c.shape.slice(-3),l.slice(-3))){const b=l[0]*l[1]*(l[2]+1),x={dataId:n.dataId,shape:[1,b,t.inChannels],dtype:n.dtype},v=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,E(ym(c.shape,x.shape),()=>`packed reshape ${c.shape} to ${x.shape} isn't free`);const w=Ne({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}});g.push(w);const _=bm({a:x,b:w,backend:s,transposeA:f,transposeB:y,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a}),I=s.texData.get(_.dataId);E(I.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=v,I.shape=t.outShape,m=Hs({inputs:{x:_},backend:s}),m.shape=t.outShape,g.push(_)}else{const b=t.outHeight*t.outWidth,x=Ne({inputs:{x:n},backend:s,attrs:{shape:p?[t.batchSize,b,t.inChannels]:[t.batchSize,t.inChannels,b]}}),v=Ne({inputs:{x:e},backend:s,attrs:{shape:[1,t.inChannels,t.outChannels]}}),w=bm({a:p?x:v,b:p?v:x,transposeA:!p,transposeB:y,backend:s,bias:i,activation:o,preluActivationWeights:r,leakyreluAlpha:a});m=Ne({inputs:{x:w},backend:s,attrs:{shape:t.outShape}}),g.push(x),g.push(v),g.push(w)}for(const b of g)s.disposeIntermediateTensorInfo(b);return m}function UR({x:n,filter:e,convInfo:t,backend:s,bias:i=null,preluActivationWeights:r=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:h,outHeight:d,dataFormat:p}=t,f=p==="channelsLast",y=l*c*u,m=d*h,g=[t.batchSize,y,m],b=!0,x=!1,v=[];if(r!=null){const $=xm(r.shape,f);$!=null&&(r=Ne({inputs:{x:r},backend:s,attrs:{shape:$}}),v.push(r))}if(i!=null){const $=xm(i.shape,f);$!=null&&(i=Ne({inputs:{x:i},backend:s,attrs:{shape:$}}),v.push(i))}const w=Ne({inputs:{x:e},backend:s,attrs:{shape:[1,y,re(e.shape)/y]}});v.push(w);const _=new jne(g,t),I=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],C=s.runWebGLProgram(_,[n],"float32",I),S=Ne({inputs:{x:C},backend:s,attrs:{shape:g}});v.push(C),v.push(S);const M=i!=null,A=r!=null,D=o==="leakyrelu",F=o?zh(o,!0):null,k=new AR(f?S.shape:w.shape,f?w.shape:S.shape,f?[t.batchSize,m,t.outChannels]:[t.batchSize,t.outChannels,m],b,x,M,F,A,D),P=f?[S,w]:[w,S];if(i&&P.push(i),A&&P.push(r),D){const $=s.makeTensorInfo([],"float32",Jr(a,"float32"));P.push($),v.push($)}const O=s.runWebGLProgram(k,P,"float32"),V=Ne({inputs:{x:O},backend:s,attrs:{shape:t.outShape}});v.push(O);for(const $ of v)s.disposeIntermediateTensorInfo($);return V}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qne(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dataFormat:l,dilations:c,dimRoundingMode:u}=s,h=ea(l),d=zn(i.shape,r.shape,a,c,o,u,!1,h);let p;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))p=WR({x:i,filter:r,convInfo:d,backend:t});else if(d.strideWidth<=2&&h==="channelsLast"&&ee().getBool("WEBGL_EXP_CONV")){const y=new VR(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=t.runWebGLProgram(y,[i,r],"float32",m)}else if(ee().getBool("WEBGL_CONV_IM2COL"))p=UR({x:i,filter:r,convInfo:d,backend:t});else{const y=new zR(d);p=t.runWebGLProgram(y,[i,r],"float32")}const f=Ne({inputs:{x:p},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(p),f}const Jne={kernelName:ed,backendName:"webgl",kernelFunc:Qne};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qne{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${a}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class ese{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,l=s-1-e.padInfo.left,c=a?1:2,u=a?2:3,h=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${h}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class tse{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${r};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${s} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class nse{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,s=e.filterHeight,i=e.filterWidth,r=e.strideDepth,a=e.strideHeight,o=e.strideWidth,l=t-1-e.padInfo.front,c=s-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${r}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${s}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${s} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,pad:o,dataFormat:l,dimRoundingMode:c,filterShape:u}=s,h=ea(l),d=zn(i.shape,u,a,1,o,c,!1,h),p=new qne(d);return t.runWebGLProgram(p,[i,r],"float32")}const ise={kernelName:Bm,backendName:"webgl",kernelFunc:sse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{inputShape:a,strides:o,pad:l,dataFormat:c,dimRoundingMode:u}=s,h=ea(c),d=zn(a,r.shape,o,1,l,u,!1,h),p=new ese(d);return t.runWebGLProgram(p,[i,r],"float32")}const ase={kernelName:td,backendName:"webgl",kernelFunc:rse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ose(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=s,c=$a(i.shape,r.shape,a,l,o),u=new Yne(c);return t.runWebGLProgram(u,[i,r],"float32")}const lse={kernelName:nd,backendName:"webgl",kernelFunc:ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,pad:o,filterShape:l}=s,c=$a(i.shape,l,a,1,o),u=new tse(c);return t.runWebGLProgram(u,[i,r],"float32")}const use={kernelName:$m,backendName:"webgl",kernelFunc:cse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hse(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{pad:a,strides:o,inputShape:l}=s,c=$a(l,r.shape,o,1,a),u=new nse(c);return t.runWebGLProgram(u,[i,r],"float32")}const dse={kernelName:Xm,backendName:"webgl",kernelFunc:hse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pse=Bu+`
  return cos(x);
`,fse=kt({opSnippet:pse}),mse={kernelName:Dc,backendName:"webgl",kernelFunc:fse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gse=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,yse=kt({opSnippet:gse}),bse={kernelName:Fc,backendName:"webgl",kernelFunc:yse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xse{constructor(e,t,s,i,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,l,c]=e,[u]=t,[h,d]=s;this.outputShape=[u,h,d,c];const p=i==="bilinear"?1:0,[f,y]=[`${o-1}.0`,`${l-1}.0`],[m,g,b]=h>1?[`${(o-1)/(h-1)}`,"(y2-y1) * height_ratio",`y1*${f} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${f}`],[x,v,w]=d>1?[`${(l-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${y} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${y}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${x});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${g};
        float width_scale = ${v};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${f} ) {
          setOutput(float(${r}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${y} ) {
          setOutput(float(${r}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${p} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vse=n=>{const{inputs:e,backend:t,attrs:s}=n,{image:i,boxes:r,boxInd:a}=e,{cropSize:o,method:l,extrapolationValue:c}=s,u=new xse(i.shape,r.shape,o,l,c);return t.runWebGLProgram(u,[i,r,a],"float32")},wse={kernelName:Km,backendName:"webgl",kernelFunc:vse};var Wh;(function(n){n.Prod="*",n.Sum="+"})(Wh||(Wh={}));let TM=class{constructor(e,t,s,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,a=this.op===Wh.Prod?"1.0":"0.0",o=s?a:`getX(${_M(r,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";s?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${Kt(r)} coords = getOutputCoords();
        int end = ${IM(r,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${IM(r,"coords",this.op)} = idx;
          val ${this.op}= getX(${_M(r,"coords",this.op)});
        }
        setOutput(val);
      }
    `}};function _M(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function IM(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BR(n,e,t,s,i,r){const a=e.shape.length,o=un([s],a);let l=e;o!=null&&(l=fs({inputs:{x:e},backend:t,attrs:{perm:o}}));const c=gn(1,a)[0];if(c!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${s}`);const u=l.shape[c];let h=Hs({inputs:{x:l},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const p=new TM(n,l.shape,!1,r),f=[[d]],y=h;h=t.runWebGLProgram(p,[h],h.dtype,f),t.disposeIntermediateTensorInfo(y)}if(i){const d=new TM(n,l.shape,i,r),p=h;h=t.runWebGLProgram(d,[h],h.dtype),t.disposeIntermediateTensorInfo(p)}if(o!=null){const d=Xa(o),p=fs({inputs:{x:h},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(l),p}return h}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:a,reverse:o}=s;return BR(Wh.Prod,i,t,r,a,o)}const Tse={kernelName:Hm,backendName:"webgl",kernelFunc:Sse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _se(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,exclusive:a,reverse:o}=s;return BR(Wh.Sum,i,t,r,a,o)}const Ise={kernelName:sd,backendName:"webgl",kernelFunc:_se};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,weights:r}=e,{size:a,binaryOutput:o}=s;if(i.shape.length===1){const l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=TR(l,c,r.dtype,r.shape,a);return t.makeTensorInfo([a],r.dtype,u)}else if(i.shape.length===2){const l=t.bufferSync(i),c=t.bufferSync(r),u=Gq(l,c,a,o);return t.makeTensorInfo(u.shape,r.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const Cse={kernelName:Zm,backendName:"webgl",kernelFunc:Mse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ese{constructor(e,t,s){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=s,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockSize:r,dataFormat:a}=s,o=i.shape[0],l=a==="NHWC"?i.shape[1]:i.shape[2],c=a==="NHWC"?i.shape[2]:i.shape[3],u=a==="NHWC"?i.shape[3]:i.shape[1],h=l*r,d=c*r,p=u/(r*r),f=a==="NHWC"?[o,h,d,p]:[o,p,h,d],y=new Ese(f,r,a);return t.runWebGLProgram(y,[i],i.dtype)}const Nse={kernelName:Ym,backendName:"webgl",kernelFunc:kse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $R{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bs(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";s&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:c=`
          float activation(float x) {
            ${s}
          }
        `,u="result = activation(result);");const h=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${h}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XR{constructor(e,t=!1,s=null,i=!1,r=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=bs(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,h=e.filterWidth,d=h;let p=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let g=0;g<h;g++)p+=`
          vec4 xTexelC${g*2};
          int xTexelC${g*2}Ready;
          vec4 xTexelC${g*2+1};
          int xTexelC${g*2+1}Ready;
          vec4 xC${g};`;p+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let g=0;g<h;g++)p+=`
          xTexelC${g*2} = vec4(0.0);
          xTexelC${g*2}Ready = 0;
          xTexelC${g*2+1} = vec4(0.0);
          xTexelC${g*2+1}Ready = 0;
          xC${g} = vec4(0.0);`;p+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let g=0;g<(d+1)/2;g++){const b=g*2;if(p+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?p+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:p+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):p+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<h)){const x=o%2===0?Pm(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(p+=`
                  xCOffset = xC + imod(pads[1], 2) + ${x};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?p+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:p+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):x===1?p+=`
                    xC${b+1} = xTexelC${b};
                    `:p+=`
                    xCOffset = xC + ${x};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<h&&(o%2===1?(p+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<h&&(p+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(p+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<h&&(p+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<h&&(p+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<h&&(p+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}p+=`
    }
  `,p+=`
      }
    `;let f="",y="";s&&(i?f=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${s}
        }`:r?f=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${s}
        }`:f=`vec4 activation(vec4 x) {
          ${s}
        }`,y="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${f}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${p}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${y}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l,dimRoundingMode:c}=s;let u=l;u==null&&(u=[1,1]),E(Qn(a,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const h=zn(i.shape,r.shape,a,u,o,c,!0);let d;ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?d=new XR(h):d=new $R(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return t.runWebGLProgram(d,[i,r],"float32",p)}const Ase={kernelName:id,backendName:"webgl",kernelFunc:Rse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lse{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,s=e.strideWidth,i=e.padInfo.top,r=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${s} - ${r};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Pse{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,s=e.filterWidth,i=e.strideHeight,r=e.strideWidth,a=t-1-e.padInfo.top,o=s-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${s}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${s} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,dy:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,filterShape:u}=s,h=zn(i.shape,u,a,o,l,c,!0),d=new Lse(h);return t.runWebGLProgram(d,[i,r],"float32")}const Fse={kernelName:jm,backendName:"webgl",kernelFunc:Dse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ose(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,filter:r}=e,{strides:a,dilations:o,pad:l,dimRoundingMode:c,inputShape:u}=s,h=zn(u,r.shape,a,o,l,c,!0),d=new Pse(h);return t.runWebGLProgram(d,[i,r],"float32")}const Gse={kernelName:Qm,backendName:"webgl",kernelFunc:Ose};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zse{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vse(n){const{inputs:e,backend:t}=n,{x:s}=e,i=[...s.shape,...s.shape],r=re(s.shape),a=Ne({inputs:{x:s},backend:t,attrs:{shape:[r]}}),o=new zse(r),l=t.runWebGLProgram(o,[a],a.dtype),c=Ne({inputs:{x:l},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(l),c}const Wse={kernelName:Jm,backendName:"webgl",kernelFunc:Vse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Use{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:s,padInfo:i,strideHeight:r,strideWidth:a,filterHeight:o,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:h,left:d}=i;this.userCode=`
      const ivec2 strides = ivec2(${r}, ${a});
      const ivec2 pads = ivec2(${h}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${s}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bse(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r}=e,{strides:a,pad:o,dilations:l}=s,c=Kd(i.shape,r.shape,a,o,"NHWC",l);let u;const h=new Use(c);u=t.runWebGLProgram(h,[i,r],"float32");const d=Ne({inputs:{x:u},backend:t,attrs:{shape:c.outShape}});return t.disposeIntermediateTensorInfo(u),d}const $se={kernelName:rd,backendName:"webgl",kernelFunc:Bse};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const{inputs:e,backend:t,attrs:s}=n,{equation:i}=s,r=e,{allDims:a,summedDims:o,idDims:l}=ew(i,r.length);nw(a.length,l,r);const{path:c,steps:u}=sw(o,l),h=u.length;let d=null,p=a.length;const f=[];for(let y=0;y<h;++y){for(const m of u[y]){const{permutationIndices:g,expandDims:b}=tw(p,l[m]);let x;iw(g)?x=r[m]:(x=fs({inputs:{x:r[m]},backend:t,attrs:{perm:g}}),f.push(x));const v=x.shape.slice();for(let w=0;w<b.length;++w)v.splice(b[w],0,1);St(x.shape,v)||(x=Ne({inputs:{x},backend:t,attrs:{shape:v}}),f.push(x)),d===null?d=x:(d=ZS({inputs:{a:x,b:d},backend:t}),f.push(d))}y<h-1&&(c[y]>=0&&(d=tb({inputs:{x:d},backend:t,attrs:{axis:c[y]-(a.length-p),keepDims:!1}}),f.push(d)),p--)}for(const y of f)y!==d&&t.disposeIntermediateTensorInfo(y);return d}const Hse={kernelName:qm,backendName:"webgl",kernelFunc:Xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kse="return (x >= 0.0) ? x : (exp(x) - 1.0);",Zse=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Yse=kt({opSnippet:Kse,packedOpSnippet:Zse}),jse={kernelName:Gc,backendName:"webgl",kernelFunc:Yse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse="return (b >= 1.0) ? a : a * (b + 1.0);",Jse=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,qse=n=>{const{inputs:e,backend:t}=n,{dy:s,y:i}=e,r=ee().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ep(Jse,s.shape,i.shape):new vc(Qse,s.shape,i.shape);return t.runWebGLProgram(r,[s,i],s.dtype)},eie={kernelName:eg,backendName:"webgl",kernelFunc:qse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tie=`
  return vec4(equal(a, b));
`,nie="return float(a == b);",sie=qn({opSnippet:nie,packedOpSnippet:tie,dtype:"bool",cpuKernelImpl:Uq}),iie={kernelName:ad,backendName:"webgl",kernelFunc:sie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rie=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${Kv};
  float a1 = ${Zv};
  float a2 = ${Yv};
  float a3 = ${jv};
  float a4 = ${Qv};
  float a5 = ${Jv};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,aie=kt({opSnippet:rie}),oie={kernelName:zc,backendName:"webgl",kernelFunc:aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie=Bu+`
  return exp(x);
`,cie=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,HR=kt({opSnippet:lie,packedOpSnippet:cie,cpuKernelImpl:Bq,dtype:"float32"}),uie={kernelName:Vc,backendName:"webgl",kernelFunc:HR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ix(n){const{inputs:e,attrs:t,backend:s}=n,{dim:i}=t,{input:r}=e,a=r.shape.length,o=r.shape.slice();let l=i;return i<0&&(E(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),l=a+i+1),o.splice(l,0,1),Ne({inputs:{x:r},backend:s,attrs:{shape:o}})}const hie={kernelName:od,backendName:"webgl",kernelFunc:Ix};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MM="return exp(x) - 1.0;",die=kt({opSnippet:MM,packedOpSnippet:MM,cpuKernelImpl:$q}),pie={kernelName:Wc,backendName:"webgl",kernelFunc:die};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let CM=class{constructor(e,t,s){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const r=s?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=s?`${i}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${r};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KR(n,e,t){const s=t.texData.get(n.dataId),i=re(n.shape),r=n.shape[n.shape.length-1],a=i/r,o=Ne({inputs:{x:n},backend:t,attrs:{shape:[a,r]}}),l=o.shape,c=new CM("real",l,e),u=new CM("imag",l,e),h=[{dataId:s.complexTensorInfos.real.dataId,dtype:s.complexTensorInfos.real.dtype,shape:l},{dataId:s.complexTensorInfos.imag.dataId,dtype:s.complexTensorInfos.imag.dtype,shape:l}],d=t.runWebGLProgram(c,h,"float32"),p=t.runWebGLProgram(u,h,"float32"),f=Ya({inputs:{real:d,imag:p},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p);const y=Ne({inputs:{x:f},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(f),y}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fie(n){const{inputs:e,backend:t}=n,{input:s}=e;return KR(s,!1,t)}const mie={kernelName:tg,backendName:"webgl",kernelFunc:fie};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gie{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Np(n){const{backend:e,attrs:t}=n,{shape:s,value:i}=t;let{dtype:r}=t;if(r=r||_c(i),r==="string"){const a=pn(r,re(s));return a.fill(i),e.makeTensorInfo(s,r,a)}else{const a=new gie(s,i),o=[[i]];return e.runWebGLProgram(a,[],r,o)}}const yie={kernelName:ng,backendName:"webgl",kernelFunc:Np};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bie{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xie={kernelName:sg,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,s=e,i=new bie(t.shape);return s.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EM="return floor(x);",vie=kt({opSnippet:EM,packedOpSnippet:EM,cpuKernelImpl:Xq}),wie={kernelName:Uc,backendName:"webgl",kernelFunc:vie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sie=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,Tie=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,_ie=qn({opSnippet:Sie,packedOpSnippet:Tie,dtype:"int32"}),Iie={kernelName:Bc,backendName:"webgl",kernelFunc:_ie};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mie{constructor(e){this.variableNames=["A"];const t=ys(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${s}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cie{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=ys(),[s,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${s}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eie={kernelName:jf,backendName:"webgl",kernelFunc:kie};let Nl,a0=ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function kie(n){const{inputs:e,backend:t,attrs:s}=n;let{pixels:i}=e;const{numChannels:r}=s,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],h=[c,l,r];if(o||a){const y=ee().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Nl==null||y!==a0)&&(a0=y,Nl=document.createElement("canvas").getContext("2d",{willReadFrequently:a0})),Nl.canvas.width=l,Nl.canvas.height=c,Nl.drawImage(i,0,0,l,c),i=Nl.canvas}const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=ti.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),i);const p=ee().getBool("WEBGL_PACK")?new Cie(h):new Mie(h),f=t.runWebGLProgram(p,[d],"int32");return t.disposeData(d.dataId),f}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=s,y=ea(u),m=zn(i.shape,r.shape,l,h,c,d,!1,y);let g;const b=[],x=a!=null,v=o!=null,w=p==="leakyrelu",_=()=>{const C=[i,r],S=(M,A)=>{if(A==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const D=Ne({inputs:{x:M},backend:t,attrs:{shape:[M.shape[0],1,1]}});return b.push(D),D}return M};if(x&&C.push(S(a,u)),v&&C.push(S(o,u)),w){const M=t.makeTensorInfo([],"float32",Jr(f,"float32"));C.push(M),b.push(M)}return C};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))g=WR({x:i,filter:r,convInfo:m,backend:t,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else if(m.strideWidth<=2&&y==="channelsLast"&&ee().getBool("WEBGL_EXP_CONV")){const C=p?zh(p,!0):null,S=new VR(m,x,C,v,w),M=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],A=_();g=t.runWebGLProgram(S,A,"float32",M)}else if(ee().getBool("WEBGL_CONV_IM2COL"))g=UR({x:i,filter:r,convInfo:m,backend:t,bias:a,activation:p,preluActivationWeights:o,leakyreluAlpha:f});else{const C=p?zh(p,!1):null,S=new zR(m,x,C,v,w),M=_();g=t.runWebGLProgram(S,M,"float32")}const I=Ne({inputs:{x:g},backend:t,attrs:{shape:m.outShape}});return b.push(g),b.forEach(C=>t.disposeIntermediateTensorInfo(C)),I}const Rie={kernelName:Ih,backendName:"webgl",kernelFunc:Nie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aie(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,filter:r,bias:a,preluActivationWeights:o}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=s,f=[];let y=u;y==null&&(y=[1,1]),E(Qn(l,y),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${y}'`);const m=zn(i.shape,r.shape,l,y,c,h,!0),g=ee().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,b=d?zh(d,g):null,x=[i,r],v=a!=null,w=o!=null,_=d==="leakyrelu";if(v&&x.push(a),w&&x.push(o),_){const M=t.makeTensorInfo([],"float32",Jr(p,"float32"));x.push(M),f.push(M)}let I;g?I=new XR(m,v,b,w,_):I=new $R(m,v,b,w,_);const C=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],S=t.runWebGLProgram(I,x,"float32",C);return f.forEach(M=>t.disposeIntermediateTensorInfo(M)),S}const Lie={kernelName:Mh,backendName:"webgl",kernelFunc:Aie};class Pie{constructor(e,t,s,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=s;const r=Kt(s.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${r} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Die(n){const{inputs:e,backend:t}=n,{params:s,indices:i}=e,r=i.shape,a=r[r.length-1],o=re(s.shape),[l,c,u,h]=Ty(s,i),d=Ne({inputs:{x:i},backend:t,attrs:{shape:[c,a]}}),p=Ne({inputs:{x:s},backend:t,attrs:{shape:[re(s.shape)/u,u]}});if(t.shouldExecuteOnCPU([s,i])||s.dtype==="string"){const g=t.readSync(i.dataId),b=t.bufferSync(s),x=Hq(g,b,s.dtype,c,a,u,h,s.shape,o);return t.makeTensorInfo(l,s.dtype,x.values)}const f=new Pie(a,h,[c,u],s.shape),y=t.runWebGLProgram(f,[p,d],p.dtype),m=Ne({inputs:{x:y},backend:t,attrs:{shape:l}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(y),m}const Fie={kernelName:ig,backendName:"webgl",kernelFunc:Die};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oie{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const s=Kt(this.rank),i=Gie(e);this.userCode=`
      void main() {
        ${s} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function Gie(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[];for(let i=0;i<n.length;i++)i===2?s.push("index"):s.push(`${t[i]}`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZR(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,indices:r}=e,{axis:a,batchDims:o}=s,l=mt(a,i.shape)[0];if(ee().get("DEBUG")){const b=t.readSync(r.dataId),x=i.shape[l];for(let v=0;v<b.length;++v){const w=b[v];E(w<=x-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${x-1}]`)}}const c=aw(i,r,l,o),u=re(r.shape),h=[],d=Ne({inputs:{x:i},backend:t,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),p=Ne({inputs:{x:r},backend:t,attrs:{shape:[c.batchSize,u/c.batchSize]}});h.push(d),h.push(p);const f=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(t.shouldExecuteOnCPU([i,r])||i.dtype==="string"){const b=t.bufferSync(p),x=t.bufferSync(d),v=Kq(x,b,f);return h.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(c.outputShape,v.dtype,v.values)}const y=new Oie(d.shape,f),m=t.runWebGLProgram(y,[d,p],d.dtype);h.push(m);const g=Ne({inputs:{x:m},backend:t,attrs:{shape:c.outputShape}});return h.forEach(b=>t.disposeIntermediateTensorInfo(b)),g}const zie={kernelName:cd,backendName:"webgl",kernelFunc:ZR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vie="return float(a > b);",Wie=`
  return vec4(greaterThan(a, b));
`,Uie=qn({opSnippet:Vie,packedOpSnippet:Wie,cpuKernelImpl:Zq,dtype:"bool"}),Bie={kernelName:ud,backendName:"webgl",kernelFunc:Uie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $ie="return float(a >= b);",Xie=`
  return vec4(greaterThanEqual(a, b));
`,Hie=qn({opSnippet:$ie,packedOpSnippet:Xie,dtype:"bool",cpuKernelImpl:Yq}),Kie={kernelName:$c,backendName:"webgl",kernelFunc:Hie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zie(n){const{inputs:e,backend:t}=n,{input:s}=e;return KR(s,!0,t)}const Yie={kernelName:rg,backendName:"webgl",kernelFunc:Zie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jie="return float(!isnan(x) && !isinf(x));",Qie=kt({opSnippet:jie,dtype:"bool"}),Jie={kernelName:Hc,backendName:"webgl",kernelFunc:Qie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qie="return float(isinf(x));",ere=kt({opSnippet:qie,dtype:"bool"}),tre={kernelName:Kc,backendName:"webgl",kernelFunc:ere};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre="return float(isnan(x));",sre=kt({opSnippet:nre,dtype:"bool"}),ire={kernelName:Zc,backendName:"webgl",kernelFunc:sre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rre="return float(a < b);",are=`
  return vec4(lessThan(a, b));
`,ore=qn({opSnippet:rre,packedOpSnippet:are,cpuKernelImpl:jq,dtype:"bool"}),lre={kernelName:dd,backendName:"webgl",kernelFunc:ore};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cre="return float(a <= b);",ure=`
  return vec4(lessThanEqual(a, b));
`,hre=qn({opSnippet:cre,packedOpSnippet:ure,cpuKernelImpl:Qq,dtype:"bool"}),dre={kernelName:pd,backendName:"webgl",kernelFunc:hre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pre(n){const{backend:e,attrs:t}=n,{start:s,stop:i,num:r}=t,a=Jq(s,i,r);return e.makeTensorInfo([a.length],"float32",a)}const fre={kernelName:og,backendName:"webgl",kernelFunc:pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre=Bu+`
  return x < 0.0 ? 0./0. : log(x);
`,gre=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,yre=kt({opSnippet:mre,packedOpSnippet:gre,cpuKernelImpl:qq}),bre={kernelName:Yc,backendName:"webgl",kernelFunc:yre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xre=Bu+`
  return log(1.0 + x);
`,vre=kt({opSnippet:xre}),wre={kernelName:jc,backendName:"webgl",kernelFunc:vre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sre="return float(a >= 1.0 && b >= 1.0);",Tre=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,_re=qn({opSnippet:Sre,packedOpSnippet:Tre,dtype:"bool"}),Ire={kernelName:fd,backendName:"webgl",kernelFunc:_re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mre="return float(!(x >= 1.0));",Cre=kt({opSnippet:Mre}),Ere={kernelName:md,backendName:"webgl",kernelFunc:Cre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kre="return float(a >= 1.0 || b >= 1.0);",Nre=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Rre=qn({opSnippet:kre,packedOpSnippet:Nre,dtype:"bool"}),Are={kernelName:gd,backendName:"webgl",kernelFunc:Rre};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lre{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pre{constructor(e,t,s,i,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let l;const c=`float(${s}) + float(${i}) * sum`;r===.5?l=`inversesqrt(${c})`:r===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${r}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dre=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{depthRadius:r,bias:a,alpha:o,beta:l}=s,c=ee().getBool("WEBGL_PACK_NORMALIZATION")?new Pre(i.shape,r,a,o,l):new Lre(i.shape,r,a,o,l);return t.runWebGLProgram(c,[i],i.dtype)},Fre={kernelName:yd,backendName:"webgl",kernelFunc:Dre};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ore{constructor(e,t,s,i,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=s,this.alpha=i,this.beta=r,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${s});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${r})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${r});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gre=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i,y:r,dy:a}=e,{depthRadius:o,bias:l,alpha:c,beta:u}=s,h=new Ore(i.shape,o,l,c,u);return t.runWebGLProgram(h,[i,r,a],i.dtype)},zre={kernelName:lg,backendName:"webgl",kernelFunc:Gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vre(n,e,t,s){const i=re(e),r=re(n.shape)/i,a=Ne({inputs:{x:n},attrs:{shape:[r,i]},backend:s}),o=hl(a,n.dtype,"max",s),l=Ne({inputs:{x:o},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YR(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reductionIndices:r,keepDims:a}=s,o=i.shape.length,l=mt(r,i.shape);let c=l;const u=un(c,o),h=u!=null,d=t.shouldExecuteOnCPU([i]);let p=i;if(h){if(d){const b=t.texData.get(p.dataId).values,x=new Array(o);for(let _=0;_<x.length;_++)x[_]=i.shape[u[_]];const v=HS(b,i.shape,i.dtype,u,x);p=t.makeTensorInfo(x,i.dtype);const w=t.texData.get(p.dataId);w.values=v}else p=eb(i,u,t);c=gn(c.length,o)}Jn("max",c,o);const[f,y]=Vn(p.shape,c);let m=f;a&&(m=mn(f,l));let g;if(d){const b=t.texData.get(p.dataId).values,x=eee(b,re(y),m,i.dtype);g=t.makeTensorInfo(m,i.dtype);const v=t.texData.get(g.dataId);v.values=x}else g=Vre(p,y,m,t);return h&&t.disposeIntermediateTensorInfo(p),g}const Wre={kernelName:bd,backendName:"webgl",kernelFunc:YR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ure=KS+`
  return max(a, b);
`,Bre=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Cp+`
  return result;
`,$re=qn({opSnippet:Ure,packedOpSnippet:Bre,cpuKernelImpl:tee}),Xre={kernelName:Qc,backendName:"webgl",kernelFunc:$re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e;Ip(i,"maxPool");const{filterSize:r,strides:a,pad:o,dimRoundingMode:l}=s,c=1;E(Qn(a,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${c}'`);const u=_i(i.shape,r,a,c,o,l);if(u.filterWidth===1&&u.filterHeight===1&&St(u.inShape,u.outShape))return Hs({inputs:{x:i},backend:t});const h=new Vh(u,"max",!1);return t.runWebGLProgram(h,[i],i.dtype)}const Kre={kernelName:xd,backendName:"webgl",kernelFunc:Hre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{filterSize:r,strides:a,pad:o,dataFormat:l,dimRoundingMode:c}=s,u=[1,1,1],h=qr(i.shape,r,a,u,o,c,l),d=new YS(h,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const Yre={kernelName:vd,backendName:"webgl",kernelFunc:Zre};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jre{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,s=e.strideWidth,i=e.dilationHeight,r=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=r-1-e.padInfo.top,l=a-1-e.padInfo.left,c=r*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${r};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Qre{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,s=e.strideHeight,i=e.strideWidth,r=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,h=l-1-e.padInfo.front,d=c-1-e.padInfo.top,p=u-1-e.padInfo.left,f=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${h}, ${d}, ${p});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${r}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${s}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${f} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r}=e,a=r,{filterSize:o,strides:l,pad:c,dimRoundingMode:u}=s,h=[1,1,1],d=qr(a.shape,o,l,h,c,u),p=new YS(d,"max",!0),f=t.runWebGLProgram(p,[a],a.dtype),y=new Qre(d),m=t.runWebGLProgram(y,[i,f],a.dtype);return t.disposeIntermediateTensorInfo(f),m}const qre={kernelName:ug,backendName:"webgl",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eae(n){const{inputs:e,backend:t,attrs:s}=n,{dy:i,input:r,output:a}=e,o=r;Ip([r,a],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:h}=s,d=_i(o.shape,l,c,1,u,h),p=!0,f=new Vh(d,"max",p),y=t.runWebGLProgram(f,[o],o.dtype),m=new jre(d),g=t.runWebGLProgram(m,[i,y],o.dtype);return t.disposeIntermediateTensorInfo(y),g}const tae={kernelName:cg,backendName:"webgl",kernelFunc:eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nae(n,e,t,s){let i=new Vh(t,"max",!1);const r=s.runWebGLProgram(i,[n],"float32");i=new Vh(t,"max",!0,!0,e);const a=s.runWebGLProgram(i,[n],"float32");return[r,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sae={kernelName:hg,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{filterSize:i,strides:r,pad:a,includeBatchInIndex:o}=e,l=t;E(s.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${s.shape.length}.`);const c=[1,1];E(Qn(r,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${r} and dilations '${c}'`);const u=_i(s.shape,i,r,c,a),[h,d]=nae(s,o,u,l);return[h,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iae(n,e,t,s){const i=re(e),r=re(n.shape)/i,a=Ne({inputs:{x:n},attrs:{shape:[r,i]},backend:s}),o=hl(a,"float32","mean",s),l=Ne({inputs:{x:o},attrs:{shape:t},backend:s});return s.disposeIntermediateTensorInfo(a),s.disposeIntermediateTensorInfo(o),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rae={kernelName:wd,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:s}=n,{keepDims:i,axis:r}=e,a=t,o=s.shape.length,l=mt(r,s.shape);let c=l;const u=un(c,o),h=u!=null,d=a.shouldExecuteOnCPU([s]),p=[];let f=s;if(h){if(d){const x=a.texData.get(f.dataId).values,v=new Array(o);for(let I=0;I<v.length;I++)v[I]=s.shape[u[I]];const w=HS(x,s.shape,s.dtype,u,v);f=a.makeTensorInfo(v,s.dtype);const _=a.texData.get(f.dataId);_.values=w}else f=eb(s,u,a);p.push(f),c=gn(c.length,o)}Jn("sum",c,o);const[y,m]=Vn(f.shape,c);let g=y;i&&(g=mn(y,l));const b=iae(f,m,g,a);for(const x of p)a.disposeIntermediateTensorInfo(x);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aae(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s,o=i.shape.length,l=mt(r,i.shape);let c=l;const u=un(c,o);let h=i;u!=null&&(h=fs({inputs:{x:i},backend:t,attrs:{perm:u}}),c=gn(c.length,i.shape.length)),Jn("min",c,o);const[d,p]=Vn(h.shape,c),f=re(p),y=Ne({inputs:{x:h},backend:t,attrs:{shape:[-1,f]}}),m=hl(y,y.dtype,"min",t);let g;if(a){const b=mn(d,l);g=Ne({inputs:{x:m},backend:t,attrs:{shape:b}})}else g=Ne({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(y),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(h),g}const oae={kernelName:Sd,backendName:"webgl",kernelFunc:aae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae=KS+`
  return min(a, b);
`,cae=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Cp+`
  return result;
`,uae=qn({opSnippet:lae,packedOpSnippet:cae,cpuKernelImpl:nee}),hae={kernelName:Jc,backendName:"webgl",kernelFunc:uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dae{constructor(e,t,s){this.variableNames=["x"],this.outputShape=t.map((u,h)=>u[0]+e[h]+u[1]);const i=e.length,r=Kt(i),a=t.map(u=>u[0]).join(","),o=t.map((u,h)=>u[0]+e[h]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=s==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${r} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pae{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((f,y)=>f[0]+e[y]+f[1]);const i=e.length,r=Kt(i),a=t.map(f=>f[0]).join(","),o=t.map((f,y)=>f[0]+e[y]).join(","),l=hs("rc",i),c=hs("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=s==="reflect"?0:1;let p="";if(i===1){const f=`
        ${r} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
      `}else{const f=`
        ${r} source = rc;
        ${r} lt = ${r}(lessThan(source, start));
        ${r} gte = ${r}(greaterThanEqual(source, end));
        ${r} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;p=`
        ${r} rc = outputLoc;
        ${f}
        result[0] = getChannel(getX(${c.join()}), ${h});
        ${l[i-1]} += 1;
        if(${u}) {
          ${f}
          result[1] = getChannel(getX(${c.join()}), ${h});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${f}
          result[2] = getChannel(getX(${c.join()}), ${h});
          ${l[i-1]} += 1;
          if(${u}) {
            ${f}
            result[3] = getChannel(getX(${c.join()}), ${h});
          }
        }
      `}this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fae=({inputs:n,backend:e,attrs:t})=>{const{x:s}=n,{paddings:i,mode:r}=t,a=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new pae(s.shape,i,r):new dae(s.shape,i,r);return e.runWebGLProgram(a,[s],s.dtype)},mae={kernelName:Td,backendName:"webgl",kernelFunc:fae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gae=`if (b == 0.0) return NAN;
  return mod(a, b);`,yae=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Cp+`
  return result;
`,bae=qn({opSnippet:gae,packedOpSnippet:yae}),xae={kernelName:qc,backendName:"webgl",kernelFunc:bae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vae{constructor(e,t,s){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,s],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wae=`
if (a == b) {
  return 1.0;
};
return a / b;`,Sae=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,jR=qn({opSnippet:wae,packedOpSnippet:Sae,checkOutOfBounds:!0}),Tae={kernelName:Oc,backendName:"webgl",kernelFunc:jR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kM="return a - b;",QR=qn({opSnippet:kM,packedOpSnippet:kM,supportsComplex:!0,cpuKernelImpl:See}),_ae={kernelName:mu,backendName:"webgl",kernelFunc:QR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JR(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{dim:r}=s,a=mt([r],i.shape),o=YR({inputs:{x:i},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),l=mn(o.shape,a),c=Ne({inputs:{x:o},backend:t,attrs:{shape:l}}),u=QR({inputs:{a:i,b:c},backend:t}),h=HR({inputs:{x:u},backend:t}),d=tb({inputs:{x:h},backend:t,attrs:{axis:a,keepDims:!1}}),p=Ne({inputs:{x:d},backend:t,attrs:{shape:l}}),f=jR({inputs:{a:h,b:p},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(p),f}const Iae={kernelName:Wd,backendName:"webgl",kernelFunc:JR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mae(n){const{inputs:e,backend:t,attrs:s}=n,{logits:i}=e,{numSamples:r,seed:a,normalized:o}=s,l=o?i:JR({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],h=new vae(c,u,r),d=[[a]],p=t.runWebGLProgram(h,[l],"int32",d);return o||t.disposeIntermediateTensorInfo(l),p}const Cae={kernelName:dg,backendName:"webgl",kernelFunc:Mae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eae=Mi+`
  return -x;
`,kae=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Nae(n){const{inputs:e,backend:t}=n,{x:s}=e;if(t.shouldExecuteOnCPU([s])){const r=t.texData.get(s.dataId),[a,o]=iee(r.values,s.shape,s.dtype);return t.makeTensorInfo(o,s.dtype,a)}let i;return ee().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new wa(s.shape,kae):i=new or(s.shape,Eae),t.runWebGLProgram(i,[s],s.dtype)}const Rae={kernelName:_d,backendName:"webgl",kernelFunc:Nae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aae=xy;function Lae(n){qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),{selectedIndices:h}=Aae(c,u,a,o,l);return t.makeTensorInfo([h.length],"int32",new Int32Array(h))}const Pae={kernelName:pg,backendName:"webgl",kernelFunc:Lae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dae=vy;function Fae(n){qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,padToMaxOutputSize:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),{selectedIndices:d,validOutputs:p}=Dae(u,h,a,o,l,c);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([p]))]}const Oae={kernelName:fg,backendName:"webgl",kernelFunc:Fae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gae=wy;function zae(n){qs("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:s}=n,{boxes:i,scores:r}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:l,softNmsSigma:c}=s,u=t.readSync(i.dataId),h=t.readSync(r.dataId),d=a,p=o,f=l,y=c,{selectedIndices:m,selectedScores:g}=Gae(u,h,d,p,f,y);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([g.length],"float32",new Float32Array(g))]}const Vae={kernelName:mg,backendName:"webgl",kernelFunc:zae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wae{constructor(e,t,s,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${s}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uae=n=>{const{inputs:e,backend:t,attrs:s}=n,{indices:i}=e,{dtype:r,depth:a,onValue:o,offValue:l}=s,c=re(i.shape),u=new Wae(c,a,o,l),h=Ne({inputs:{x:i},backend:t,attrs:{shape:[c]}}),d=t.runWebGLProgram(u,[h],r);t.disposeIntermediateTensorInfo(h);const p=[...i.shape,a],f=Ne({inputs:{x:d},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(d),f},Bae={kernelName:Cd,backendName:"webgl",kernelFunc:Uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vm(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="complex64"){const i=kp({inputs:{input:s},backend:t}),r=vm({inputs:{x:i},backend:t}),a=nb({inputs:{input:s},backend:t}),o=vm({inputs:{x:a},backend:t}),l=Ya({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return Np({attrs:{shape:s.shape,dtype:s.dtype,value:s.dtype==="string"?"":0},backend:t})}const $ae={kernelName:$d,backendName:"webgl",kernelFunc:vm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qR(n){const{inputs:e,backend:t}=n,{x:s}=e;if(s.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(s.dtype==="complex64"){const i=kp({inputs:{input:s},backend:t}),r=qR({inputs:{x:i},backend:t}),a=nb({inputs:{input:s},backend:t}),o=vm({inputs:{x:a},backend:t}),l=Ya({inputs:{real:r,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(r),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),l}else return Np({attrs:{shape:s.shape,dtype:s.dtype,value:1},backend:t})}const Xae={kernelName:Md,backendName:"webgl",kernelFunc:qR};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hae(n){const{inputs:e,backend:t,attrs:s}=n,{axis:i}=s;if(e.length===1)return Ix({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const r=e[0].shape,a=e[0].dtype;e.forEach(u=>{jn(r,u.shape,"All tensors passed to stack must have matching shapes"),E(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],l=e.map(u=>{const h=Ix({inputs:{input:u},backend:t,attrs:{dim:i}});return o.push(h),h}),c=GR({inputs:l,backend:t,attrs:{axis:i}});return o.forEach(u=>t.disposeIntermediateTensorInfo(u)),c}const Kae={kernelName:Ed,backendName:"webgl",kernelFunc:Hae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zae{constructor(e,t,s){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,r=Kt(i),a=t.map(c=>c[0]).join(","),o=t.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${r} start = ${r}(${a});
      ${r} end = ${r}(${o});

      void main() {
        ${r} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${r} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yae{constructor(e,t,s){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((y,m)=>y[0]+e[m]+y[1]);const i=e.length,r=Kt(i),a=t.map(y=>y[0]).join(","),o=t.map((y,m)=>y[0]+e[m]).join(","),l=hs("rc",i),c=hs("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,h=i===1?"source":`vec2(${c.slice(-2).join()})`,d=[`${r} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],p=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let f="";for(let y=0,m=i===1?2:4;y<m;y++)f+=`
        ${d[y]}
        if (${p}) {
          result[${y}] = float(value);
        } else {
          ${r} source = rc - start;
          result[${y}] = getChannel(getX(${c.join()}), ${h});
        }
      `;f+=i===1?"} ":"}}",this.userCode=`
      const ${r} start = ${r}(${a});
      const ${r} end = ${r}(${o});

      void main() {
        ${r} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${f}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eA=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{paddings:r,constantValue:a}=s;if(re(i.shape)===0){const c=r.map((u,h)=>u[0]+i.shape[h]+u[1]);return Np({backend:t,attrs:{shape:c,value:a,dtype:i.dtype}})}const o=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Yae(i.shape,r,a):new Zae(i.shape,r,a),l=[[a]];return t.runWebGLProgram(o,[i],i.dtype,l)},jae={kernelName:kd,backendName:"webgl",kernelFunc:eA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qae=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Jae=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Cp+`
  return result;
`,qae=qn({opSnippet:Qae,packedOpSnippet:Jae}),eoe={kernelName:tu,backendName:"webgl",kernelFunc:qae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function toe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{axis:r,keepDims:a}=s,o=i.shape.length,l=[],c=mt(r,i.shape);let u=c;const h=un(u,o);let d=i;h!=null&&(d=fs({inputs:{x:i},backend:t,attrs:{perm:h}}),u=gn(u.length,o),l.push(d)),Jn("prod",u,o);let p;if(t.shouldExecuteOnCPU([d])){const f=t.texData.get(d.dataId).values,{outVals:y,outShape:m,outDtype:g}=aee(d.shape,d.dtype,f,u);p=t.makeTensorInfo(m,g,y)}else{const[f,y]=Vn(d.shape,u),m=re(y),g=Ne({inputs:{x:d},backend:t,attrs:{shape:[-1,m]}}),b=zg(i.dtype),x=hl(g,b,"prod",t);p=Ne({inputs:{x},backend:t,attrs:{shape:f}}),l.push(g),l.push(x)}if(a){l.push(p);const f=mn(p.shape,c);p=Ne({inputs:{x:p},backend:t,attrs:{shape:f}})}return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),p}const noe={kernelName:Rd,backendName:"webgl",kernelFunc:toe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function soe(n){const{inputs:e,backend:t,attrs:s}=n,{paramsNestedSplits:i,paramsDenseValues:r,indices:a}=e,{outputRaggedRank:o}=s,l=i.map(g=>t.readSync(g.dataId)),c=i.map(g=>g.shape),u=t.readSync(r.dataId),h=t.readSync(a.dataId),[d,p,f]=oee(l,c,u,r.shape,r.dtype,h,a.shape,o),y=d.map(g=>t.makeTensorInfo([g.length],"int32",g)),m=t.makeTensorInfo(f,r.dtype,p);return y.concat([m])}const ioe={kernelName:gg,backendName:"webgl",kernelFunc:soe};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function roe(n){const{inputs:e,backend:t}=n,{starts:s,limits:i,deltas:r}=e,a=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=lee(a,s.shape,s.dtype,o,i.shape,l,r.shape),h=t.makeTensorInfo([c.length],"int32",c),d=t.makeTensorInfo([u.length],s.dtype,u);return[h,d]}const aoe={kernelName:yg,backendName:"webgl",kernelFunc:roe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ooe(n){const{inputs:e,backend:t,attrs:s}=n,{shape:i,values:r,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:l}=s,c=t.readSync(i.dataId),u=t.readSync(r.dataId),h=t.readSync(a.dataId),d=o.map(m=>t.readSync(m.dataId)),p=o.map(m=>m.shape),[f,y]=cee(c,i.shape,u,r.shape,r.dtype,h,a.shape,d,p,l);return t.makeTensorInfo(f,r.dtype,y)}const loe={kernelName:bg,backendName:"webgl",kernelFunc:ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tA=n=>{const{backend:e,attrs:t}=n,{start:s,stop:i,step:r,dtype:a}=t,o=uee(s,i,r,a);return e.makeTensorInfo([o.length],a,o)},coe={kernelName:xg,backendName:"webgl",kernelFunc:tA};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uoe="return 1.0 / x;",hoe=kt({opSnippet:uoe}),doe={kernelName:nu,backendName:"webgl",kernelFunc:hoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const poe=Mi+`
  return (x < 0.0) ? 0.0 : x;
`,foe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,moe=kt({opSnippet:poe,packedOpSnippet:foe}),goe={kernelName:su,backendName:"webgl",kernelFunc:moe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yoe=Mi+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,boe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,xoe=kt({opSnippet:yoe,packedOpSnippet:boe}),voe={kernelName:iu,backendName:"webgl",kernelFunc:xoe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class woe{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const u=[i&&t>1?o-1:o,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Soe{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const u=[i&&t>1?o-1:o,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s];let d;r?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Toe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=s,[l,c]=o,u=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Soe(i.shape,l,c,r,a):new woe(i.shape,l,c,r,a);return t.runWebGLProgram(u,[i],"float32")}const _oe={kernelName:Pd,backendName:"webgl",kernelFunc:Toe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ioe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,a,o]=e,l=[s&&a>1?i-1:i,s&&o>1?r-1:r],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,y=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${r-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Moe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:a}=s,o=new Ioe(r.shape,i.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const Coe={kernelName:Sg,backendName:"webgl",kernelFunc:Moe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eoe{constructor(e,t,s,i,r){this.variableNames=["A"],this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const u=[i&&t>1?o-1:o,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let p;r?p="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":p="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/h[0]},
          ${u[1]/h[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class koe{constructor(e,t,s,i,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,l,c]=e;this.outputShape=[a,t,s,c];const u=[i&&t>1?o-1:o,i&&s>1?l-1:l],h=[i&&t>1?t-1:t,i&&s>1?s-1:s],d=i?"0.5":"0.0";let p;r?p="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":p="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/h[0]},
          ${u[1]/h[1]},
          ${u[1]/h[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${p};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${s-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Noe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i}=e,{alignCorners:r,halfPixelCenters:a,size:o}=s,[l,c]=o,u=ee().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new koe(i.shape,l,c,r,a):new Eoe(i.shape,l,c,r,a);return t.runWebGLProgram(u,[i],i.dtype)}const Roe={kernelName:Ld,backendName:"webgl",kernelFunc:Noe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aoe{constructor(e,t,s){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,r]=t,[,a,o]=e,l=[s&&a>1?i-1:i,s&&o>1?r-1:r],c=[s&&a>1?a-1:a,s&&o>1?o-1:o],u=l[0]/c[0],h=l[1]/c[1],d=1/u,p=1/h,f=Math.ceil(d)*2+2,y=Math.ceil(p)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${h});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${p});

        const int winHeight = int(${f});
        const int winWidth = int(${y});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${s} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${r}) - 1),
                ${s} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Loe(n){const{inputs:e,backend:t,attrs:s}=n,{images:i,dy:r}=e,{alignCorners:a}=s,o=new Aoe(r.shape,i.shape,a);return t.runWebGLProgram(o,[r],r.dtype)}const Poe={kernelName:wg,backendName:"webgl",kernelFunc:Loe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Doe{constructor(e,t){this.variableNames=["x"];const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);if(this.outputShape=e,s===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,r=e.map((o,l)=>i(l)).join(","),a=Kt(s);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${r}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Foe{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const s=e.length;if(s>4)throw new Error(`WebGL backend: Reverse of rank-${s} tensor is not yet supported`);this.outputShape=e;const i=hs("rc",s),r=`${i[s-1]} + 1 < ${this.outputShape[s-1]}`,a=`${i[s-2]} + 1 < ${this.outputShape[s-2]}`,o=Kt(s);s===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${r}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${r}){
            result.g = ${c(i.slice())};
          }
          if(${a}) {
            result.b = ${u(i.slice())};
            if(${r}) {
              result.a = ${h(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(f){return d(f)}function c(f){return f[s-1]="("+f[s-1]+" + 1)",d(f)}function u(f){return f[s-2]="("+f[s-2]+" + 1)",d(f)}function h(f){return f[s-1]="("+f[s-1]+" + 1)",f[s-2]="("+f[s-2]+" + 1)",d(f)}function d(f){const y=e.map((b,x)=>p(x,f)),m=y.join(","),g=y.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${g}))`}function p(f,y){return t.indexOf(f)!==-1&&e[f]!==1?`${e[f]} - ${y[f]} - 1`:`${y[f]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ooe(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{dims:r}=s,a=i.shape.length,o=mt(r,i.shape);if(a===0)return Hs({inputs:{x:i},backend:t});const l=ee().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Foe(i.shape,o):new Doe(i.shape,o);return t.runWebGLProgram(l,[i],i.dtype)}const Goe={kernelName:Dd,backendName:"webgl",kernelFunc:Ooe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zoe{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const s=e[1],i=e[2];this.outputShape=e;let r="";typeof t=="number"?r=`float outputValue = ${t.toFixed(2)};`:r=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${r}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${s}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Voe={kernelName:Gg,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:s}=n,{radians:i,fillValue:r,center:a}=e,o=t,l=new zoe(s.shape,r),[c,u]=$v(a,s.shape[1],s.shape[2]),h=[[c,u,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(l,[s],s.dtype,h)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Woe=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Uoe=kt({opSnippet:Woe}),Boe={kernelName:ru,backendName:"webgl",kernelFunc:Uoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $oe="return inversesqrt(x);",Xoe=kt({opSnippet:$oe,cpuKernelImpl:hee}),Hoe={kernelName:au,backendName:"webgl",kernelFunc:Xoe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nA{constructor(e,t,s,i,r,a,o=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=Kt(r.length),c=Kt(a.length);let u="";s===1?u="i":s===2&&(u="i, j");const h=`getIndices(${u})`;let d="";i===1?d="i":i===2&&(d="i, coords[1]");const p=`getUpdates(${d})`,f=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${r});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${h});
              flattenedIndex += index * ${f};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Koe(n){const{inputs:e,backend:t,attrs:s}=n,{indices:i,updates:r}=e,{shape:a}=s,{sliceRank:o,numUpdates:l,sliceSize:c,strides:u,outputSize:h}=ku(r,i,a),d=[h/c,c];if(h===0)return t.makeTensorInfo(a,i.dtype);const p=Ne({inputs:{x:i},backend:t,attrs:{shape:[l,o]}}),f=Ne({inputs:{x:r},backend:t,attrs:{shape:[l,c]}}),y=t.makeTensorInfo([],"float32",new Float32Array([0])),m=new nA(l,o,p.shape.length,f.shape.length,u,d),g=t.runWebGLProgram(m,[f,p,y],f.dtype),b=Ne({inputs:{x:g},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(y),b}const Zoe={kernelName:Tg,backendName:"webgl",kernelFunc:Koe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yoe{constructor(e,t,s,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,s];const r="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=ee().getNumber("WEBGL_VERSION")===2?r:a,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function joe(n){const{inputs:e,backend:t,attrs:s}=n,{sortedSequence:i,values:r}=e,{side:a}=s,o=new Yoe(i.shape[0],i.shape[1],r.shape[1],a),l=[[i.shape[1]]];return t.runWebGLProgram(o,[i,r],"int32",l)}const Qoe={kernelName:_g,backendName:"webgl",kernelFunc:joe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Joe{constructor(e,t,s){this.variableNames=["c","a","b"],this.outputShape=t;let i,r;if(s>4)throw Error(`Where for rank ${s} is not yet supported`);if(s===1)r="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<t.length;u++)c.push(`${o[u]}`),u<e&&l.push(`${o[u]}`);i=l.join(),r=c.join()}const a=Kt(s);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${r}));
        } else {
          setOutput(getB(${r}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qoe(n){const{inputs:e,backend:t}=n,{condition:s,t:i,e:r}=e,a=new Joe(s.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(a,[s,i,r],Es(i.dtype,r.dtype))}const ele={kernelName:Fd,backendName:"webgl",kernelFunc:qoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tle=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${My};
  float scale = ${Cy};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,nle=kt({opSnippet:tle}),sle={kernelName:ou,backendName:"webgl",kernelFunc:nle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ile=Bu+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,rle=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,ale=kt({opSnippet:ile,packedOpSnippet:rle,cpuKernelImpl:pee}),ole={kernelName:hu,backendName:"webgl",kernelFunc:ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lle=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,cle=kt({opSnippet:lle}),ule={kernelName:uu,backendName:"webgl",kernelFunc:cle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hle=Bu+`
  return sin(x);
`,dle=kt({opSnippet:hle}),ple={kernelName:lu,backendName:"webgl",kernelFunc:dle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fle=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,mle=kt({opSnippet:fle}),gle={kernelName:cu,backendName:"webgl",kernelFunc:mle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yle=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,ble=kt({opSnippet:yle}),xle={kernelName:du,backendName:"webgl",kernelFunc:ble};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vle=n=>{const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{blockShape:r,paddings:a}=s;E(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=r.reduce((g,b)=>g*b),l=[[0,0]];l.push(...a);for(let g=1+r.length;g<i.shape.length;++g)l.push([0,0]);const c=[],u=eA({inputs:{x:i},backend:t,attrs:{paddings:l,constantValue:0}}),h=hp(u.shape,r,o,!1),d=dp(h.length,r.length,!1),p=pp(u.shape,r,o,!1),f=Ne({inputs:{x:u},backend:t,attrs:{shape:h}}),y=fs({inputs:{x:f},backend:t,attrs:{perm:d}}),m=Ne({inputs:{x:y},backend:t,attrs:{shape:p}});return c.push(u),c.push(f),c.push(y),c.forEach(g=>t.disposeIntermediateTensorInfo(g)),m},wle={kernelName:zd,backendName:"webgl",kernelFunc:vle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sle(n){const{inputs:e,backend:t}=n,{indices:s,values:i,denseShape:r,defaultValue:a}=e;if(r.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${r.shape}`);if(s.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${s.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(s.dataId),l=t.readSync(i.dataId),c=t.readSync(r.dataId),u=t.readSync(a.dataId)[0],[h,d,p,f,y]=mee(o,s.shape,s.dtype,l,i.dtype,c,u);return[t.makeTensorInfo(d,s.dtype,h),t.makeTensorInfo([d[0]],i.dtype,p),t.makeTensorInfo([f.length],"bool",new Uint8Array(f.map(m=>Number(m)))),t.makeTensorInfo([y.length],s.dtype,new Int32Array(y))]}const Tle={kernelName:Ig,backendName:"webgl",kernelFunc:Sle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _le(n){const{inputs:e,backend:t}=n,{inputIndices:s,inputShape:i,newShape:r}=e;if(s.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${s.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(r.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${r.shape}`);const a=Array.from(t.readSync(i.dataId)),o=t.readSync(s.dataId),l=Array.from(t.readSync(r.dataId)),[c,u,h]=gee(o,s.shape,s.dtype,a,l);return[t.makeTensorInfo(u,s.dtype,c),t.makeTensorInfo([h.length],r.dtype,new Int32Array(h))]}const Ile={kernelName:Mg,backendName:"webgl",kernelFunc:_le};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mle(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${r.shape}`);const a=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=IR(a,s.shape,s.dtype,o,l,!0);return t.makeTensorInfo(u,s.dtype,c)}const Cle={kernelName:Cg,backendName:"webgl",kernelFunc:Mle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ele(n){const{inputs:e,backend:t}=n,{data:s,indices:i,segmentIds:r}=e;if(s.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(r.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${r.shape}`);const a=t.readSync(s.dataId),o=t.readSync(i.dataId),l=t.readSync(r.dataId),[c,u]=IR(a,s.shape,s.dtype,o,l);return t.makeTensorInfo(u,s.dtype,c)}const kle={kernelName:Eg,backendName:"webgl",kernelFunc:Ele};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nle(n){const{inputs:e,backend:t,attrs:s}=n,{sparseIndices:i,sparseValues:r,defaultValue:a}=e,{outputShape:o}=s,{sliceRank:l,numUpdates:c,sliceSize:u,strides:h,outputSize:d}=ku(r,i,o),p=!1;if(r.dtype==="string"){const g=t.bufferSync(i),b=t.bufferSync(r),x=Br(t.readSync(a.dataId)[0]),v=dee(g,b,o,d,u,c,l,h,x,p);return t.makeTensorInfo(o,v.dtype,v.values)}const f=new nA(c,l,i.shape.length,r.shape.length,h,[d,1],p),y=t.runWebGLProgram(f,[r,i,a],r.dtype),m=Ne({inputs:{x:y},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(y),m}const Rle={kernelName:kg,backendName:"webgl",kernelFunc:Nle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ale(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{numOrSizeSplits:r,axis:a}=s,o=mt(a,i.shape)[0],l=rw(i,r,o),c=i.shape.length,u=new Array(c).fill(0),h=i.shape.slice();return l.map(d=>{const p=[...h];p[o]=d;const f=$u({inputs:{x:i},backend:t,attrs:{begin:u,size:p}});return u[o]+=d,f})}const Lle={kernelName:Vd,backendName:"webgl",kernelFunc:Ale};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NM="return sqrt(x);",Ple=kt({opSnippet:NM,packedOpSnippet:NM,cpuKernelImpl:yee}),Dle={kernelName:pu,backendName:"webgl",kernelFunc:Ple};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fle="return x * x;",Ole=kt({opSnippet:Fle}),Gle={kernelName:Ng,backendName:"webgl",kernelFunc:Ole};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RM="return (a - b) * (a - b);",zle=qn({opSnippet:RM,packedOpSnippet:RM}),Vle={kernelName:fu,backendName:"webgl",kernelFunc:zle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wle({inputs:n,attrs:e,backend:t}){const{x:s}=n,i=Mi+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,r=new or(s.shape,i);return t.runWebGLProgram(r,[s],s.dtype)}const Ule={kernelName:xu,backendName:"webgl",kernelFunc:Wle};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ble{constructor(e,t,s){this.variableNames=["x"],this.outputShape=s;const i=s.length,r=Kt(s.length),a=Kt(s.length);let o="";if(i===1)o="coords * strides + begin";else{let l=0;o=s.map((c,u)=>(l++,s.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${r} begin = ${r}(${e});
      ${r} strides = ${r}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $le(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{begin:r,end:a,strides:o,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=s,{finalShapeSparse:p,finalShape:f,isIdentity:y,sliceDim0:m,isSimpleSlice:g,begin:b,end:x,strides:v}=Wv(i.shape,r,a,o,l,c,u,h,d);let w;if(y)w=Ne({inputs:{x:i},backend:t,attrs:{shape:f}});else if(m||g){E(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const I=Gv(b,x,v),C=$u({inputs:{x:i},backend:t,attrs:{begin:b,size:I}});w=Ne({inputs:{x:C},backend:t,attrs:{shape:f}}),t.disposeIntermediateTensorInfo(C)}else if(t.shouldExecuteOnCPU([i])){const I=t.readSync(i.dataId),C=ut(i.shape,i.dtype,I),S=bee(p,C,v,b);w=t.makeTensorInfo(f,i.dtype,S.values)}else{const I=new Ble(b,v,p);w=t.runWebGLProgram(I,[i],i.dtype)}const _=Ne({inputs:{x:w},backend:t,attrs:{shape:f}});return t.disposeIntermediateTensorInfo(w),_}const Xle={kernelName:Rg,backendName:"webgl",kernelFunc:$le};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hle(n){const{inputs:e,backend:t,attrs:s}=n,{separator:i,nGramWidths:r,leftPad:a,rightPad:o,padWidth:l,preserveShortSequences:c}=s,{data:u,dataSplits:h}=e,d=t.readSync(u.dataId),p=t.readSync(h.dataId),[f,y]=xee(d,p,i,r,a,o,l,c);return[t.makeTensorInfo([f.length],"string",f),t.makeTensorInfo(h.shape,"int32",y)]}const Kle={kernelName:Ag,backendName:"webgl",kernelFunc:Hle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zle(n){const{inputs:e,backend:t,attrs:s}=n,{skipEmpty:i}=s,{input:r,delimiter:a}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(r.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${r.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(r.dataId),l=t.readSync(a.dataId)[0],[c,u,h]=vee(o,l,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",c),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(h))]}const Yle={kernelName:Lg,backendName:"webgl",kernelFunc:Zle};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jle(n){const{inputs:e,backend:t,attrs:s}=n,{numBuckets:i}=s,{input:r}=e;if(r.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(r.dataId),o=wee(a,i);return t.makeTensorInfo(r.shape,"int32",o)}const Qle={kernelName:Pg,backendName:"webgl",kernelFunc:jle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jle="return tan(x);",qle=kt({opSnippet:Jle}),ece={kernelName:gu,backendName:"webgl",kernelFunc:qle};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tce=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,nce=kt({opSnippet:tce}),sce={kernelName:yu,backendName:"webgl",kernelFunc:nce};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ice{constructor(e,t){this.variableNames=["A"];const s=new Array(e.length);for(let a=0;a<s.length;a++)s[a]=e[a]*t[a];this.outputShape=s,this.rank=s.length;const i=Kt(this.rank),r=rce(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${r}));
      }
    `}}function rce(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],s=[];for(let i=0;i<n.length;i++)s.push(`imod(${t[i]}, ${n[i]})`);return s.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sA(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{reps:r}=s;if(i.dtype==="string"||i.shape.length>5){const o=t.readSync(i.dataId),l=i.dtype==="string"?o.map(h=>Br(h)):o,c=ut(i.shape,i.dtype,l),u=Tee(c,r);return t.makeTensorInfo(u.shape,u.dtype,u.values)}const a=new ice(i.shape,r);return t.runWebGLProgram(a,[i],i.dtype)}const ace={kernelName:bu,backendName:"webgl",kernelFunc:sA};class oce{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class lce{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ao(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function AM(n){let e=1;for(;e<n;)e*=2;return e}function cce(n){const{inputs:e,backend:t,attrs:s}=n,{x:i}=e,{k:r,sorted:a}=s,o=ee().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ee().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(t.shouldExecuteOnCPU([i])||u<o||r>l){const S=t.readSync(i.dataId),[M,A]=_ee(S,c,i.dtype,r,a);return[t.makeTensorInfo(M.shape,M.dtype,M.values),t.makeTensorInfo(A.shape,A.dtype,A.values)]}if(r===0)return c[c.length-1]=0,[t.makeTensorInfo(c,i.dtype,[]),t.makeTensorInfo(c,"int32",[])];if(u===1)return[i,Np({attrs:{shape:c,dtype:"int32",value:0},backend:t})];const h=t.texData.get(i.dataId),d=h!==null&&h.isPacked,p=d?t.unpackTensor(i):i,f=re(c)/u,y=Ne({inputs:{x:p},attrs:{shape:[f,u]},backend:t});d&&ao(t,p);const m=AM(r),g=AM(u);let b=null;const x=()=>b===null?[y,y]:[y,b],v=(S,M,A)=>{const D=x(),F=new oce(A),k=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[S],[M]],P=b;b=t.runWebGLProgram(F,D,"int32",k),ao(t,P)};for(let S=1;S<m;S*=2){const M=S*2;for(let A=S;A>=1;A/=2)v(M,A,[f,g])}for(let S=g;S>m;S/=2){const M=x(),A=new lce([f,S/2]),D=[[u],[b===null?1:0],[m]],F=b;b=t.runWebGLProgram(A,M,"int32",D),ao(t,F);const k=m/2,P=k*2;for(let O=k;O>=1;O/=2)v(P,O,b.shape)}let w=b;b=$u({inputs:{x:b},backend:t,attrs:{begin:0,size:[f,r]}}),ao(t,w);let _=ZR({inputs:{x:y,indices:b},backend:t,attrs:{axis:1,batchDims:1}});ao(t,y);const I=c.slice(0,-1);I.push(r),w=b,b=Ne({inputs:{x:b},attrs:{shape:I},backend:t}),ao(t,w);const C=_;return _=Ne({inputs:{x:_},attrs:{shape:I},backend:t}),ao(t,C),[_,b]}const uce={kernelName:Dg,backendName:"webgl",kernelFunc:cce};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hce{constructor(e,t,s,i,r,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=s==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${r});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${r});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dce(n){const{inputs:e,backend:t,attrs:s}=n,{image:i,transforms:r}=e,{interpolation:a,fillMode:o,fillValue:l,outputShape:c}=s,[u,h,d,p]=i.shape,[f,y]=c??[h,d],m=[u,f,y,p],g=new hce(h,d,a,o,l,m);return t.runWebGLProgram(g,[i,r],"float32")}const pce={kernelName:Fg,backendName:"webgl",kernelFunc:dce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fce(n){const{inputs:e,attrs:t,backend:s}=n,{axis:i}=t,{x:r}=e;Ip(r,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=s.readSync(r.dataId),{outputValues:o,outputShape:l,indices:c}=Iee(a,i,r.shape,r.dtype);return[s.makeTensorInfo(l,r.dtype,o),s.makeTensorInfo([c.length],"int32",c)]}const mce={kernelName:Og,backendName:"webgl",kernelFunc:fce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gce(n){const{inputs:e,backend:t,attrs:s}=n,{value:i}=e;let{axis:r}=s;r<0&&(r+=i.shape.length);const a=i,o=a.shape.length,l=i.shape[r],c=new Array(o-1);let u=0;for(let y=0;y<o;y++)y!==r&&(c[u++]=a.shape[y]);const h=[],d=new Array(o).fill(0),p=a.shape.slice();p[r]=1;const f=new Array(l);for(let y=0;y<f.length;y++){d[r]=y;const m=$u({inputs:{x:a},backend:t,attrs:{begin:d,size:p}}),g=Ne({inputs:{x:m},backend:t,attrs:{shape:c}});f[y]=g,h.push(m)}return h.forEach(y=>t.disposeIntermediateTensorInfo(y)),f}const yce={kernelName:Ud,backendName:"webgl",kernelFunc:gce};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bce{constructor(e,t){this.variableNames=["x","segmentIds"];const s=e.windowSize,i=e.batchSize,r=e.inSize,a=e.numSegments,o=a*Math.ceil(r/s);this.outputShape=[i,o];const l="0.0",c="sumValue",u=Math.floor(s/4)*4,h=s%4,d=`
        sumValue += dot(values, segFilter);
    `;let p="";r%s>0&&(p=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return initializationValue;
        }
      `);let f="";r%s>0&&(f=`
        if (inIdx < 0 || inIdx >= ${r}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${f}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${s}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${h===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${h===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${h===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xce(n){const{inputs:e,backend:t,attrs:s}=n,{x:i,segmentIds:r}=e,{numSegments:a}=s,o=i.shape.length,l=[];let c=0;const u=un([c],o);let h=i;u!=null&&(h=fs({inputs:{x:i},backend:t,attrs:{perm:u}}),l.push(h),c=gn(1,o)[0]);const d=WE(h.shape,c,a),p=re([h.shape[c]]),f=Ne({inputs:{x:h},backend:t,attrs:{shape:[-1,p]}});l.push(f);const y=zg(i.dtype),m=(v,w,_,I,C)=>{const S=v.shape[0],M=v.shape[1],A=VE(M,C),D={windowSize:A,inSize:M,batchSize:S,numSegments:C},F=new bce(D,w),k=t.compileAndRun(F,[v,_],I);if(l.push(k),k.shape[1]===C)return k;const P=tA({backend:t,attrs:{start:0,stop:C,step:1,dtype:"float32"}}),O=sA({inputs:{x:P},backend:t,attrs:{reps:[M/A]}});return l.push(P),l.push(O),m(k,w,O,I,C)},g=m(f,"unsortedSegmentSum",r,y,a),b=Ne({inputs:{x:g},backend:t,attrs:{shape:d}});let x=b;if(u!=null){l.push(b);const v=Xa(u);x=fs({inputs:{x},backend:t,attrs:{perm:v}})}return l.forEach(v=>t.disposeIntermediateTensorInfo(v)),x}const vce={kernelName:Bd,backendName:"webgl",kernelFunc:xce};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wce=[gte,bte,wte,_te,Mte,kte,Rte,Lte,Ote,zte,Ute,Xte,Zte,Jte,tne,sne,rne,cne,hne,pne,yne,_ne,Mne,Ene,Pne,Fne,Vne,qee,Bne,Zne,Jne,ise,ase,lse,use,dse,mse,bse,wse,Tse,Ise,Cse,Nse,Ase,Fse,Gse,Wse,$se,Hse,jse,eie,iie,oie,uie,hie,pie,mie,yie,xie,wie,Iie,Eie,Rie,Lie,Fie,zie,Bie,Kie,Jee,Yie,Hne,Jie,tre,ire,tte,lre,dre,fre,bre,wre,Ire,Ere,Are,Fre,zre,Wre,Xre,Kre,Yre,qre,tae,sae,rae,oae,hae,mae,xae,Cae,ite,Rae,Pae,Oae,Vae,Nne,Bae,Xae,Kae,jae,eoe,ste,noe,ioe,aoe,loe,coe,Rne,Tae,doe,goe,voe,ate,_oe,Coe,Roe,Poe,Goe,Voe,Boe,Hoe,Zoe,Qoe,ele,sle,ole,ule,ple,gle,Sne,Iae,xle,wle,Tle,Ile,Cle,kle,Rle,Lle,Dle,Gle,Vle,Ule,Xle,Kle,Yle,Qle,_ae,pte,ece,sce,ace,uce,pce,fte,mce,yce,vce,$ae];for(const n of wce)As(n);const iA="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIFd0e2NvbnN0cnVjdG9yKG49W10sZT1RdCl7aWYodGhpcy5kYXRhPW4sdGhpcy5sZW5ndGg9dGhpcy5kYXRhLmxlbmd0aCx0aGlzLmNvbXBhcmU9ZSx0aGlzLmxlbmd0aD4wKWZvcihsZXQgdD0odGhpcy5sZW5ndGg+PjEpLTE7dD49MDt0LS0pdGhpcy5fZG93bih0KX1wdXNoKG4pe3RoaXMuZGF0YS5wdXNoKG4pLHRoaXMubGVuZ3RoKyssdGhpcy5fdXAodGhpcy5sZW5ndGgtMSl9cG9wKCl7aWYodGhpcy5sZW5ndGg9PT0wKXJldHVybjtjb25zdCBuPXRoaXMuZGF0YVswXSxlPXRoaXMuZGF0YS5wb3AoKTtyZXR1cm4gdGhpcy5sZW5ndGgtLSx0aGlzLmxlbmd0aD4wJiYodGhpcy5kYXRhWzBdPWUsdGhpcy5fZG93bigwKSksbn1wZWVrKCl7cmV0dXJuIHRoaXMuZGF0YVswXX1fdXAobil7Y29uc3R7ZGF0YTplLGNvbXBhcmU6dH09dGhpcyxzPWVbbl07Zm9yKDtuPjA7KXtjb25zdCByPW4tMT4+MSxpPWVbcl07aWYodChzLGkpPj0wKWJyZWFrO2Vbbl09aSxuPXJ9ZVtuXT1zfV9kb3duKG4pe2NvbnN0e2RhdGE6ZSxjb21wYXJlOnR9PXRoaXMscz10aGlzLmxlbmd0aD4+MSxyPWVbbl07Zm9yKDtuPHM7KXtsZXQgaT0objw8MSkrMSxoPWVbaV07Y29uc3QgbD1pKzE7aWYobDx0aGlzLmxlbmd0aCYmdChlW2xdLGgpPDAmJihpPWwsaD1lW2xdKSx0KGgscik+PTApYnJlYWs7ZVtuXT1oLG49aX1lW25dPXJ9fWZ1bmN0aW9uIFF0KG8sbil7cmV0dXJuIG88bj8tMTpvPm4/MTowfWNvbnN0IHl0PW89Pntjb25zdHt2MTpuLHYyOmV9PW87bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9KG5bc11eZVtzXSk+Pj4wO3QrPVp0KHIpfXJldHVybiB0fSxadD1vPT57dmFyIG49by0obz4+MSYxNDMxNjU1NzY1KTtyZXR1cm4gbj0obj4+MiY4NTg5OTM0NTkpKyhuJjg1ODk5MzQ1OSksbj0obj4+NCkrbiYyNTI2NDUxMzUsbj0obj4+OCkrbiYxNjcxMTkzNSxuPShuPj4xNikrbiY2NTUzNSxufSxjdD0xLHZ0PW89Pntjb25zdHtrZXl3aWR0aDpuLGtleWhlaWdodDplLHF1ZXJ5d2lkdGg6dCxxdWVyeWhlaWdodDpzLG1hdGNoZXM6cn09byxpPXQqMS4yLGg9LWksbD1zKjEuMix1PS1sLGY9MTIsZz0xMCxhPS0xLGo9MSx5PTEvTWF0aC5sb2coMTApLG09TWF0aC5tYXgobixlKSxNPU1hdGguZmxvb3Iobi8yKSxUPU1hdGguZmxvb3IoZS8yKSxFPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludC5zY2FsZSxLPXJbTl0ua2V5cG9pbnQuc2NhbGU7Sz09MCYmY29uc29sZS5sb2coIkVSUk9SIGRpdmlkZSB6ZXJvIik7Y29uc3Qgdj0kL0s7RS5wdXNoKHYqbSl9RS5zb3J0KChOLCQpPT5OLSQpO2NvbnN0IFI9LjI1KkVbTWF0aC5mbG9vcihFLmxlbmd0aC8yKS0oRS5sZW5ndGglMj09MD8xOjApLTFdLHE9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGktaCkvUikpLEk9TWF0aC5tYXgoNSxNYXRoLmNlaWwoKGwtdSkvUikpLHo9cSpJLEI9eipmLGM9W10scD1bXSxTPXt9O2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtjb25zdCAkPXJbTl0ucXVlcnlwb2ludCxLPXJbTl0ua2V5cG9pbnQse3g6dix5OlYsc2NhbGU6TCxhbmdsZTpDfT14dCh7cXVlcnlwb2ludDokLGtleXBvaW50Okssa2V5Y2VudGVyWDpNLGtleWNlbnRlclk6VCxzY2FsZU9uZU92ZXJMb2dLOnl9KTtpZih2PGh8fHY+PWl8fFY8dXx8Vj49bHx8Qzw9LU1hdGguUEl8fEM+TWF0aC5QSXx8TDxhfHxMPj1qKXtjW05dPSExO2NvbnRpbnVlfWxldCBYPXEqKHYtaCkvKGktaCksd3Q9SSooVi11KS8obC11KSxwdD1mKihDK01hdGguUEkpLygyKk1hdGguUEkpLGR0PWcqKEwtYSkvKGotYSk7cFtOXT17YmluWDpYLGJpblk6d3QsYmluQW5nbGU6cHQsYmluU2NhbGU6ZHR9O2xldCBpdD1NYXRoLmZsb29yKFgtLjUpLGx0PU1hdGguZmxvb3Iod3QtLjUpLGh0PU1hdGguZmxvb3IoZHQtLjUpLGp0PShNYXRoLmZsb29yKHB0LS41KStmKSVmO2lmKGl0PDB8fGl0KzE+PXF8fGx0PDB8fGx0KzE+PUl8fGh0PDB8fGh0KzE+PWcpe2NbTl09ITE7Y29udGludWV9Zm9yKGxldCB1dD0wO3V0PDI7dXQrKyl7bGV0IGt0PWl0K3V0O2ZvcihsZXQgYnQ9MDtidDwyO2J0Kyspe2xldCB1bj1sdCtidDtmb3IobGV0IEl0PTA7SXQ8MjtJdCsrKXtsZXQgY249KGp0K0l0KSVmO2ZvcihsZXQgUnQ9MDtSdDwyO1J0Kyspe2xldCBmbj1odCtSdDtjb25zdCBOdD1rdCt1bipxK2NuKnorZm4qQjtTW050XT09PXZvaWQgMCYmKFNbTnRdPTApLFNbTnRdKz0xfX19fWNbTl09ITB9bGV0IGQ9MCxEPS0xO2lmKE9iamVjdC5rZXlzKFMpLmZvckVhY2goTj0+e1NbTl0+ZCYmKGQ9U1tOXSxEPU4pfSksZDwzKXJldHVybltdO2NvbnN0IFU9TWF0aC5mbG9vcihEJUIleiVxKSxGPU1hdGguZmxvb3IoKEQtVSklQiV6L3EpLFA9TWF0aC5mbG9vcigoRC1VLUYqcSklQi96KSxZPU1hdGguZmxvb3IoKEQtVS1GKnEtUCp6KS9CKSxHPVtdO2ZvcihsZXQgTj0wO048ci5sZW5ndGg7TisrKXtpZighY1tOXSljb250aW51ZTtjb25zdCAkPXBbTl07aWYoTWF0aC5hYnMoJC5iaW5YLShVKy41KSk+PWN0fHxNYXRoLmFicygkLmJpblktKEYrLjUpKT49Y3R8fE1hdGguYWJzKCQuYmluU2NhbGUtKFkrLjUpKT49Y3QpY29udGludWU7Y29uc3QgTD1NYXRoLmFicygkLmJpbkFuZ2xlLShQKy41KSk7TWF0aC5taW4oTCxmLUwpPj1jdHx8Ry5wdXNoKHJbTl0pfXJldHVybiBHfSx4dD0oe3F1ZXJ5cG9pbnQ6byxrZXlwb2ludDpuLGtleWNlbnRlclg6ZSxrZXljZW50ZXJZOnQsc2NhbGVPbmVPdmVyTG9nSzpzfSk9PntsZXQgcj1vLmFuZ2xlLW4uYW5nbGU7cjw9LU1hdGguUEk/cis9MipNYXRoLlBJOnI+TWF0aC5QSSYmKHItPTIqTWF0aC5QSSk7Y29uc3QgaT1vLnNjYWxlL24uc2NhbGUsaD1pKk1hdGguY29zKHIpLGw9aSpNYXRoLnNpbihyKSx1PVtoLC1sLGwsaF0sZj1bdVswXSpuLngrdVsxXSpuLnksdVsyXSpuLngrdVszXSpuLnldLGc9by54LWZbMF0sYT1vLnktZlsxXTtyZXR1cm57eDp1WzBdKmUrdVsxXSp0K2cseTp1WzJdKmUrdVszXSp0K2EsYW5nbGU6cixzY2FsZTpNYXRoLmxvZyhpKSpzfX0sQXQ9T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztmdW5jdGlvbiBXKG8pe3JldHVybiBBdC5jYWxsKG8pLmVuZHNXaXRoKCJBcnJheV0iKX1mdW5jdGlvbiB0ZShvKXt2YXIgbj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06e307aWYoIVcobykpdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBiZSBhbiBhcnJheSIpO2lmKG8ubGVuZ3RoPT09MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJpbnB1dCBtdXN0IG5vdCBiZSBlbXB0eSIpO3ZhciBlPW4uZnJvbUluZGV4LHQ9ZT09PXZvaWQgMD8wOmUscz1uLnRvSW5kZXgscj1zPT09dm9pZCAwP28ubGVuZ3RoOnM7aWYodDwwfHx0Pj1vLmxlbmd0aHx8IU51bWJlci5pc0ludGVnZXIodCkpdGhyb3cgbmV3IEVycm9yKCJmcm9tSW5kZXggbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIgc21hbGxlciB0aGFuIGxlbmd0aCIpO2lmKHI8PXR8fHI+by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBFcnJvcigidG9JbmRleCBtdXN0IGJlIGFuIGludGVnZXIgZ3JlYXRlciB0aGFuIGZyb21JbmRleCBhbmQgYXQgbW9zdCBlcXVhbCB0byBsZW5ndGgiKTtmb3IodmFyIGk9b1t0XSxoPXQrMTtoPHI7aCsrKW9baF0+aSYmKGk9b1toXSk7cmV0dXJuIGl9ZnVuY3Rpb24gZWUobyl7dmFyIG49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O2lmKCFXKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKTt2YXIgZT1uLmZyb21JbmRleCx0PWU9PT12b2lkIDA/MDplLHM9bi50b0luZGV4LHI9cz09PXZvaWQgMD9vLmxlbmd0aDpzO2lmKHQ8MHx8dD49by5sZW5ndGh8fCFOdW1iZXIuaXNJbnRlZ2VyKHQpKXRocm93IG5ldyBFcnJvcigiZnJvbUluZGV4IG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIHNtYWxsZXIgdGhhbiBsZW5ndGgiKTtpZihyPD10fHxyPm8ubGVuZ3RofHwhTnVtYmVyLmlzSW50ZWdlcihyKSl0aHJvdyBuZXcgRXJyb3IoInRvSW5kZXggbXVzdCBiZSBhbiBpbnRlZ2VyIGdyZWF0ZXIgdGhhbiBmcm9tSW5kZXggYW5kIGF0IG1vc3QgZXF1YWwgdG8gbGVuZ3RoIik7Zm9yKHZhciBpPW9bdF0saD10KzE7aDxyO2grKylvW2hdPGkmJihpPW9baF0pO3JldHVybiBpfWZ1bmN0aW9uIHF0KG8pe3ZhciBuPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fTtpZihXKG8pKXtpZihvLmxlbmd0aD09PTApdGhyb3cgbmV3IFR5cGVFcnJvcigiaW5wdXQgbXVzdCBub3QgYmUgZW1wdHkiKX1lbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoImlucHV0IG11c3QgYmUgYW4gYXJyYXkiKTt2YXIgZTtpZihuLm91dHB1dCE9PXZvaWQgMCl7aWYoIVcobi5vdXRwdXQpKXRocm93IG5ldyBUeXBlRXJyb3IoIm91dHB1dCBvcHRpb24gbXVzdCBiZSBhbiBhcnJheSBpZiBzcGVjaWZpZWQiKTtlPW4ub3V0cHV0fWVsc2UgZT1uZXcgQXJyYXkoby5sZW5ndGgpO3ZhciB0PWVlKG8pLHM9dGUobyk7aWYodD09PXMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbmltdW0gYW5kIG1heGltdW0gaW5wdXQgdmFsdWVzIGFyZSBlcXVhbC4gQ2Fubm90IHJlc2NhbGUgYSBjb25zdGFudCBhcnJheSIpO3ZhciByPW4ubWluLGk9cj09PXZvaWQgMD9uLmF1dG9NaW5NYXg/dDowOnIsaD1uLm1heCxsPWg9PT12b2lkIDA/bi5hdXRvTWluTWF4P3M6MTpoO2lmKGk+PWwpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBvcHRpb24gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4IG9wdGlvbiIpO2Zvcih2YXIgdT0obC1pKS8ocy10KSxmPTA7ZjxvLmxlbmd0aDtmKyspZVtmXT0ob1tmXS10KSp1K2k7cmV0dXJuIGV9Y29uc3QgZnQ9IiAiLnJlcGVhdCgyKSxfdD0iICIucmVwZWF0KDQpO2Z1bmN0aW9uIG5lKCl7cmV0dXJuIFR0KHRoaXMpfWZ1bmN0aW9uIFR0KG8sbj17fSl7Y29uc3R7bWF4Um93czplPTE1LG1heENvbHVtbnM6dD0xMCxtYXhOdW1TaXplOnM9OCxwYWRNaW51czpyPSJhdXRvIn09bjtyZXR1cm5gJHtvLmNvbnN0cnVjdG9yLm5hbWV9IHsKJHtmdH1bCiR7X3R9JHtzZShvLGUsdCxzLHIpfQoke2Z0fV0KJHtmdH1yb3dzOiAke28ucm93c30KJHtmdH1jb2x1bW5zOiAke28uY29sdW1uc30KfWB9ZnVuY3Rpb24gc2UobyxuLGUsdCxzKXtjb25zdHtyb3dzOnIsY29sdW1uczppfT1vLGg9TWF0aC5taW4ocixuKSxsPU1hdGgubWluKGksZSksdT1bXTtpZihzPT09ImF1dG8iKXtzPSExO3Q6Zm9yKGxldCBmPTA7ZjxoO2YrKylmb3IobGV0IGc9MDtnPGw7ZysrKWlmKG8uZ2V0KGYsZyk8MCl7cz0hMDticmVhayB0fX1mb3IobGV0IGY9MDtmPGg7ZisrKXtsZXQgZz1bXTtmb3IobGV0IGE9MDthPGw7YSsrKWcucHVzaChvZShvLmdldChmLGEpLHQscykpO3UucHVzaChgJHtnLmpvaW4oIiAiKX1gKX1yZXR1cm4gbCE9PWkmJih1W3UubGVuZ3RoLTFdKz1gIC4uLiAke2ktZX0gbW9yZSBjb2x1bW5zYCksaCE9PXImJnUucHVzaChgLi4uICR7ci1ufSBtb3JlIHJvd3NgKSx1LmpvaW4oYAoke190fWApfWZ1bmN0aW9uIG9lKG8sbixlKXtyZXR1cm4obz49MCYmZT9gICR7enQobyxuLTEpfWA6enQobyxuKSkucGFkRW5kKG4pfWZ1bmN0aW9uIHp0KG8sbil7bGV0IGU9by50b1N0cmluZygpO2lmKGUubGVuZ3RoPD1uKXJldHVybiBlO2xldCB0PW8udG9GaXhlZChuKTtpZih0Lmxlbmd0aD5uJiYodD1vLnRvRml4ZWQoTWF0aC5tYXgoMCxuLSh0Lmxlbmd0aC1uKSkpKSx0Lmxlbmd0aDw9biYmIXQuc3RhcnRzV2l0aCgiMC4wMDAiKSYmIXQuc3RhcnRzV2l0aCgiLTAuMDAwIikpcmV0dXJuIHQ7bGV0IHM9by50b0V4cG9uZW50aWFsKG4pO3JldHVybiBzLmxlbmd0aD5uJiYocz1vLnRvRXhwb25lbnRpYWwoTWF0aC5tYXgoMCxuLShzLmxlbmd0aC1uKSkpKSxzLnNsaWNlKDApfWZ1bmN0aW9uIHJlKG8sbil7by5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5hZGRTKHQpOnRoaXMuYWRkTSh0KX0sby5wcm90b3R5cGUuYWRkUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpK3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5hZGRNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSt0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5hZGQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuYWRkKHMpfSxvLnByb3RvdHlwZS5zdWI9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnN1YlModCk6dGhpcy5zdWJNKHQpfSxvLnByb3RvdHlwZS5zdWJTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciktdCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLnN1Yk09ZnVuY3Rpb24odCl7aWYodD1uLmNoZWNrTWF0cml4KHQpLHRoaXMucm93cyE9PXQucm93c3x8dGhpcy5jb2x1bW5zIT09dC5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJNYXRyaWNlcyBkaW1lbnNpb25zIG11c3QgYmUgZXF1YWwiKTtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpLXQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnN1Yj1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5zdWIocyl9LG8ucHJvdG90eXBlLnN1YnRyYWN0PW8ucHJvdG90eXBlLnN1YixvLnByb3RvdHlwZS5zdWJ0cmFjdFM9by5wcm90b3R5cGUuc3ViUyxvLnByb3RvdHlwZS5zdWJ0cmFjdE09by5wcm90b3R5cGUuc3ViTSxvLnN1YnRyYWN0PW8uc3ViLG8ucHJvdG90eXBlLm11bD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMubXVsUyh0KTp0aGlzLm11bE0odCl9LG8ucHJvdG90eXBlLm11bFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSp0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubXVsTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikqdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ubXVsPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLm11bChzKX0sby5wcm90b3R5cGUubXVsdGlwbHk9by5wcm90b3R5cGUubXVsLG8ucHJvdG90eXBlLm11bHRpcGx5Uz1vLnByb3RvdHlwZS5tdWxTLG8ucHJvdG90eXBlLm11bHRpcGx5TT1vLnByb3RvdHlwZS5tdWxNLG8ubXVsdGlwbHk9by5tdWwsby5wcm90b3R5cGUuZGl2PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5kaXZTKHQpOnRoaXMuZGl2TSh0KX0sby5wcm90b3R5cGUuZGl2Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpL3QpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5kaXZNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKS90LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5kaXY9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuZGl2KHMpfSxvLnByb3RvdHlwZS5kaXZpZGU9by5wcm90b3R5cGUuZGl2LG8ucHJvdG90eXBlLmRpdmlkZVM9by5wcm90b3R5cGUuZGl2UyxvLnByb3RvdHlwZS5kaXZpZGVNPW8ucHJvdG90eXBlLmRpdk0sby5kaXZpZGU9by5kaXYsby5wcm90b3R5cGUubW9kPWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5tb2RTKHQpOnRoaXMubW9kTSh0KX0sby5wcm90b3R5cGUubW9kUz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpJXQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5tb2RNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSV0LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5tb2Q9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkubW9kKHMpfSxvLnByb3RvdHlwZS5tb2R1bHVzPW8ucHJvdG90eXBlLm1vZCxvLnByb3RvdHlwZS5tb2R1bHVzUz1vLnByb3RvdHlwZS5tb2RTLG8ucHJvdG90eXBlLm1vZHVsdXNNPW8ucHJvdG90eXBlLm1vZE0sby5tb2R1bHVzPW8ubW9kLG8ucHJvdG90eXBlLmFuZD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMuYW5kUyh0KTp0aGlzLmFuZE0odCl9LG8ucHJvdG90eXBlLmFuZFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKSZ0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUuYW5kTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscikmdC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8uYW5kPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLmFuZChzKX0sby5wcm90b3R5cGUub3I9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLm9yUyh0KTp0aGlzLm9yTSh0KX0sby5wcm90b3R5cGUub3JTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dCk7cmV0dXJuIHRoaXN9LG8ucHJvdG90eXBlLm9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscil8dC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ub3I9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkub3Iocyl9LG8ucHJvdG90eXBlLnhvcj1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMueG9yUyh0KTp0aGlzLnhvck0odCl9LG8ucHJvdG90eXBlLnhvclM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKV50KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUueG9yTT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMsciledC5nZXQocyxyKSk7cmV0dXJuIHRoaXN9LG8ueG9yPWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnhvcihzKX0sby5wcm90b3R5cGUubGVmdFNoaWZ0PWZ1bmN0aW9uKHQpe3JldHVybiB0eXBlb2YgdD09Im51bWJlciI/dGhpcy5sZWZ0U2hpZnRTKHQpOnRoaXMubGVmdFNoaWZ0TSh0KX0sby5wcm90b3R5cGUubGVmdFNoaWZ0Uz1mdW5jdGlvbih0KXtmb3IobGV0IHM9MDtzPHRoaXMucm93cztzKyspZm9yKGxldCByPTA7cjx0aGlzLmNvbHVtbnM7cisrKXRoaXMuc2V0KHMscix0aGlzLmdldChzLHIpPDx0KTtyZXR1cm4gdGhpc30sby5wcm90b3R5cGUubGVmdFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik8PHQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLmxlZnRTaGlmdD1mdW5jdGlvbih0LHMpe3JldHVybiBuZXcgbih0KS5sZWZ0U2hpZnQocyl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTKHQpOnRoaXMuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdE0odCl9LG8ucHJvdG90eXBlLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnRTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5zaWduUHJvcGFnYXRpbmdSaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+PnQuZ2V0KHMscikpO3JldHVybiB0aGlzfSxvLnNpZ25Qcm9wYWdhdGluZ1JpZ2h0U2hpZnQ9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkuc2lnblByb3BhZ2F0aW5nUmlnaHRTaGlmdChzKX0sby5wcm90b3R5cGUucmlnaHRTaGlmdD1mdW5jdGlvbih0KXtyZXR1cm4gdHlwZW9mIHQ9PSJudW1iZXIiP3RoaXMucmlnaHRTaGlmdFModCk6dGhpcy5yaWdodFNoaWZ0TSh0KX0sby5wcm90b3R5cGUucmlnaHRTaGlmdFM9ZnVuY3Rpb24odCl7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsdGhpcy5nZXQocyxyKT4+PnQpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5yaWdodFNoaWZ0TT1mdW5jdGlvbih0KXtpZih0PW4uY2hlY2tNYXRyaXgodCksdGhpcy5yb3dzIT09dC5yb3dzfHx0aGlzLmNvbHVtbnMhPT10LmNvbHVtbnMpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIk1hdHJpY2VzIGRpbWVuc2lvbnMgbXVzdCBiZSBlcXVhbCIpO2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLHRoaXMuZ2V0KHMscik+Pj50LmdldChzLHIpKTtyZXR1cm4gdGhpc30sby5yaWdodFNoaWZ0PWZ1bmN0aW9uKHQscyl7cmV0dXJuIG5ldyBuKHQpLnJpZ2h0U2hpZnQocyl9LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdD1vLnByb3RvdHlwZS5yaWdodFNoaWZ0LG8ucHJvdG90eXBlLnplcm9GaWxsUmlnaHRTaGlmdFM9by5wcm90b3R5cGUucmlnaHRTaGlmdFMsby5wcm90b3R5cGUuemVyb0ZpbGxSaWdodFNoaWZ0TT1vLnByb3RvdHlwZS5yaWdodFNoaWZ0TSxvLnplcm9GaWxsUmlnaHRTaGlmdD1vLnJpZ2h0U2hpZnQsby5wcm90b3R5cGUubm90PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsfnRoaXMuZ2V0KHQscykpO3JldHVybiB0aGlzfSxvLm5vdD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubm90KCl9LG8ucHJvdG90eXBlLmFicz1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYWJzKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hYnM9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFicygpfSxvLnByb3RvdHlwZS5hY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hY29zPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hY29zKCl9LG8ucHJvdG90eXBlLmFjb3NoPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5hY29zaCh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYWNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFjb3NoKCl9LG8ucHJvdG90eXBlLmFzaW49ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmFzaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmFzaW4oKX0sby5wcm90b3R5cGUuYXNpbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmFzaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5hc2luaD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXNpbmgoKX0sby5wcm90b3R5cGUuYXRhbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uYXRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuYXRhbigpfSxvLnByb3RvdHlwZS5hdGFuaD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguYXRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmF0YW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5hdGFuaCgpfSxvLnByb3RvdHlwZS5jYnJ0PWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jYnJ0KHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jYnJ0PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5jYnJ0KCl9LG8ucHJvdG90eXBlLmNlaWw9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNlaWwodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNlaWw9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNlaWwoKX0sby5wcm90b3R5cGUuY2x6MzI9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNsejMyKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5jbHozMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY2x6MzIoKX0sby5wcm90b3R5cGUuY29zPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5jb3ModGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvcz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuY29zKCl9LG8ucHJvdG90eXBlLmNvc2g9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmNvc2godGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmNvc2g9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmNvc2goKX0sby5wcm90b3R5cGUuZXhwPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHAodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLmV4cD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkuZXhwKCl9LG8ucHJvdG90eXBlLmV4cG0xPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5leHBtMSh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZXhwbTE9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmV4cG0xKCl9LG8ucHJvdG90eXBlLmZsb29yPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5mbG9vcih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8uZmxvb3I9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZsb29yKCl9LG8ucHJvdG90eXBlLmZyb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguZnJvdW5kKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5mcm91bmQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLmZyb3VuZCgpfSxvLnByb3RvdHlwZS5sb2c9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZyh0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5sb2coKX0sby5wcm90b3R5cGUubG9nMXA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzFwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxcD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMXAoKX0sby5wcm90b3R5cGUubG9nMTA9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLmxvZzEwKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5sb2cxMD1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMTAoKX0sby5wcm90b3R5cGUubG9nMj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgubG9nMih0aGlzLmdldCh0LHMpKSk7cmV0dXJuIHRoaXN9LG8ubG9nMj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkubG9nMigpfSxvLnByb3RvdHlwZS5yb3VuZD1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGgucm91bmQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnJvdW5kPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5yb3VuZCgpfSxvLnByb3RvdHlwZS5zaWduPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaWduKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaWduPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaWduKCl9LG8ucHJvdG90eXBlLnNpbj1mdW5jdGlvbigpe2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5zZXQodCxzLE1hdGguc2luKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW49ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNpbigpfSxvLnByb3RvdHlwZS5zaW5oPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC5zaW5oKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby5zaW5oPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgbih0KS5zaW5oKCl9LG8ucHJvdG90eXBlLnNxcnQ9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnNxcnQodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnNxcnQoKX0sby5wcm90b3R5cGUudGFuPWZ1bmN0aW9uKCl7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWZvcihsZXQgcz0wO3M8dGhpcy5jb2x1bW5zO3MrKyl0aGlzLnNldCh0LHMsTWF0aC50YW4odGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudGFuKCl9LG8ucHJvdG90eXBlLnRhbmg9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRhbmgodGhpcy5nZXQodCxzKSkpO3JldHVybiB0aGlzfSxvLnRhbmg9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBuKHQpLnRhbmgoKX0sby5wcm90b3R5cGUudHJ1bmM9ZnVuY3Rpb24oKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuc2V0KHQscyxNYXRoLnRydW5jKHRoaXMuZ2V0KHQscykpKTtyZXR1cm4gdGhpc30sby50cnVuYz1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IG4odCkudHJ1bmMoKX0sby5wb3c9ZnVuY3Rpb24odCxzKXtyZXR1cm4gbmV3IG4odCkucG93KHMpfSxvLnByb3RvdHlwZS5wb3c9ZnVuY3Rpb24odCl7cmV0dXJuIHR5cGVvZiB0PT0ibnVtYmVyIj90aGlzLnBvd1ModCk6dGhpcy5wb3dNKHQpfSxvLnByb3RvdHlwZS5wb3dTPWZ1bmN0aW9uKHQpe2ZvcihsZXQgcz0wO3M8dGhpcy5yb3dzO3MrKylmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspdGhpcy5zZXQocyxyLE1hdGgucG93KHRoaXMuZ2V0KHMsciksdCkpO3JldHVybiB0aGlzfSxvLnByb3RvdHlwZS5wb3dNPWZ1bmN0aW9uKHQpe2lmKHQ9bi5jaGVja01hdHJpeCh0KSx0aGlzLnJvd3MhPT10LnJvd3N8fHRoaXMuY29sdW1ucyE9PXQuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiTWF0cmljZXMgZGltZW5zaW9ucyBtdXN0IGJlIGVxdWFsIik7Zm9yKGxldCBzPTA7czx0aGlzLnJvd3M7cysrKWZvcihsZXQgcj0wO3I8dGhpcy5jb2x1bW5zO3IrKyl0aGlzLnNldChzLHIsTWF0aC5wb3codGhpcy5nZXQocyxyKSx0LmdldChzLHIpKSk7cmV0dXJuIHRoaXN9fWZ1bmN0aW9uIFEobyxuLGUpe2xldCB0PWU/by5yb3dzOm8ucm93cy0xO2lmKG48MHx8bj50KXRocm93IG5ldyBSYW5nZUVycm9yKCJSb3cgaW5kZXggb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gWihvLG4sZSl7bGV0IHQ9ZT9vLmNvbHVtbnM6by5jb2x1bW5zLTE7aWYobjwwfHxuPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIkNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UiKX1mdW5jdGlvbiB0dChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8uY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIGNvbHVtbnMiKTtyZXR1cm4gbn1mdW5jdGlvbiBldChvLG4pe2lmKG4udG8xREFycmF5JiYobj1uLnRvMURBcnJheSgpKSxuLmxlbmd0aCE9PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9yIHNpemUgbXVzdCBiZSB0aGUgc2FtZSBhcyB0aGUgbnVtYmVyIG9mIHJvd3MiKTtyZXR1cm4gbn1mdW5jdGlvbiBpZShvLG4pe2lmKCFXKG4pKXRocm93IG5ldyBUeXBlRXJyb3IoInJvdyBpbmRpY2VzIG11c3QgYmUgYW4gYXJyYXkiKTtmb3IobGV0IGU9MDtlPG4ubGVuZ3RoO2UrKylpZihuW2VdPDB8fG5bZV0+PW8ucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigicm93IGluZGljZXMgYXJlIG91dCBvZiByYW5nZSIpfWZ1bmN0aW9uIGxlKG8sbil7aWYoIVcobikpdGhyb3cgbmV3IFR5cGVFcnJvcigiY29sdW1uIGluZGljZXMgbXVzdCBiZSBhbiBhcnJheSIpO2ZvcihsZXQgZT0wO2U8bi5sZW5ndGg7ZSsrKWlmKG5bZV08MHx8bltlXT49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJjb2x1bW4gaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gRnQobyxuLGUsdCxzKXtpZihhcmd1bWVudHMubGVuZ3RoIT09NSl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiZXhwZWN0ZWQgNCBhcmd1bWVudHMiKTtpZihhdCgic3RhcnRSb3ciLG4pLGF0KCJlbmRSb3ciLGUpLGF0KCJzdGFydENvbHVtbiIsdCksYXQoImVuZENvbHVtbiIscyksbj5lfHx0PnN8fG48MHx8bj49by5yb3dzfHxlPDB8fGU+PW8ucm93c3x8dDwwfHx0Pj1vLmNvbHVtbnN8fHM8MHx8cz49by5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKCJTdWJtYXRyaXggaW5kaWNlcyBhcmUgb3V0IG9mIHJhbmdlIil9ZnVuY3Rpb24gZ3QobyxuPTApe2xldCBlPVtdO2ZvcihsZXQgdD0wO3Q8bzt0KyspZS5wdXNoKG4pO3JldHVybiBlfWZ1bmN0aW9uIGF0KG8sbil7aWYodHlwZW9mIG4hPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoYCR7b30gbXVzdCBiZSBhIG51bWJlcmApfWZ1bmN0aW9uIG50KG8pe2lmKG8uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiRW1wdHkgbWF0cml4IGhhcyBubyBlbGVtZW50cyB0byBpbmRleCIpfWZ1bmN0aW9uIGhlKG8pe2xldCBuPWd0KG8ucm93cyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW2VdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIHVlKG8pe2xldCBuPWd0KG8uY29sdW1ucyk7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7KytlKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zOysrdCluW3RdKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGNlKG8pe2xldCBuPTA7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKyluKz1vLmdldChlLHQpO3JldHVybiBufWZ1bmN0aW9uIGZlKG8pe2xldCBuPWd0KG8ucm93cywxKTtmb3IobGV0IGU9MDtlPG8ucm93czsrK2UpZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7Kyt0KW5bZV0qPW8uZ2V0KGUsdCk7cmV0dXJuIG59ZnVuY3Rpb24gZ2Uobyl7bGV0IG49Z3Qoby5jb2x1bW5zLDEpO2ZvcihsZXQgZT0wO2U8by5yb3dzOysrZSlmb3IobGV0IHQ9MDt0PG8uY29sdW1uczsrK3Qpblt0XSo9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBhZShvKXtsZXQgbj0xO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspbio9by5nZXQoZSx0KTtyZXR1cm4gbn1mdW5jdGlvbiBtZShvLG4sZSl7Y29uc3QgdD1vLnJvd3Mscz1vLmNvbHVtbnMscj1bXTtmb3IobGV0IGk9MDtpPHQ7aSsrKXtsZXQgaD0wLGw9MCx1PTA7Zm9yKGxldCBmPTA7ZjxzO2YrKyl1PW8uZ2V0KGksZiktZVtpXSxoKz11LGwrPXUqdTtuP3IucHVzaCgobC1oKmgvcykvKHMtMSkpOnIucHVzaCgobC1oKmgvcykvcyl9cmV0dXJuIHJ9ZnVuY3Rpb24gd2UobyxuLGUpe2NvbnN0IHQ9by5yb3dzLHM9by5jb2x1bW5zLHI9W107Zm9yKGxldCBpPTA7aTxzO2krKyl7bGV0IGg9MCxsPTAsdT0wO2ZvcihsZXQgZj0wO2Y8dDtmKyspdT1vLmdldChmLGkpLWVbaV0saCs9dSxsKz11KnU7bj9yLnB1c2goKGwtaCpoL3QpLyh0LTEpKTpyLnB1c2goKGwtaCpoL3QpL3QpfXJldHVybiByfWZ1bmN0aW9uIHBlKG8sbixlKXtjb25zdCB0PW8ucm93cyxzPW8uY29sdW1ucyxyPXQqcztsZXQgaT0wLGg9MCxsPTA7Zm9yKGxldCB1PTA7dTx0O3UrKylmb3IobGV0IGY9MDtmPHM7ZisrKWw9by5nZXQodSxmKS1lLGkrPWwsaCs9bCpsO3JldHVybiBuPyhoLWkqaS9yKS8oci0xKTooaC1pKmkvcikvcn1mdW5jdGlvbiBkZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCktbltlXSl9ZnVuY3Rpb24geWUobyxuKXtmb3IobGV0IGU9MDtlPG8ucm93cztlKyspZm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKW8uc2V0KGUsdCxvLmdldChlLHQpLW5bdF0pfWZ1bmN0aW9uIE1lKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS1uKX1mdW5jdGlvbiBFZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8uY29sdW1ucztzKyspdCs9TWF0aC5wb3coby5nZXQoZSxzKSwyKS8oby5jb2x1bW5zLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIFNlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW2VdKX1mdW5jdGlvbiBqZShvKXtjb25zdCBuPVtdO2ZvcihsZXQgZT0wO2U8by5jb2x1bW5zO2UrKyl7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPG8ucm93cztzKyspdCs9TWF0aC5wb3coby5nZXQocyxlKSwyKS8oby5yb3dzLTEpO24ucHVzaChNYXRoLnNxcnQodCkpfXJldHVybiBufWZ1bmN0aW9uIGtlKG8sbil7Zm9yKGxldCBlPTA7ZTxvLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8by5jb2x1bW5zO3QrKylvLnNldChlLHQsby5nZXQoZSx0KS9uW3RdKX1mdW5jdGlvbiBiZShvKXtjb25zdCBuPW8uc2l6ZS0xO2xldCBlPTA7Zm9yKGxldCB0PTA7dDxvLmNvbHVtbnM7dCsrKWZvcihsZXQgcz0wO3M8by5yb3dzO3MrKyllKz1NYXRoLnBvdyhvLmdldChzLHQpLDIpL247cmV0dXJuIE1hdGguc3FydChlKX1mdW5jdGlvbiBJZShvLG4pe2ZvcihsZXQgZT0wO2U8by5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PG8uY29sdW1uczt0Kyspby5zZXQoZSx0LG8uZ2V0KGUsdCkvbil9Y2xhc3MgX3tzdGF0aWMgZnJvbTFEQXJyYXkobixlLHQpe2lmKG4qZSE9PXQubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKCJkYXRhIGxlbmd0aCBkb2VzIG5vdCBtYXRjaCBnaXZlbiBkaW1lbnNpb25zIik7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHRbaSplK2hdKTtyZXR1cm4gcn1zdGF0aWMgcm93VmVjdG9yKG4pe2xldCBlPW5ldyBiKDEsbi5sZW5ndGgpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KDAsdCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgY29sdW1uVmVjdG9yKG4pe2xldCBlPW5ldyBiKG4ubGVuZ3RoLDEpO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWUuc2V0KHQsMCxuW3RdKTtyZXR1cm4gZX1zdGF0aWMgemVyb3MobixlKXtyZXR1cm4gbmV3IGIobixlKX1zdGF0aWMgb25lcyhuLGUpe3JldHVybiBuZXcgYihuLGUpLmZpbGwoMSl9c3RhdGljIHJhbmQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7cmFuZG9tOnM9TWF0aC5yYW5kb219PXQ7bGV0IHI9bmV3IGIobixlKTtmb3IobGV0IGk9MDtpPG47aSsrKWZvcihsZXQgaD0wO2g8ZTtoKyspci5zZXQoaSxoLHMoKSk7cmV0dXJuIHJ9c3RhdGljIHJhbmRJbnQobixlLHQ9e30pe2lmKHR5cGVvZiB0IT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7bWluOnM9MCxtYXg6cj0xZTMscmFuZG9tOmk9TWF0aC5yYW5kb219PXQ7aWYoIU51bWJlci5pc0ludGVnZXIocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWluIG11c3QgYmUgYW4gaW50ZWdlciIpO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKHIpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1heCBtdXN0IGJlIGFuIGludGVnZXIiKTtpZihzPj1yKXRocm93IG5ldyBSYW5nZUVycm9yKCJtaW4gbXVzdCBiZSBzbWFsbGVyIHRoYW4gbWF4Iik7bGV0IGg9ci1zLGw9bmV3IGIobixlKTtmb3IobGV0IHU9MDt1PG47dSsrKWZvcihsZXQgZj0wO2Y8ZTtmKyspe2xldCBnPXMrTWF0aC5yb3VuZChpKCkqaCk7bC5zZXQodSxmLGcpfXJldHVybiBsfXN0YXRpYyBleWUobixlLHQpe2U9PT12b2lkIDAmJihlPW4pLHQ9PT12b2lkIDAmJih0PTEpO2xldCBzPU1hdGgubWluKG4sZSkscj10aGlzLnplcm9zKG4sZSk7Zm9yKGxldCBpPTA7aTxzO2krKylyLnNldChpLGksdCk7cmV0dXJuIHJ9c3RhdGljIGRpYWcobixlLHQpe2xldCBzPW4ubGVuZ3RoO2U9PT12b2lkIDAmJihlPXMpLHQ9PT12b2lkIDAmJih0PWUpO2xldCByPU1hdGgubWluKHMsZSx0KSxpPXRoaXMuemVyb3MoZSx0KTtmb3IobGV0IGg9MDtoPHI7aCsrKWkuc2V0KGgsaCxuW2hdKTtyZXR1cm4gaX1zdGF0aWMgbWluKG4sZSl7bj10aGlzLmNoZWNrTWF0cml4KG4pLGU9dGhpcy5jaGVja01hdHJpeChlKTtsZXQgdD1uLnJvd3Mscz1uLmNvbHVtbnMscj1uZXcgYih0LHMpO2ZvcihsZXQgaT0wO2k8dDtpKyspZm9yKGxldCBoPTA7aDxzO2grKylyLnNldChpLGgsTWF0aC5taW4obi5nZXQoaSxoKSxlLmdldChpLGgpKSk7cmV0dXJuIHJ9c3RhdGljIG1heChuLGUpe249dGhpcy5jaGVja01hdHJpeChuKSxlPXRoaXMuY2hlY2tNYXRyaXgoZSk7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IHRoaXModCxzKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgaD0wO2g8cztoKyspci5zZXQoaSxoLE1hdGgubWF4KG4uZ2V0KGksaCksZS5nZXQoaSxoKSkpO3JldHVybiByfXN0YXRpYyBjaGVja01hdHJpeChuKXtyZXR1cm4gXy5pc01hdHJpeChuKT9uOm5ldyBiKG4pfXN0YXRpYyBpc01hdHJpeChuKXtyZXR1cm4gbiE9bnVsbCYmbi5rbGFzcz09PSJNYXRyaXgifWdldCBzaXplKCl7cmV0dXJuIHRoaXMucm93cyp0aGlzLmNvbHVtbnN9YXBwbHkobil7aWYodHlwZW9mIG4hPSJmdW5jdGlvbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigiY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uIik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyluLmNhbGwodGhpcyxlLHQpO3JldHVybiB0aGlzfXRvMURBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5wdXNoKHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXRvMkRBcnJheSgpe2xldCBuPVtdO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKyl7bi5wdXNoKFtdKTtmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspbltlXS5wdXNoKHRoaXMuZ2V0KGUsdCkpfXJldHVybiBufXRvSlNPTigpe3JldHVybiB0aGlzLnRvMkRBcnJheSgpfWlzUm93VmVjdG9yKCl7cmV0dXJuIHRoaXMucm93cz09PTF9aXNDb2x1bW5WZWN0b3IoKXtyZXR1cm4gdGhpcy5jb2x1bW5zPT09MX1pc1ZlY3Rvcigpe3JldHVybiB0aGlzLnJvd3M9PT0xfHx0aGlzLmNvbHVtbnM9PT0xfWlzU3F1YXJlKCl7cmV0dXJuIHRoaXMucm93cz09PXRoaXMuY29sdW1uc31pc0VtcHR5KCl7cmV0dXJuIHRoaXMucm93cz09PTB8fHRoaXMuY29sdW1ucz09PTB9aXNTeW1tZXRyaWMoKXtpZih0aGlzLmlzU3F1YXJlKCkpe2ZvcihsZXQgbj0wO248dGhpcy5yb3dzO24rKylmb3IobGV0IGU9MDtlPD1uO2UrKylpZih0aGlzLmdldChuLGUpIT09dGhpcy5nZXQoZSxuKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4hMX1pc0VjaGVsb25Gb3JtKCl7bGV0IG49MCxlPTAsdD0tMSxzPSEwLHI9ITE7Zm9yKDtuPHRoaXMucm93cyYmczspe2ZvcihlPTAscj0hMTtlPHRoaXMuY29sdW1ucyYmcj09PSExOyl0aGlzLmdldChuLGUpPT09MD9lKys6dGhpcy5nZXQobixlKT09PTEmJmU+dD8ocj0hMCx0PWUpOihzPSExLHI9ITApO24rK31yZXR1cm4gc31pc1JlZHVjZWRFY2hlbG9uRm9ybSgpe2xldCBuPTAsZT0wLHQ9LTEscz0hMCxyPSExO2Zvcig7bjx0aGlzLnJvd3MmJnM7KXtmb3IoZT0wLHI9ITE7ZTx0aGlzLmNvbHVtbnMmJnI9PT0hMTspdGhpcy5nZXQobixlKT09PTA/ZSsrOnRoaXMuZ2V0KG4sZSk9PT0xJiZlPnQ/KHI9ITAsdD1lKToocz0hMSxyPSEwKTtmb3IobGV0IGk9ZSsxO2k8dGhpcy5yb3dzO2krKyl0aGlzLmdldChuLGkpIT09MCYmKHM9ITEpO24rK31yZXR1cm4gc31lY2hlbG9uRm9ybSgpe2xldCBuPXRoaXMuY2xvbmUoKSxlPTAsdD0wO2Zvcig7ZTxuLnJvd3MmJnQ8bi5jb2x1bW5zOyl7bGV0IHM9ZTtmb3IobGV0IHI9ZTtyPG4ucm93cztyKyspbi5nZXQocix0KT5uLmdldChzLHQpJiYocz1yKTtpZihuLmdldChzLHQpPT09MCl0Kys7ZWxzZXtuLnN3YXBSb3dzKGUscyk7bGV0IHI9bi5nZXQoZSx0KTtmb3IobGV0IGk9dDtpPG4uY29sdW1ucztpKyspbi5zZXQoZSxpLG4uZ2V0KGUsaSkvcik7Zm9yKGxldCBpPWUrMTtpPG4ucm93cztpKyspe2xldCBoPW4uZ2V0KGksdCkvbi5nZXQoZSx0KTtuLnNldChpLHQsMCk7Zm9yKGxldCBsPXQrMTtsPG4uY29sdW1ucztsKyspbi5zZXQoaSxsLG4uZ2V0KGksbCktbi5nZXQoZSxsKSpoKX1lKyssdCsrfX1yZXR1cm4gbn1yZWR1Y2VkRWNoZWxvbkZvcm0oKXtsZXQgbj10aGlzLmVjaGVsb25Gb3JtKCksZT1uLmNvbHVtbnMsdD1uLnJvd3Mscz10LTE7Zm9yKDtzPj0wOylpZihuLm1heFJvdyhzKT09PTApcy0tO2Vsc2V7bGV0IHI9MCxpPSExO2Zvcig7cjx0JiZpPT09ITE7KW4uZ2V0KHMscik9PT0xP2k9ITA6cisrO2ZvcihsZXQgaD0wO2g8cztoKyspe2xldCBsPW4uZ2V0KGgscik7Zm9yKGxldCB1PXI7dTxlO3UrKyl7bGV0IGY9bi5nZXQoaCx1KS1sKm4uZ2V0KHMsdSk7bi5zZXQoaCx1LGYpfX1zLS19cmV0dXJuIG59c2V0KCl7dGhyb3cgbmV3IEVycm9yKCJzZXQgbWV0aG9kIGlzIHVuaW1wbGVtZW50ZWQiKX1nZXQoKXt0aHJvdyBuZXcgRXJyb3IoImdldCBtZXRob2QgaXMgdW5pbXBsZW1lbnRlZCIpfXJlcGVhdChuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e3Jvd3M6ZT0xLGNvbHVtbnM6dD0xfT1uO2lmKCFOdW1iZXIuaXNJbnRlZ2VyKGUpfHxlPD0wKXRocm93IG5ldyBUeXBlRXJyb3IoInJvd3MgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIiKTtpZighTnVtYmVyLmlzSW50ZWdlcih0KXx8dDw9MCl0aHJvdyBuZXcgVHlwZUVycm9yKCJjb2x1bW5zIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIik7bGV0IHM9bmV3IGIodGhpcy5yb3dzKmUsdGhpcy5jb2x1bW5zKnQpO2ZvcihsZXQgcj0wO3I8ZTtyKyspZm9yKGxldCBpPTA7aTx0O2krKylzLnNldFN1Yk1hdHJpeCh0aGlzLHRoaXMucm93cypyLHRoaXMuY29sdW1ucyppKTtyZXR1cm4gc31maWxsKG4pe2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LG4pO3JldHVybiB0aGlzfW5lZygpe3JldHVybiB0aGlzLm11bFMoLTEpfWdldFJvdyhuKXtRKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKWUucHVzaCh0aGlzLmdldChuLHQpKTtyZXR1cm4gZX1nZXRSb3dWZWN0b3Iobil7cmV0dXJuIGIucm93VmVjdG9yKHRoaXMuZ2V0Um93KG4pKX1zZXRSb3cobixlKXtRKHRoaXMsbiksZT10dCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsZVt0XSk7cmV0dXJuIHRoaXN9c3dhcFJvd3MobixlKXtRKHRoaXMsbiksUSh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl7bGV0IHM9dGhpcy5nZXQobix0KTt0aGlzLnNldChuLHQsdGhpcy5nZXQoZSx0KSksdGhpcy5zZXQoZSx0LHMpfXJldHVybiB0aGlzfWdldENvbHVtbihuKXtaKHRoaXMsbik7bGV0IGU9W107Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKWUucHVzaCh0aGlzLmdldCh0LG4pKTtyZXR1cm4gZX1nZXRDb2x1bW5WZWN0b3Iobil7cmV0dXJuIGIuY29sdW1uVmVjdG9yKHRoaXMuZ2V0Q29sdW1uKG4pKX1zZXRDb2x1bW4obixlKXtaKHRoaXMsbiksZT1ldCh0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLnNldCh0LG4sZVt0XSk7cmV0dXJuIHRoaXN9c3dhcENvbHVtbnMobixlKXtaKHRoaXMsbiksWih0aGlzLGUpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxuKTt0aGlzLnNldCh0LG4sdGhpcy5nZXQodCxlKSksdGhpcy5zZXQodCxlLHMpfXJldHVybiB0aGlzfWFkZFJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KStuW3RdKTtyZXR1cm4gdGhpc31zdWJSb3dWZWN0b3Iobil7bj10dCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCktblt0XSk7cmV0dXJuIHRoaXN9bXVsUm93VmVjdG9yKG4pe249dHQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpKm5bdF0pO3JldHVybiB0aGlzfWRpdlJvd1ZlY3RvcihuKXtuPXR0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KS9uW3RdKTtyZXR1cm4gdGhpc31hZGRDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkrbltlXSk7cmV0dXJuIHRoaXN9c3ViQ29sdW1uVmVjdG9yKG4pe249ZXQodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKXRoaXMuc2V0KGUsdCx0aGlzLmdldChlLHQpLW5bZV0pO3JldHVybiB0aGlzfW11bENvbHVtblZlY3RvcihuKXtuPWV0KHRoaXMsbik7Zm9yKGxldCBlPTA7ZTx0aGlzLnJvd3M7ZSsrKWZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChlLHQsdGhpcy5nZXQoZSx0KSpuW2VdKTtyZXR1cm4gdGhpc31kaXZDb2x1bW5WZWN0b3Iobil7bj1ldCh0aGlzLG4pO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspdGhpcy5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkvbltlXSk7cmV0dXJuIHRoaXN9bXVsUm93KG4sZSl7USh0aGlzLG4pO2ZvcihsZXQgdD0wO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLnNldChuLHQsdGhpcy5nZXQobix0KSplKTtyZXR1cm4gdGhpc31tdWxDb2x1bW4obixlKXtaKHRoaXMsbik7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXRoaXMuc2V0KHQsbix0aGlzLmdldCh0LG4pKmUpO3JldHVybiB0aGlzfW1heChuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5lW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk+ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1heEluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKT5uJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1pbihuKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gTmFOO3N3aXRjaChuKXtjYXNlInJvdyI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMucm93cykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3RdJiYoZVt0XT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlImNvbHVtbiI6e2NvbnN0IGU9bmV3IEFycmF5KHRoaXMuY29sdW1ucykuZmlsbChOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxlW3NdJiYoZVtzXT10aGlzLmdldCh0LHMpKTtyZXR1cm4gZX1jYXNlIHZvaWQgMDp7bGV0IGU9dGhpcy5nZXQoMCwwKTtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KHQscyk8ZSYmKGU9dGhpcy5nZXQodCxzKSk7cmV0dXJuIGV9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fW1pbkluZGV4KCl7bnQodGhpcyk7bGV0IG49dGhpcy5nZXQoMCwwKSxlPVswLDBdO2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKylmb3IobGV0IHM9MDtzPHRoaXMuY29sdW1ucztzKyspdGhpcy5nZXQodCxzKTxuJiYobj10aGlzLmdldCh0LHMpLGVbMF09dCxlWzFdPXMpO3JldHVybiBlfW1heFJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPmUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1heFJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk+ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1pblJvdyhuKXtpZihRKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldChuLDApO2ZvcihsZXQgdD0xO3Q8dGhpcy5jb2x1bW5zO3QrKyl0aGlzLmdldChuLHQpPGUmJihlPXRoaXMuZ2V0KG4sdCkpO3JldHVybiBlfW1pblJvd0luZGV4KG4pe1EodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldChuLDApLHQ9W24sMF07Zm9yKGxldCBzPTE7czx0aGlzLmNvbHVtbnM7cysrKXRoaXMuZ2V0KG4scyk8ZSYmKGU9dGhpcy5nZXQobixzKSx0WzFdPXMpO3JldHVybiB0fW1heENvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPmUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1heENvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik+ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fW1pbkNvbHVtbihuKXtpZihaKHRoaXMsbiksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIE5hTjtsZXQgZT10aGlzLmdldCgwLG4pO2ZvcihsZXQgdD0xO3Q8dGhpcy5yb3dzO3QrKyl0aGlzLmdldCh0LG4pPGUmJihlPXRoaXMuZ2V0KHQsbikpO3JldHVybiBlfW1pbkNvbHVtbkluZGV4KG4pe1oodGhpcyxuKSxudCh0aGlzKTtsZXQgZT10aGlzLmdldCgwLG4pLHQ9WzAsbl07Zm9yKGxldCBzPTE7czx0aGlzLnJvd3M7cysrKXRoaXMuZ2V0KHMsbik8ZSYmKGU9dGhpcy5nZXQocyxuKSx0WzBdPXMpO3JldHVybiB0fWRpYWcoKXtsZXQgbj1NYXRoLm1pbih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKSxlPVtdO2ZvcihsZXQgdD0wO3Q8bjt0KyspZS5wdXNoKHRoaXMuZ2V0KHQsdCkpO3JldHVybiBlfW5vcm0obj0iZnJvYmVuaXVzIil7bGV0IGU9MDtpZihuPT09Im1heCIpcmV0dXJuIHRoaXMubWF4KCk7aWYobj09PSJmcm9iZW5pdXMiKXtmb3IobGV0IHQ9MDt0PHRoaXMucm93czt0KyspZm9yKGxldCBzPTA7czx0aGlzLmNvbHVtbnM7cysrKWU9ZSt0aGlzLmdldCh0LHMpKnRoaXMuZ2V0KHQscyk7cmV0dXJuIE1hdGguc3FydChlKX1lbHNlIHRocm93IG5ldyBSYW5nZUVycm9yKGB1bmtub3duIG5vcm0gdHlwZTogJHtufWApfWN1bXVsYXRpdmVTdW0oKXtsZXQgbj0wO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbis9dGhpcy5nZXQoZSx0KSx0aGlzLnNldChlLHQsbik7cmV0dXJuIHRoaXN9ZG90KG4pe18uaXNNYXRyaXgobikmJihuPW4udG8xREFycmF5KCkpO2xldCBlPXRoaXMudG8xREFycmF5KCk7aWYoZS5sZW5ndGghPT1uLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcigidmVjdG9ycyBkbyBub3QgaGF2ZSB0aGUgc2FtZSBzaXplIik7bGV0IHQ9MDtmb3IobGV0IHM9MDtzPGUubGVuZ3RoO3MrKyl0Kz1lW3NdKm5bc107cmV0dXJuIHR9bW11bChuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5yb3dzLHQ9dGhpcy5jb2x1bW5zLHM9bi5jb2x1bW5zLHI9bmV3IGIoZSxzKSxpPW5ldyBGbG9hdDY0QXJyYXkodCk7Zm9yKGxldCBoPTA7aDxzO2grKyl7Zm9yKGxldCBsPTA7bDx0O2wrKylpW2xdPW4uZ2V0KGwsaCk7Zm9yKGxldCBsPTA7bDxlO2wrKyl7bGV0IHU9MDtmb3IobGV0IGY9MDtmPHQ7ZisrKXUrPXRoaXMuZ2V0KGwsZikqaVtmXTtyLnNldChsLGgsdSl9fXJldHVybiByfXN0cmFzc2VuMngyKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigyLDIpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPW4uZ2V0KDAsMCkscj10aGlzLmdldCgwLDEpLGk9bi5nZXQoMCwxKSxoPXRoaXMuZ2V0KDEsMCksbD1uLmdldCgxLDApLHU9dGhpcy5nZXQoMSwxKSxmPW4uZ2V0KDEsMSksZz0odCt1KSoocytmKSxhPShoK3UpKnMsaj10KihpLWYpLHc9dSoobC1zKSx5PSh0K3IpKmYsbT0oaC10KSoocytpKSxNPShyLXUpKihsK2YpLFQ9Zyt3LXkrTSxFPWoreSxrPWErdyxSPWctYStqK207cmV0dXJuIGUuc2V0KDAsMCxUKSxlLnNldCgwLDEsRSksZS5zZXQoMSwwLGspLGUuc2V0KDEsMSxSKSxlfXN0cmFzc2VuM3gzKG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT1uZXcgYigzLDMpO2NvbnN0IHQ9dGhpcy5nZXQoMCwwKSxzPXRoaXMuZ2V0KDAsMSkscj10aGlzLmdldCgwLDIpLGk9dGhpcy5nZXQoMSwwKSxoPXRoaXMuZ2V0KDEsMSksbD10aGlzLmdldCgxLDIpLHU9dGhpcy5nZXQoMiwwKSxmPXRoaXMuZ2V0KDIsMSksZz10aGlzLmdldCgyLDIpLGE9bi5nZXQoMCwwKSxqPW4uZ2V0KDAsMSksdz1uLmdldCgwLDIpLHk9bi5nZXQoMSwwKSxtPW4uZ2V0KDEsMSksTT1uLmdldCgxLDIpLFQ9bi5nZXQoMiwwKSxFPW4uZ2V0KDIsMSksaz1uLmdldCgyLDIpLFI9KHQrcytyLWktaC1mLWcpKm0scT0odC1pKSooLWorbSksST1oKigtYStqK3ktbS1NLVQrayksej0oLXQraStoKSooYS1qK20pLEI9KGkraCkqKC1hK2opLGM9dCphLHA9KC10K3UrZikqKGEtdytNKSxTPSgtdCt1KSoody1NKSxkPSh1K2YpKigtYSt3KSxEPSh0K3Mrci1oLWwtdS1mKSpNLFU9ZiooLWErdyt5LW0tTS1UK0UpLEY9KC1yK2YrZykqKG0rVC1FKSxQPShyLWcpKihtLUUpLFk9cipULEc9KGYrZykqKC1UK0UpLE49KC1yK2grbCkqKE0rVC1rKSwkPShyLWwpKihNLWspLEs9KGgrbCkqKC1UK2spLHY9cyp5LFY9bCpFLEw9aSp3LEM9dSpqLFg9ZyprLHd0PWMrWSt2LHB0PVIreitCK2MrRitZK0csZHQ9YytwK2QrRCtZK04rSyxpdD1xK0kreitjK1krTiskLGx0PXEreitCK2MrVixodD1ZK04rJCtLK0wsanQ9YytwK1MrVStGK1ArWSx1dD1GK1ArWStHK0Msa3Q9YytwK1MrZCtYO3JldHVybiBlLnNldCgwLDAsd3QpLGUuc2V0KDAsMSxwdCksZS5zZXQoMCwyLGR0KSxlLnNldCgxLDAsaXQpLGUuc2V0KDEsMSxsdCksZS5zZXQoMSwyLGh0KSxlLnNldCgyLDAsanQpLGUuc2V0KDIsMSx1dCksZS5zZXQoMiwyLGt0KSxlfW1tdWxTdHJhc3NlbihuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5jbG9uZSgpLHQ9ZS5yb3dzLHM9ZS5jb2x1bW5zLHI9bi5yb3dzLGk9bi5jb2x1bW5zO3MhPT1yJiZjb25zb2xlLndhcm4oYE11bHRpcGx5aW5nICR7dH0geCAke3N9IGFuZCAke3J9IHggJHtpfSBtYXRyaXg6IGRpbWVuc2lvbnMgZG8gbm90IG1hdGNoLmApO2Z1bmN0aW9uIGgoZyxhLGope2xldCB3PWcucm93cyx5PWcuY29sdW1ucztpZih3PT09YSYmeT09PWopcmV0dXJuIGc7e2xldCBtPV8uemVyb3MoYSxqKTtyZXR1cm4gbT1tLnNldFN1Yk1hdHJpeChnLDAsMCksbX19bGV0IGw9TWF0aC5tYXgodCxyKSx1PU1hdGgubWF4KHMsaSk7ZT1oKGUsbCx1KSxuPWgobixsLHUpO2Z1bmN0aW9uIGYoZyxhLGosdyl7aWYoajw9NTEyfHx3PD01MTIpcmV0dXJuIGcubW11bChhKTtqJTI9PT0xJiZ3JTI9PT0xPyhnPWgoZyxqKzEsdysxKSxhPWgoYSxqKzEsdysxKSk6aiUyPT09MT8oZz1oKGcsaisxLHcpLGE9aChhLGorMSx3KSk6dyUyPT09MSYmKGc9aChnLGosdysxKSxhPWgoYSxqLHcrMSkpO2xldCB5PXBhcnNlSW50KGcucm93cy8yLDEwKSxtPXBhcnNlSW50KGcuY29sdW1ucy8yLDEwKSxNPWcuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxUPWEuc3ViTWF0cml4KDAseS0xLDAsbS0xKSxFPWcuc3ViTWF0cml4KDAseS0xLG0sZy5jb2x1bW5zLTEpLGs9YS5zdWJNYXRyaXgoMCx5LTEsbSxhLmNvbHVtbnMtMSksUj1nLnN1Yk1hdHJpeCh5LGcucm93cy0xLDAsbS0xKSxxPWEuc3ViTWF0cml4KHksYS5yb3dzLTEsMCxtLTEpLEk9Zy5zdWJNYXRyaXgoeSxnLnJvd3MtMSxtLGcuY29sdW1ucy0xKSx6PWEuc3ViTWF0cml4KHksYS5yb3dzLTEsbSxhLmNvbHVtbnMtMSksQj1mKF8uYWRkKE0sSSksXy5hZGQoVCx6KSx5LG0pLGM9ZihfLmFkZChSLEkpLFQseSxtKSxwPWYoTSxfLnN1YihrLHopLHksbSksUz1mKEksXy5zdWIocSxUKSx5LG0pLGQ9ZihfLmFkZChNLEUpLHoseSxtKSxEPWYoXy5zdWIoUixNKSxfLmFkZChULGspLHksbSksVT1mKF8uc3ViKEUsSSksXy5hZGQocSx6KSx5LG0pLEY9Xy5hZGQoQixTKTtGLnN1YihkKSxGLmFkZChVKTtsZXQgUD1fLmFkZChwLGQpLFk9Xy5hZGQoYyxTKSxHPV8uc3ViKEIsYyk7Ry5hZGQocCksRy5hZGQoRCk7bGV0IE49Xy56ZXJvcygyKkYucm93cywyKkYuY29sdW1ucyk7cmV0dXJuIE49Ti5zZXRTdWJNYXRyaXgoRiwwLDApLE49Ti5zZXRTdWJNYXRyaXgoUCxGLnJvd3MsMCksTj1OLnNldFN1Yk1hdHJpeChZLDAsRi5jb2x1bW5zKSxOPU4uc2V0U3ViTWF0cml4KEcsRi5yb3dzLEYuY29sdW1ucyksTi5zdWJNYXRyaXgoMCxqLTEsMCx3LTEpfXJldHVybiBmKGUsbixsLHUpfXNjYWxlUm93cyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMucm93cztyKyspe2NvbnN0IGk9dGhpcy5nZXRSb3cocik7aS5sZW5ndGg+MCYmcXQoaSx7bWluOmUsbWF4OnQsb3V0cHV0Oml9KSxzLnNldFJvdyhyLGkpfXJldHVybiBzfXNjYWxlQ29sdW1ucyhuPXt9KXtpZih0eXBlb2YgbiE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e21pbjplPTAsbWF4OnQ9MX09bjtpZighTnVtYmVyLmlzRmluaXRlKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoIm1pbiBtdXN0IGJlIGEgbnVtYmVyIik7aWYoIU51bWJlci5pc0Zpbml0ZSh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtYXggbXVzdCBiZSBhIG51bWJlciIpO2lmKGU+PXQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoIm1pbiBtdXN0IGJlIHNtYWxsZXIgdGhhbiBtYXgiKTtsZXQgcz1uZXcgYih0aGlzLnJvd3MsdGhpcy5jb2x1bW5zKTtmb3IobGV0IHI9MDtyPHRoaXMuY29sdW1ucztyKyspe2NvbnN0IGk9dGhpcy5nZXRDb2x1bW4ocik7aS5sZW5ndGgmJnF0KGkse21pbjplLG1heDp0LG91dHB1dDppfSkscy5zZXRDb2x1bW4ocixpKX1yZXR1cm4gc31mbGlwUm93cygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMuY29sdW1ucy8yKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQoZSx0KSxyPXRoaXMuZ2V0KGUsdGhpcy5jb2x1bW5zLTEtdCk7dGhpcy5zZXQoZSx0LHIpLHRoaXMuc2V0KGUsdGhpcy5jb2x1bW5zLTEtdCxzKX1yZXR1cm4gdGhpc31mbGlwQ29sdW1ucygpe2NvbnN0IG49TWF0aC5jZWlsKHRoaXMucm93cy8yKTtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspZm9yKGxldCB0PTA7dDxuO3QrKyl7bGV0IHM9dGhpcy5nZXQodCxlKSxyPXRoaXMuZ2V0KHRoaXMucm93cy0xLXQsZSk7dGhpcy5zZXQodCxlLHIpLHRoaXMuc2V0KHRoaXMucm93cy0xLXQsZSxzKX1yZXR1cm4gdGhpc31rcm9uZWNrZXJQcm9kdWN0KG4pe249Yi5jaGVja01hdHJpeChuKTtsZXQgZT10aGlzLnJvd3MsdD10aGlzLmNvbHVtbnMscz1uLnJvd3Mscj1uLmNvbHVtbnMsaT1uZXcgYihlKnMsdCpyKTtmb3IobGV0IGg9MDtoPGU7aCsrKWZvcihsZXQgbD0wO2w8dDtsKyspZm9yKGxldCB1PTA7dTxzO3UrKylmb3IobGV0IGY9MDtmPHI7ZisrKWkuc2V0KHMqaCt1LHIqbCtmLHRoaXMuZ2V0KGgsbCkqbi5nZXQodSxmKSk7cmV0dXJuIGl9a3JvbmVja2VyU3VtKG4pe2lmKG49Yi5jaGVja01hdHJpeChuKSwhdGhpcy5pc1NxdWFyZSgpfHwhbi5pc1NxdWFyZSgpKXRocm93IG5ldyBFcnJvcigiS3JvbmVja2VyIFN1bSBuZWVkcyB0d28gU3F1YXJlIE1hdHJpY2VzIik7bGV0IGU9dGhpcy5yb3dzLHQ9bi5yb3dzLHM9dGhpcy5rcm9uZWNrZXJQcm9kdWN0KGIuZXllKHQsdCkpLHI9Yi5leWUoZSxlKS5rcm9uZWNrZXJQcm9kdWN0KG4pO3JldHVybiBzLmFkZChyKX10cmFuc3Bvc2UoKXtsZXQgbj1uZXcgYih0aGlzLmNvbHVtbnMsdGhpcy5yb3dzKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspZm9yKGxldCB0PTA7dDx0aGlzLmNvbHVtbnM7dCsrKW4uc2V0KHQsZSx0aGlzLmdldChlLHQpKTtyZXR1cm4gbn1zb3J0Um93cyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspdGhpcy5zZXRSb3coZSx0aGlzLmdldFJvdyhlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zb3J0Q29sdW1ucyhuPVB0KXtmb3IobGV0IGU9MDtlPHRoaXMuY29sdW1ucztlKyspdGhpcy5zZXRDb2x1bW4oZSx0aGlzLmdldENvbHVtbihlKS5zb3J0KG4pKTtyZXR1cm4gdGhpc31zdWJNYXRyaXgobixlLHQscyl7RnQodGhpcyxuLGUsdCxzKTtsZXQgcj1uZXcgYihlLW4rMSxzLXQrMSk7Zm9yKGxldCBpPW47aTw9ZTtpKyspZm9yKGxldCBoPXQ7aDw9cztoKyspci5zZXQoaS1uLGgtdCx0aGlzLmdldChpLGgpKTtyZXR1cm4gcn1zdWJNYXRyaXhSb3cobixlLHQpe2lmKGU9PT12b2lkIDAmJihlPTApLHQ9PT12b2lkIDAmJih0PXRoaXMuY29sdW1ucy0xKSxlPnR8fGU8MHx8ZT49dGhpcy5jb2x1bW5zfHx0PDB8fHQ+PXRoaXMuY29sdW1ucyl0aHJvdyBuZXcgUmFuZ2VFcnJvcigiQXJndW1lbnQgb3V0IG9mIHJhbmdlIik7bGV0IHM9bmV3IGIobi5sZW5ndGgsdC1lKzEpO2ZvcihsZXQgcj0wO3I8bi5sZW5ndGg7cisrKWZvcihsZXQgaT1lO2k8PXQ7aSsrKXtpZihuW3JdPDB8fG5bcl0+PXRoaXMucm93cyl0aHJvdyBuZXcgUmFuZ2VFcnJvcihgUm93IGluZGV4IG91dCBvZiByYW5nZTogJHtuW3JdfWApO3Muc2V0KHIsaS1lLHRoaXMuZ2V0KG5bcl0saSkpfXJldHVybiBzfXN1Yk1hdHJpeENvbHVtbihuLGUsdCl7aWYoZT09PXZvaWQgMCYmKGU9MCksdD09PXZvaWQgMCYmKHQ9dGhpcy5yb3dzLTEpLGU+dHx8ZTwwfHxlPj10aGlzLnJvd3N8fHQ8MHx8dD49dGhpcy5yb3dzKXRocm93IG5ldyBSYW5nZUVycm9yKCJBcmd1bWVudCBvdXQgb2YgcmFuZ2UiKTtsZXQgcz1uZXcgYih0LWUrMSxuLmxlbmd0aCk7Zm9yKGxldCByPTA7cjxuLmxlbmd0aDtyKyspZm9yKGxldCBpPWU7aTw9dDtpKyspe2lmKG5bcl08MHx8bltyXT49dGhpcy5jb2x1bW5zKXRocm93IG5ldyBSYW5nZUVycm9yKGBDb2x1bW4gaW5kZXggb3V0IG9mIHJhbmdlOiAke25bcl19YCk7cy5zZXQoaS1lLHIsdGhpcy5nZXQoaSxuW3JdKSl9cmV0dXJuIHN9c2V0U3ViTWF0cml4KG4sZSx0KXtpZihuPWIuY2hlY2tNYXRyaXgobiksbi5pc0VtcHR5KCkpcmV0dXJuIHRoaXM7bGV0IHM9ZStuLnJvd3MtMSxyPXQrbi5jb2x1bW5zLTE7RnQodGhpcyxlLHMsdCxyKTtmb3IobGV0IGk9MDtpPG4ucm93cztpKyspZm9yKGxldCBoPTA7aDxuLmNvbHVtbnM7aCsrKXRoaXMuc2V0KGUraSx0K2gsbi5nZXQoaSxoKSk7cmV0dXJuIHRoaXN9c2VsZWN0aW9uKG4sZSl7aWUodGhpcyxuKSxsZSh0aGlzLGUpO2xldCB0PW5ldyBiKG4ubGVuZ3RoLGUubGVuZ3RoKTtmb3IobGV0IHM9MDtzPG4ubGVuZ3RoO3MrKyl7bGV0IHI9bltzXTtmb3IobGV0IGk9MDtpPGUubGVuZ3RoO2krKyl7bGV0IGg9ZVtpXTt0LnNldChzLGksdGhpcy5nZXQocixoKSl9fXJldHVybiB0fXRyYWNlKCl7bGV0IG49TWF0aC5taW4odGhpcy5yb3dzLHRoaXMuY29sdW1ucyksZT0wO2ZvcihsZXQgdD0wO3Q8bjt0KyspZSs9dGhpcy5nZXQodCx0KTtyZXR1cm4gZX1jbG9uZSgpe2xldCBuPW5ldyBiKHRoaXMucm93cyx0aGlzLmNvbHVtbnMpO2ZvcihsZXQgZT0wO2U8dGhpcy5yb3dzO2UrKylmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0Kyspbi5zZXQoZSx0LHRoaXMuZ2V0KGUsdCkpO3JldHVybiBufXN1bShuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBoZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIHVlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBjZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19cHJvZHVjdChuKXtzd2l0Y2gobil7Y2FzZSJyb3ciOnJldHVybiBmZSh0aGlzKTtjYXNlImNvbHVtbiI6cmV0dXJuIGdlKHRoaXMpO2Nhc2Ugdm9pZCAwOnJldHVybiBhZSh0aGlzKTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19bWVhbihuKXtjb25zdCBlPXRoaXMuc3VtKG4pO3N3aXRjaChuKXtjYXNlInJvdyI6e2ZvcihsZXQgdD0wO3Q8dGhpcy5yb3dzO3QrKyllW3RdLz10aGlzLmNvbHVtbnM7cmV0dXJuIGV9Y2FzZSJjb2x1bW4iOntmb3IobGV0IHQ9MDt0PHRoaXMuY29sdW1uczt0KyspZVt0XS89dGhpcy5yb3dzO3JldHVybiBlfWNhc2Ugdm9pZCAwOnJldHVybiBlL3RoaXMuc2l6ZTtkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgaW52YWxpZCBvcHRpb246ICR7bn1gKX19dmFyaWFuY2UobixlPXt9KXtpZih0eXBlb2Ygbj09Im9iamVjdCImJihlPW4sbj12b2lkIDApLHR5cGVvZiBlIT0ib2JqZWN0Iil0aHJvdyBuZXcgVHlwZUVycm9yKCJvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Iik7Y29uc3R7dW5iaWFzZWQ6dD0hMCxtZWFuOnM9dGhpcy5tZWFuKG4pfT1lO2lmKHR5cGVvZiB0IT0iYm9vbGVhbiIpdGhyb3cgbmV3IFR5cGVFcnJvcigidW5iaWFzZWQgbXVzdCBiZSBhIGJvb2xlYW4iKTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyhzKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJtZWFuIG11c3QgYmUgYW4gYXJyYXkiKTtyZXR1cm4gbWUodGhpcyx0LHMpfWNhc2UiY29sdW1uIjp7aWYoIVcocykpdGhyb3cgbmV3IFR5cGVFcnJvcigibWVhbiBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIHdlKHRoaXMsdCxzKX1jYXNlIHZvaWQgMDp7aWYodHlwZW9mIHMhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIm1lYW4gbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBwZSh0aGlzLHQscyl9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXN0YW5kYXJkRGV2aWF0aW9uKG4sZSl7dHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKTtjb25zdCB0PXRoaXMudmFyaWFuY2UobixlKTtpZihuPT09dm9pZCAwKXJldHVybiBNYXRoLnNxcnQodCk7Zm9yKGxldCBzPTA7czx0Lmxlbmd0aDtzKyspdFtzXT1NYXRoLnNxcnQodFtzXSk7cmV0dXJuIHR9Y2VudGVyKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2NvbnN0e2NlbnRlcjp0PXRoaXMubWVhbihuKX09ZTtzd2l0Y2gobil7Y2FzZSJyb3ciOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBkZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiB5ZSh0aGlzLHQpLHRoaXN9Y2FzZSB2b2lkIDA6e2lmKHR5cGVvZiB0IT0ibnVtYmVyIil0aHJvdyBuZXcgVHlwZUVycm9yKCJjZW50ZXIgbXVzdCBiZSBhIG51bWJlciIpO3JldHVybiBNZSh0aGlzLHQpLHRoaXN9ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgb3B0aW9uOiAke259YCl9fXNjYWxlKG4sZT17fSl7aWYodHlwZW9mIG49PSJvYmplY3QiJiYoZT1uLG49dm9pZCAwKSx0eXBlb2YgZSE9Im9iamVjdCIpdGhyb3cgbmV3IFR5cGVFcnJvcigib3B0aW9ucyBtdXN0IGJlIGFuIG9iamVjdCIpO2xldCB0PWUuc2NhbGU7c3dpdGNoKG4pe2Nhc2Uicm93Ijp7aWYodD09PXZvaWQgMCl0PUVlKHRoaXMpO2Vsc2UgaWYoIVcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcigic2NhbGUgbXVzdCBiZSBhbiBhcnJheSIpO3JldHVybiBTZSh0aGlzLHQpLHRoaXN9Y2FzZSJjb2x1bW4iOntpZih0PT09dm9pZCAwKXQ9amUodGhpcyk7ZWxzZSBpZighVyh0KSl0aHJvdyBuZXcgVHlwZUVycm9yKCJzY2FsZSBtdXN0IGJlIGFuIGFycmF5Iik7cmV0dXJuIGtlKHRoaXMsdCksdGhpc31jYXNlIHZvaWQgMDp7aWYodD09PXZvaWQgMCl0PWJlKHRoaXMpO2Vsc2UgaWYodHlwZW9mIHQhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoInNjYWxlIG11c3QgYmUgYSBudW1iZXIiKTtyZXR1cm4gSWUodGhpcyx0KSx0aGlzfWRlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIG9wdGlvbjogJHtufWApfX10b1N0cmluZyhuKXtyZXR1cm4gVHQodGhpcyxuKX19Xy5wcm90b3R5cGUua2xhc3M9Ik1hdHJpeCIsdHlwZW9mIFN5bWJvbDwidSImJihfLnByb3RvdHlwZVtTeW1ib2wuZm9yKCJub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbSIpXT1uZSk7ZnVuY3Rpb24gUHQobyxuKXtyZXR1cm4gby1ufWZ1bmN0aW9uIFJlKG8pe3JldHVybiBvLmV2ZXJ5KG49PnR5cGVvZiBuPT0ibnVtYmVyIil9Xy5yYW5kb209Xy5yYW5kLF8ucmFuZG9tSW50PV8ucmFuZEludCxfLmRpYWdvbmFsPV8uZGlhZyxfLnByb3RvdHlwZS5kaWFnb25hbD1fLnByb3RvdHlwZS5kaWFnLF8uaWRlbnRpdHk9Xy5leWUsXy5wcm90b3R5cGUubmVnYXRlPV8ucHJvdG90eXBlLm5lZyxfLnByb3RvdHlwZS50ZW5zb3JQcm9kdWN0PV8ucHJvdG90eXBlLmtyb25lY2tlclByb2R1Y3Q7Y2xhc3MgYiBleHRlbmRzIF97Y29uc3RydWN0b3IobixlKXtpZihzdXBlcigpLGIuaXNNYXRyaXgobikpcmV0dXJuIG4uY2xvbmUoKTtpZihOdW1iZXIuaXNJbnRlZ2VyKG4pJiZuPj0wKWlmKHRoaXMuZGF0YT1bXSxOdW1iZXIuaXNJbnRlZ2VyKGUpJiZlPj0wKWZvcihsZXQgdD0wO3Q8bjt0KyspdGhpcy5kYXRhLnB1c2gobmV3IEZsb2F0NjRBcnJheShlKSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJuQ29sdW1ucyBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciIpO2Vsc2UgaWYoVyhuKSl7Y29uc3QgdD1uO2lmKG49dC5sZW5ndGgsZT1uP3RbMF0ubGVuZ3RoOjAsdHlwZW9mIGUhPSJudW1iZXIiKXRocm93IG5ldyBUeXBlRXJyb3IoIkRhdGEgbXVzdCBiZSBhIDJEIGFycmF5IHdpdGggYXQgbGVhc3Qgb25lIGVsZW1lbnQiKTt0aGlzLmRhdGE9W107Zm9yKGxldCBzPTA7czxuO3MrKyl7aWYodFtzXS5sZW5ndGghPT1lKXRocm93IG5ldyBSYW5nZUVycm9yKCJJbmNvbnNpc3RlbnQgYXJyYXkgZGltZW5zaW9ucyIpO2lmKCFSZSh0W3NdKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbnB1dCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyIpO3RoaXMuZGF0YS5wdXNoKEZsb2F0NjRBcnJheS5mcm9tKHRbc10pKX19ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyIG9yIGFuIGFycmF5Iik7dGhpcy5yb3dzPW4sdGhpcy5jb2x1bW5zPWV9c2V0KG4sZSx0KXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdPXQsdGhpc31nZXQobixlKXtyZXR1cm4gdGhpcy5kYXRhW25dW2VdfXJlbW92ZVJvdyhuKXtyZXR1cm4gUSh0aGlzLG4pLHRoaXMuZGF0YS5zcGxpY2UobiwxKSx0aGlzLnJvd3MtPTEsdGhpc31hZGRSb3cobixlKXtyZXR1cm4gZT09PXZvaWQgMCYmKGU9bixuPXRoaXMucm93cyksUSh0aGlzLG4sITApLGU9RmxvYXQ2NEFycmF5LmZyb20odHQodGhpcyxlKSksdGhpcy5kYXRhLnNwbGljZShuLDAsZSksdGhpcy5yb3dzKz0xLHRoaXN9cmVtb3ZlQ29sdW1uKG4pe1oodGhpcyxuKTtmb3IobGV0IGU9MDtlPHRoaXMucm93cztlKyspe2NvbnN0IHQ9bmV3IEZsb2F0NjRBcnJheSh0aGlzLmNvbHVtbnMtMSk7Zm9yKGxldCBzPTA7czxuO3MrKyl0W3NdPXRoaXMuZGF0YVtlXVtzXTtmb3IobGV0IHM9bisxO3M8dGhpcy5jb2x1bW5zO3MrKyl0W3MtMV09dGhpcy5kYXRhW2VdW3NdO3RoaXMuZGF0YVtlXT10fXJldHVybiB0aGlzLmNvbHVtbnMtPTEsdGhpc31hZGRDb2x1bW4obixlKXt0eXBlb2YgZT4idSImJihlPW4sbj10aGlzLmNvbHVtbnMpLFoodGhpcyxuLCEwKSxlPWV0KHRoaXMsZSk7Zm9yKGxldCB0PTA7dDx0aGlzLnJvd3M7dCsrKXtjb25zdCBzPW5ldyBGbG9hdDY0QXJyYXkodGhpcy5jb2x1bW5zKzEpO2xldCByPTA7Zm9yKDtyPG47cisrKXNbcl09dGhpcy5kYXRhW3RdW3JdO2ZvcihzW3IrK109ZVt0XTtyPHRoaXMuY29sdW1ucysxO3IrKylzW3JdPXRoaXMuZGF0YVt0XVtyLTFdO3RoaXMuZGF0YVt0XT1zfXJldHVybiB0aGlzLmNvbHVtbnMrPTEsdGhpc319cmUoXyxiKTtjbGFzcyBzdCBleHRlbmRzIF97Y29uc3RydWN0b3Iobil7c3VwZXIoKSx0aGlzLmRhdGE9bix0aGlzLnJvd3M9bi5sZW5ndGgsdGhpcy5jb2x1bW5zPW5bMF0ubGVuZ3RofXNldChuLGUsdCl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXT10LHRoaXN9Z2V0KG4sZSl7cmV0dXJuIHRoaXMuZGF0YVtuXVtlXX19Y2xhc3MgTmV7Y29uc3RydWN0b3Iobil7bj1zdC5jaGVja01hdHJpeChuKTtsZXQgZT1uLmNsb25lKCksdD1lLnJvd3Mscz1lLmNvbHVtbnMscj1uZXcgRmxvYXQ2NEFycmF5KHQpLGk9MSxoLGwsdSxmLGcsYSxqLHcseTtmb3IoaD0wO2g8dDtoKyspcltoXT1oO2Zvcih3PW5ldyBGbG9hdDY0QXJyYXkodCksbD0wO2w8cztsKyspe2ZvcihoPTA7aDx0O2grKyl3W2hdPWUuZ2V0KGgsbCk7Zm9yKGg9MDtoPHQ7aCsrKXtmb3IoeT1NYXRoLm1pbihoLGwpLGc9MCx1PTA7dTx5O3UrKylnKz1lLmdldChoLHUpKndbdV07d1toXS09ZyxlLnNldChoLGwsd1toXSl9Zm9yKGY9bCxoPWwrMTtoPHQ7aCsrKU1hdGguYWJzKHdbaF0pPk1hdGguYWJzKHdbZl0pJiYoZj1oKTtpZihmIT09bCl7Zm9yKHU9MDt1PHM7dSsrKWE9ZS5nZXQoZix1KSxlLnNldChmLHUsZS5nZXQobCx1KSksZS5zZXQobCx1LGEpO2o9cltmXSxyW2ZdPXJbbF0scltsXT1qLGk9LWl9aWYobDx0JiZlLmdldChsLGwpIT09MClmb3IoaD1sKzE7aDx0O2grKyllLnNldChoLGwsZS5nZXQoaCxsKS9lLmdldChsLGwpKX10aGlzLkxVPWUsdGhpcy5waXZvdFZlY3Rvcj1yLHRoaXMucGl2b3RTaWduPWl9aXNTaW5ndWxhcigpe2xldCBuPXRoaXMuTFUsZT1uLmNvbHVtbnM7Zm9yKGxldCB0PTA7dDxlO3QrKylpZihuLmdldCh0LHQpPT09MClyZXR1cm4hMDtyZXR1cm4hMX1zb2x2ZShuKXtuPWIuY2hlY2tNYXRyaXgobik7bGV0IGU9dGhpcy5MVTtpZihlLnJvd3MhPT1uLnJvd3MpdGhyb3cgbmV3IEVycm9yKCJJbnZhbGlkIG1hdHJpeCBkaW1lbnNpb25zIik7aWYodGhpcy5pc1Npbmd1bGFyKCkpdGhyb3cgbmV3IEVycm9yKCJMVSBtYXRyaXggaXMgc2luZ3VsYXIiKTtsZXQgcz1uLmNvbHVtbnMscj1uLnN1Yk1hdHJpeFJvdyh0aGlzLnBpdm90VmVjdG9yLDAscy0xKSxpPWUuY29sdW1ucyxoLGwsdTtmb3IodT0wO3U8aTt1KyspZm9yKGg9dSsxO2g8aTtoKyspZm9yKGw9MDtsPHM7bCsrKXIuc2V0KGgsbCxyLmdldChoLGwpLXIuZ2V0KHUsbCkqZS5nZXQoaCx1KSk7Zm9yKHU9aS0xO3U+PTA7dS0tKXtmb3IobD0wO2w8cztsKyspci5zZXQodSxsLHIuZ2V0KHUsbCkvZS5nZXQodSx1KSk7Zm9yKGg9MDtoPHU7aCsrKWZvcihsPTA7bDxzO2wrKylyLnNldChoLGwsci5nZXQoaCxsKS1yLmdldCh1LGwpKmUuZ2V0KGgsdSkpfXJldHVybiByfWdldCBkZXRlcm1pbmFudCgpe2xldCBuPXRoaXMuTFU7aWYoIW4uaXNTcXVhcmUoKSl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCBtdXN0IGJlIHNxdWFyZSIpO2xldCBlPXRoaXMucGl2b3RTaWduLHQ9bi5jb2x1bW5zO2ZvcihsZXQgcz0wO3M8dDtzKyspZSo9bi5nZXQocyxzKTtyZXR1cm4gZX1nZXQgbG93ZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI+aT9zLnNldChyLGksbi5nZXQocixpKSk6cj09PWk/cy5zZXQocixpLDEpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5MVSxlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCk7Zm9yKGxldCByPTA7cjxlO3IrKylmb3IobGV0IGk9MDtpPHQ7aSsrKXI8PWk/cy5zZXQocixpLG4uZ2V0KHIsaSkpOnMuc2V0KHIsaSwwKTtyZXR1cm4gc31nZXQgcGl2b3RQZXJtdXRhdGlvblZlY3Rvcigpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucGl2b3RWZWN0b3IpfX1mdW5jdGlvbiB4KG8sbil7bGV0IGU9MDtyZXR1cm4gTWF0aC5hYnMobyk+TWF0aC5hYnMobik/KGU9bi9vLE1hdGguYWJzKG8pKk1hdGguc3FydCgxK2UqZSkpOm4hPT0wPyhlPW8vbixNYXRoLmFicyhuKSpNYXRoLnNxcnQoMStlKmUpKTowfWNsYXNzIHZle2NvbnN0cnVjdG9yKG4pe249c3QuY2hlY2tNYXRyaXgobik7bGV0IGU9bi5jbG9uZSgpLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IEZsb2F0NjRBcnJheShzKSxpLGgsbCx1O2ZvcihsPTA7bDxzO2wrKyl7bGV0IGY9MDtmb3IoaT1sO2k8dDtpKyspZj14KGYsZS5nZXQoaSxsKSk7aWYoZiE9PTApe2ZvcihlLmdldChsLGwpPDAmJihmPS1mKSxpPWw7aTx0O2krKyllLnNldChpLGwsZS5nZXQoaSxsKS9mKTtmb3IoZS5zZXQobCxsLGUuZ2V0KGwsbCkrMSksaD1sKzE7aDxzO2grKyl7Zm9yKHU9MCxpPWw7aTx0O2krKyl1Kz1lLmdldChpLGwpKmUuZ2V0KGksaCk7Zm9yKHU9LXUvZS5nZXQobCxsKSxpPWw7aTx0O2krKyllLnNldChpLGgsZS5nZXQoaSxoKSt1KmUuZ2V0KGksbCkpfX1yW2xdPS1mfXRoaXMuUVI9ZSx0aGlzLlJkaWFnPXJ9c29sdmUobil7bj1iLmNoZWNrTWF0cml4KG4pO2xldCBlPXRoaXMuUVIsdD1lLnJvd3M7aWYobi5yb3dzIT09dCl0aHJvdyBuZXcgRXJyb3IoIk1hdHJpeCByb3cgZGltZW5zaW9ucyBtdXN0IGFncmVlIik7aWYoIXRoaXMuaXNGdWxsUmFuaygpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IGlzIHJhbmsgZGVmaWNpZW50Iik7bGV0IHM9bi5jb2x1bW5zLHI9bi5jbG9uZSgpLGk9ZS5jb2x1bW5zLGgsbCx1LGY7Zm9yKHU9MDt1PGk7dSsrKWZvcihsPTA7bDxzO2wrKyl7Zm9yKGY9MCxoPXU7aDx0O2grKylmKz1lLmdldChoLHUpKnIuZ2V0KGgsbCk7Zm9yKGY9LWYvZS5nZXQodSx1KSxoPXU7aDx0O2grKylyLnNldChoLGwsci5nZXQoaCxsKStmKmUuZ2V0KGgsdSkpfWZvcih1PWktMTt1Pj0wO3UtLSl7Zm9yKGw9MDtsPHM7bCsrKXIuc2V0KHUsbCxyLmdldCh1LGwpL3RoaXMuUmRpYWdbdV0pO2ZvcihoPTA7aDx1O2grKylmb3IobD0wO2w8cztsKyspci5zZXQoaCxsLHIuZ2V0KGgsbCktci5nZXQodSxsKSplLmdldChoLHUpKX1yZXR1cm4gci5zdWJNYXRyaXgoMCxpLTEsMCxzLTEpfWlzRnVsbFJhbmsoKXtsZXQgbj10aGlzLlFSLmNvbHVtbnM7Zm9yKGxldCBlPTA7ZTxuO2UrKylpZih0aGlzLlJkaWFnW2VdPT09MClyZXR1cm4hMTtyZXR1cm4hMH1nZXQgdXBwZXJUcmlhbmd1bGFyTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4uY29sdW1ucyx0PW5ldyBiKGUsZSkscyxyO2ZvcihzPTA7czxlO3MrKylmb3Iocj0wO3I8ZTtyKyspczxyP3Quc2V0KHMscixuLmdldChzLHIpKTpzPT09cj90LnNldChzLHIsdGhpcy5SZGlhZ1tzXSk6dC5zZXQocyxyLDApO3JldHVybiB0fWdldCBvcnRob2dvbmFsTWF0cml4KCl7bGV0IG49dGhpcy5RUixlPW4ucm93cyx0PW4uY29sdW1ucyxzPW5ldyBiKGUsdCkscixpLGgsbDtmb3IoaD10LTE7aD49MDtoLS0pe2ZvcihyPTA7cjxlO3IrKylzLnNldChyLGgsMCk7Zm9yKHMuc2V0KGgsaCwxKSxpPWg7aTx0O2krKylpZihuLmdldChoLGgpIT09MCl7Zm9yKGw9MCxyPWg7cjxlO3IrKylsKz1uLmdldChyLGgpKnMuZ2V0KHIsaSk7Zm9yKGw9LWwvbi5nZXQoaCxoKSxyPWg7cjxlO3IrKylzLnNldChyLGkscy5nZXQocixpKStsKm4uZ2V0KHIsaCkpfX1yZXR1cm4gc319Y2xhc3MgRHR7Y29uc3RydWN0b3IobixlPXt9KXtpZihuPXN0LmNoZWNrTWF0cml4KG4pLG4uaXNFbXB0eSgpKXRocm93IG5ldyBFcnJvcigiTWF0cml4IG11c3QgYmUgbm9uLWVtcHR5Iik7bGV0IHQ9bi5yb3dzLHM9bi5jb2x1bW5zO2NvbnN0e2NvbXB1dGVMZWZ0U2luZ3VsYXJWZWN0b3JzOnI9ITAsY29tcHV0ZVJpZ2h0U2luZ3VsYXJWZWN0b3JzOmk9ITAsYXV0b1RyYW5zcG9zZTpoPSExfT1lO2xldCBsPSEhcix1PSEhaSxmPSExLGc7aWYodDxzKWlmKCFoKWc9bi5jbG9uZSgpLGNvbnNvbGUud2FybigiQ29tcHV0aW5nIFNWRCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgY29sdW1ucyB0aGFuIHJvd3MuIENvbnNpZGVyIGVuYWJsaW5nIGF1dG9UcmFuc3Bvc2UiKTtlbHNle2c9bi50cmFuc3Bvc2UoKSx0PWcucm93cyxzPWcuY29sdW1ucyxmPSEwO2xldCBjPWw7bD11LHU9Y31lbHNlIGc9bi5jbG9uZSgpO2xldCBhPU1hdGgubWluKHQscyksaj1NYXRoLm1pbih0KzEscyksdz1uZXcgRmxvYXQ2NEFycmF5KGopLHk9bmV3IGIodCxhKSxtPW5ldyBiKHMscyksTT1uZXcgRmxvYXQ2NEFycmF5KHMpLFQ9bmV3IEZsb2F0NjRBcnJheSh0KSxFPW5ldyBGbG9hdDY0QXJyYXkoaik7Zm9yKGxldCBjPTA7YzxqO2MrKylFW2NdPWM7bGV0IGs9TWF0aC5taW4odC0xLHMpLFI9TWF0aC5tYXgoMCxNYXRoLm1pbihzLTIsdCkpLHE9TWF0aC5tYXgoayxSKTtmb3IobGV0IGM9MDtjPHE7YysrKXtpZihjPGspe3dbY109MDtmb3IobGV0IHA9YztwPHQ7cCsrKXdbY109eCh3W2NdLGcuZ2V0KHAsYykpO2lmKHdbY10hPT0wKXtnLmdldChjLGMpPDAmJih3W2NdPS13W2NdKTtmb3IobGV0IHA9YztwPHQ7cCsrKWcuc2V0KHAsYyxnLmdldChwLGMpL3dbY10pO2cuc2V0KGMsYyxnLmdldChjLGMpKzEpfXdbY109LXdbY119Zm9yKGxldCBwPWMrMTtwPHM7cCsrKXtpZihjPGsmJndbY10hPT0wKXtsZXQgUz0wO2ZvcihsZXQgZD1jO2Q8dDtkKyspUys9Zy5nZXQoZCxjKSpnLmdldChkLHApO1M9LVMvZy5nZXQoYyxjKTtmb3IobGV0IGQ9YztkPHQ7ZCsrKWcuc2V0KGQscCxnLmdldChkLHApK1MqZy5nZXQoZCxjKSl9TVtwXT1nLmdldChjLHApfWlmKGwmJmM8aylmb3IobGV0IHA9YztwPHQ7cCsrKXkuc2V0KHAsYyxnLmdldChwLGMpKTtpZihjPFIpe01bY109MDtmb3IobGV0IHA9YysxO3A8cztwKyspTVtjXT14KE1bY10sTVtwXSk7aWYoTVtjXSE9PTApe01bYysxXTwwJiYoTVtjXT0wLU1bY10pO2ZvcihsZXQgcD1jKzE7cDxzO3ArKylNW3BdLz1NW2NdO01bYysxXSs9MX1pZihNW2NdPS1NW2NdLGMrMTx0JiZNW2NdIT09MCl7Zm9yKGxldCBwPWMrMTtwPHQ7cCsrKVRbcF09MDtmb3IobGV0IHA9YysxO3A8dDtwKyspZm9yKGxldCBTPWMrMTtTPHM7UysrKVRbcF0rPU1bU10qZy5nZXQocCxTKTtmb3IobGV0IHA9YysxO3A8cztwKyspe2xldCBTPS1NW3BdL01bYysxXTtmb3IobGV0IGQ9YysxO2Q8dDtkKyspZy5zZXQoZCxwLGcuZ2V0KGQscCkrUypUW2RdKX19aWYodSlmb3IobGV0IHA9YysxO3A8cztwKyspbS5zZXQocCxjLE1bcF0pfX1sZXQgST1NYXRoLm1pbihzLHQrMSk7aWYoazxzJiYod1trXT1nLmdldChrLGspKSx0PEkmJih3W0ktMV09MCksUisxPEkmJihNW1JdPWcuZ2V0KFIsSS0xKSksTVtJLTFdPTAsbCl7Zm9yKGxldCBjPWs7YzxhO2MrKyl7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfWZvcihsZXQgYz1rLTE7Yz49MDtjLS0paWYod1tjXSE9PTApe2ZvcihsZXQgcD1jKzE7cDxhO3ArKyl7bGV0IFM9MDtmb3IobGV0IGQ9YztkPHQ7ZCsrKVMrPXkuZ2V0KGQsYykqeS5nZXQoZCxwKTtTPS1TL3kuZ2V0KGMsYyk7Zm9yKGxldCBkPWM7ZDx0O2QrKyl5LnNldChkLHAseS5nZXQoZCxwKStTKnkuZ2V0KGQsYykpfWZvcihsZXQgcD1jO3A8dDtwKyspeS5zZXQocCxjLC15LmdldChwLGMpKTt5LnNldChjLGMsMSt5LmdldChjLGMpKTtmb3IobGV0IHA9MDtwPGMtMTtwKyspeS5zZXQocCxjLDApfWVsc2V7Zm9yKGxldCBwPTA7cDx0O3ArKyl5LnNldChwLGMsMCk7eS5zZXQoYyxjLDEpfX1pZih1KWZvcihsZXQgYz1zLTE7Yz49MDtjLS0pe2lmKGM8UiYmTVtjXSE9PTApZm9yKGxldCBwPWMrMTtwPHM7cCsrKXtsZXQgUz0wO2ZvcihsZXQgZD1jKzE7ZDxzO2QrKylTKz1tLmdldChkLGMpKm0uZ2V0KGQscCk7Uz0tUy9tLmdldChjKzEsYyk7Zm9yKGxldCBkPWMrMTtkPHM7ZCsrKW0uc2V0KGQscCxtLmdldChkLHApK1MqbS5nZXQoZCxjKSl9Zm9yKGxldCBwPTA7cDxzO3ArKyltLnNldChwLGMsMCk7bS5zZXQoYyxjLDEpfWxldCB6PUktMSxCPU51bWJlci5FUFNJTE9OO2Zvcig7ST4wOyl7bGV0IGMscDtmb3IoYz1JLTI7Yz49LTEmJmMhPT0tMTtjLS0pe2NvbnN0IFM9TnVtYmVyLk1JTl9WQUxVRStCKk1hdGguYWJzKHdbY10rTWF0aC5hYnMod1tjKzFdKSk7aWYoTWF0aC5hYnMoTVtjXSk8PVN8fE51bWJlci5pc05hTihNW2NdKSl7TVtjXT0wO2JyZWFrfX1pZihjPT09SS0yKXA9NDtlbHNle2xldCBTO2ZvcihTPUktMTtTPj1jJiZTIT09YztTLS0pe2xldCBkPShTIT09ST9NYXRoLmFicyhNW1NdKTowKSsoUyE9PWMrMT9NYXRoLmFicyhNW1MtMV0pOjApO2lmKE1hdGguYWJzKHdbU10pPD1CKmQpe3dbU109MDticmVha319Uz09PWM/cD0zOlM9PT1JLTE/cD0xOihwPTIsYz1TKX1zd2l0Y2goYysrLHApe2Nhc2UgMTp7bGV0IFM9TVtJLTJdO01bSS0yXT0wO2ZvcihsZXQgZD1JLTI7ZD49YztkLS0pe2xldCBEPXgod1tkXSxTKSxVPXdbZF0vRCxGPVMvRDtpZih3W2RdPUQsZCE9PWMmJihTPS1GKk1bZC0xXSxNW2QtMV09VSpNW2QtMV0pLHUpZm9yKGxldCBQPTA7UDxzO1ArKylEPVUqbS5nZXQoUCxkKStGKm0uZ2V0KFAsSS0xKSxtLnNldChQLEktMSwtRiptLmdldChQLGQpK1UqbS5nZXQoUCxJLTEpKSxtLnNldChQLGQsRCl9YnJlYWt9Y2FzZSAyOntsZXQgUz1NW2MtMV07TVtjLTFdPTA7Zm9yKGxldCBkPWM7ZDxJO2QrKyl7bGV0IEQ9eCh3W2RdLFMpLFU9d1tkXS9ELEY9Uy9EO2lmKHdbZF09RCxTPS1GKk1bZF0sTVtkXT1VKk1bZF0sbClmb3IobGV0IFA9MDtQPHQ7UCsrKUQ9VSp5LmdldChQLGQpK0YqeS5nZXQoUCxjLTEpLHkuc2V0KFAsYy0xLC1GKnkuZ2V0KFAsZCkrVSp5LmdldChQLGMtMSkpLHkuc2V0KFAsZCxEKX1icmVha31jYXNlIDM6e2NvbnN0IFM9TWF0aC5tYXgoTWF0aC5hYnMod1tJLTFdKSxNYXRoLmFicyh3W0ktMl0pLE1hdGguYWJzKE1bSS0yXSksTWF0aC5hYnMod1tjXSksTWF0aC5hYnMoTVtjXSkpLGQ9d1tJLTFdL1MsRD13W0ktMl0vUyxVPU1bSS0yXS9TLEY9d1tjXS9TLFA9TVtjXS9TLFk9KChEK2QpKihELWQpK1UqVSkvMixHPWQqVSooZCpVKTtsZXQgTj0wOyhZIT09MHx8RyE9PTApJiYoWTwwP049MC1NYXRoLnNxcnQoWSpZK0cpOk49TWF0aC5zcXJ0KFkqWStHKSxOPUcvKFkrTikpO2xldCAkPShGK2QpKihGLWQpK04sSz1GKlA7Zm9yKGxldCB2PWM7djxJLTE7disrKXtsZXQgVj14KCQsSyk7Vj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpO2xldCBMPSQvVixDPUsvVjtpZih2IT09YyYmKE1bdi0xXT1WKSwkPUwqd1t2XStDKk1bdl0sTVt2XT1MKk1bdl0tQyp3W3ZdLEs9Qyp3W3YrMV0sd1t2KzFdPUwqd1t2KzFdLHUpZm9yKGxldCBYPTA7WDxzO1grKylWPUwqbS5nZXQoWCx2KStDKm0uZ2V0KFgsdisxKSxtLnNldChYLHYrMSwtQyptLmdldChYLHYpK0wqbS5nZXQoWCx2KzEpKSxtLnNldChYLHYsVik7aWYoVj14KCQsSyksVj09PTAmJihWPU51bWJlci5NSU5fVkFMVUUpLEw9JC9WLEM9Sy9WLHdbdl09ViwkPUwqTVt2XStDKndbdisxXSx3W3YrMV09LUMqTVt2XStMKndbdisxXSxLPUMqTVt2KzFdLE1bdisxXT1MKk1bdisxXSxsJiZ2PHQtMSlmb3IobGV0IFg9MDtYPHQ7WCsrKVY9TCp5LmdldChYLHYpK0MqeS5nZXQoWCx2KzEpLHkuc2V0KFgsdisxLC1DKnkuZ2V0KFgsdikrTCp5LmdldChYLHYrMSkpLHkuc2V0KFgsdixWKX1NW0ktMl09JDticmVha31jYXNlIDQ6e2lmKHdbY108PTAmJih3W2NdPXdbY108MD8td1tjXTowLHUpKWZvcihsZXQgUz0wO1M8PXo7UysrKW0uc2V0KFMsYywtbS5nZXQoUyxjKSk7Zm9yKDtjPHomJiEod1tjXT49d1tjKzFdKTspe2xldCBTPXdbY107aWYod1tjXT13W2MrMV0sd1tjKzFdPVMsdSYmYzxzLTEpZm9yKGxldCBkPTA7ZDxzO2QrKylTPW0uZ2V0KGQsYysxKSxtLnNldChkLGMrMSxtLmdldChkLGMpKSxtLnNldChkLGMsUyk7aWYobCYmYzx0LTEpZm9yKGxldCBkPTA7ZDx0O2QrKylTPXkuZ2V0KGQsYysxKSx5LnNldChkLGMrMSx5LmdldChkLGMpKSx5LnNldChkLGMsUyk7YysrfUktLTticmVha319fWlmKGYpe2xldCBjPW07bT15LHk9Y310aGlzLm09dCx0aGlzLm49cyx0aGlzLnM9dyx0aGlzLlU9eSx0aGlzLlY9bX1zb2x2ZShuKXtsZXQgZT1uLHQ9dGhpcy50aHJlc2hvbGQscz10aGlzLnMubGVuZ3RoLHI9Yi56ZXJvcyhzLHMpO2ZvcihsZXQgYT0wO2E8czthKyspTWF0aC5hYnModGhpcy5zW2FdKTw9dD9yLnNldChhLGEsMCk6ci5zZXQoYSxhLDEvdGhpcy5zW2FdKTtsZXQgaT10aGlzLlUsaD10aGlzLnJpZ2h0U2luZ3VsYXJWZWN0b3JzLGw9aC5tbXVsKHIpLHU9aC5yb3dzLGY9aS5yb3dzLGc9Yi56ZXJvcyh1LGYpO2ZvcihsZXQgYT0wO2E8dTthKyspZm9yKGxldCBqPTA7ajxmO2orKyl7bGV0IHc9MDtmb3IobGV0IHk9MDt5PHM7eSsrKXcrPWwuZ2V0KGEseSkqaS5nZXQoaix5KTtnLnNldChhLGosdyl9cmV0dXJuIGcubW11bChlKX1zb2x2ZUZvckRpYWdvbmFsKG4pe3JldHVybiB0aGlzLnNvbHZlKGIuZGlhZyhuKSl9aW52ZXJzZSgpe2xldCBuPXRoaXMuVixlPXRoaXMudGhyZXNob2xkLHQ9bi5yb3dzLHM9bi5jb2x1bW5zLHI9bmV3IGIodCx0aGlzLnMubGVuZ3RoKTtmb3IobGV0IGY9MDtmPHQ7ZisrKWZvcihsZXQgZz0wO2c8cztnKyspTWF0aC5hYnModGhpcy5zW2ddKT5lJiZyLnNldChmLGcsbi5nZXQoZixnKS90aGlzLnNbZ10pO2xldCBpPXRoaXMuVSxoPWkucm93cyxsPWkuY29sdW1ucyx1PW5ldyBiKHQsaCk7Zm9yKGxldCBmPTA7Zjx0O2YrKylmb3IobGV0IGc9MDtnPGg7ZysrKXtsZXQgYT0wO2ZvcihsZXQgaj0wO2o8bDtqKyspYSs9ci5nZXQoZixqKSppLmdldChnLGopO3Uuc2V0KGYsZyxhKX1yZXR1cm4gdX1nZXQgY29uZGl0aW9uKCl7cmV0dXJuIHRoaXMuc1swXS90aGlzLnNbTWF0aC5taW4odGhpcy5tLHRoaXMubiktMV19Z2V0IG5vcm0yKCl7cmV0dXJuIHRoaXMuc1swXX1nZXQgcmFuaygpe2xldCBuPU1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXSpOdW1iZXIuRVBTSUxPTixlPTAsdD10aGlzLnM7Zm9yKGxldCBzPTAscj10Lmxlbmd0aDtzPHI7cysrKXRbc10+biYmZSsrO3JldHVybiBlfWdldCBkaWFnb25hbCgpe3JldHVybiBBcnJheS5mcm9tKHRoaXMucyl9Z2V0IHRocmVzaG9sZCgpe3JldHVybiBOdW1iZXIuRVBTSUxPTi8yKk1hdGgubWF4KHRoaXMubSx0aGlzLm4pKnRoaXMuc1swXX1nZXQgbGVmdFNpbmd1bGFyVmVjdG9ycygpe3JldHVybiB0aGlzLlV9Z2V0IHJpZ2h0U2luZ3VsYXJWZWN0b3JzKCl7cmV0dXJuIHRoaXMuVn1nZXQgZGlhZ29uYWxNYXRyaXgoKXtyZXR1cm4gYi5kaWFnKHRoaXMucyl9fWZ1bmN0aW9uIE10KG8sbj0hMSl7cmV0dXJuIG89c3QuY2hlY2tNYXRyaXgobyksbj9uZXcgRHQobykuaW52ZXJzZSgpOnFlKG8sYi5leWUoby5yb3dzKSl9ZnVuY3Rpb24gcWUobyxuLGU9ITEpe3JldHVybiBvPXN0LmNoZWNrTWF0cml4KG8pLG49c3QuY2hlY2tNYXRyaXgobiksZT9uZXcgRHQobykuc29sdmUobik6by5pc1NxdWFyZSgpP25ldyBOZShvKS5zb2x2ZShuKTpuZXcgdmUobykuc29sdmUobil9Y29uc3QgX2U9MTIzNCxUZT0oKT0+KHtzZWVkOl9lLGFycmF5U2h1ZmZsZShuKXtjb25zdHthcnI6ZSxzYW1wbGVTaXplOnR9PW47Zm9yKGxldCBzPTA7czx0O3MrKyl7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCByPXRoaXMuc2VlZD4+MTYmMzI3Njc7cj1yJWUubGVuZ3RoO2xldCBpPWVbc107ZVtzXT1lW3JdLGVbcl09aX19LG5leHRJbnQobil7dGhpcy5zZWVkPSgyMTQwMTMqdGhpcy5zZWVkKzI1MzEwMTEpJS0yMTQ3NDgzNjQ4O2xldCBlPXRoaXMuc2VlZD4+MTYmMzI3Njc7cmV0dXJuIGU9ZSVuLGV9fSksSj0obyxuLGUpPT4oblswXS1vWzBdKSooZVsxXS1vWzFdKS0oblsxXS1vWzFdKSooZVswXS1vWzBdKSx6ZT0obyxuLGUsdCxzLHIsaSxoKT0+IShKKG8sbixlKT4wIT1KKHMscixpKT4wfHxKKG4sZSx0KT4wIT1KKHIsaSxoKT4wfHxKKGUsdCxvKT4wIT1KKGksaCxzKT4wfHxKKHQsbyxuKT4wIT1KKGgscyxyKT4wKSxGZT0obyxuLGUsdCxzLHIpPT5KKG8sbixlKT4wPT1KKHQscyxyKT4wLFBlPW89Pntjb25zdCBuPW9bNF0qb1s4XS1vWzVdKm9bN10sZT1vWzNdKm9bOF0tb1s1XSpvWzZdLHQ9b1szXSpvWzddLW9bNF0qb1s2XTtyZXR1cm4gb1swXSpuLW9bMV0qZStvWzJdKnR9LEJ0PShvLG4pPT57Y29uc3QgZT1QZShvKTtpZihNYXRoLmFicyhlKTw9bilyZXR1cm4gbnVsbDtjb25zdCB0PTEvZTtyZXR1cm5bKG9bNF0qb1s4XS1vWzVdKm9bN10pKnQsKG9bMl0qb1s3XS1vWzFdKm9bOF0pKnQsKG9bMV0qb1s1XS1vWzJdKm9bNF0pKnQsKG9bNV0qb1s2XS1vWzNdKm9bOF0pKnQsKG9bMF0qb1s4XS1vWzJdKm9bNl0pKnQsKG9bMl0qb1szXS1vWzBdKm9bNV0pKnQsKG9bM10qb1s3XS1vWzRdKm9bNl0pKnQsKG9bMV0qb1s2XS1vWzBdKm9bN10pKnQsKG9bMF0qb1s0XS1vWzFdKm9bM10pKnRdfSxvdD0obyxuKT0+e2NvbnN0IGU9bls2XSpvWzBdK25bN10qb1sxXStuWzhdLHQ9W107cmV0dXJuIHRbMF09KG5bMF0qb1swXStuWzFdKm9bMV0rblsyXSkvZSx0WzFdPShuWzNdKm9bMF0rbls0XSpvWzFdK25bNV0pL2UsdH0sRGU9KG8sbixlLHQpPT57Y29uc3Qgcz1ydChuLG8pLHI9cnQoZSxvKSxpPXJ0KHQsbyksaD1ydChuLGUpLGw9cnQodCxlKSx1PW10KHMsciksZj1tdChyLGkpLGc9bXQocyxpKSxhPW10KGgsbCk7cmV0dXJuIE1hdGgubWluKE1hdGgubWluKE1hdGgubWluKHUsZiksZyksYSl9LEJlPShvLG4sZSx0KT0+e2NvbnN0IHM9SihvLG4sZSk8PTA7cmV0dXJuIShKKG4sZSx0KTw9MCE9PXN8fEooZSx0LG8pPD0wIT09c3x8Sih0LG8sbik8PTAhPT1zKX0scnQ9KG8sbik9PltvWzBdLW5bMF0sb1sxXS1uWzFdXSxtdD0obyxuKT0+e2NvbnN0IGU9b1swXSpuWzFdLW9bMV0qblswXTtyZXR1cm4gTWF0aC5hYnMoZSkqLjV9LFZ0PShvLG4pPT57Y29uc3R7bm9ybVBvaW50czplLHBhcmFtOnR9PVh0KG8pLHtub3JtUG9pbnRzOnMscGFyYW06cn09WHQobiksaT1zLmxlbmd0aCxoPVtdLGw9W107Zm9yKGxldCB1PTA7dTxpO3UrKyl7Y29uc3QgZj1bZVt1XVswXSxlW3VdWzFdLDEsMCwwLDAsLShlW3VdWzBdKnNbdV1bMF0pLC0oZVt1XVsxXSpzW3VdWzBdKV0sZz1bMCwwLDAsZVt1XVswXSxlW3VdWzFdLDEsLShlW3VdWzBdKnNbdV1bMV0pLC0oZVt1XVsxXSpzW3VdWzFdKV07aC5wdXNoKGYpLGgucHVzaChnKSxsLnB1c2goW3NbdV1bMF1dKSxsLnB1c2goW3NbdV1bMV1dKX10cnl7Y29uc3QgdT1uZXcgYihoKSxmPW5ldyBiKGwpLGc9dS50cmFuc3Bvc2UoKSxhPWcubW11bCh1KSxqPWcubW11bChmKSx5PU10KGEpLm1tdWwoaikudG8xREFycmF5KCk7cmV0dXJuIFZlKHksdCxyKX1jYXRjaHtyZXR1cm4gbnVsbH19LFh0PW89PntsZXQgbj0wLGU9MDtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyluKz1vW2xdWzBdLGUrPW9bbF1bMV07bGV0IHQ9bi9vLmxlbmd0aCxzPWUvby5sZW5ndGgscj0wO2ZvcihsZXQgbD0wO2w8by5sZW5ndGg7bCsrKXtjb25zdCB1PW9bbF1bMF0tdCxmPW9bbF1bMV0tcztyKz1NYXRoLnNxcnQodSp1K2YqZil9bGV0IGk9TWF0aC5zcXJ0KDIpKm8ubGVuZ3RoL3I7Y29uc3QgaD1bXTtmb3IobGV0IGw9MDtsPG8ubGVuZ3RoO2wrKyloLnB1c2goWyhvW2xdWzBdLXQpKmksKG9bbF1bMV0tcykqaV0pO3JldHVybntub3JtUG9pbnRzOmgscGFyYW06e21lYW5YOnQsbWVhblk6cyxzOml9fX0sVmU9KG8sbixlKT0+e2NvbnN0IHQ9ZS5zKmUubWVhblgscz1lLnMqZS5tZWFuWSxyPVtvWzBdK3Qqb1s2XSxvWzFdK3Qqb1s3XSwob1swXSt0Km9bNl0pKi1uLm1lYW5YKyhvWzFdK3Qqb1s3XSkqLW4ubWVhblkrKG9bMl0rdCkvbi5zLG9bM10rcypvWzZdLG9bNF0rcypvWzddLChvWzNdK3Mqb1s2XSkqLW4ubWVhblgrKG9bNF0rcypvWzddKSotbi5tZWFuWSsob1s1XStzKS9uLnMsZS5zKm9bNl0sZS5zKm9bN10sZS5zKm9bNl0qLW4ubWVhblgrZS5zKm9bN10qLW4ubWVhblkrZS5zL24uc107Zm9yKGxldCBpPTA7aTw5O2krKylyW2ldPXJbaV0vcls4XTtyZXR1cm4gcn0sWGU9LjAxLFVlPTEwLCRlPTIwLExlPTEwLFV0PW89Pntjb25zdHtzcmNQb2ludHM6bixkc3RQb2ludHM6ZSxrZXlmcmFtZTp0LHF1aWNrTW9kZTpzfT1vLHI9W1swLDBdLFt0LndpZHRoLDBdLFt0LndpZHRoLHQuaGVpZ2h0XSxbMCx0LmhlaWdodF1dLGk9NDtpZihuLmxlbmd0aDxpKXJldHVybiBudWxsO2NvbnN0IGg9WGUsbD0xLyhoKmgpLHU9TWF0aC5taW4oVWUsbi5sZW5ndGgpLGY9VGUoKSxnPVtdO2ZvcihsZXQgRT0wO0U8bi5sZW5ndGg7RSsrKWdbRV09RTtmLmFycmF5U2h1ZmZsZSh7YXJyOmcsc2FtcGxlU2l6ZTpnLmxlbmd0aH0pO2NvbnN0IGE9cz9MZTokZSxqPWEqMjtsZXQgdz0wO2NvbnN0IHk9W107Zm9yKDt3PGomJnkubGVuZ3RoPGE7KXtpZih3Kz0xLGYuYXJyYXlTaHVmZmxlKHthcnI6ZyxzYW1wbGVTaXplOml9KSwhemUobltnWzBdXSxuW2dbMV1dLG5bZ1syXV0sbltnWzNdXSxlW2dbMF1dLGVbZ1sxXV0sZVtnWzJdXSxlW2dbM11dKSljb250aW51ZTtjb25zdCBFPVZ0KFtuW2dbMF1dLG5bZ1sxXV0sbltnWzJdXSxuW2dbM11dXSxbZVtnWzBdXSxlW2dbMV1dLGVbZ1syXV0sZVtnWzNdXV0pO0UhPT1udWxsJiZIZSh7SDpFLHRlc3RQb2ludHM6cn0pJiZ5LnB1c2goRSl9aWYoeS5sZW5ndGg9PT0wKXJldHVybiBudWxsO2NvbnN0IG09W107Zm9yKGxldCBFPTA7RTx5Lmxlbmd0aDtFKyspbS5wdXNoKHtIOnlbRV0sY29zdDowfSk7bGV0IE09dTtmb3IobGV0IEU9MDtFPG4ubGVuZ3RoJiZtLmxlbmd0aD4yO0UrPU0pe009TWF0aC5taW4odSxuLmxlbmd0aC1FKTtsZXQgaz1FK007Zm9yKGxldCBSPTA7UjxtLmxlbmd0aDtSKyspZm9yKGxldCBxPUU7cTxrO3ErKyl7Y29uc3QgST1DZSh7SDptW1JdLkgsc3JjUG9pbnQ6bltxXSxkc3RQb2ludDplW3FdLG9uZU92ZXJTY2FsZTI6bH0pO21bUl0uY29zdCs9SX1tLnNvcnQoKFIscSk9PlIuY29zdC1xLmNvc3QpLG0uc3BsaWNlKC1NYXRoLmZsb29yKChtLmxlbmd0aCsxKS8yKSl9bGV0IFQ9bnVsbDtmb3IobGV0IEU9MDtFPG0ubGVuZ3RoO0UrKyl7Y29uc3Qgaz1ZZSh7aW5IOm1bRV0uSH0pO2lmKE9lKHtIOmssdGVzdFBvaW50czpyLGtleWZyYW1lOnR9KSl7VD1rO2JyZWFrfX1yZXR1cm4gVH0sT2U9KHtIOm8sdGVzdFBvaW50czpuLGtleWZyYW1lOmV9KT0+e2NvbnN0IHQ9QnQobywxZS01KTtpZih0PT09bnVsbClyZXR1cm4hMTtjb25zdCBzPVtdO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKXMucHVzaChvdChuW2ldLHQpKTtyZXR1cm4hKERlKHNbMF0sc1sxXSxzWzJdLHNbM10pPGUud2lkdGgqZS5oZWlnaHQqMWUtNHx8IUJlKHNbMF0sc1sxXSxzWzJdLHNbM10pKX0sWWU9KHtpbkg6b30pPT57Y29uc3Qgbj0xL29bOF0sZT1bXTtmb3IobGV0IHQ9MDt0PDg7dCsrKWVbdF09b1t0XSpuO3JldHVybiBlWzhdPTEsZX0sQ2U9KHtIOm8sc3JjUG9pbnQ6bixkc3RQb2ludDplLG9uZU92ZXJTY2FsZTI6dH0pPT57Y29uc3Qgcz1vdChuLG8pLHI9W3NbMF0tZVswXSxzWzFdLWVbMV1dO3JldHVybiBNYXRoLmxvZygxKyhyWzBdKnJbMF0rclsxXSpyWzFdKSp0KX0sSGU9KHtIOm8sdGVzdFBvaW50czpufSk9Pntjb25zdCBlPVtdO2ZvcihsZXQgdD0wO3Q8bi5sZW5ndGg7dCsrKWVbdF09b3Qoblt0XSxvKTtmb3IobGV0IHQ9MDt0PG4ubGVuZ3RoO3QrKyl7Y29uc3Qgcz10LHI9KHQrMSklbi5sZW5ndGgsaT0odCsyKSVuLmxlbmd0aDtpZighRmUobltzXSxuW3JdLG5baV0sZVtzXSxlW3JdLGVbaV0pKXJldHVybiExfXJldHVybiEwfSwkdD0zLEx0PTYsS2U9OCxPdD0uNyxKZT0oe2tleWZyYW1lOm8scXVlcnlwb2ludHM6bixxdWVyeXdpZHRoOmUscXVlcnloZWlnaHQ6dCxkZWJ1Z01vZGU6c30pPT57bGV0IHI9e307Y29uc3QgaT1bXTtmb3IobGV0IG09MDttPG4ubGVuZ3RoO20rKyl7Y29uc3QgTT1uW21dLFQ9TS5tYXhpbWE/by5tYXhpbWFQb2ludHM6by5taW5pbWFQb2ludHM7aWYoVC5sZW5ndGg9PT0wKWNvbnRpbnVlO2NvbnN0IEU9TS5tYXhpbWE/by5tYXhpbWFQb2ludHNDbHVzdGVyLnJvb3ROb2RlOm8ubWluaW1hUG9pbnRzQ2x1c3Rlci5yb290Tm9kZSxrPVtdLFI9bmV3IFd0KFtdLChCLGMpPT5CLmQtYy5kKTtFdCh7bm9kZTpFLGtleXBvaW50czpULHF1ZXJ5cG9pbnQ6TSxxdWV1ZTpSLGtleXBvaW50SW5kZXhlczprLG51bVBvcDowfSk7bGV0IHE9LTEsST1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUix6PU51bWJlci5NQVhfU0FGRV9JTlRFR0VSO2ZvcihsZXQgQj0wO0I8ay5sZW5ndGg7QisrKXtjb25zdCBjPVRba1tCXV0scD15dCh7djE6Yy5kZXNjcmlwdG9ycyx2MjpNLmRlc2NyaXB0b3JzfSk7cDxJPyh6PUksST1wLHE9a1tCXSk6cDx6JiYoej1wKX1xIT09LTEmJih6PT09TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJ8fDEqSS96PE90KSYmaS5wdXNoKHtxdWVyeXBvaW50Ok0sa2V5cG9pbnQ6VFtxXX0pfWlmKHMmJihyLm1hdGNoZXM9aSksaS5sZW5ndGg8THQpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgaD12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczppfSk7cyYmKHIuaG91Z2hNYXRjaGVzPWgpO2NvbnN0IGw9VXQoe3NyY1BvaW50czpoLm1hcChtPT5bbS5rZXlwb2ludC54LG0ua2V5cG9pbnQueV0pLGRzdFBvaW50czpoLm1hcChtPT5bbS5xdWVyeXBvaW50LngsbS5xdWVyeXBvaW50LnldKSxrZXlmcmFtZTpvfSk7aWYobD09PW51bGwpcmV0dXJue2RlYnVnRXh0cmE6cn07Y29uc3QgdT1ZdCh7SDpsLG1hdGNoZXM6aCx0aHJlc2hvbGQ6JHR9KTtpZihzJiYoci5pbmxpZXJNYXRjaGVzPXUpLHUubGVuZ3RoPEx0KXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IGY9QnQobCwxZS01KSxnPTEwKjEwLGE9W107Zm9yKGxldCBtPTA7bTxuLmxlbmd0aDttKyspe2NvbnN0IE09blttXSxUPW90KFtNLngsTS55XSxmKTtsZXQgRT0tMSxrPU51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFI9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Y29uc3QgcT1NLm1heGltYT9vLm1heGltYVBvaW50czpvLm1pbmltYVBvaW50cztmb3IobGV0IEk9MDtJPHEubGVuZ3RoO0krKyl7Y29uc3Qgej1xW0ldO2lmKCh6LngtVFswXSkqKHoueC1UWzBdKSsoei55LVRbMV0pKih6LnktVFsxXSk+Zyljb250aW51ZTtjb25zdCBjPXl0KHt2MTp6LmRlc2NyaXB0b3JzLHYyOk0uZGVzY3JpcHRvcnN9KTtjPGs/KFI9ayxrPWMsRT1JKTpjPFImJihSPWMpfUUhPT0tMSYmKFI9PT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8MSprL1I8T3QpJiZhLnB1c2goe3F1ZXJ5cG9pbnQ6TSxrZXlwb2ludDpxW0VdfSl9cyYmKHIubWF0Y2hlczI9YSk7Y29uc3Qgaj12dCh7a2V5d2lkdGg6by53aWR0aCxrZXloZWlnaHQ6by5oZWlnaHQscXVlcnl3aWR0aDplLHF1ZXJ5aGVpZ2h0OnQsbWF0Y2hlczphfSk7cyYmKHIuaG91Z2hNYXRjaGVzMj1qKTtjb25zdCB3PVV0KHtzcmNQb2ludHM6ai5tYXAobT0+W20ua2V5cG9pbnQueCxtLmtleXBvaW50LnldKSxkc3RQb2ludHM6ai5tYXAobT0+W20ucXVlcnlwb2ludC54LG0ucXVlcnlwb2ludC55XSksa2V5ZnJhbWU6b30pO2lmKHc9PT1udWxsKXJldHVybntkZWJ1Z0V4dHJhOnJ9O2NvbnN0IHk9WXQoe0g6dyxtYXRjaGVzOmosdGhyZXNob2xkOiR0fSk7cmV0dXJuIHMmJihyLmlubGllck1hdGNoZXMyPXkpLHtIOncsbWF0Y2hlczp5LGRlYnVnRXh0cmE6cn19LEV0PSh7bm9kZTpvLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSk9PntpZihvLmxlYWYpe2ZvcihsZXQgbD0wO2w8by5wb2ludEluZGV4ZXMubGVuZ3RoO2wrKylzLnB1c2goby5wb2ludEluZGV4ZXNbbF0pO3JldHVybn1jb25zdCBpPVtdO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKXtjb25zdCBmPW8uY2hpbGRyZW5bbF0uY2VudGVyUG9pbnRJbmRleCxnPXl0KHt2MTpuW2ZdLmRlc2NyaXB0b3JzLHYyOmUuZGVzY3JpcHRvcnN9KTtpLnB1c2goZyl9bGV0IGg9TnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7Zm9yKGxldCBsPTA7bDxvLmNoaWxkcmVuLmxlbmd0aDtsKyspaD1NYXRoLm1pbihoLGlbbF0pO2ZvcihsZXQgbD0wO2w8by5jaGlsZHJlbi5sZW5ndGg7bCsrKWlbbF0hPT1oJiZ0LnB1c2goe25vZGU6by5jaGlsZHJlbltsXSxkOmlbbF19KTtmb3IobGV0IGw9MDtsPG8uY2hpbGRyZW4ubGVuZ3RoO2wrKylpW2xdPT09aCYmRXQoe25vZGU6by5jaGlsZHJlbltsXSxrZXlwb2ludHM6bixxdWVyeXBvaW50OmUscXVldWU6dCxrZXlwb2ludEluZGV4ZXM6cyxudW1Qb3A6cn0pO2lmKHI8S2UmJnQubGVuZ3RoPjApe2NvbnN0e25vZGU6bCxkOnV9PXQucG9wKCk7cis9MSxFdCh7bm9kZTpsLGtleXBvaW50czpuLHF1ZXJ5cG9pbnQ6ZSxxdWV1ZTp0LGtleXBvaW50SW5kZXhlczpzLG51bVBvcDpyfSl9fSxZdD1vPT57Y29uc3R7SDpuLG1hdGNoZXM6ZSx0aHJlc2hvbGQ6dH09byxzPXQqdCxyPVtdO2ZvcihsZXQgaT0wO2k8ZS5sZW5ndGg7aSsrKXtjb25zdCBoPWVbaV0ucXVlcnlwb2ludCxsPWVbaV0ua2V5cG9pbnQsdT1vdChbbC54LGwueV0sbik7KHVbMF0taC54KSoodVswXS1oLngpKyh1WzFdLWgueSkqKHVbMV0taC55KTw9cyYmci5wdXNoKGVbaV0pfXJldHVybiByfTtjbGFzcyBHZXtjb25zdHJ1Y3RvcihuLGUsdD0hMSl7dGhpcy5xdWVyeVdpZHRoPW4sdGhpcy5xdWVyeUhlaWdodD1lLHRoaXMuZGVidWdNb2RlPXR9bWF0Y2hEZXRlY3Rpb24obixlKXtsZXQgdD17ZnJhbWVzOltdfSxzPW51bGw7Zm9yKGxldCBsPTA7bDxuLmxlbmd0aDtsKyspe2NvbnN0e0g6dSxtYXRjaGVzOmYsZGVidWdFeHRyYTpnfT1KZSh7a2V5ZnJhbWU6bltsXSxxdWVyeXBvaW50czplLHF1ZXJ5d2lkdGg6dGhpcy5xdWVyeVdpZHRoLHF1ZXJ5aGVpZ2h0OnRoaXMucXVlcnlIZWlnaHQsZGVidWdNb2RlOnRoaXMuZGVidWdNb2RlfSk7dC5mcmFtZXMucHVzaChnKSx1JiYocz09PW51bGx8fHMubWF0Y2hlcy5sZW5ndGg8Zi5sZW5ndGgpJiYocz17a2V5ZnJhbWVJbmRleDpsLEg6dSxtYXRjaGVzOmZ9KX1pZihzPT09bnVsbClyZXR1cm57a2V5ZnJhbWVJbmRleDotMSxkZWJ1Z0V4dHJhOnR9O2NvbnN0IHI9W10saT1bXSxoPW5bcy5rZXlmcmFtZUluZGV4XTtmb3IobGV0IGw9MDtsPHMubWF0Y2hlcy5sZW5ndGg7bCsrKXtjb25zdCB1PXMubWF0Y2hlc1tsXS5xdWVyeXBvaW50LGY9cy5tYXRjaGVzW2xdLmtleXBvaW50O3IucHVzaCh7eDp1LngseTp1Lnl9KSxpLnB1c2goe3g6KGYueCsuNSkvaC5zY2FsZSx5OihmLnkrLjUpL2guc2NhbGUsejowfSl9cmV0dXJue3NjcmVlbkNvb3JkczpyLHdvcmxkQ29vcmRzOmksa2V5ZnJhbWVJbmRleDpzLmtleWZyYW1lSW5kZXgsZGVidWdFeHRyYTp0fX19Y29uc3QgV2U9KHtzY3JlZW5Db29yZHM6byx3b3JsZENvb3JkczpuLHByb2plY3Rpb25UcmFuc2Zvcm06ZX0pPT57Y29uc3QgdD1WdChuLm1hcChtPT5bbS54LG0ueV0pLG8ubWFwKG09PlttLngsbS55XSkpLHM9bmV3IGIoW1t0WzBdLHRbMV0sdFsyXV0sW3RbM10sdFs0XSx0WzVdXSxbdFs2XSx0WzddLHRbOF1dXSkscj1uZXcgYihlKSxsPU10KHIpLm1tdWwocykudG8xREFycmF5KCksdT1NYXRoLnNxcnQobFswXSpsWzBdK2xbM10qbFszXStsWzZdKmxbNl0pLGY9TWF0aC5zcXJ0KGxbMV0qbFsxXStsWzRdKmxbNF0rbFs3XSpsWzddKSxnPSh1K2YpLzIsYT1bXTthWzBdPWxbMF0vdSxhWzNdPWxbM10vdSxhWzZdPWxbNl0vdSxhWzFdPWxbMV0vZixhWzRdPWxbNF0vZixhWzddPWxbN10vZixhWzJdPWFbM10qYVs3XS1hWzZdKmFbNF0sYVs1XT1hWzZdKmFbMV0tYVswXSphWzddLGFbOF09YVswXSphWzRdLWFbMV0qYVszXTtjb25zdCBqPU1hdGguc3FydChhWzJdKmFbMl0rYVs1XSphWzVdK2FbOF0qYVs4XSk7YVsyXS89aixhWzVdLz1qLGFbOF0vPWo7Y29uc3Qgdz1bXTtyZXR1cm4gd1swXT1sWzJdL2csd1sxXT1sWzVdL2csd1syXT1sWzhdL2csW1thWzBdLGFbMV0sYVsyXSx3WzBdXSxbYVszXSxhWzRdLGFbNV0sd1sxXV0sW2FbNl0sYVs3XSxhWzhdLHdbMl1dXX0sUWU9KG8sbik9Pltbb1swXVswXSpuWzBdWzBdK29bMF1bMl0qblsyXVswXSxvWzBdWzBdKm5bMF1bMV0rb1swXVsyXSpuWzJdWzFdLG9bMF1bMF0qblswXVsyXStvWzBdWzJdKm5bMl1bMl0sb1swXVswXSpuWzBdWzNdK29bMF1bMl0qblsyXVszXV0sW29bMV1bMV0qblsxXVswXStvWzFdWzJdKm5bMl1bMF0sb1sxXVsxXSpuWzFdWzFdK29bMV1bMl0qblsyXVsxXSxvWzFdWzFdKm5bMV1bMl0rb1sxXVsyXSpuWzJdWzJdLG9bMV1bMV0qblsxXVszXStvWzFdWzJdKm5bMl1bM11dLFtuWzJdWzBdLG5bMl1bMV0sblsyXVsyXSxuWzJdWzNdXV0sQ3Q9KG8sbixlLHQpPT57Y29uc3Qgcz1vWzBdWzBdKm4rb1swXVsxXSplK29bMF1bM10scj1vWzFdWzBdKm4rb1sxXVsxXSplK29bMV1bM10saT1vWzJdWzBdKm4rb1syXVsxXSplK29bMl1bM107cmV0dXJue3g6cyx5OnIsejppfX0sWmU9KG8sbixlLHQpPT57Y29uc3R7eDpzLHk6cix6Oml9PUN0KG8sbixlKTtyZXR1cm57eDpzL2kseTpyL2l9fSx4ZT01LEFlPTQsSHQ9MTAsdG49LjEsZW49Ljk5O2xldCBIPVtbXSxbXSxbXV0sQT1bW10sW11dLE89W1tdLFtdLFtdXTtjb25zdCBubj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dH0pPT57bGV0IHM9MCxyPTA7Zm9yKGxldCBnPTA7ZzxlLmxlbmd0aDtnKyspcys9ZVtnXS54LHIrPWVbZ10ueTtzLz1lLmxlbmd0aCxyLz1lLmxlbmd0aDtjb25zdCBpPVtdO2ZvcihsZXQgZz0wO2c8ZS5sZW5ndGg7ZysrKWkucHVzaCh7eDplW2ddLngtcyx5OmVbZ10ueS1yLHo6ZVtnXS56fSk7Y29uc3QgaD1bW10sW10sW11dO2ZvcihsZXQgZz0wO2c8MztnKyspZm9yKGxldCBhPTA7YTwzO2ErKyloW2ddW2FdPW9bZ11bYV07aFswXVszXT1vWzBdWzBdKnMrb1swXVsxXSpyK29bMF1bM10saFsxXVszXT1vWzFdWzBdKnMrb1sxXVsxXSpyK29bMV1bM10saFsyXVszXT1vWzJdWzBdKnMrb1syXVsxXSpyK29bMl1bM107Y29uc3QgbD1bMSwuOCwuNiwuNCwwXTtsZXQgdT1oLGY9bnVsbDtmb3IobGV0IGc9MDtnPGwubGVuZ3RoO2crKyl7Y29uc3QgYT1zbih7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTp1LHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkczppLHNjcmVlbkNvb3Jkczp0LGlubGllclByb2I6bFtnXX0pO2lmKHU9YS5tb2RlbFZpZXdUcmFuc2Zvcm0sYS5lcnI8eGUpe2Y9dTticmVha319cmV0dXJuIGY9PT1udWxsP251bGw6KGZbMF1bM109ZlswXVszXS1mWzBdWzBdKnMtZlswXVsxXSpyLGZbMV1bM109ZlsxXVszXS1mWzFdWzBdKnMtZlsxXVsxXSpyLGZbMl1bM109ZlsyXVszXS1mWzJdWzBdKnMtZlsyXVsxXSpyLGYpfSxzbj0oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06byxwcm9qZWN0aW9uVHJhbnNmb3JtOm4sd29ybGRDb29yZHM6ZSxzY3JlZW5Db29yZHM6dCxpbmxpZXJQcm9iOnN9KT0+e2NvbnN0IHI9czwxO2xldCBpPW8saD0wLGw9MCx1PW5ldyBBcnJheShlLmxlbmd0aCksZj1uZXcgQXJyYXkoZS5sZW5ndGgpLGc9bmV3IEFycmF5KGUubGVuZ3RoKSxhPW5ldyBBcnJheShlLmxlbmd0aCk7Zm9yKGxldCBqPTA7ajw9SHQ7aisrKXtjb25zdCB3PVFlKG4saSk7Zm9yKGxldCBFPTA7RTxlLmxlbmd0aDtFKyspe2NvbnN0IGs9WmUodyxlW0VdLngsZVtFXS55LGVbRV0ueiksUj10W0VdLngtay54LHE9dFtFXS55LWsueTtnW0VdPVIsYVtFXT1xLHVbRV09UipSK3EqcX1sZXQgeTtpZihsPTAscil7Y29uc3QgRT1NYXRoLm1heCgzLE1hdGguZmxvb3IoZS5sZW5ndGgqcyktMSk7Zm9yKGxldCBrPTA7azxlLmxlbmd0aDtrKyspZltrXT11W2tdO2Yuc29ydCgoayxSKT0+ay1SKSx5PU1hdGgubWF4KGZbRV0qQWUsMTYpO2ZvcihsZXQgaz0wO2s8ZS5sZW5ndGg7aysrKWZba10+eT9sKz15LzY6bCs9eS82KigxLSgxLWZba10veSkqKDEtZltrXS95KSooMS1mW2tdL3kpKX1lbHNlIGZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKWwrPXVbRV07aWYobC89ZS5sZW5ndGgsbDx0bnx8aj4wJiZsL2g+ZW58fGo9PT1IdClicmVhaztoPWw7Y29uc3QgbT1bXSxNPVtdO2ZvcihsZXQgRT0wO0U8ZS5sZW5ndGg7RSsrKXtpZihyJiZ1W0VdPnkpY29udGludWU7Y29uc3Qgaz1sbih7bW9kZWxWaWV3UHJvamVjdGlvblRyYW5zZm9ybTp3LG1vZGVsVmlld1RyYW5zZm9ybTppLHByb2plY3Rpb25UcmFuc2Zvcm06bix3b3JsZENvb3JkOmVbRV19KTtpZihyKXtjb25zdCBSPSgxLXVbRV0veSkqKDEtdVtFXS95KTtmb3IobGV0IHE9MDtxPDI7cSsrKWZvcihsZXQgST0wO0k8NjtJKyspa1txXVtJXSo9UjttLnB1c2goW2dbRV0qUl0pLG0ucHVzaChbYVtFXSpSXSl9ZWxzZSBtLnB1c2goW2dbRV1dKSxtLnB1c2goW2FbRV1dKTtmb3IobGV0IFI9MDtSPGsubGVuZ3RoO1IrKylNLnB1c2goa1tSXSl9Y29uc3QgVD1ybih7ZFU6bSxKX1VfUzpNfSk7aWYoVD09PW51bGwpYnJlYWs7aT1vbih7bW9kZWxWaWV3VHJhbnNmb3JtOmksZFM6VH0pfXJldHVybnttb2RlbFZpZXdUcmFuc2Zvcm06aSxlcnI6bH19LG9uPSh7bW9kZWxWaWV3VHJhbnNmb3JtOm8sZFM6bn0pPT57bGV0IGU9blswXSpuWzBdK25bMV0qblsxXStuWzJdKm5bMl0sdCxzLHI7ZTwxZS02Pyh0PTEscz0wLHI9MCxlPTApOihlPU1hdGguc3FydChlKSx0PW5bMF0vZSxzPW5bMV0vZSxyPW5bMl0vZSk7Y29uc3QgaT1NYXRoLmNvcyhlKSxoPU1hdGguc2luKGUpLGw9MS1pO0hbMF1bMF09dCp0KmwraSxIWzBdWzFdPXQqcypsLXIqaCxIWzBdWzJdPXQqcipsK3MqaCxIWzBdWzNdPW5bM10sSFsxXVswXT1zKnQqbCtyKmgsSFsxXVsxXT1zKnMqbCtpLEhbMV1bMl09cypyKmwtdCpoLEhbMV1bM109bls0XSxIWzJdWzBdPXIqdCpsLXMqaCxIWzJdWzFdPXIqcypsK3QqaCxIWzJdWzJdPXIqcipsK2ksSFsyXVszXT1uWzVdO2NvbnN0IHU9W1tdLFtdLFtdXTtmb3IobGV0IGY9MDtmPDM7ZisrKXtmb3IobGV0IGc9MDtnPDQ7ZysrKXVbZl1bZ109b1tmXVswXSpIWzBdW2ddK29bZl1bMV0qSFsxXVtnXStvW2ZdWzJdKkhbMl1bZ107dVtmXVszXSs9b1tmXVszXX1yZXR1cm4gdX0scm49KHtkVTpvLEpfVV9TOm59KT0+e2NvbnN0IGU9bmV3IGIobiksdD1uZXcgYihvKSxzPWUudHJhbnNwb3NlKCkscj1zLm1tdWwoZSksaT1zLm1tdWwodCk7bGV0IGg7dHJ5e2g9TXQocil9Y2F0Y2h7cmV0dXJuIG51bGx9cmV0dXJuIGgubW11bChpKS50bzFEQXJyYXkoKX0sbG49KHttb2RlbFZpZXdQcm9qZWN0aW9uVHJhbnNmb3JtOm8sbW9kZWxWaWV3VHJhbnNmb3JtOm4scHJvamVjdGlvblRyYW5zZm9ybTplLHdvcmxkQ29vcmQ6dH0pPT57Y29uc3Qgcz1uLHt4OnIseTppLHo6aH09dCxsPUN0KG8scixpKSx1PWwueipsLno7QVswXVswXT1lWzBdWzBdKmwuei91LEFbMF1bMV09ZVswXVsxXSpsLnovdSxBWzBdWzJdPShlWzBdWzJdKmwuei1lWzJdWzJdKmwueCkvdSxBWzFdWzBdPWVbMV1bMF0qbC56L3UsQVsxXVsxXT1lWzFdWzFdKmwuei91LEFbMV1bMl09KGVbMV1bMl0qbC56LWVbMl1bMl0qbC55KS91LE9bMF1bMF09c1swXVsyXSppLE9bMF1bMV09LXNbMF1bMl0qcixPWzBdWzJdPXNbMF1bMV0qci1zWzBdWzBdKmksT1swXVszXT1zWzBdWzBdLE9bMF1bNF09c1swXVsxXSxPWzBdWzVdPXNbMF1bMl0sT1sxXVswXT1zWzFdWzJdKmksT1sxXVsxXT0tc1sxXVsyXSpyLE9bMV1bMl09c1sxXVsxXSpyLXNbMV1bMF0qaSxPWzFdWzNdPXNbMV1bMF0sT1sxXVs0XT1zWzFdWzFdLE9bMV1bNV09c1sxXVsyXSxPWzJdWzBdPXNbMl1bMl0qaSxPWzJdWzFdPS1zWzJdWzJdKnIsT1syXVsyXT1zWzJdWzFdKnItc1syXVswXSppLE9bMl1bM109c1syXVswXSxPWzJdWzRdPXNbMl1bMV0sT1syXVs1XT1zWzJdWzJdO2NvbnN0IGY9W1tdLFtdXTtmb3IobGV0IGc9MDtnPDI7ZysrKWZvcihsZXQgYT0wO2E8NjthKyspe2ZbZ11bYV09MDtmb3IobGV0IGo9MDtqPDM7aisrKWZbZ11bYV0rPUFbZ11bal0qT1tqXVthXX1yZXR1cm4gZn07Y2xhc3MgaG57Y29uc3RydWN0b3Iobil7dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtPW59ZXN0aW1hdGUoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmV9KXtyZXR1cm4gV2Uoe3NjcmVlbkNvb3JkczpuLHdvcmxkQ29vcmRzOmUscHJvamVjdGlvblRyYW5zZm9ybTp0aGlzLnByb2plY3Rpb25UcmFuc2Zvcm19KX1yZWZpbmVFc3RpbWF0ZSh7aW5pdGlhbE1vZGVsVmlld1RyYW5zZm9ybTpuLHdvcmxkQ29vcmRzOmUsc2NyZWVuQ29vcmRzOnR9KXtyZXR1cm4gbm4oe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06bix3b3JsZENvb3JkczplLHNjcmVlbkNvb3Jkczp0LHByb2plY3Rpb25UcmFuc2Zvcm06dGhpcy5wcm9qZWN0aW9uVHJhbnNmb3JtfSl9fWxldCBLdD1udWxsLEp0PSExLEd0PW51bGwsU3Q9bnVsbDtvbm1lc3NhZ2U9bz0+e2NvbnN0e2RhdGE6bn09bztzd2l0Y2gobi50eXBlKXtjYXNlInNldHVwIjpuLnByb2plY3Rpb25UcmFuc2Zvcm0sS3Q9bi5tYXRjaGluZ0RhdGFMaXN0LEp0PW4uZGVidWdNb2RlLEd0PW5ldyBHZShuLmlucHV0V2lkdGgsbi5pbnB1dEhlaWdodCxKdCksU3Q9bmV3IGhuKG4ucHJvamVjdGlvblRyYW5zZm9ybSk7YnJlYWs7Y2FzZSJtYXRjaCI6Y29uc3QgZT1uLnRhcmdldEluZGV4ZXM7bGV0IHQ9LTEscz1udWxsLHI9bnVsbDtmb3IobGV0IGY9MDtmPGUubGVuZ3RoO2YrKyl7Y29uc3QgZz1lW2ZdLHtrZXlmcmFtZUluZGV4OmEsc2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6dyxkZWJ1Z0V4dHJhOnl9PUd0Lm1hdGNoRGV0ZWN0aW9uKEt0W2ddLG4uZmVhdHVyZVBvaW50cyk7aWYocj15LGEhPT0tMSl7Y29uc3QgbT1TdC5lc3RpbWF0ZSh7c2NyZWVuQ29vcmRzOmosd29ybGRDb29yZHM6d30pO20mJih0PWcscz1tKTticmVha319cG9zdE1lc3NhZ2Uoe3R5cGU6Im1hdGNoRG9uZSIsdGFyZ2V0SW5kZXg6dCxtb2RlbFZpZXdUcmFuc2Zvcm06cyxkZWJ1Z0V4dHJhOnJ9KTticmVhaztjYXNlInRyYWNrVXBkYXRlIjpjb25zdHttb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfT1uLHU9U3QucmVmaW5lRXN0aW1hdGUoe2luaXRpYWxNb2RlbFZpZXdUcmFuc2Zvcm06aSx3b3JsZENvb3JkczpoLHNjcmVlbkNvb3JkczpsfSk7cG9zdE1lc3NhZ2Uoe3R5cGU6InRyYWNrVXBkYXRlRG9uZSIsbW9kZWxWaWV3VHJhbnNmb3JtOnV9KTticmVhaztjYXNlImRpc3Bvc2UiOmNsb3NlKCk7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWVzc2FnZSB0eXBlICcke24udHlwZX0nYCl9fX0pKCk7Cg==",LM=typeof window<"u"&&window.Blob&&new Blob([atob(iA)],{type:"text/javascript;charset=utf-8"});function Sce(){let n;try{if(n=LM&&(window.URL||window.webkitURL).createObjectURL(LM),!n)throw"";return new Worker(n)}catch{return new Worker("data:application/javascript;base64,"+iA)}finally{n&&(window.URL||window.webkitURL).revokeObjectURL(n)}}const Tce=(n,e)=>[[n[0][0]*e[0][0]+n[0][2]*e[2][0],n[0][0]*e[0][1]+n[0][2]*e[2][1],n[0][0]*e[0][2]+n[0][2]*e[2][2],n[0][0]*e[0][3]+n[0][2]*e[2][3]],[n[1][1]*e[1][0]+n[1][2]*e[2][0],n[1][1]*e[1][1]+n[1][2]*e[2][1],n[1][1]*e[1][2]+n[1][2]*e[2][2],n[1][1]*e[1][3]+n[1][2]*e[2][3]],[e[2][0],e[2][1],e[2][2],e[2][3]]],_ce=(n,e,t,s)=>{const i=n[0][0]*e+n[0][1]*t+n[0][3],r=n[1][0]*e+n[1][1]*t+n[1][3],a=n[2][0]*e+n[2][1]*t+n[2][3];return{x:i,y:r,z:a}},Ice=(n,e,t,s)=>{const{x:i,y:r,z:a}=_ce(n,e,t);return{x:i/a,y:r/a}},Mce=6,Cce=1,Ece=10,kce=1,Nce=.8,Rce=1,Yi=1e3;class Ace{constructor(e,t,s,i,r,a=!1){this.markerDimensions=e,this.trackingDataList=t,this.projectionTransform=s,this.debugMode=a,this.trackingKeyframeList=[];for(let l=0;l<t.length;l++)this.trackingKeyframeList.push(t[l][Rce]);let o=0;for(let l=0;l<this.trackingKeyframeList.length;l++)o=Math.max(o,this.trackingKeyframeList[l].points.length);this.featurePointsListT=[],this.imagePixelsListT=[],this.imagePropertiesListT=[];for(let l=0;l<this.trackingKeyframeList.length;l++){const{featurePoints:c,imagePixels:u,imageProperties:h}=this._prebuild(this.trackingKeyframeList[l],o);this.featurePointsListT[l]=c,this.imagePixelsListT[l]=u,this.imagePropertiesListT[l]=h}this.kernelCaches={}}dummyRun(e){let t=[[1,1,1,1],[1,1,1,1],[1,1,1,1]];for(let s=0;s<this.featurePointsListT.length;s++)this.track(e,t,s)}track(e,t,s){let i={};const r=Tce(this.projectionTransform,t),a=this._buildAdjustedModelViewTransform(r);this.markerDimensions[s][0],this.markerDimensions[s][1],this.trackingKeyframeList[s].width,this.trackingKeyframeList[s].height;const o=this.featurePointsListT[s],l=this.imagePixelsListT[s],c=this.imagePropertiesListT[s],u=this._computeProjection(a,e,s),{matchingPointsT:h,simT:d}=this._computeMatching(o,l,c,u),p=h.arraySync(),f=d.arraySync(),y=this.trackingKeyframeList[s],m=[],g=[],b=[];for(let x=0;x<p.length;x++)if(f[x]>Nce&&x<y.points.length){b.push(x);const v=Ice(r,p[x][0],p[x][1]);g.push(v),m.push({x:y.points[x].x/y.scale,y:y.points[x].y/y.scale,z:0})}return this.debugMode&&(i={projectedImage:u.arraySync(),matchingPoints:h.arraySync(),goodTrack:b,trackedPoints:g}),a.dispose(),u.dispose(),h.dispose(),d.dispose(),{worldCoords:m,screenCoords:g,debugExtra:i}}_computeMatching(e,t,s,i){const r=Mce,a=r*2+1,o=Ece*Cce,l=kce,c=o*2+1,u=i.shape[0],h=i.shape[1],d=e.shape[0];if(!this.kernelCaches.computeMatching){const p={variableNames:["features","markerPixels","markerProperties","targetPixels"],outputShape:[d,c*c],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    int featureIndex = coords[0];
	    int searchOffsetIndex = coords[1];

	    int markerWidth = int(getMarkerProperties(0));
	    int markerHeight = int(getMarkerProperties(1));
	    float markerScale = getMarkerProperties(2);

	    int searchOffsetX = imod(searchOffsetIndex, ${c}) * ${l};
	    int searchOffsetY = searchOffsetIndex / ${c} * ${l};

	    int sCenterX = int(getFeatures(featureIndex, 0) * markerScale);
	    int sCenterY = int(getFeatures(featureIndex, 1) * markerScale);

	    int sx = sCenterX + searchOffsetX - ${o};
	    int sy = sCenterY + searchOffsetY - ${o};

	    if (sx < ${r} || sx >= (${h} - ${r}) || sy < ${r} || sy >= (${u} - ${r})) {
	      setOutput(-2.);
	    } 
	    else {
	      float sumPoint = 0.;
	      float sumPointSquare = 0.;
	      float sumTemplate = 0.;
	      float sumTemplateSquare = 0.;
	      float sumPointTemplate = 0.;

	      for (int templateOffsetY = 0; templateOffsetY < ${a}; templateOffsetY++) {
		for (int templateOffsetX = 0; templateOffsetX < ${a}; templateOffsetX++) {
		  int fx2 = sCenterX + templateOffsetX - ${r};
		  int fy2 = sCenterY + templateOffsetY - ${r};

		  int sx2 = sx + templateOffsetX - ${r};
		  int sy2 = sy + templateOffsetY - ${r};

		  int markerPixelIndex = fy2 * markerWidth + fx2;
		  float markerPixel = getMarkerPixels(markerPixelIndex);
		  float targetPixel = getTargetPixels(sy2, sx2);

		  sumTemplate += markerPixel;
		  sumTemplateSquare += markerPixel * markerPixel;
		  sumPoint += targetPixel;
		  sumPointSquare += targetPixel * targetPixel;
		  sumPointTemplate += targetPixel * markerPixel;
		}
	      }

	      // Normalized cross-correlation
	      // !important divide first avoid overflow (e.g. sumPoint / count * sumPoint)
	      float count = float(${a} * ${a});
	      float pointVariance = sqrt(sumPointSquare - sumPoint / count * sumPoint);
	      float templateVariance = sqrt(sumTemplateSquare - sumTemplate / count * sumTemplate);

	      if (pointVariance < 0.0000001) {
		setOutput(-3.);
	      } else if (templateVariance < 0.0000001) {
		//setOutput(sumTemplate);
		setOutput(-4.);
	      } else {
		sumPointTemplate -= sumPoint / count * sumTemplate;
		float sim = sumPointTemplate / pointVariance / templateVariance;  
		setOutput(sim);
	      }
	    }
	  }
	`},f={variableNames:["featurePoints","markerProperties","maxIndex"],outputShape:[d,2],userCode:`
	  void main() {
	    ivec2 coords = getOutputCoords();

	    float markerScale = getMarkerProperties(2);

	    int featureIndex = coords[0];

	    int maxIndex = int(getMaxIndex(featureIndex));
	    int searchLocationIndex = maxIndex / ${c*c};
	    int searchOffsetIndex = imod(maxIndex, ${c*c});

	    if (coords[1] == 0) {
	      int searchOffsetX = imod(searchOffsetIndex, ${c}) * ${l};
	      setOutput(getFeaturePoints(featureIndex, 0) + float(searchOffsetX - ${o}) / markerScale);
	    }
	    else if (coords[1] == 1) {
	      int searchOffsetY = searchOffsetIndex / ${c} * ${l};
	      setOutput(getFeaturePoints(featureIndex, 1) + float(searchOffsetY - ${o}) / markerScale);
	    }
	  }
	`},y={variableNames:["sims","maxIndex"],outputShape:[d],userCode:`
	  void main() {
	    int featureIndex = getOutputCoords();
	    int maxIndex = int(getMaxIndex(featureIndex));
	    setOutput(getSims(featureIndex, maxIndex));
	  }
	`};this.kernelCaches.computeMatching=[p,f,y]}return j(()=>{const p=this.kernelCaches.computeMatching,f=this._compileAndRun(p[0],[e,t,s,i]),y=f.argMax(1),m=this._compileAndRun(p[1],[e,s,y]),g=this._compileAndRun(p[2],[f,y]);return{matchingPointsT:m,simT:g}})}_computeProjection(e,t,s){const i=this.trackingKeyframeList[s].width,r=this.trackingKeyframeList[s].height,a=this.trackingKeyframeList[s].scale,o=i+"-"+r+"-"+a;if(this.kernelCaches.computeProjection||(this.kernelCaches.computeProjection={}),!this.kernelCaches.computeProjection[o]){const l={variableNames:["M","pixel"],outputShape:[r,i],userCode:`
	  void main() {
	      ivec2 coords = getOutputCoords();

	      float m00 = getM(0, 0) * ${Yi}.;
	      float m01 = getM(0, 1) * ${Yi}.;
	      float m03 = getM(0, 3) * ${Yi}.;
	      float m10 = getM(1, 0) * ${Yi}.;
	      float m11 = getM(1, 1) * ${Yi}.;
	      float m13 = getM(1, 3) * ${Yi}.;
	      float m20 = getM(2, 0) * ${Yi}.;
	      float m21 = getM(2, 1) * ${Yi}.;
	      float m23 = getM(2, 3) * ${Yi}.;

	      float y = float(coords[0]) / float(${a});
	      float x = float(coords[1]) / float(${a});
	      float uz = (x * m20) + (y * m21) + m23;
	      float oneOverUz = 1. / uz;

	      float ux = (x * m00) + (y * m01) + m03;
	      float uy = (x * m10) + (y * m11) + m13;

	      ux = floor(ux * oneOverUz + 0.5);
	      uy = floor(uy * oneOverUz + 0.5);
	      setOutput(getPixel(int(uy), int(ux)));
	    }
	`};this.kernelCaches.computeProjection[o]=l}return j(()=>{const l=this.kernelCaches.computeProjection[o];return this._compileAndRun(l,[e,t])})}_buildAdjustedModelViewTransform(e){return j(()=>{let t=[];for(let s=0;s<e.length;s++){t.push([]);for(let i=0;i<e[s].length;i++)t[s].push(e[s][i]/Yi)}return en(t,[3,4])})}_prebuild(e,t){return j(()=>{const s=e.scale,i=[];for(let o=0;o<t;o++)o<e.points.length?i.push([e.points[o].x/s,e.points[o].y/s]):i.push([-1,-1]);const r=en(e.data,[e.width*e.height]),a=en([e.width,e.height,e.scale],[3]);return{featurePoints:en(i,[i.length,2],"float32"),imagePixels:r,imageProperties:a}})}_compileAndRun(e,t){const s=Gr().compileAndRun(e,t);return Ut().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}}const Sf=[{sigma:.55,points:[[-1,0],[-.5,-.866025],[.5,-.866025],[1,-0],[.5,.866025],[-.5,.866025]]},{sigma:.475,points:[[0,.930969],[-.806243,.465485],[-.806243,-.465485],[-0,-.930969],[.806243,-.465485],[.806243,.465485]]},{sigma:.4,points:[[.847306,-0],[.423653,.733789],[-.423653,.733789],[-.847306,0],[-.423653,-.733789],[.423653,-.733789]]},{sigma:.325,points:[[-0,-.741094],[.641806,-.370547],[.641806,.370547],[0,.741094],[-.641806,.370547],[-.641806,-.370547]]},{sigma:.25,points:[[-.595502,0],[-.297751,-.51572],[.297751,-.51572],[.595502,-0],[.297751,.51572],[-.297751,.51572]]},{sigma:.175,points:[[0,.362783],[-.314179,.181391],[-.314179,-.181391],[-0,-.362783],[.314179,-.181391],[.314179,.181391]]},{sigma:.1,points:[[0,0]]}],Xo=[];for(let n=0;n<Sf.length;n++){const e=Sf[n].sigma;for(let t=0;t<Sf[n].points.length;t++){const s=Sf[n].points[t];Xo.push([e,s[0],s[1]])}}const o0={};function Lce(n){const e=n.shape[1],t=n.shape[0],s="w"+e+"h"+t;if(!o0.hasOwnProperty(s)){const i={variableNames:["p"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0], coords[1]-2);
          sum += getP(coords[0], coords[1]-1) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0], coords[1]+1) * 4.;
          sum += getP(coords[0], coords[1]+2);
          setOutput(sum);
        }
      `},r={variableNames:["p"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();

          float sum = getP(coords[0]-2, coords[1]);
          sum += getP(coords[0]-1, coords[1]) * 4.;
          sum += getP(coords[0], coords[1]) * 6.;
          sum += getP(coords[0]+1, coords[1]) * 4.;
          sum += getP(coords[0]+2, coords[1]);
          sum /= 256.;
          setOutput(sum);
        }
      `};o0[s]=[i,r]}return o0[s]}const Pce=n=>{const e=n.inputs.image,t=n.backend,[s,i]=Lce(e),r=t.runWebGLProgram(s,[e],e.dtype),a=t.runWebGLProgram(i,[r],e.dtype);return t.disposeIntermediateTensorInfo(r),a},Dce={kernelName:"BinomialFilter",backendName:"webgl",kernelFunc:Pce},Tf=7,PM=3,Fce=PM*PM,l0=4,Oce=(l0+1)*(l0+1)/l0,c0={};function Gce(n){const e=n.shape[1],t=n.shape[0],s="w"+e+"h"+t;if(!c0.hasOwnProperty(s)){const i={variableNames:["image0","image1","image2"],outputShape:[t,e],userCode:`
        void main() {
          ivec2 coords = getOutputCoords();
    
          int y = coords[0];
          int x = coords[1];
    
          float value = getImage1(y, x);
    
          // Step 1: find local maxima/minima
          if (value * value < ${Fce}.) {
            setOutput(0.);
            return;
          }
          if (y < ${Tf} || y > ${t-1-Tf}) {
            setOutput(0.);
            return;
          }
          if (x < ${Tf} || x > ${e-1-Tf}) {
            setOutput(0.);
            return;
          }
    
          bool isMax = true;
          bool isMin = true;
          for (int dy = -1; dy <= 1; dy++) {
            for (int dx = -1; dx <= 1; dx++) {
              float value0 = getImage0(y+dy, x+dx);
              float value1 = getImage1(y+dy, x+dx);
              float value2 = getImage2(y+dy, x+dx);
    
        if (value < value0 || value < value1 || value < value2) {
          isMax = false;
        }
        if (value > value0 || value > value1 || value > value2) {
          isMin = false;
        }
            }
          }
    
          if (!isMax && !isMin) {
            setOutput(0.);
            return;
          }
    
          // compute edge score and reject based on threshold
          float dxx = getImage1(y, x+1) + getImage1(y, x-1) - 2. * getImage1(y, x);
          float dyy = getImage1(y+1, x) + getImage1(y-1, x) - 2. * getImage1(y, x);
          float dxy = 0.25 * (getImage1(y-1,x-1) + getImage1(y+1,x+1) - getImage1(y-1,x+1) - getImage1(y+1,x-1));
    
          float det = (dxx * dyy) - (dxy * dxy);
    
          if (abs(det) < 0.0001) { // determinant undefined. no solution
            setOutput(0.);
            return;
          }
    
          float edgeScore = (dxx + dyy) * (dxx + dyy) / det;
    
          if (abs(edgeScore) >= ${Oce} ) {
            setOutput(0.);
            return;
          }
          setOutput(getImage1(y,x));
        }
      `};c0[s]=i}return c0[s]}const zce=n=>{let{image0:e,image1:t,image2:s}=n.inputs;const i=n.backend,r=Gce(t);return e=Ut().runKernel("DownsampleBilinear",{image:e}),s=Ut().runKernel("UpsampleBilinear",{image:s,targetImage:t}),i.runWebGLProgram(r,[e,t,s],t.dtype)},Vce={kernelName:"BuildExtremas",backendName:"webgl",kernelFunc:zce},sh=36,u0={};function Wce(n){const e=n.shape[0];if(!u0.hasOwnProperty(e)){const t={variableNames:["histogram"],outputShape:[n.shape[0]],userCode:`
            void main() {
                int featureIndex = getOutputCoords();

                int maxIndex = 0;
                for (int i = 1; i < ${sh}; i++) {
                    if (getHistogram(featureIndex, i) > getHistogram(featureIndex, maxIndex)) {
                        maxIndex = i;
                    }
                }

                int prev = imod(maxIndex - 1 + ${sh}, ${sh});
                int next = imod(maxIndex + 1, ${sh});

                /**
                 * Fit a quatratic to 3 points. The system of equations is:
                 *
                 * y0 = A*x0^2 + B*x0 + C
                 * y1 = A*x1^2 + B*x1 + C
                 * y2 = A*x2^2 + B*x2 + C
                 *
                 * This system of equations is solved for A,B,C.
                 */
                float p10 = float(maxIndex - 1);
                float p11 = getHistogram(featureIndex, prev); 
                float p20 = float(maxIndex);
                float p21 = getHistogram(featureIndex, maxIndex); 
                float p30 = float(maxIndex + 1);
                float p31 = getHistogram(featureIndex, next); 

                float d1 = (p30-p20)*(p30-p10);
                float d2 = (p10-p20)*(p30-p10);
                float d3 = p10-p20;

                // If any of the denominators are zero then, just use maxIndex.
                    float fbin = float(maxIndex);
                if ( abs(d1) > 0.00001 && abs(d2) > 0.00001 && abs(d3) > 0.00001) {
                float a = p10*p10;
                float b = p20*p20;

                // Solve for the coefficients A,B,C
                float A = ((p31-p21)/d1)-((p11-p21)/d2);
                float B = ((p11-p21)+(A*(b-a)))/d3;
                float C = p11-(A*a)-(B*p10);
                fbin = -B / (2. * A);
                }

                float an = 2.0 *${Math.PI} * (fbin + 0.5) / ${sh}. - ${Math.PI};
                setOutput(an);
            }
            `};u0[e]=t}return u0[e]}const Uce=n=>{const{histograms:e}=n.inputs,t=n.backend,s=Wce(e);return t.runWebGLProgram(s,[e],e.dtype)},Bce={kernelName:"ComputeExtremaAngles",backendName:"webgl",kernelFunc:Uce},DM=7,h0={};function $ce(n,e){const t=`${n}|${e.shape[0]}`;if(!h0.hasOwnProperty(t)){const s=[];for(let a=1;a<n;a++)s.push("image"+a);let i="float getPixel(int octave, int y, int x) {";for(let a=1;a<n;a++)i+=`
  if (octave == ${a}) {
	return getImage${a}(y, x);
  }
`;i+="}";const r={variableNames:[...s,"extrema","angles","freakPoints"],outputShape:[e.shape[0],Xo.length],userCode:`
  ${i}
  void main() {
	ivec2 coords = getOutputCoords();
	int featureIndex = coords[0];
	int freakIndex = coords[1];

	float freakSigma = getFreakPoints(freakIndex, 0);
	float freakX = getFreakPoints(freakIndex, 1);
	float freakY = getFreakPoints(freakIndex, 2);

	int octave = int(getExtrema(featureIndex, 1));
	float inputY = getExtrema(featureIndex, 2);
	float inputX = getExtrema(featureIndex, 3);
	float inputAngle = getAngles(featureIndex);
	float cos = ${DM}. * cos(inputAngle);
	float sin = ${DM}. * sin(inputAngle);

	float yp = inputY + freakX * sin + freakY * cos;
	float xp = inputX + freakX * cos + freakY * -sin;

	int x0 = int(floor(xp));
	int x1 = x0 + 1;
	int y0 = int(floor(yp));
	int y1 = y0 + 1;

	float f1 = getPixel(octave, y0, x0);
	float f2 = getPixel(octave, y0, x1);
	float f3 = getPixel(octave, y1, x0);
	float f4 = getPixel(octave, y1, x1);

	float x1f = float(x1);
	float y1f = float(y1);
	float x0f = float(x0);
	float y0f = float(y0);

	// ratio for interpolation between four neighbouring points
	float value = (x1f - xp) * (y1f - yp) * f1
		+ (xp - x0f) * (y1f - yp) * f2
		+ (x1f - xp) * (yp - y0f) * f3
		+ (xp - x0f) * (yp - y0f) * f4;

	setOutput(value);
  }
`};h0[t]=r}return h0[t]}const Xce=n=>{const{gaussianImagesT:e,prunedExtremas:t,prunedExtremasAngles:s,freakPointsT:i,pyramidImagesLength:r}=n.inputs,a=n.backend,o=$ce(r,t);return a.runWebGLProgram(o,[...e,t,s,i],"float32")},Hce={kernelName:"ComputeExtremaFreak",backendName:"webgl",kernelFunc:Xce},rA=(Xo.length-1)*Xo.length/2,Kce=Math.ceil(rA/8),d0={};function Zce(n){const e=`${n.shape[0]}`;if(!d0.hasOwnProperty(e)){const t={variableNames:["freak","p"],outputShape:[n.shape[0],Kce],userCode:`
  void main() {
    ivec2 coords = getOutputCoords();
    int featureIndex = coords[0];
    int descIndex = coords[1] * 8;

    int sum = 0;
    for (int i = 0; i < 8; i++) {
      if (descIndex + i >= ${rA}) {
        continue;
      }

      int p1 = int(getP(descIndex + i, 0));
      int p2 = int(getP(descIndex + i, 1));

      float v1 = getFreak(featureIndex, p1);
      float v2 = getFreak(featureIndex, p2);

      if (v1 < v2 + 0.01) {
        sum += int(pow(2.0, float(7 - i)));
      }
    }
    setOutput(float(sum));
  }
`};d0[e]=t}return d0[e]}const Yce=n=>{const{extremaFreaks:e,positionT:t}=n.inputs,{backend:s}=n,i=Zce(e);return s.runWebGLProgram(i,[e,t],"int32")},jce={kernelName:"ComputeFreakDescriptors",backendName:"webgl",kernelFunc:Yce},p0={};function Qce(n,e){const t=`${n}|${e}`;if(!p0.hasOwnProperty(t)){const s=[];let i="float getPixel(int octave, int y, int x) {";for(let r=1;r<n;r++)s.push("image"+r),i+=`
				if (octave == ${r}) {
					return getImage${r}(y, x);
				}
			`;i+="}",p0[t]={variableNames:[...s,"extrema"],outputShape:[e,3,3],userCode:`
			${i}
		
			void main() {
				ivec3 coords = getOutputCoords();
				int featureIndex = coords[0];
				float score = getExtrema(featureIndex, 0);
				if (score == 0.0) {
					return;
				}
		
				int dy = coords[1]-1;
				int dx = coords[2]-1;
				int octave = int(getExtrema(featureIndex, 1));
				int y = int(getExtrema(featureIndex, 2));
				int x = int(getExtrema(featureIndex, 3));
				setOutput(getPixel(octave, y+dy, x+dx));
			}
			`}}return p0[t]}const Jce=n=>{const{prunedExtremasList:e,dogPyramidImagesT:t}=n.inputs,s=n.backend,i=Qce(t.length,e.length),r=en(e,[e.length,e[0].length],"int32");return s.runWebGLProgram(i,[...t.slice(1),r],t[0].dtype)},qce={kernelName:"ComputeLocalization",backendName:"webgl",kernelFunc:Jce},eue=.159154943091895,Rl=36,f0={};function tue(n,e,t){const s=`${t}|${n.shape[0]}|${e.shape[0]}`;if(!f0.hasOwnProperty(s)){const i=[];for(let l=1;l<t;l++)i.push("image"+l);let r="float getPixel(int octave, int y, int x) {";for(let l=1;l<t;l++)r+=`
            if (octave == ${l}) {
                return getImage${l}(y, x);
            }
            `;r+="}";const a={variableNames:[...i,"extrema","radial"],outputShape:[n.shape[0],e.shape[0],2],userCode:`
                ${r}

                void main() {
                    ivec3 coords = getOutputCoords();
                    int featureIndex = coords[0];
                    int radialIndex = coords[1];
                    int propertyIndex = coords[2];

                    int radialY = int(getRadial(radialIndex, 0));
                    int radialX = int(getRadial(radialIndex, 1));
                    float radialW = getRadial(radialIndex, 2);

                    int octave = int(getExtrema(featureIndex, 1));
                    int y = int(getExtrema(featureIndex, 2));
                    int x = int(getExtrema(featureIndex, 3));

                    int xp = x + radialX;
                    int yp = y + radialY;

                    float dy = getPixel(octave, yp+1, xp) - getPixel(octave, yp-1, xp);
                    float dx = getPixel(octave, yp, xp+1) - getPixel(octave, yp, xp-1);

                    if (propertyIndex == 0) {
                    // be careful that atan(0, 0) gives 1.57 instead of 0 (different from js), but doesn't matter here, coz magnitude is 0
                    
                    float angle = atan(dy, dx) + ${Math.PI};
                    float fbin = angle * ${Rl}. * ${eue};
                    setOutput(fbin);
                    return;
                    }

                    if (propertyIndex == 1) {
                        float mag = sqrt(dx * dx + dy * dy);
                        float magnitude = radialW * mag;
                        setOutput(magnitude);
                        return;
                    }
                }

                `},o={variableNames:["fbinMag"],outputShape:[n.shape[0],Rl],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int featureIndex = coords[0];
                int binIndex = coords[1];

                float sum = 0.;
                for (int i = 0; i < ${e.shape[0]}; i++) {
                    float fbin = getFbinMag(featureIndex, i, 0);
                    int bin = int(floor(fbin - 0.5));
                    int b1 = imod(bin + ${Rl}, ${Rl});
                    int b2 = imod(bin + 1 + ${Rl}, ${Rl});

                    if (b1 == binIndex || b2 == binIndex) {
                        float magnitude = getFbinMag(featureIndex, i, 1);
                        float w2 = fbin - float(bin) - 0.5;
                        float w1 = w2 * -1. + 1.;

                        if (b1 == binIndex) {
                            sum += w1 * magnitude;
                        }
                        if (b2 == binIndex) {
                            sum += w2 * magnitude;
                        }
                    }
                }
                setOutput(sum);
            }
            `};f0[s]=[a,o]}return f0[s]}const nue=n=>{const{gaussianImagesT:e,prunedExtremasT:t,radialPropertiesT:s,pyramidImagesLength:i}=n.inputs,r=n.backend,[a,o]=tue(t,s,i),l=r.runWebGLProgram(a,[...e,t,s],s.dtype),c=r.runWebGLProgram(o,[l],s.dtype);return r.disposeIntermediateTensorInfo(l),c},sue={kernelName:"ComputeOrientationHistograms",backendName:"webgl",kernelFunc:nue},m0={};function iue(n){const e=n.shape[1],t=n.shape[0],s="w"+e+"h"+t;if(!m0.hasOwnProperty(s)){const i={variableNames:["p"],outputShape:[Math.floor(t/2),Math.floor(e/2)],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();
                int y = coords[0] * 2;
                int x = coords[1] * 2;
        
                float sum = getP(y, x) * 0.25;
                sum += getP(y+1,x) * 0.25; 
                sum += getP(y, x+1) * 0.25; 
                sum += getP(y+1,x+1) * 0.25;
                setOutput(sum);
            }
            `};m0[s]=i}return m0[s]}const rue=n=>{const e=n.inputs.image,t=n.backend,s=iue(e);return t.runWebGLProgram(s,[e],e.dtype)},aue={kernelName:"DownsampleBilinear",backendName:"webgl",kernelFunc:rue},oue=n=>{const{extremasResultT:e}=n.inputs,t=n.backend,s=e.shape[0],i=e.shape[1],r={variableNames:["extrema"],outputShape:[Math.floor(s/2),Math.floor(i/2)],userCode:`
		  void main() {
			ivec2 coords = getOutputCoords();
			int y = coords[0] * 2;
			int x = coords[1] * 2;
  
			float location = 0.0;
			float values = getExtrema(y, x);
  
			if (getExtrema(y+1, x) != 0.0) {
			  location = 1.0;
		  values = getExtrema(y+1, x);
			}
			else if (getExtrema(y, x+1) != 0.0) {
			  location = 2.0;
		  values = getExtrema(y, x+1);
			}
			else if (getExtrema(y+1, x+1) != 0.0) {
			  location = 3.0;
		  values = getExtrema(y+1, x+1);
			}
  
			if (values < 0.0) {
			  setOutput(location * -1000.0 + values);
			} else {
			  setOutput(location * 1000.0 + values);
			}
		  }
		`};return t.runWebGLProgram(r,[e],e.dtype)},lue={kernelName:"ExtremaReduction",backendName:"webgl",kernelFunc:oue},_f=36,cue=5,g0={};function uue(n){const e=`h${n.shape[0]}`;if(!g0.hasOwnProperty(e)){const t={variableNames:["histogram"],outputShape:[n.shape[0],_f],userCode:`
            void main() {
                ivec2 coords = getOutputCoords();

                int featureIndex = coords[0];
                int binIndex = coords[1];

                int prevBin = imod(binIndex - 1 + ${_f}, ${_f});
                int nextBin = imod(binIndex + 1, ${_f});
                float result = 0.274068619061197 * getHistogram(featureIndex, prevBin) + 0.451862761877606 * getHistogram(featureIndex, binIndex) + 0.274068619061197 * getHistogram(featureIndex, nextBin);

                setOutput(result);
            }
            `};g0[e]=t}return g0[e]}const hue=n=>{let{histograms:e}=n.inputs;const t=n.backend,s=uue(e);for(let i=0;i<cue;i++){const r=e;e=t.runWebGLProgram(s,[e],e.dtype),i>0&&t.disposeIntermediateTensorInfo(r)}return e},due={kernelName:"SmoothHistograms",backendName:"webgl",kernelFunc:hue},y0={};function pue(n,e){const t=e.shape[1],s=e.shape[0],i="w"+t+"h"+s;if(!y0.hasOwnProperty(i)){const r={variableNames:["p"],outputShape:[s,t],userCode:`
              void main() {
                ivec2 coords = getOutputCoords();
                int j = coords[0];
                int i = coords[1];
        
                float sj = 0.5 * float(j) - 0.25; 
                float si = 0.5 * float(i) - 0.25;
        
                float sj0 = floor(sj);
                float sj1 = ceil(sj);
                float si0 = floor(si);
                float si1 = ceil(si);
        
                int sj0I = int(sj0);
                int sj1I = int(sj1);
                int si0I = int(si0);
                int si1I = int(si1);
        
                float sum = 0.0;
                sum += getP(sj0I, si0I) * (si1 - si) * (sj1 - sj);
                sum += getP(sj1I, si0I) * (si1 - si) * (sj - sj0);
                sum += getP(sj0I, si1I) * (si - si0) * (sj1 - sj);
                sum += getP(sj1I, si1I) * (si - si0) * (sj - sj0);
                setOutput(sum);
              }
            `};y0[i]=r}return y0[i]}const fue=n=>{const{image:e,targetImage:t}=n.inputs,s=n.backend,i=pue(e,t);return s.runWebGLProgram(i,[e],e.dtype)},mue={kernelName:"UpsampleBilinear",backendName:"webgl",kernelFunc:fue};As(Dce);As(Vce);As(Bce);As(Hce);As(jce);As(qce);As(sue);As(aue);As(lue);As(due);As(mue);const FM=8,gue=5,ih=10,yue=5,b0=3,bue=1.5;(Xo.length-1)*Xo.length/2;class aA{constructor(e,t,s=!1){this.debugMode=s,this.width=e,this.height=t;let i=0;for(;e>=FM&&t>=FM&&(e/=2,t/=2,i++,i!==gue););this.numOctaves=i,this.tensorCaches={},this.kernelCaches={}}detectImageData(e){const t=new Uint8ClampedArray(4*e.length);for(let i=0;i<e.length;i++)t[4*i]=e[i],t[4*i+1]=e[i],t[4*i+2]=e[i],t[4*i+3]=255;const s=new ImageData(t,this.width,this.height);return this.detect(s)}detect(e){let t=null;const s=[];for(let g=0;g<this.numOctaves;g++){let b,x;g===0?b=this._applyFilter(e):b=this._downsampleBilinear(s[g-1][s[g-1].length-1]),x=this._applyFilter(b),s.push([b,x])}const i=[];for(let g=0;g<this.numOctaves;g++){let b=this._differenceImageBinomial(s[g][0],s[g][1]);i.push(b)}const r=[];for(let g=1;g<this.numOctaves-1;g++){const b=this._buildExtremas(i[g-1],i[g],i[g+1]);r.push(b)}const a=this._applyPrune(r),o=this._computeLocalization(a,i),l=this._computeOrientationHistograms(o,s),c=this._smoothHistograms(l),u=this._computeExtremaAngles(c),h=this._computeExtremaFreak(s,o,u),d=this._computeFreakDescriptors(h),p=o.arraySync(),f=u.arraySync(),y=d.arraySync();this.debugMode&&(t={pyramidImages:s.map(g=>g.map(b=>b.arraySync())),dogPyramidImages:i.map(g=>g?g.arraySync():null),extremasResults:r.map(g=>g.arraySync()),extremaAngles:u.arraySync(),prunedExtremas:a,localizedExtremas:o.arraySync()}),s.forEach(g=>g.forEach(b=>b.dispose())),i.forEach(g=>g&&g.dispose()),r.forEach(g=>g.dispose()),o.dispose(),l.dispose(),c.dispose(),u.dispose(),h.dispose(),d.dispose();const m=[];for(let g=0;g<p.length;g++){if(p[g][0]==0)continue;const b=[];for(let C=0;C<y[g].length;C+=4){const S=y[g][C],M=y[g][C+1],A=y[g][C+2],D=y[g][C+3];let F=S*16777216+M*65536+A*256+D;b.push(F)}const x=p[g][1],v=p[g][2],w=p[g][3]*Math.pow(2,x)+Math.pow(2,x-1)-.5,_=v*Math.pow(2,x)+Math.pow(2,x-1)-.5,I=Math.pow(2,x);m.push({maxima:p[g][0]>0,x:w,y:_,scale:I,angle:f[g],descriptors:b})}return{featurePoints:m,debugExtra:t}}_computeFreakDescriptors(e){if(!this.tensorCaches.computeFreakDescriptors){const s=[],i=[];for(let o=0;o<e.shape[1];o++)for(let l=o+1;l<e.shape[1];l++)s.push(o),i.push(l);const r=en(s,[s.length]).cast("int32"),a=en(i,[i.length]).cast("int32");this.tensorCaches.computeFreakDescriptors={positionT:hn(ps([r,a],1))}}const{positionT:t}=this.tensorCaches.computeFreakDescriptors;return j(()=>Ut().runKernel("ComputeFreakDescriptors",{extremaFreaks:e,positionT:t}))}_computeExtremaFreak(e,t,s){this.tensorCaches._computeExtremaFreak||j(()=>{const a=en(Xo);this.tensorCaches._computeExtremaFreak={freakPointsT:hn(a)}});const{freakPointsT:i}=this.tensorCaches._computeExtremaFreak,r=[];for(let a=1;a<e.length;a++)r.push(e[a][1]);return j(()=>Ut().runKernel("ComputeExtremaFreak",{gaussianImagesT:r,prunedExtremas:t,prunedExtremasAngles:s,freakPointsT:i,pyramidImagesLength:e.length}))}_computeExtremaAngles(e){return j(()=>Ut().runKernel("ComputeExtremaAngles",{histograms:e}))}_computeOrientationHistograms(e,t){const s=[];for(let r=1;r<t.length;r++)s.push(t[r][1]);this.tensorCaches.orientationHistograms||j(()=>{const r=-1/(2*b0*b0),a=b0*bue,o=Math.ceil(a),l=[];for(let c=-o;c<=o;c++)for(let u=-o;u<=o;u++){const h=u*u+c*c;if(h<=a*a){const d=h*r;let p=(720+d*(720+d*(360+d*(120+d*(30+d*(6+d))))))*.0013888888;l.push([c,u,p])}}this.tensorCaches.orientationHistograms={radialPropertiesT:hn(en(l,[l.length,3]))}});const{radialPropertiesT:i}=this.tensorCaches.orientationHistograms;return j(()=>Ut().runKernel("ComputeOrientationHistograms",{gaussianImagesT:s,prunedExtremasT:e,radialPropertiesT:i,pyramidImagesLength:t.length}))}_smoothHistograms(e){return j(()=>Ut().runKernel("SmoothHistograms",{histograms:e}))}_computeLocalization(e,t){return j(()=>{const s=Ut().runKernel("ComputeLocalization",{prunedExtremasList:e,dogPyramidImagesT:t}).arraySync(),i=[];for(let a=0;a<s.length;a++){i.push([]);for(let o=0;o<s[a].length;o++)i[a].push([])}const r=[];for(let a=0;a<e.length;a++)r[a]=[e[a][0],e[a][1],e[a][2],e[a][3]];for(let a=0;a<r.length;a++){if(r[a][0]===0)continue;const o=s[a],l=.5*(o[1][2]-o[1][0]),c=.5*(o[2][1]-o[0][1]),u=o[1][2]+o[1][0]-2*o[1][1],h=o[2][1]+o[0][1]-2*o[1][1],d=.25*(o[0][0]+o[2][2]-o[0][2]-o[2][0]),p=u*h-d*d,f=(h*-l+-d*-c)/p,y=(-d*-l+u*-c)/p,m=r[a][2]+y,g=r[a][3]+f;Math.abs(p)<1e-4||(r[a][2]=m,r[a][3]=g)}return en(r,[r.length,r[0].length],"float32")})}_applyPrune(e){const t=ih*ih,s=yue,i=[],r=[];for(let o=0;o<t;o++){r.push([]),i.push([]);for(let l=0;l<s;l++)r[o].push([0,0,0,0]),i[o].push(0)}j(()=>{for(let o=0;o<e.length;o++){const l=Ut().runKernel("ExtremaReduction",{extremasResultT:e[o]}),c=o+1,u=l.arraySync(),h=l.shape[0],d=l.shape[1],p=d*2/ih,f=h*2/ih;for(let y=0;y<h;y++)for(let m=0;m<d;m++){const g=u[y][m];if(g==0)continue;const b=g%1e3,x=Math.floor(Math.abs(g)/1e3),v=m*2+(x===2||x===3?1:0),w=y*2+(x===1||x===3?1:0),_=Math.floor(v/p),I=Math.floor(w/f)*ih+_,C=Math.abs(b);let S=s;for(;S>=1&&C>i[I][S-1];)S-=1;if(S<s){for(let M=s-1;M>=S+1;M--)i[I][M]=i[I][M-1],r[I][M][0]=r[I][M-1][0],r[I][M][1]=r[I][M-1][1],r[I][M][2]=r[I][M-1][2],r[I][M][3]=r[I][M-1][3];i[I][S]=C,r[I][S][0]=b,r[I][S][1]=c,r[I][S][2]=w,r[I][S][3]=v}}}});const a=[];for(let o=0;o<t;o++)for(let l=0;l<s;l++)a.push(r[o][l]);return a}_buildExtremas(e,t,s){return j(()=>Ut().runKernel("BuildExtremas",{image0:e,image1:t,image2:s}))}_differenceImageBinomial(e,t){return j(()=>e.sub(t))}_applyFilter(e){return j(()=>Ut().runKernel("BinomialFilter",{image:e}))}_downsampleBilinear(e){return j(()=>Ut().runKernel("DownsampleBilinear",{image:e}))}_compileAndRun(e,t){const s=Gr().compileAndRun(e,t);return Ut().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}_runWebGLProgram(e,t,s){const i=Gr().runWebGLProgram(e,t,s);return Ut().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}}class xue{constructor(e,t,s=!1){this.debugMode=s,this.width=e,this.height=t;let i=Math.min(e,t)/2,r=Math.pow(2,Math.round(Math.log(i)/Math.log(2)));this.cropSize=r,this.detector=new aA(r,r,s),this.kernelCaches={},this.lastRandomIndex=4}detect(e){const t=Math.floor(this.height/2-this.cropSize/2),s=Math.floor(this.width/2-this.cropSize/2),i=this._detect(e,s,t);return this.debugMode&&(i.debugExtra.crop={startX:s,startY:t,cropSize:this.cropSize}),i}detectMoving(e){const t=this.lastRandomIndex%3,s=Math.floor(this.lastRandomIndex/3);let i=Math.floor(this.height/2-this.cropSize+s*this.cropSize/2),r=Math.floor(this.width/2-this.cropSize+t*this.cropSize/2);return r<0&&(r=0),i<0&&(i=0),r>=this.width-this.cropSize&&(r=this.width-this.cropSize-1),i>=this.height-this.cropSize&&(i=this.height-this.cropSize-1),this.lastRandomIndex=(this.lastRandomIndex+1)%9,this._detect(e,r,i)}_detect(e,t,s){const i=e.slice([s,t],[this.cropSize,this.cropSize]),{featurePoints:r,debugExtra:a}=this.detector.detect(i);return r.forEach(o=>{o.x+=t,o.y+=s}),this.debugMode&&(a.projectedImage=i.arraySync()),i.dispose(),{featurePoints:r,debugExtra:a}}}const oA=({image:n,ratio:e})=>{const t=Math.round(n.width*e),s=Math.round(n.height*e),i=new Uint8Array(t*s);for(let r=0;r<t;r++){let a=Math.round(1*r/e),o=Math.round(1*(r+1)/e)-1;o>=n.width&&(o=n.width-1);for(let l=0;l<s;l++){let c=Math.round(1*l/e),u=Math.round(1*(l+1)/e)-1;u>=n.height&&(u=n.height-1);let h=0,d=0;for(let p=a;p<=o;p++)for(let f=c;f<=u;f++)h+=1*n.data[f*n.width+p],d+=1;i[l*t+r]=Math.floor(h/d)}}return{data:i,width:t,height:s}},vue=100,wue=n=>{const e=vue/Math.min(n.width,n.height),t=[];let s=e;for(;;)if(t.push(s),s*=Math.pow(2,1/3),s>=.95){s=1;break}t.push(s),t.reverse();const i=[];for(let r=0;r<t.length;r++)n.width*t[r],n.height*t[r],i.push(Object.assign(oA({image:n,ratio:t[r]}),{scale:t[r]}));return i},Sue=n=>{const e=Math.min(n.width,n.height),t=[],s=[];t.push(256/e),t.push(128/e);for(let i=0;i<t.length;i++)s.push(Object.assign(oA({image:n,ratio:t[i]}),{scale:t[i]}));return s},Tue=n=>{const{v1:e,v2:t}=n;let s=0;for(let i=0;i<e.length;i++){let r=(e[i]^t[i])>>>0;s+=_ue(r)}return s},_ue=n=>{var e=n-(n>>1&1431655765);return e=(e>>2&858993459)+(e&858993459),e=(e>>4)+e&252645135,e=(e>>8)+e&16711935,e=(e>>16)+e&65535,e},Iue=1234,Mue=()=>({seed:Iue,arrayShuffle(n){const{arr:e,sampleSize:t}=n;for(let s=0;s<t;s++){this.seed=(214013*this.seed+2531011)%-2147483648;let i=this.seed>>16&32767;i=i%e.length;let r=e[s];e[s]=e[i],e[i]=r}},nextInt(n){this.seed=(214013*this.seed+2531011)%-2147483648;let e=this.seed>>16&32767;return e=e%n,e}}),Cue=16,Eue=128,Mx=8,kue=n=>{const{points:e,pointIndexes:t,randomizer:s}=n,i=[];for(let l=0;l<t.length;l++)i.push(l);let r=Number.MAX_SAFE_INTEGER,a=-1;const o=[];for(let l=0;l<Eue;l++){s.arrayShuffle({arr:i,sampleSize:Mx});let c=0;const u=[];for(let h=0;h<t.length;h++){let d=Number.MAX_SAFE_INTEGER;for(let p=0;p<Mx;p++){const f=t[i[p]],y=Tue({v1:e[t[h]].descriptors,v2:e[f].descriptors});y<d&&(u[h]=i[p],d=y)}c+=d}o.push(u),c<r&&(r=c,a=l)}return o[a]},OM=({points:n})=>{const e=[];for(let s=0;s<n.length;s++)e.push(s);const t=Mue();return{rootNode:lA({points:n,pointIndexes:e,centerPointIndex:null,randomizer:t})}},lA=n=>{const{points:e,pointIndexes:t,centerPointIndex:s,randomizer:i}=n;let r=!1;(t.length<=Mx||t.length<=Cue)&&(r=!0);const a={};if(!r){const l=kue({points:e,pointIndexes:t,randomizer:i});for(let c=0;c<l.length;c++)a[t[l[c]]]===void 0&&(a[t[l[c]]]=[]),a[t[l[c]]].push(t[c])}Object.keys(a).length===1&&(r=!0);const o={centerPointIndex:s};if(r){o.leaf=!0,o.pointIndexes=[];for(let l=0;l<t.length;l++)o.pointIndexes.push(t[l]);return o}return o.leaf=!1,o.children=[],Object.keys(a).forEach(l=>{o.children.push(lA({points:e,pointIndexes:a[l],centerPointIndex:l,randomizer:i}))}),o};var xo=4294967295;function Nue(n,e,t){var s=t/4294967296,i=t;n.setUint32(e,s),n.setUint32(e+4,i)}function cA(n,e,t){var s=Math.floor(t/4294967296),i=t;n.setUint32(e,s),n.setUint32(e+4,i)}function uA(n,e){var t=n.getInt32(e),s=n.getUint32(e+4);return t*4294967296+s}function Rue(n,e){var t=n.getUint32(e),s=n.getUint32(e+4);return t*4294967296+s}var x0,v0,w0,sb=(typeof process>"u"||((x0=process==null?void 0:process.env)===null||x0===void 0?void 0:x0.TEXT_ENCODING)!=="never")&&typeof TextEncoder<"u"&&typeof TextDecoder<"u";function GM(n){for(var e=n.length,t=0,s=0;s<e;){var i=n.charCodeAt(s++);if(i&4294967168)if(!(i&4294965248))t+=2;else{if(i>=55296&&i<=56319&&s<e){var r=n.charCodeAt(s);(r&64512)===56320&&(++s,i=((i&1023)<<10)+(r&1023)+65536)}i&4294901760?t+=4:t+=3}else{t++;continue}}return t}function Aue(n,e,t){for(var s=n.length,i=t,r=0;r<s;){var a=n.charCodeAt(r++);if(a&4294967168)if(!(a&4294965248))e[i++]=a>>6&31|192;else{if(a>=55296&&a<=56319&&r<s){var o=n.charCodeAt(r);(o&64512)===56320&&(++r,a=((a&1023)<<10)+(o&1023)+65536)}a&4294901760?(e[i++]=a>>18&7|240,e[i++]=a>>12&63|128,e[i++]=a>>6&63|128):(e[i++]=a>>12&15|224,e[i++]=a>>6&63|128)}else{e[i++]=a;continue}e[i++]=a&63|128}}var wm=sb?new TextEncoder:void 0,Lue=sb?typeof process<"u"&&((v0=process==null?void 0:process.env)===null||v0===void 0?void 0:v0.TEXT_ENCODING)!=="force"?200:0:xo;function Pue(n,e,t){e.set(wm.encode(n),t)}function Due(n,e,t){wm.encodeInto(n,e.subarray(t))}var Fue=wm!=null&&wm.encodeInto?Due:Pue,Oue=4096;function hA(n,e,t){for(var s=e,i=s+t,r=[],a="";s<i;){var o=n[s++];if(!(o&128))r.push(o);else if((o&224)===192){var l=n[s++]&63;r.push((o&31)<<6|l)}else if((o&240)===224){var l=n[s++]&63,c=n[s++]&63;r.push((o&31)<<12|l<<6|c)}else if((o&248)===240){var l=n[s++]&63,c=n[s++]&63,u=n[s++]&63,h=(o&7)<<18|l<<12|c<<6|u;h>65535&&(h-=65536,r.push(h>>>10&1023|55296),h=56320|h&1023),r.push(h)}else r.push(o);r.length>=Oue&&(a+=String.fromCharCode.apply(String,r),r.length=0)}return r.length>0&&(a+=String.fromCharCode.apply(String,r)),a}var Gue=sb?new TextDecoder:null,zue=sb?typeof process<"u"&&((w0=process==null?void 0:process.env)===null||w0===void 0?void 0:w0.TEXT_DECODER)!=="force"?200:0:xo;function Vue(n,e,t){var s=n.subarray(e,e+t);return Gue.decode(s)}var If=function(){function n(e,t){this.type=e,this.data=t}return n}(),Wue=globalThis&&globalThis.__extends||function(){var n=function(e,t){return n=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(s,i){s.__proto__=i}||function(s,i){for(var r in i)Object.prototype.hasOwnProperty.call(i,r)&&(s[r]=i[r])},n(e,t)};return function(e,t){if(typeof t!="function"&&t!==null)throw new TypeError("Class extends value "+String(t)+" is not a constructor or null");n(e,t);function s(){this.constructor=e}e.prototype=t===null?Object.create(t):(s.prototype=t.prototype,new s)}}(),qi=function(n){Wue(e,n);function e(t){var s=n.call(this,t)||this,i=Object.create(e.prototype);return Object.setPrototypeOf(s,i),Object.defineProperty(s,"name",{configurable:!0,enumerable:!1,value:e.name}),s}return e}(Error),Uue=-1,Bue=4294967296-1,$ue=17179869184-1;function Xue(n){var e=n.sec,t=n.nsec;if(e>=0&&t>=0&&e<=$ue)if(t===0&&e<=Bue){var s=new Uint8Array(4),i=new DataView(s.buffer);return i.setUint32(0,e),s}else{var r=e/4294967296,a=e&4294967295,s=new Uint8Array(8),i=new DataView(s.buffer);return i.setUint32(0,t<<2|r&3),i.setUint32(4,a),s}else{var s=new Uint8Array(12),i=new DataView(s.buffer);return i.setUint32(0,t),cA(i,4,e),s}}function Hue(n){var e=n.getTime(),t=Math.floor(e/1e3),s=(e-t*1e3)*1e6,i=Math.floor(s/1e9);return{sec:t+i,nsec:s-i*1e9}}function Kue(n){if(n instanceof Date){var e=Hue(n);return Xue(e)}else return null}function Zue(n){var e=new DataView(n.buffer,n.byteOffset,n.byteLength);switch(n.byteLength){case 4:{var t=e.getUint32(0),s=0;return{sec:t,nsec:s}}case 8:{var i=e.getUint32(0),r=e.getUint32(4),t=(i&3)*4294967296+r,s=i>>>2;return{sec:t,nsec:s}}case 12:{var t=uA(e,4),s=e.getUint32(0);return{sec:t,nsec:s}}default:throw new qi("Unrecognized data size for timestamp (expected 4, 8, or 12): ".concat(n.length))}}function Yue(n){var e=Zue(n);return new Date(e.sec*1e3+e.nsec/1e6)}var jue={type:Uue,encode:Kue,decode:Yue},dA=function(){function n(){this.builtInEncoders=[],this.builtInDecoders=[],this.encoders=[],this.decoders=[],this.register(jue)}return n.prototype.register=function(e){var t=e.type,s=e.encode,i=e.decode;if(t>=0)this.encoders[t]=s,this.decoders[t]=i;else{var r=1+t;this.builtInEncoders[r]=s,this.builtInDecoders[r]=i}},n.prototype.tryToEncode=function(e,t){for(var s=0;s<this.builtInEncoders.length;s++){var i=this.builtInEncoders[s];if(i!=null){var r=i(e,t);if(r!=null){var a=-1-s;return new If(a,r)}}}for(var s=0;s<this.encoders.length;s++){var i=this.encoders[s];if(i!=null){var r=i(e,t);if(r!=null){var a=s;return new If(a,r)}}}return e instanceof If?e:null},n.prototype.decode=function(e,t,s){var i=t<0?this.builtInDecoders[-1-t]:this.decoders[t];return i?i(e,t,s):new If(t,e)},n.defaultCodec=new n,n}();function Sm(n){return n instanceof Uint8Array?n:ArrayBuffer.isView(n)?new Uint8Array(n.buffer,n.byteOffset,n.byteLength):n instanceof ArrayBuffer?new Uint8Array(n):Uint8Array.from(n)}function Que(n){if(n instanceof ArrayBuffer)return new DataView(n);var e=Sm(n);return new DataView(e.buffer,e.byteOffset,e.byteLength)}var Jue=100,que=2048,ehe=function(){function n(e,t,s,i,r,a,o,l){e===void 0&&(e=dA.defaultCodec),t===void 0&&(t=void 0),s===void 0&&(s=Jue),i===void 0&&(i=que),r===void 0&&(r=!1),a===void 0&&(a=!1),o===void 0&&(o=!1),l===void 0&&(l=!1),this.extensionCodec=e,this.context=t,this.maxDepth=s,this.initialBufferSize=i,this.sortKeys=r,this.forceFloat32=a,this.ignoreUndefined=o,this.forceIntegerToFloat=l,this.pos=0,this.view=new DataView(new ArrayBuffer(this.initialBufferSize)),this.bytes=new Uint8Array(this.view.buffer)}return n.prototype.reinitializeState=function(){this.pos=0},n.prototype.encodeSharedRef=function(e){return this.reinitializeState(),this.doEncode(e,1),this.bytes.subarray(0,this.pos)},n.prototype.encode=function(e){return this.reinitializeState(),this.doEncode(e,1),this.bytes.slice(0,this.pos)},n.prototype.doEncode=function(e,t){if(t>this.maxDepth)throw new Error("Too deep objects in depth ".concat(t));e==null?this.encodeNil():typeof e=="boolean"?this.encodeBoolean(e):typeof e=="number"?this.encodeNumber(e):typeof e=="string"?this.encodeString(e):this.encodeObject(e,t)},n.prototype.ensureBufferSizeToWrite=function(e){var t=this.pos+e;this.view.byteLength<t&&this.resizeBuffer(t*2)},n.prototype.resizeBuffer=function(e){var t=new ArrayBuffer(e),s=new Uint8Array(t),i=new DataView(t);s.set(this.bytes),this.view=i,this.bytes=s},n.prototype.encodeNil=function(){this.writeU8(192)},n.prototype.encodeBoolean=function(e){e===!1?this.writeU8(194):this.writeU8(195)},n.prototype.encodeNumber=function(e){Number.isSafeInteger(e)&&!this.forceIntegerToFloat?e>=0?e<128?this.writeU8(e):e<256?(this.writeU8(204),this.writeU8(e)):e<65536?(this.writeU8(205),this.writeU16(e)):e<4294967296?(this.writeU8(206),this.writeU32(e)):(this.writeU8(207),this.writeU64(e)):e>=-32?this.writeU8(224|e+32):e>=-128?(this.writeU8(208),this.writeI8(e)):e>=-32768?(this.writeU8(209),this.writeI16(e)):e>=-2147483648?(this.writeU8(210),this.writeI32(e)):(this.writeU8(211),this.writeI64(e)):this.forceFloat32?(this.writeU8(202),this.writeF32(e)):(this.writeU8(203),this.writeF64(e))},n.prototype.writeStringHeader=function(e){if(e<32)this.writeU8(160+e);else if(e<256)this.writeU8(217),this.writeU8(e);else if(e<65536)this.writeU8(218),this.writeU16(e);else if(e<4294967296)this.writeU8(219),this.writeU32(e);else throw new Error("Too long string: ".concat(e," bytes in UTF-8"))},n.prototype.encodeString=function(e){var t=5,s=e.length;if(s>Lue){var i=GM(e);this.ensureBufferSizeToWrite(t+i),this.writeStringHeader(i),Fue(e,this.bytes,this.pos),this.pos+=i}else{var i=GM(e);this.ensureBufferSizeToWrite(t+i),this.writeStringHeader(i),Aue(e,this.bytes,this.pos),this.pos+=i}},n.prototype.encodeObject=function(e,t){var s=this.extensionCodec.tryToEncode(e,this.context);if(s!=null)this.encodeExtension(s);else if(Array.isArray(e))this.encodeArray(e,t);else if(ArrayBuffer.isView(e))this.encodeBinary(e);else if(typeof e=="object")this.encodeMap(e,t);else throw new Error("Unrecognized object: ".concat(Object.prototype.toString.apply(e)))},n.prototype.encodeBinary=function(e){var t=e.byteLength;if(t<256)this.writeU8(196),this.writeU8(t);else if(t<65536)this.writeU8(197),this.writeU16(t);else if(t<4294967296)this.writeU8(198),this.writeU32(t);else throw new Error("Too large binary: ".concat(t));var s=Sm(e);this.writeU8a(s)},n.prototype.encodeArray=function(e,t){var s=e.length;if(s<16)this.writeU8(144+s);else if(s<65536)this.writeU8(220),this.writeU16(s);else if(s<4294967296)this.writeU8(221),this.writeU32(s);else throw new Error("Too large array: ".concat(s));for(var i=0,r=e;i<r.length;i++){var a=r[i];this.doEncode(a,t+1)}},n.prototype.countWithoutUndefined=function(e,t){for(var s=0,i=0,r=t;i<r.length;i++){var a=r[i];e[a]!==void 0&&s++}return s},n.prototype.encodeMap=function(e,t){var s=Object.keys(e);this.sortKeys&&s.sort();var i=this.ignoreUndefined?this.countWithoutUndefined(e,s):s.length;if(i<16)this.writeU8(128+i);else if(i<65536)this.writeU8(222),this.writeU16(i);else if(i<4294967296)this.writeU8(223),this.writeU32(i);else throw new Error("Too large map object: ".concat(i));for(var r=0,a=s;r<a.length;r++){var o=a[r],l=e[o];this.ignoreUndefined&&l===void 0||(this.encodeString(o),this.doEncode(l,t+1))}},n.prototype.encodeExtension=function(e){var t=e.data.length;if(t===1)this.writeU8(212);else if(t===2)this.writeU8(213);else if(t===4)this.writeU8(214);else if(t===8)this.writeU8(215);else if(t===16)this.writeU8(216);else if(t<256)this.writeU8(199),this.writeU8(t);else if(t<65536)this.writeU8(200),this.writeU16(t);else if(t<4294967296)this.writeU8(201),this.writeU32(t);else throw new Error("Too large extension object: ".concat(t));this.writeI8(e.type),this.writeU8a(e.data)},n.prototype.writeU8=function(e){this.ensureBufferSizeToWrite(1),this.view.setUint8(this.pos,e),this.pos++},n.prototype.writeU8a=function(e){var t=e.length;this.ensureBufferSizeToWrite(t),this.bytes.set(e,this.pos),this.pos+=t},n.prototype.writeI8=function(e){this.ensureBufferSizeToWrite(1),this.view.setInt8(this.pos,e),this.pos++},n.prototype.writeU16=function(e){this.ensureBufferSizeToWrite(2),this.view.setUint16(this.pos,e),this.pos+=2},n.prototype.writeI16=function(e){this.ensureBufferSizeToWrite(2),this.view.setInt16(this.pos,e),this.pos+=2},n.prototype.writeU32=function(e){this.ensureBufferSizeToWrite(4),this.view.setUint32(this.pos,e),this.pos+=4},n.prototype.writeI32=function(e){this.ensureBufferSizeToWrite(4),this.view.setInt32(this.pos,e),this.pos+=4},n.prototype.writeF32=function(e){this.ensureBufferSizeToWrite(4),this.view.setFloat32(this.pos,e),this.pos+=4},n.prototype.writeF64=function(e){this.ensureBufferSizeToWrite(8),this.view.setFloat64(this.pos,e),this.pos+=8},n.prototype.writeU64=function(e){this.ensureBufferSizeToWrite(8),Nue(this.view,this.pos,e),this.pos+=8},n.prototype.writeI64=function(e){this.ensureBufferSizeToWrite(8),cA(this.view,this.pos,e),this.pos+=8},n}(),the={};function nhe(n,e){e===void 0&&(e=the);var t=new ehe(e.extensionCodec,e.context,e.maxDepth,e.initialBufferSize,e.sortKeys,e.forceFloat32,e.ignoreUndefined,e.forceIntegerToFloat);return t.encodeSharedRef(n)}function S0(n){return"".concat(n<0?"-":"","0x").concat(Math.abs(n).toString(16).padStart(2,"0"))}var she=16,ihe=16,rhe=function(){function n(e,t){e===void 0&&(e=she),t===void 0&&(t=ihe),this.maxKeyLength=e,this.maxLengthPerKey=t,this.hit=0,this.miss=0,this.caches=[];for(var s=0;s<this.maxKeyLength;s++)this.caches.push([])}return n.prototype.canBeCached=function(e){return e>0&&e<=this.maxKeyLength},n.prototype.find=function(e,t,s){var i=this.caches[s-1];e:for(var r=0,a=i;r<a.length;r++){for(var o=a[r],l=o.bytes,c=0;c<s;c++)if(l[c]!==e[t+c])continue e;return o.str}return null},n.prototype.store=function(e,t){var s=this.caches[e.length-1],i={bytes:e,str:t};s.length>=this.maxLengthPerKey?s[Math.random()*s.length|0]=i:s.push(i)},n.prototype.decode=function(e,t,s){var i=this.find(e,t,s);if(i!=null)return this.hit++,i;this.miss++;var r=hA(e,t,s),a=Uint8Array.prototype.slice.call(e,t,t+s);return this.store(a,r),r},n}(),ahe=globalThis&&globalThis.__awaiter||function(n,e,t,s){function i(r){return r instanceof t?r:new t(function(a){a(r)})}return new(t||(t=Promise))(function(r,a){function o(u){try{c(s.next(u))}catch(h){a(h)}}function l(u){try{c(s.throw(u))}catch(h){a(h)}}function c(u){u.done?r(u.value):i(u.value).then(o,l)}c((s=s.apply(n,e||[])).next())})},T0=globalThis&&globalThis.__generator||function(n,e){var t={label:0,sent:function(){if(r[0]&1)throw r[1];return r[1]},trys:[],ops:[]},s,i,r,a;return a={next:o(0),throw:o(1),return:o(2)},typeof Symbol=="function"&&(a[Symbol.iterator]=function(){return this}),a;function o(c){return function(u){return l([c,u])}}function l(c){if(s)throw new TypeError("Generator is already executing.");for(;t;)try{if(s=1,i&&(r=c[0]&2?i.return:c[0]?i.throw||((r=i.return)&&r.call(i),0):i.next)&&!(r=r.call(i,c[1])).done)return r;switch(i=0,r&&(c=[c[0]&2,r.value]),c[0]){case 0:case 1:r=c;break;case 4:return t.label++,{value:c[1],done:!1};case 5:t.label++,i=c[1],c=[0];continue;case 7:c=t.ops.pop(),t.trys.pop();continue;default:if(r=t.trys,!(r=r.length>0&&r[r.length-1])&&(c[0]===6||c[0]===2)){t=0;continue}if(c[0]===3&&(!r||c[1]>r[0]&&c[1]<r[3])){t.label=c[1];break}if(c[0]===6&&t.label<r[1]){t.label=r[1],r=c;break}if(r&&t.label<r[2]){t.label=r[2],t.ops.push(c);break}r[2]&&t.ops.pop(),t.trys.pop();continue}c=e.call(n,t)}catch(u){c=[6,u],i=0}finally{s=r=0}if(c[0]&5)throw c[1];return{value:c[0]?c[1]:void 0,done:!0}}},zM=globalThis&&globalThis.__asyncValues||function(n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var e=n[Symbol.asyncIterator],t;return e?e.call(n):(n=typeof __values=="function"?__values(n):n[Symbol.iterator](),t={},s("next"),s("throw"),s("return"),t[Symbol.asyncIterator]=function(){return this},t);function s(r){t[r]=n[r]&&function(a){return new Promise(function(o,l){a=n[r](a),i(o,l,a.done,a.value)})}}function i(r,a,o,l){Promise.resolve(l).then(function(c){r({value:c,done:o})},a)}},Xl=globalThis&&globalThis.__await||function(n){return this instanceof Xl?(this.v=n,this):new Xl(n)},ohe=globalThis&&globalThis.__asyncGenerator||function(n,e,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s=t.apply(n,e||[]),i,r=[];return i={},a("next"),a("throw"),a("return"),i[Symbol.asyncIterator]=function(){return this},i;function a(d){s[d]&&(i[d]=function(p){return new Promise(function(f,y){r.push([d,p,f,y])>1||o(d,p)})})}function o(d,p){try{l(s[d](p))}catch(f){h(r[0][3],f)}}function l(d){d.value instanceof Xl?Promise.resolve(d.value.v).then(c,u):h(r[0][2],d)}function c(d){o("next",d)}function u(d){o("throw",d)}function h(d,p){d(p),r.shift(),r.length&&o(r[0][0],r[0][1])}},lhe=function(n){var e=typeof n;return e==="string"||e==="number"},rh=-1,jS=new DataView(new ArrayBuffer(0)),che=new Uint8Array(jS.buffer),Cx=function(){try{jS.getInt8(0)}catch(n){return n.constructor}throw new Error("never reached")}(),VM=new Cx("Insufficient data"),uhe=new rhe,hhe=function(){function n(e,t,s,i,r,a,o,l){e===void 0&&(e=dA.defaultCodec),t===void 0&&(t=void 0),s===void 0&&(s=xo),i===void 0&&(i=xo),r===void 0&&(r=xo),a===void 0&&(a=xo),o===void 0&&(o=xo),l===void 0&&(l=uhe),this.extensionCodec=e,this.context=t,this.maxStrLength=s,this.maxBinLength=i,this.maxArrayLength=r,this.maxMapLength=a,this.maxExtLength=o,this.keyDecoder=l,this.totalPos=0,this.pos=0,this.view=jS,this.bytes=che,this.headByte=rh,this.stack=[]}return n.prototype.reinitializeState=function(){this.totalPos=0,this.headByte=rh,this.stack.length=0},n.prototype.setBuffer=function(e){this.bytes=Sm(e),this.view=Que(this.bytes),this.pos=0},n.prototype.appendBuffer=function(e){if(this.headByte===rh&&!this.hasRemaining(1))this.setBuffer(e);else{var t=this.bytes.subarray(this.pos),s=Sm(e),i=new Uint8Array(t.length+s.length);i.set(t),i.set(s,t.length),this.setBuffer(i)}},n.prototype.hasRemaining=function(e){return this.view.byteLength-this.pos>=e},n.prototype.createExtraByteError=function(e){var t=this,s=t.view,i=t.pos;return new RangeError("Extra ".concat(s.byteLength-i," of ").concat(s.byteLength," byte(s) found at buffer[").concat(e,"]"))},n.prototype.decode=function(e){this.reinitializeState(),this.setBuffer(e);var t=this.doDecodeSync();if(this.hasRemaining(1))throw this.createExtraByteError(this.pos);return t},n.prototype.decodeMulti=function(e){return T0(this,function(t){switch(t.label){case 0:this.reinitializeState(),this.setBuffer(e),t.label=1;case 1:return this.hasRemaining(1)?[4,this.doDecodeSync()]:[3,3];case 2:return t.sent(),[3,1];case 3:return[2]}})},n.prototype.decodeAsync=function(e){var t,s,i,r;return ahe(this,void 0,void 0,function(){var a,o,l,c,u,h,d,p;return T0(this,function(f){switch(f.label){case 0:a=!1,f.label=1;case 1:f.trys.push([1,6,7,12]),t=zM(e),f.label=2;case 2:return[4,t.next()];case 3:if(s=f.sent(),!!s.done)return[3,5];if(l=s.value,a)throw this.createExtraByteError(this.totalPos);this.appendBuffer(l);try{o=this.doDecodeSync(),a=!0}catch(y){if(!(y instanceof Cx))throw y}this.totalPos+=this.pos,f.label=4;case 4:return[3,2];case 5:return[3,12];case 6:return c=f.sent(),i={error:c},[3,12];case 7:return f.trys.push([7,,10,11]),s&&!s.done&&(r=t.return)?[4,r.call(t)]:[3,9];case 8:f.sent(),f.label=9;case 9:return[3,11];case 10:if(i)throw i.error;return[7];case 11:return[7];case 12:if(a){if(this.hasRemaining(1))throw this.createExtraByteError(this.totalPos);return[2,o]}throw u=this,h=u.headByte,d=u.pos,p=u.totalPos,new RangeError("Insufficient data in parsing ".concat(S0(h)," at ").concat(p," (").concat(d," in the current buffer)"))}})})},n.prototype.decodeArrayStream=function(e){return this.decodeMultiAsync(e,!0)},n.prototype.decodeStream=function(e){return this.decodeMultiAsync(e,!1)},n.prototype.decodeMultiAsync=function(e,t){return ohe(this,arguments,function(){var s,i,r,a,o,l,c,u,h;return T0(this,function(d){switch(d.label){case 0:s=t,i=-1,d.label=1;case 1:d.trys.push([1,13,14,19]),r=zM(e),d.label=2;case 2:return[4,Xl(r.next())];case 3:if(a=d.sent(),!!a.done)return[3,12];if(o=a.value,t&&i===0)throw this.createExtraByteError(this.totalPos);this.appendBuffer(o),s&&(i=this.readArraySize(),s=!1,this.complete()),d.label=4;case 4:d.trys.push([4,9,,10]),d.label=5;case 5:return[4,Xl(this.doDecodeSync())];case 6:return[4,d.sent()];case 7:return d.sent(),--i===0?[3,8]:[3,5];case 8:return[3,10];case 9:if(l=d.sent(),!(l instanceof Cx))throw l;return[3,10];case 10:this.totalPos+=this.pos,d.label=11;case 11:return[3,2];case 12:return[3,19];case 13:return c=d.sent(),u={error:c},[3,19];case 14:return d.trys.push([14,,17,18]),a&&!a.done&&(h=r.return)?[4,Xl(h.call(r))]:[3,16];case 15:d.sent(),d.label=16;case 16:return[3,18];case 17:if(u)throw u.error;return[7];case 18:return[7];case 19:return[2]}})})},n.prototype.doDecodeSync=function(){e:for(;;){var e=this.readHeadByte(),t=void 0;if(e>=224)t=e-256;else if(e<192)if(e<128)t=e;else if(e<144){var s=e-128;if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e<160){var s=e-144;if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else{var i=e-160;t=this.decodeUtf8String(i,0)}else if(e===192)t=null;else if(e===194)t=!1;else if(e===195)t=!0;else if(e===202)t=this.readF32();else if(e===203)t=this.readF64();else if(e===204)t=this.readU8();else if(e===205)t=this.readU16();else if(e===206)t=this.readU32();else if(e===207)t=this.readU64();else if(e===208)t=this.readI8();else if(e===209)t=this.readI16();else if(e===210)t=this.readI32();else if(e===211)t=this.readI64();else if(e===217){var i=this.lookU8();t=this.decodeUtf8String(i,1)}else if(e===218){var i=this.lookU16();t=this.decodeUtf8String(i,2)}else if(e===219){var i=this.lookU32();t=this.decodeUtf8String(i,4)}else if(e===220){var s=this.readU16();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===221){var s=this.readU32();if(s!==0){this.pushArrayState(s),this.complete();continue e}else t=[]}else if(e===222){var s=this.readU16();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===223){var s=this.readU32();if(s!==0){this.pushMapState(s),this.complete();continue e}else t={}}else if(e===196){var s=this.lookU8();t=this.decodeBinary(s,1)}else if(e===197){var s=this.lookU16();t=this.decodeBinary(s,2)}else if(e===198){var s=this.lookU32();t=this.decodeBinary(s,4)}else if(e===212)t=this.decodeExtension(1,0);else if(e===213)t=this.decodeExtension(2,0);else if(e===214)t=this.decodeExtension(4,0);else if(e===215)t=this.decodeExtension(8,0);else if(e===216)t=this.decodeExtension(16,0);else if(e===199){var s=this.lookU8();t=this.decodeExtension(s,1)}else if(e===200){var s=this.lookU16();t=this.decodeExtension(s,2)}else if(e===201){var s=this.lookU32();t=this.decodeExtension(s,4)}else throw new qi("Unrecognized type byte: ".concat(S0(e)));this.complete();for(var r=this.stack;r.length>0;){var a=r[r.length-1];if(a.type===0)if(a.array[a.position]=t,a.position++,a.position===a.size)r.pop(),t=a.array;else continue e;else if(a.type===1){if(!lhe(t))throw new qi("The type of key must be string or number but "+typeof t);if(t==="__proto__")throw new qi("The key __proto__ is not allowed");a.key=t,a.type=2;continue e}else if(a.map[a.key]=t,a.readCount++,a.readCount===a.size)r.pop(),t=a.map;else{a.key=null,a.type=1;continue e}}return t}},n.prototype.readHeadByte=function(){return this.headByte===rh&&(this.headByte=this.readU8()),this.headByte},n.prototype.complete=function(){this.headByte=rh},n.prototype.readArraySize=function(){var e=this.readHeadByte();switch(e){case 220:return this.readU16();case 221:return this.readU32();default:{if(e<160)return e-144;throw new qi("Unrecognized array type byte: ".concat(S0(e)))}}},n.prototype.pushMapState=function(e){if(e>this.maxMapLength)throw new qi("Max length exceeded: map length (".concat(e,") > maxMapLengthLength (").concat(this.maxMapLength,")"));this.stack.push({type:1,size:e,key:null,readCount:0,map:{}})},n.prototype.pushArrayState=function(e){if(e>this.maxArrayLength)throw new qi("Max length exceeded: array length (".concat(e,") > maxArrayLength (").concat(this.maxArrayLength,")"));this.stack.push({type:0,size:e,array:new Array(e),position:0})},n.prototype.decodeUtf8String=function(e,t){var s;if(e>this.maxStrLength)throw new qi("Max length exceeded: UTF-8 byte length (".concat(e,") > maxStrLength (").concat(this.maxStrLength,")"));if(this.bytes.byteLength<this.pos+t+e)throw VM;var i=this.pos+t,r;return this.stateIsMapKey()&&!((s=this.keyDecoder)===null||s===void 0)&&s.canBeCached(e)?r=this.keyDecoder.decode(this.bytes,i,e):e>zue?r=Vue(this.bytes,i,e):r=hA(this.bytes,i,e),this.pos+=t+e,r},n.prototype.stateIsMapKey=function(){if(this.stack.length>0){var e=this.stack[this.stack.length-1];return e.type===1}return!1},n.prototype.decodeBinary=function(e,t){if(e>this.maxBinLength)throw new qi("Max length exceeded: bin length (".concat(e,") > maxBinLength (").concat(this.maxBinLength,")"));if(!this.hasRemaining(e+t))throw VM;var s=this.pos+t,i=this.bytes.subarray(s,s+e);return this.pos+=t+e,i},n.prototype.decodeExtension=function(e,t){if(e>this.maxExtLength)throw new qi("Max length exceeded: ext length (".concat(e,") > maxExtLength (").concat(this.maxExtLength,")"));var s=this.view.getInt8(this.pos+t),i=this.decodeBinary(e,t+1);return this.extensionCodec.decode(i,s,this.context)},n.prototype.lookU8=function(){return this.view.getUint8(this.pos)},n.prototype.lookU16=function(){return this.view.getUint16(this.pos)},n.prototype.lookU32=function(){return this.view.getUint32(this.pos)},n.prototype.readU8=function(){var e=this.view.getUint8(this.pos);return this.pos++,e},n.prototype.readI8=function(){var e=this.view.getInt8(this.pos);return this.pos++,e},n.prototype.readU16=function(){var e=this.view.getUint16(this.pos);return this.pos+=2,e},n.prototype.readI16=function(){var e=this.view.getInt16(this.pos);return this.pos+=2,e},n.prototype.readU32=function(){var e=this.view.getUint32(this.pos);return this.pos+=4,e},n.prototype.readI32=function(){var e=this.view.getInt32(this.pos);return this.pos+=4,e},n.prototype.readU64=function(){var e=Rue(this.view,this.pos);return this.pos+=8,e},n.prototype.readI64=function(){var e=uA(this.view,this.pos);return this.pos+=8,e},n.prototype.readF32=function(){var e=this.view.getFloat32(this.pos);return this.pos+=4,e},n.prototype.readF64=function(){var e=this.view.getFloat64(this.pos);return this.pos+=8,e},n}(),dhe={};function phe(n,e){e===void 0&&(e=dhe);var t=new hhe(e.extensionCodec,e.context,e.maxStrLength,e.maxBinLength,e.maxArrayLength,e.maxMapLength,e.maxExtLength);return t.decode(n)}const WM=2;class fhe{constructor(){this.data=null}compileImageTargets(e,t){return new Promise(async(s,i)=>{const r=[];for(let c=0;c<e.length;c++){const u=e[c],h=this.createProcessCanvas(u).getContext("2d");h.drawImage(u,0,0,u.width,u.height);const d=h.getImageData(0,0,u.width,u.height),p=new Uint8Array(u.width*u.height);for(let y=0;y<p.length;y++){const m=y*4;p[y]=Math.floor((d.data[m]+d.data[m+1]+d.data[m+2])/3)}const f={data:p,height:u.height,width:u.width};r.push(f)}const a=50/r.length;let o=0;this.data=[];for(let c=0;c<r.length;c++){const u=r[c],h=wue(u),d=a/h.length,p=await mhe(h,()=>{o+=d,t(o)});this.data.push({targetImage:u,imageList:h,matchingData:p})}for(let c=0;c<r.length;c++){const u=Sue(r[c]);this.data[c].trackingImageList=u}const l=await this.compileTrack({progressCallback:t,targetImages:r,basePercent:50});for(let c=0;c<r.length;c++)this.data[c].trackingData=l[c];s(this.data)})}exportData(){const e=[];for(let t=0;t<this.data.length;t++)e.push({targetImage:{width:this.data[t].targetImage.width,height:this.data[t].targetImage.height},trackingData:this.data[t].trackingData,matchingData:this.data[t].matchingData});return nhe({v:WM,dataList:e})}importData(e){const t=phe(new Uint8Array(e));if(!t.v||t.v!==WM)return console.error("Your compiled .mind might be outdated. Please recompile"),[];const{dataList:s}=t;this.data=[];for(let i=0;i<s.length;i++)this.data.push({targetImage:s[i].targetImage,trackingData:s[i].trackingData,matchingData:s[i].matchingData});return this.data}createProcessCanvas(e){console.warn("missing createProcessCanvas implementation")}compileTrack({progressCallback:e,targetImages:t,basePercent:s}){console.warn("missing compileTrack implementation")}}const mhe=async(n,e)=>{const t=[];for(let s=0;s<n.length;s++){const i=n[s],r=new aA(i.width,i.height);await up(),j(()=>{const a=en(i.data,[i.data.length],"float32").reshape([i.height,i.width]),{featurePoints:o}=r.detect(a),l=o.filter(d=>d.maxima),c=o.filter(d=>!d.maxima),u=OM({points:l}),h=OM({points:c});t.push({maximaPoints:l,minimaPoints:c,maximaPointsCluster:u,minimaPointsCluster:h,width:i.width,height:i.height,scale:i.scale}),e(s)})}return t},pA="KGZ1bmN0aW9uKCl7InVzZSBzdHJpY3QiO2NsYXNzIHp7Y29uc3RydWN0b3Iocyx0LG8pe3RoaXMuY3Vtc3VtPVtdO2ZvcihsZXQgZT0wO2U8bztlKyspe3RoaXMuY3Vtc3VtLnB1c2goW10pO2ZvcihsZXQgbj0wO248dDtuKyspdGhpcy5jdW1zdW1bZV0ucHVzaCgwKX10aGlzLmN1bXN1bVswXVswXT1zWzBdO2ZvcihsZXQgZT0xO2U8dDtlKyspdGhpcy5jdW1zdW1bMF1bZV09dGhpcy5jdW1zdW1bMF1bZS0xXStzW2VdO2ZvcihsZXQgZT0xO2U8bztlKyspdGhpcy5jdW1zdW1bZV1bMF09dGhpcy5jdW1zdW1bZS0xXVswXStzW2UqdF07Zm9yKGxldCBlPTE7ZTxvO2UrKylmb3IobGV0IG49MTtuPHQ7bisrKXRoaXMuY3Vtc3VtW2VdW25dPXNbZSp0K25dK3RoaXMuY3Vtc3VtW2UtMV1bbl0rdGhpcy5jdW1zdW1bZV1bbi0xXS10aGlzLmN1bXN1bVtlLTFdW24tMV19cXVlcnkocyx0LG8sZSl7bGV0IG49dGhpcy5jdW1zdW1bZV1bb107cmV0dXJuIHQ+MCYmKG4tPXRoaXMuY3Vtc3VtW3QtMV1bb10pLHM+MCYmKG4tPXRoaXMuY3Vtc3VtW2VdW3MtMV0pLHM+MCYmdD4wJiYobis9dGhpcy5jdW1zdW1bdC0xXVtzLTFdKSxufX1jb25zdCBDPTEwLGI9MixNPTYsRj01LEk9Ljk1LEw9LjksTz0uMixaPTgsTj0yNCoyLzMsVT1yPT57Y29uc3R7ZGF0YTpzLHdpZHRoOnQsaGVpZ2h0Om8sc2NhbGU6ZX09cixuPVt0Km9dO2ZvcihsZXQgaT0wO2k8bi5sZW5ndGg7aSsrKW5baV09ITE7Y29uc3QgYT1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWFbaV09LTEsYVt0KihvLTEpK2ldPS0xO2ZvcihsZXQgaT0wO2k8bztpKyspYVtpKnRdPS0xLGFbaSp0K3QtMV09LTE7Zm9yKGxldCBpPTE7aTx0LTE7aSsrKWZvcihsZXQgcD0xO3A8by0xO3ArKyl7bGV0IGY9aSt0KnAsaD0wLGM9MDtmb3IobGV0IHU9LTE7dTw9MTt1KyspaCs9c1tmK3QqdSsxXS1zW2YrdCp1LTFdLGMrPXNbZit0K3VdLXNbZi10K3VdO2gvPTMqMjU2LGMvPTMqMjU2LGFbZl09TWF0aC5zcXJ0KChoKmgrYypjKS8yKX1jb25zdCBnPW5ldyBVaW50MzJBcnJheSgxZTMpO2ZvcihsZXQgaT0wO2k8MWUzO2krKylnW2ldPTA7Y29uc3QgZD1bLTEsMSwtdCx0XTtmb3IobGV0IGk9MTtpPHQtMTtpKyspZm9yKGxldCBwPTE7cDxvLTE7cCsrKXtsZXQgZj1pK3QqcCxoPSEwO2ZvcihsZXQgYz0wO2M8ZC5sZW5ndGg7YysrKWlmKGFbZl08PWFbZitkW2NdXSl7aD0hMTticmVha31pZihoKXtsZXQgYz1NYXRoLmZsb29yKGFbZl0qMWUzKTtjPjk5OSYmKGM9OTk5KSxjPDAmJihjPTApLGdbY10rPTEsbltmXT0hMH19Y29uc3Qgdz0uMDIqdCpvO2xldCBqPTk5OSxFPTA7Zm9yKDtqPj0wJiYoRSs9Z1tqXSwhKEU+dykpOylqLS07Zm9yKGxldCBpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmYVtpXSoxZTM8aiYmKG5baV09ITEpO2NvbnN0IGw9W107Zm9yKGxldCBpPTA7aTxzLmxlbmd0aDtpKyspbFtpXT1zW2ldKnNbaV07Y29uc3QgUz1uZXcgeihzLHQsbyksRD1uZXcgeihsLHQsbyksaz1uZXcgRmxvYXQzMkFycmF5KHMubGVuZ3RoKTtmb3IobGV0IGk9MDtpPHQ7aSsrKWZvcihsZXQgcD0wO3A8bztwKyspe2NvbnN0IGY9cCp0K2k7aWYoIW5bZl0pe2tbZl09MTtjb250aW51ZX1jb25zdCBoPVAoe2ltYWdlOnIsY3g6aSxjeTpwLHNkVGhyZXNoOkYsaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KTtpZihoPT09bnVsbCl7a1tmXT0xO2NvbnRpbnVlfWxldCBjPS0xO2ZvcihsZXQgdT0tQzt1PD1DO3UrKyl7Zm9yKGxldCBtPS1DO208PUM7bSsrKXtpZihtKm0rdSp1PD1iKmIpY29udGludWU7Y29uc3QgeD1SKHtpbWFnZTpyLGN4OmkrbSxjeTpwK3UsdmxlbjpoLHR4OmksdHk6cCxpbWFnZURhdGFDdW1zdW06UyxpbWFnZURhdGFTcXJDdW1zdW06RH0pO2lmKHghPT1udWxsJiZ4PmMmJihjPXgsYz5JKSlicmVha31pZihjPkkpYnJlYWt9a1tmXT1jfXJldHVybiBWKHtpbWFnZTpyLGZlYXR1cmVNYXA6ayx0ZW1wbGF0ZVNpemU6TSxzZWFyY2hTaXplOmIsb2NjU2l6ZTpOLG1heFNpbVRocmVzaDpMLG1pblNpbVRocmVzaDpPLHNkVGhyZXNoOlosaW1hZ2VEYXRhQ3Vtc3VtOlMsaW1hZ2VEYXRhU3FyQ3Vtc3VtOkR9KX0sVj1yPT57bGV0e2ltYWdlOnMsZmVhdHVyZU1hcDp0LHRlbXBsYXRlU2l6ZTpvLHNlYXJjaFNpemU6ZSxvY2NTaXplOm4sbWF4U2ltVGhyZXNoOmEsbWluU2ltVGhyZXNoOmcsc2RUaHJlc2g6ZCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an09cjtjb25zdHtkYXRhOkUsd2lkdGg6bCxoZWlnaHQ6UyxzY2FsZTpEfT1zO249TWF0aC5mbG9vcihNYXRoLm1pbihzLndpZHRoLHMuaGVpZ2h0KS8xMCk7Y29uc3Qgaz0obyoyKzEpKjMsQT1NYXRoLmZsb29yKGwvayksaT1NYXRoLmZsb29yKFMvayk7bGV0IHA9TWF0aC5mbG9vcihsL24pKk1hdGguZmxvb3IoUy9uKStBKmk7Y29uc3QgZj1bXSxoPW5ldyBGbG9hdDMyQXJyYXkoRS5sZW5ndGgpO2ZvcihsZXQgdT0wO3U8aC5sZW5ndGg7dSsrKWhbdV09dFt1XTtsZXQgYz0wO2Zvcig7YzxwOyl7bGV0IHU9YSxtPS0xLHg9LTE7Zm9yKGxldCB5PTA7eTxTO3krKylmb3IobGV0IFQ9MDtUPGw7VCsrKWhbeSpsK1RdPHUmJih1PWhbeSpsK1RdLG09VCx4PXkpO2lmKG09PT0tMSlicmVhaztjb25zdCB2PVAoe2ltYWdlOnMsY3g6bSxjeTp4LHNkVGhyZXNoOjAsaW1hZ2VEYXRhQ3Vtc3VtOncsaW1hZ2VEYXRhU3FyQ3Vtc3VtOmp9KTtpZih2PT09bnVsbCl7aFt4KmwrbV09MTtjb250aW51ZX1pZih2LyhvKjIrMSk8ZCl7aFt4KmwrbV09MTtjb250aW51ZX1sZXQgcT0xLF89LTE7Zm9yKGxldCB5PS1lO3k8PWU7eSsrKXtmb3IobGV0IFQ9LWU7VDw9ZTtUKyspe2lmKFQqVCt5Knk+ZSplfHxUPT09MCYmeT09PTApY29udGludWU7Y29uc3QgSD1SKHtpbWFnZTpzLHZsZW46dixjeDptK1QsY3k6eCt5LHR4Om0sdHk6eCxpbWFnZURhdGFDdW1zdW06dyxpbWFnZURhdGFTcXJDdW1zdW06an0pO2lmKEghPT1udWxsJiYoSDxxJiYocT1ILHE8ZyYmcTx1KXx8SD5fJiYoXz1ILF8+Ljk5KSkpYnJlYWt9aWYocTxnJiZxPHV8fF8+Ljk5KWJyZWFrfWlmKHE8ZyYmcTx1fHxfPi45OSl7aFt4KmwrbV09MTtjb250aW51ZX1mLnB1c2goe3g6bSx5Onh9KSxjKz0xO2ZvcihsZXQgeT0tbjt5PD1uO3krKylmb3IobGV0IFQ9LW47VDw9bjtUKyspeCt5PDB8fHgreT49U3x8bStUPDB8fG0rVD49bHx8KGhbKHgreSkqbCsobStUKV09MSl9cmV0dXJuIGZ9LFA9KHtpbWFnZTpyLGN4OnMsY3k6dCxzZFRocmVzaDpvLGltYWdlRGF0YUN1bXN1bTplLGltYWdlRGF0YVNxckN1bXN1bTpufSk9PntpZihzLU08MHx8cytNPj1yLndpZHRofHx0LU08MHx8dCtNPj1yLmhlaWdodClyZXR1cm4gbnVsbDtjb25zdCBhPTIqTSsxLGc9YSphO2xldCBkPWUucXVlcnkocy1NLHQtTSxzK00sdCtNKTtkLz1nO2xldCB3PW4ucXVlcnkocy1NLHQtTSxzK00sdCtNKTtyZXR1cm4gdy09MipkKmUucXVlcnkocy1NLHQtTSxzK00sdCtNKSx3Kz1nKmQqZCx3L2c8bypvP251bGw6KHc9TWF0aC5zcXJ0KHcpLHcpfSxSPXI9Pntjb25zdHtpbWFnZTpzLGN4OnQsY3k6byx2bGVuOmUsdHg6bix0eTphLGltYWdlRGF0YUN1bXN1bTpnLGltYWdlRGF0YVNxckN1bXN1bTpkfT1yLHtkYXRhOncsd2lkdGg6aixoZWlnaHQ6RX09cyxsPU07aWYodC1sPDB8fHQrbD49anx8by1sPDB8fG8rbD49RSlyZXR1cm4gbnVsbDtjb25zdCBTPTIqbCsxO2xldCBEPWcucXVlcnkodC1sLG8tbCx0K2wsbytsKSxrPWQucXVlcnkodC1sLG8tbCx0K2wsbytsKSxBPTAsaT0oby1sKSpqKyh0LWwpLHA9KGEtbCkqaisobi1sKSxmPWotUztmb3IobGV0IG09MDttPFM7bSsrKXtmb3IobGV0IHg9MDt4PFM7eCsrKUErPXdbaV0qd1twXSxpKz0xLHArPTE7aSs9ZixwKz1mfWxldCBoPWcucXVlcnkobi1sLGEtbCxuK2wsYStsKTtoLz1TKlMsQS09aCpEO2xldCBjPWstRCpELyhTKlMpO3JldHVybiBjPT0wP251bGw6KGM9TWF0aC5zcXJ0KGMpLDEqQS8oZSpjKSl9LFc9KHIscyk9Pntjb25zdCB0PVtdO2ZvcihsZXQgbz0wO288ci5sZW5ndGg7bysrKXtjb25zdCBlPXJbb10sbj1VKGUpLGE9e2RhdGE6ZS5kYXRhLHNjYWxlOmUuc2NhbGUsd2lkdGg6ZS53aWR0aCxoZWlnaHQ6ZS5oZWlnaHQscG9pbnRzOm59O3QucHVzaChhKSxzKG8pfXJldHVybiB0fSxYPSh7aW1hZ2U6cixyYXRpbzpzfSk9Pntjb25zdCB0PU1hdGgucm91bmQoci53aWR0aCpzKSxvPU1hdGgucm91bmQoci5oZWlnaHQqcyksZT1uZXcgVWludDhBcnJheSh0Km8pO2ZvcihsZXQgbj0wO248dDtuKyspe2xldCBhPU1hdGgucm91bmQoMSpuL3MpLGc9TWF0aC5yb3VuZCgxKihuKzEpL3MpLTE7Zz49ci53aWR0aCYmKGc9ci53aWR0aC0xKTtmb3IobGV0IGQ9MDtkPG87ZCsrKXtsZXQgdz1NYXRoLnJvdW5kKDEqZC9zKSxqPU1hdGgucm91bmQoMSooZCsxKS9zKS0xO2o+PXIuaGVpZ2h0JiYoaj1yLmhlaWdodC0xKTtsZXQgRT0wLGw9MDtmb3IobGV0IFM9YTtTPD1nO1MrKylmb3IobGV0IEQ9dztEPD1qO0QrKylFKz0xKnIuZGF0YVtEKnIud2lkdGgrU10sbCs9MTtlW2QqdCtuXT1NYXRoLmZsb29yKEUvbCl9fXJldHVybntkYXRhOmUsd2lkdGg6dCxoZWlnaHQ6b319LFk9cj0+e2NvbnN0IHM9TWF0aC5taW4oci53aWR0aCxyLmhlaWdodCksdD1bXSxvPVtdO3QucHVzaCgyNTYvcyksdC5wdXNoKDEyOC9zKTtmb3IobGV0IGU9MDtlPHQubGVuZ3RoO2UrKylvLnB1c2goT2JqZWN0LmFzc2lnbihYKHtpbWFnZTpyLHJhdGlvOnRbZV19KSx7c2NhbGU6dFtlXX0pKTtyZXR1cm4gb307b25tZXNzYWdlPXI9Pntjb25zdHtkYXRhOnN9PXI7aWYocy50eXBlPT09ImNvbXBpbGUiKXtjb25zdHt0YXJnZXRJbWFnZXM6dH09cyxvPTEwMC90Lmxlbmd0aDtsZXQgZT0wO2NvbnN0IG49W107Zm9yKGxldCBhPTA7YTx0Lmxlbmd0aDthKyspe2NvbnN0IGc9dFthXSxkPVkoZyksdz1vL2QubGVuZ3RoLGo9VyhkLEU9PntlKz13LHBvc3RNZXNzYWdlKHt0eXBlOiJwcm9ncmVzcyIscGVyY2VudDplfSl9KTtuLnB1c2goail9cG9zdE1lc3NhZ2Uoe3R5cGU6ImNvbXBpbGVEb25lIixsaXN0Om59KX19fSkoKTsK",UM=typeof window<"u"&&window.Blob&&new Blob([atob(pA)],{type:"text/javascript;charset=utf-8"});function ghe(){let n;try{if(n=UM&&(window.URL||window.webkitURL).createObjectURL(UM),!n)throw"";return new Worker(n)}catch{return new Worker("data:application/javascript;base64,"+pA)}finally{n&&(window.URL||window.webkitURL).revokeObjectURL(n)}}class yhe extends fhe{createProcessCanvas(e){const t=document.createElement("canvas");return t.width=e.width,t.height=e.height,t}compileTrack({progressCallback:e,targetImages:t,basePercent:s}){return new Promise((i,r)=>{const a=new ghe;a.onmessage=o=>{o.data.type==="progress"?e(s+o.data.percent*s/100):o.data.type==="compileDone"&&i(o.data.list)},a.postMessage({type:"compile",targetImages:t})})}}class bhe{constructor(e,t){this.width=e,this.height=t,this.texShape=[t,e];const s=document.createElement("canvas").getContext("2d");s.canvas.width=e,s.canvas.height=t,this.context=s,this.program=this.buildProgram(e,t);const i=Gr();this.tempPixelHandle=i.makeTensorInfo(this.texShape,"float32"),i.texData.get(this.tempPixelHandle.dataId).usage=2}_loadInput(e){return j(()=>{let t=Fv(e);return t=t.mean(2),t})}loadInput(e){const t=this.context;if(t.clearRect(0,0,this.context.canvas.width,this.context.canvas.height),e.width===this.height&&e.height===this.width){let i=this.context.canvas.width/2,r=this.context.canvas.height/2,a=90;t.save(),t.translate(i,r),t.rotate(a*Math.PI/180),t.drawImage(e,-e.width/2,-e.height/2),t.restore()}else this.context.drawImage(e,0,0,e.width,e.height);const s=Gr();return s.gpgpu.uploadPixelDataToTexture(s.getTexture(this.tempPixelHandle.dataId),this.context.canvas),this._compileAndRun(this.program,[this.tempPixelHandle])}buildProgram(e,t){const s=ee().getNumber("WEBGL_VERSION")===2?"texture":"texture2D";return{variableNames:["A"],outputShape:this.texShape,userCode:`
	void main() {
	  ivec2 coords = getOutputCoords();
	  int texR = coords[0];
	  int texC = coords[1];
	  vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${e}.0, ${t}.0);

	  vec4 values = ${s}(A, uv);
	  setOutput((0.299 * values.r + 0.587 * values.g + 0.114 * values.b) * 255.0);
	}
      `}}_compileAndRun(e,t){const s=Gr().compileAndRun(e,t);return Ut().makeTensorFromDataId(s.dataId,s.shape,s.dtype)}_runWebGLProgram(e,t,s){const i=Gr().runWebGLProgram(e,t,s);return Ut().makeTensorFromDataId(i.dataId,i.shape,i.dtype)}}const _0={memory:Nh,nextFrame:up},xhe=.001,vhe=1e3,whe=5,She=5;class The{constructor({inputWidth:e,inputHeight:t,onUpdate:s=null,debugMode:i=!1,maxTrack:r=1,warmupTolerance:a=null,missTolerance:o=null,filterMinCF:l=null,filterBeta:c=null}){this.inputWidth=e,this.inputHeight=t,this.maxTrack=r,this.filterMinCF=l===null?xhe:l,this.filterBeta=c===null?vhe:c,this.warmupTolerance=a===null?whe:a,this.missTolerance=o===null?She:o,this.cropDetector=new xue(this.inputWidth,this.inputHeight,i),this.inputLoader=new bhe(this.inputWidth,this.inputHeight),this.markerDimensions=null,this.onUpdate=s,this.debugMode=i,this.processingVideo=!1,this.interestedTargetIndex=-1,this.trackingStates=[];const u=10,h=1e5,d=45*Math.PI/180,p=this.inputHeight/2/Math.tan(d/2);this.projectionTransform=[[p,0,this.inputWidth/2],[0,p,this.inputHeight/2],[0,0,1]],this.projectionMatrix=this._glProjectionMatrix({projectionTransform:this.projectionTransform,width:this.inputWidth,height:this.inputHeight,near:u,far:h}),this.worker=new Sce,this.workerMatchDone=null,this.workerTrackDone=null,this.worker.onmessage=f=>{f.data.type==="matchDone"&&this.workerMatchDone!==null&&this.workerMatchDone(f.data),f.data.type==="trackUpdateDone"&&this.workerTrackDone!==null&&this.workerTrackDone(f.data)}}showTFStats(){console.log(_0.memory().numTensors),console.table(_0.memory())}addImageTargets(e){return new Promise(async(t,s)=>{const i=await(await fetch(e)).arrayBuffer(),r=this.addImageTargetsFromBuffer(i);t(r)})}addImageTargetsFromBuffer(e){const t=new yhe().importData(e),s=[],i=[],r=[];for(let a=0;a<t.length;a++)i.push(t[a].matchingData),s.push(t[a].trackingData),r.push([t[a].targetImage.width,t[a].targetImage.height]);return this.tracker=new Ace(r,s,this.projectionTransform,this.inputWidth,this.inputHeight,this.debugMode),this.worker.postMessage({type:"setup",inputWidth:this.inputWidth,inputHeight:this.inputHeight,projectionTransform:this.projectionTransform,debugMode:this.debugMode,matchingDataList:i}),this.markerDimensions=r,{dimensions:r,matchingDataList:i,trackingDataList:s}}dispose(){this.stopProcessVideo(),this.worker.postMessage({type:"dispose"})}dummyRun(e){const t=this.inputLoader.loadInput(e);this.cropDetector.detect(t),this.tracker.dummyRun(t),t.dispose()}getProjectionMatrix(){return this.projectionMatrix}getRotatedZ90Matrix(e){return[-e[1],e[0],e[2],e[3],-e[5],e[4],e[6],e[7],-e[9],e[8],e[10],e[11],-e[13],e[12],e[14],e[15]]}getWorldMatrix(e,t){return this._glModelViewMatrix(e,t)}async _detectAndMatch(e,t){const{featurePoints:s}=this.cropDetector.detectMoving(e),{targetIndex:i,modelViewTransform:r}=await this._workerMatch(s,t);return{targetIndex:i,modelViewTransform:r}}async _trackAndUpdate(e,t,s){const{worldCoords:i,screenCoords:r}=this.tracker.track(e,t,s);return i.length<4?null:await this._workerTrackUpdate(t,{worldCoords:i,screenCoords:r})}processVideo(e){if(!this.processingVideo){this.processingVideo=!0,this.trackingStates=[];for(let t=0;t<this.markerDimensions.length;t++)this.trackingStates.push({showing:!1,isTracking:!1,currentModelViewTransform:null,trackCount:0,trackMiss:0,filter:new eV({minCutOff:this.filterMinCF,beta:this.filterBeta})});(async()=>{for(;this.processingVideo;){const t=this.inputLoader.loadInput(e);if(this.trackingStates.reduce((s,i)=>s+(i.isTracking?1:0),0)<this.maxTrack){const s=[];for(let a=0;a<this.trackingStates.length;a++)this.trackingStates[a].isTracking!==!0&&(this.interestedTargetIndex!==-1&&this.interestedTargetIndex!==a||s.push(a));const{targetIndex:i,modelViewTransform:r}=await this._detectAndMatch(t,s);i!==-1&&(this.trackingStates[i].isTracking=!0,this.trackingStates[i].currentModelViewTransform=r)}for(let s=0;s<this.trackingStates.length;s++){const i=this.trackingStates[s];if(i.isTracking){let r=await this._trackAndUpdate(t,i.currentModelViewTransform,s);r===null?i.isTracking=!1:i.currentModelViewTransform=r}if(i.showing||i.isTracking&&(i.trackMiss=0,i.trackCount+=1,i.trackCount>this.warmupTolerance&&(i.showing=!0,i.trackingMatrix=null,i.filter.reset())),i.showing&&(i.isTracking?i.trackMiss=0:(i.trackCount=0,i.trackMiss+=1,i.trackMiss>this.missTolerance&&(i.showing=!1,i.trackingMatrix=null,this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:s,worldMatrix:null})))),i.showing){const r=this._glModelViewMatrix(i.currentModelViewTransform,s);i.trackingMatrix=i.filter.filter(Date.now(),r);let a=[];for(let o=0;o<i.trackingMatrix.length;o++)a[o]=i.trackingMatrix[o];e.width===this.inputHeight&&e.height===this.inputWidth&&(a=this.getRotatedZ90Matrix(a)),this.onUpdate&&this.onUpdate({type:"updateMatrix",targetIndex:s,worldMatrix:a})}}t.dispose(),this.onUpdate&&this.onUpdate({type:"processDone"}),await _0.nextFrame()}})()}}stopProcessVideo(){this.processingVideo=!1}async detect(e){const t=this.inputLoader.loadInput(e),{featurePoints:s,debugExtra:i}=await this.cropDetector.detect(t);return t.dispose(),{featurePoints:s,debugExtra:i}}async match(e,t){const{modelViewTransform:s,debugExtra:i}=await this._workerMatch(e,[t]);return{modelViewTransform:s,debugExtra:i}}async track(e,t,s){const i=this.inputLoader.loadInput(e),r=this.tracker.track(i,t,s);return i.dispose(),r}async trackUpdate(e,t){return t.worldCoords.length<4?null:await this._workerTrackUpdate(e,t)}_workerMatch(e,t){return new Promise(async(s,i)=>{this.workerMatchDone=r=>{s({targetIndex:r.targetIndex,modelViewTransform:r.modelViewTransform,debugExtra:r.debugExtra})},this.worker.postMessage({type:"match",featurePoints:e,targetIndexes:t})})}_workerTrackUpdate(e,t){return new Promise(async(s,i)=>{this.workerTrackDone=o=>{s(o.modelViewTransform)};const{worldCoords:r,screenCoords:a}=t;this.worker.postMessage({type:"trackUpdate",modelViewTransform:e,worldCoords:r,screenCoords:a})})}_glModelViewMatrix(e,t){const s=this.markerDimensions[t][1];return[e[0][0],-e[1][0],-e[2][0],0,-e[0][1],e[1][1],e[2][1],0,-e[0][2],e[1][2],e[2][2],0,e[0][1]*s+e[0][3],-(e[1][1]*s+e[1][3]),-(e[2][1]*s+e[2][3]),1]}_glProjectionMatrix({projectionTransform:e,width:t,height:s,near:i,far:r}){const a=[[2*e[0][0]/t,0,-(2*e[0][2]/t-1),0],[0,2*e[1][1]/s,-(2*e[1][2]/s-1),0],[0,0,-(r+i)/(r-i),-2*r*i/(r-i)],[0,0,-1,0]],o=[];for(let l=0;l<4;l++)for(let c=0;c<4;c++)o.push(a[c][l]);return o}}const BM=new J,_he=new Is,$M=new J,ji=new ot,Ihe=new ot;class Mhe{constructor(e={}){const t=this;let s,i,r,a;const o={camera:{style:""},objects:new WeakMap},l=e.element!==void 0?e.element:document.createElement("div");l.style.overflow="hidden",this.domElement=l;const c=document.createElement("div");c.style.transformOrigin="0 0",c.style.pointerEvents="none",l.appendChild(c);const u=document.createElement("div");u.style.transformStyle="preserve-3d",c.appendChild(u),this.getSize=function(){return{width:s,height:i}},this.render=function(y,m){const g=m.projectionMatrix.elements[5]*a;m.view&&m.view.enabled?(c.style.transform=`translate( ${-m.view.offsetX*(s/m.view.width)}px, ${-m.view.offsetY*(i/m.view.height)}px )`,c.style.transform+=`scale( ${m.view.fullWidth/m.view.width}, ${m.view.fullHeight/m.view.height} )`):c.style.transform="",y.matrixWorldAutoUpdate===!0&&y.updateMatrixWorld(),m.parent===null&&m.matrixWorldAutoUpdate===!0&&m.updateMatrixWorld();let b,x;m.isOrthographicCamera&&(b=-(m.right+m.left)/2,x=(m.top+m.bottom)/2);const v=m.view&&m.view.enabled?m.view.height/m.view.fullHeight:1,w=m.isOrthographicCamera?`scale( ${v} )scale(`+g+")translate("+h(b)+"px,"+h(x)+"px)"+d(m.matrixWorldInverse):`scale( ${v} )translateZ(`+g+"px)"+d(m.matrixWorldInverse),I=(m.isPerspectiveCamera?"perspective("+g+"px) ":"")+w+"translate("+r+"px,"+a+"px)";o.camera.style!==I&&(u.style.transform=I,o.camera.style=I),f(y,y,m)},this.setSize=function(y,m){s=y,i=m,r=s/2,a=i/2,l.style.width=y+"px",l.style.height=m+"px",c.style.width=y+"px",c.style.height=m+"px",u.style.width=y+"px",u.style.height=m+"px"};function h(y){return Math.abs(y)<1e-10?0:y}function d(y){const m=y.elements;return"matrix3d("+h(m[0])+","+h(-m[1])+","+h(m[2])+","+h(m[3])+","+h(m[4])+","+h(-m[5])+","+h(m[6])+","+h(m[7])+","+h(m[8])+","+h(-m[9])+","+h(m[10])+","+h(m[11])+","+h(m[12])+","+h(-m[13])+","+h(m[14])+","+h(m[15])+")"}function p(y){const m=y.elements;return"translate(-50%,-50%)"+("matrix3d("+h(m[0])+","+h(m[1])+","+h(m[2])+","+h(m[3])+","+h(-m[4])+","+h(-m[5])+","+h(-m[6])+","+h(-m[7])+","+h(m[8])+","+h(m[9])+","+h(m[10])+","+h(m[11])+","+h(m[12])+","+h(m[13])+","+h(m[14])+","+h(m[15])+")")}function f(y,m,g,b){if(y.isCSS3DObject){const x=y.visible===!0&&y.layers.test(g.layers)===!0;if(y.element.style.display=x===!0?"":"none",x===!0){y.onBeforeRender(t,m,g);let v;y.isCSS3DSprite?(ji.copy(g.matrixWorldInverse),ji.transpose(),y.rotation2D!==0&&ji.multiply(Ihe.makeRotationZ(y.rotation2D)),y.matrixWorld.decompose(BM,_he,$M),ji.setPosition(BM),ji.scale($M),ji.elements[3]=0,ji.elements[7]=0,ji.elements[11]=0,ji.elements[15]=1,v=p(ji)):v=p(y.matrixWorld);const w=y.element,_=o.objects.get(y);if(_===void 0||_.style!==v){w.style.transform=v;const I={style:v};o.objects.set(y,I)}w.parentNode!==u&&u.appendChild(w),y.onAfterRender(t,m,g)}}for(let x=0,v=y.children.length;x<v;x++)f(y.children[x],m,g)}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Che(n){E(Array.isArray(n),()=>"The argument passed to tf.addN() must be a list of tensors"),E(n.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${n.length}`);const e=n.map((i,r)=>N(i,`tensors${r}`,"addN")),t=e[0];e.forEach(i=>{if(i.dtype!==t.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!St(i.shape,t.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const s=e;return W.runKernel(Xh,s)}const fA=U({addN_:Che});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ehe(n,e,t,s,i,r){const a=N(n,"forgetBias","basicLSTMCell"),o=N(e,"lstmKernel","basicLSTMCell"),l=N(t,"lstmBias","basicLSTMCell"),c=N(s,"data","basicLSTMCell"),u=N(i,"c","basicLSTMCell"),h=N(r,"h","basicLSTMCell"),d=fn([c,h],1),p=ft(d,o),f=de(p,l),y=f.shape[0],m=f.shape[1]/4,g=[y,m],b=Tt(f,[0,0],g),x=Tt(f,[0,m],g),v=Tt(f,[0,m*2],g),w=Tt(f,[0,m*3],g),_=de(X(Gi(b),Oo(x)),X(u,Gi(de(a,v)))),I=X(Oo(_),Gi(w));return[_,I]}const mA=U({basicLSTMCell_:Ehe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function khe(n,e){const t=N(n,"s0","broadcastArgs","int32"),s=N(e,"s1","broadcastArgs","int32");if(t.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${t.rank}`);if(s.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${s.rank}`);const i={s0:t,s1:s};return W.runKernel(Wm,i)}const gA=U({broadcastArgs_:khe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nhe(n){const e={x:N(n,"x","diag")};return W.runKernel(Jm,e)}const yA=U({diag_:Nhe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rhe(n,...e){const t=e.map((i,r)=>N(i,`tensors${r}`,"einsum")),s={equation:n};return W.runKernel(qm,t,s)}const bA=U({einsum_:Rhe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xA(n,e,t){if(t<=0)throw new Error("The number of values should be positive.");const s={start:n,stop:e,num:t};return W.runKernel(og,{},s)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mf=2147483648;function Ahe(n,e,t="left"){const s=N(n,"sortedSequence","searchSorted"),i=N(e,"values","searchSorted"),r=s.shape[s.shape.length-1],a=i.shape[i.shape.length-1],o=K(s,[-1,r]),l=K(i,[-1,a]);if(o.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(o.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(re(l.shape)>=Mf)throw new Error(`values tensor size must less than ${Mf}`);if(o.shape[1]>=Mf)throw new Error(`trailing dim_size must less than ${Mf} for int32 output type, was ${o.shape[1]}`);const c={sortedSequence:o,values:l},u={side:t};return W.runKernel(_g,c,u)}const ib=U({searchSorted_:Ahe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vA(n,e){return ib(n,e,"left")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lhe(n,e,t,s,i=!1){const r={x:N(n,"x","maxPoolWithArgmax")},a={filterSize:e,strides:t,pad:s,includeBatchInIndex:i},o=W.runKernel(hg,r,a);return{result:o[0],indexes:o[1]}}const wA=U({maxPoolWithArgmax_:Lhe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SA(n,e,{indexing:t="xy"}={}){if(t!=="xy"&&t!=="ij")throw new TypeError(`${t} is not a valid third argument to meshgrid`);if(n===void 0)return[];let s=N(n,"x","meshgrid",n instanceof Et?n.dtype:"float32");if(e===void 0)return[s];let i=N(e,"y","meshgrid",e instanceof Et?e.dtype:"float32");const r=re(s.shape),a=re(i.shape);return t==="xy"?(s=K(s,[1,-1]),i=K(i,[-1,1]),[ft(Vs([a,1],s.dtype),s),ft(i,Vs([1,r],i.dtype))]):(s=K(s,[-1,1]),i=K(i,[1,-1]),[ft(s,Vs([1,a],s.dtype)),ft(Vs([r,1],i.dtype),i)])}function Phe(n,e,t,s){const i=N(e,"data","multiRNNCell"),r=kh(t,"c","multiRNNCell"),a=kh(s,"h","multiRNNCell");let o=i;const l=[];for(let h=0;h<n.length;h++){const d=n[h](o,r[h],a[h]);l.push(d[0]),l.push(d[1]),o=d[1]}const c=[],u=[];for(let h=0;h<l.length;h+=2)c.push(l[h]),u.push(l[h+1]);return[c,u]}const TA=U({multiRNNCell_:Phe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dhe(n,e,t,s=!1){const i=N(n,"logits","multinomial"),r=i.size,a=i.rank;if(r<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${r}.`);if(a>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${a}`);t=t||Math.random();const o={logits:a===1?K(i,[1,-1]):i},l={numSamples:e,seed:t,normalized:s},c=W.runKernel(dg,o,l);return a===1?K(c,[c.size]):c}const _A=U({multinomial_:Dhe});function Fhe(n,e){const t=N(n,"v1","outerProduct"),s=N(e,"v2","outerProduct");E(t.rank===1&&s.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${t.rank} and ${s.rank}.`);const i=K(t,[-1,1]),r=K(s,[1,-1]);return ft(i,r)}const IA=U({outerProduct_:Fhe});function Ohe(n,e,t=0){return E(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),na(n,[e],t)}const MA=U({pad1d_:Ohe});function Ghe(n,e,t=0){return E(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),na(n,e,t)}const CA=U({pad2d_:Ghe});function zhe(n,e,t=0){return E(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),na(n,e,t)}const EA=U({pad3d_:zhe});function Vhe(n,e,t=0){return E(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),na(n,e,t)}const kA=U({pad4d_:Vhe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Whe(n,e,t,s){const i=n.map((u,h)=>N(u,`tensors${h}`,"raggedGather","int32")),r=N(e,"paramsDenseValues","raggedGather"),a=N(t,"indices","raggedGather","int32"),o={paramsNestedSplits:i,paramsDenseValues:r,indices:a},l={outputRaggedRank:s},c=W.runKernel(gg,o,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const NA=U({raggedGather_:Whe});/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uhe(n,e,t){const s=N(n,"starts","raggedRange"),i=N(e,"limits","raggedRange",s.dtype),r=N(t,"deltas","raggedRange",s.dtype),a={starts:s,limits:i,deltas:r},o=W.runKernel(yg,a);return{rtNestedSplits:o[0],rtDenseValues:o[1]}}const RA=U({raggedRange_:Uhe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bhe(n,e,t,s,i){const r=N(n,"shape","raggedTensorToTensor","int32"),a=N(e,"values","raggedTensorToTensor"),o=N(t,"defaultValue","raggedTensorToTensor",a.dtype),l=s.map((h,d)=>N(h,`tensors${d}`,"raggedTensorToTensor","int32")),c={shape:r,values:a,defaultValue:o,rowPartitionTensors:l},u={rowPartitionTypes:i};return W.runKernel(bg,c,u)}const AA=U({raggedTensorToTensor_:Bhe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $he(n,e,t){Ks(n);const s=re(n);let i=null;if(t==null||t==="float32")i=new Float32Array(s);else if(t==="int32")i=new Int32Array(s);else if(t==="bool")i=new Uint8Array(s);else throw new Error(`Unknown data type ${t}`);for(let r=0;r<s;r++)i[r]=e();return W.makeTensor(i,n,t)}const LA=U({rand_:$he});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xhe=.001,PA=.1;function Hhe(n,e,t){return t==null&&(t=QS()),Ex(n,e,(s,i)=>JS(s,i,t))}function QS(){return W.backend.floatPrecision()===32?Xhe:PA}function Ex(n,e,t){let s=!0;if((Pn(n)||Pn(e))&&(s=!1),Pn(n)&&Pn(e)&&(s=!0),s){const a=n.constructor.name,o=e.constructor.name;if(a!==o)throw new Error(`Arrays are of different type. Actual: ${a}. Expected: ${o}`)}if(Array.isArray(n)&&Array.isArray(e)){const a=fr(n),o=fr(e);if(!St(a,o))throw new Error(`Arrays have different shapes. Actual: [${a}]. Expected: [${o}]`)}const i=Pn(n)?n:pr(n),r=Pn(e)?e:pr(e);if(i.length!==r.length)throw new Error(`Arrays have different lengths actual: ${i.length} vs expected: ${r.length}.
Actual:   ${i}.
Expected: ${r}.`);for(let a=0;a<r.length;++a){const o=i[a],l=r[a];if(!t(o,l))throw new Error(`Arrays differ: actual[${a}] = ${o}, expected[${a}] = ${l}.
Actual:   ${i}.
Expected: ${r}.`)}typeof expect<"u"&&expect().nothing()}function Khe(n,e){n().then(()=>e.fail(),()=>e()),typeof expect<"u"&&expect().nothing()}function Zhe(n,e){const t=typeof e=="string"||typeof e=="number"||typeof e=="boolean"?[e]:e;return ir(n)||ir(n[0])||ir(e)||ir(e[0])?Ex(n,t,(s,i)=>s==i):Ex(n,e,(s,i)=>JS(s,i,0))}function Yhe(n,e,t){if(t==null&&(t=QS()),!JS(n,e,t))throw new Error(`Numbers differ: actual === ${n}, expected === ${e}`);typeof expect<"u"&&expect().nothing()}function JS(n,e,t){return!isFinite(n)&&!isFinite(e)?!0:!(isNaN(n)||isNaN(e)||Math.abs(n-e)>t)}function jhe(n,e,t){for(let s=0;s<n.length;s++)if(n[s]<e||n[s]>t)throw new Error(`Value out of range:${n[s]} low: ${e}, high: ${t}`)}function Qhe(n,e){const t=new Float32Array(n),s=new Float32Array(e);if(t.length!==s.length)throw new Error(`Expected ArrayBuffer to be of length ${s.length}, but it was ${t.length}`);for(let i=0;i<s.length;i++)if(t[i]!==s[i])throw new Error(`Expected ArrayBuffer value at ${i} to be ${s[i]} but got ${t[i]} instead`)}function DA(n){for(let e=0;e<n.length;e++){const t=n[e];Array.isArray(t)?DA(t):n[e]=cr(t)}return n}function Jhe(n){const e=document.createElement("video");return"playsInline"in e&&(e.playsInline=!0),e.muted=!0,e.loop=!0,e.style.position="fixed",e.style.left="0px",e.style.top="0px",e.preload="auto",e.appendChild(n),new Promise(t=>{e.addEventListener("loadeddata",s=>t(e)),e.load()})}async function qhe(n){await n.play(),"requestVideoFrameCallback"in n&&await new Promise(e=>{n.requestVideoFrameCallback(e)})}const ede=Object.freeze(Object.defineProperty({__proto__:null,TEST_EPSILON_FLOAT16:PA,createVideoElement:Jhe,encodeStrings:DA,expectArrayBuffersEqual:Qhe,expectArraysClose:Hhe,expectArraysEqual:Zhe,expectNumbersClose:Yhe,expectPromiseToFail:Khe,expectValuesInRange:jhe,play:qhe,testEpsilon:QS},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tde(n,e,t=1,s="float32",i){if(Ks(n),t==null&&(t=1),s==null&&(s="float32"),s!=="float32"&&s!=="int32")throw new Error(`Unsupported data type ${s}`);const r=new S$(e,t,s,i),a=ut(n,s);for(let o=0;o<a.values.length;o++)a.values[o]=r.nextValue();return a.toTensor()}const FA=U({randomGamma_:tde});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nde(n,e,t){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return ey(n,0,1,e,t)}const OA=U({randomStandardNormal_:nde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sde(n){const e=N(n,"x","reverse");return E(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),ri(e,0)}const GA=U({reverse1d_:sde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ide(n,e){const t=N(n,"x","reverse");return E(t.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${t.rank}.`),ri(t,e)}const zA=U({reverse2d_:ide});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rde(n,e){const t=N(n,"x","reverse");return E(t.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${t.rank}.`),ri(t,e)}const VA=U({reverse3d_:rde});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ade(n,e){const t=N(n,"x","reverse");return E(t.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${t.rank}.`),ri(t,e)}const WA=U({reverse4d_:ade});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function ode(n,e){const t=N(n,"x","setdiff1d"),s=N(e,"y","setdiff1d");E(t.dtype===s.dtype,()=>`x and y should have the same dtype, but got x (${t.dtype}) and y (${s.dtype}).`),E(t.rank===1,()=>`x should be 1D tensor, but got x (${t.shape}).`),E(s.rank===1,()=>`y should be 1D tensor, but got y (${s.shape}).`);const i=await t.data(),r=await s.data(),a=new Set(r);let o=0;for(let u=0;u<i.length;u++)a.has(i[u])||o++;const l=new En([o],t.dtype),c=new En([o],"int32");for(let u=0,h=0;u<i.length;u++)a.has(i[u])||(l.values[h]=i[u],c.values[h]=u,h++);return[l.toTensor(),c.toTensor()]}const UA=ode;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BA(n,e,t){if(jo(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const s=fr(n,t);if(s.length!==4&&s.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Ba(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $A(n,e,t){if(jo(n),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const s=fr(n,t);if(s.length!==5&&s.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Ba(n,e,s,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XA(n,e,t){if(jo(n),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const s=fr(n,t);if(s.length!==6&&s.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(s.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||s,Ba(n,e,s,t)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HA(n,e){return ib(n,e,"right")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function lde(n){const e=N(n,"condition","whereAsync","bool"),t=await e.data(),s=py(e.shape,t);return n!==e&&e.dispose(),s}const qS=lde;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function cde(n,e,t){const s=N(n,"tensor","boolMask"),i=N(e,"mask","boolMask","bool"),r=t??0,a=i.rank,o=s.shape;E(a>0,()=>"mask cannot be scalar"),jn(o.slice(r,r+a),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let y=r;y<r+a;y++)l*=o[y];const c=o.slice(0,r).concat([l],o.slice(r+a)),u=K(s,c),h=K(i,[-1]),d=await qS(h),p=Ka(d,[1]),f=Iu(u,p,r);return n!==s&&s.dispose(),e!==i&&i.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f}const KA=cde;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ude(n,e,t,s,i=!0){const r=N(n,"v","movingAverage"),a=N(e,"x","movingAverage"),o=N(t,"decay","movingAverage");vC(r,a),E(St(r.shape,a.shape),()=>"Shape mismatch in v and x");const l=Ke(1),c=Fe(l,o);let u=X(Fe(a,r),c);if(i){E(s!=null,()=>"When using zeroDebias: true, step is required.");const h=N(s,"step","movingAverage");u=Ue(u,Fe(l,Kr(o,h)))}return de(r,u)}const ZA=U({movingAverage_:ude});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hde(n,e,t){Ks(t);const s=N(n,"indices","scatterND","int32"),i=N(e,"updates","scatterND");Sv(i,s,t);const r={indices:s,updates:i},a={shape:t};return W.runKernel(Tg,r,a)}const YA=U({scatterND_:hde});function dde(n,e,t,s){if(n.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${n.dtype}.`);if(n.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${n.shape}.`);const i=n.rank>0?n.shape[0]:1,r=n.rank>1?n.shape[1]:1;if(t.length!==r)throw new Error(`outputShape has incorrect number of elements:, ${t.length}, should be: ${r}.`);const a=e.size;if(!(e.rank===0||e.rank===1&&a===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==s.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pde(n,e,t,s=0){Ks(t);const i=N(n,"sparseIndices","sparseToDense","int32"),r=N(e,"sparseValues","sparseToDense","string_or_numeric"),a=N(s,"defaultValue","sparseToDense",r.dtype);dde(i,r,t,a);const o={sparseIndices:i,sparseValues:r,defaultValue:a},l={outputShape:t};return W.runKernel(kg,o,l)}const jA=U({sparseToDense_:pde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fde(n,e){const t=N(e,"indices","gatherND","int32"),s={params:N(n,"x","gatherND","string_or_numeric"),indices:t};return W.runKernel(ig,s)}const QA=U({gatherND_:fde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mde(n,e,t=1){const s=N(n,"predictions","inTopK"),i=N(e,"targets","inTopK");E(s.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${s.rank}`),E(s.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${s.rank} and targets rank ${i.rank}`),jn(s.shape.slice(0,s.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const r=s.shape[s.shape.length-1];E(t>0&&t<=r,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${r}), but got ${t}`);const a=await s.data(),o=await i.data(),[l,c]=[a.length/r,r],u=Rn("bool",l);for(let h=0;h<l;h++){const d=h*c,p=a.subarray(d,d+c),f=[];for(let y=0;y<p.length;y++)f.push({value:p[y],index:y});f.sort((y,m)=>m.value-y.value),u[h]=0;for(let y=0;y<t;y++)if(f[y].index===o[h]){u[h]=1;break}}return n!==s&&s.dispose(),e!==i&&i.dispose(),en(u,i.shape,"bool")}const JA=mde;/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gde({x:n,filter:e,strides:t,pad:s,dataFormat:i="NHWC",dilations:r=[1,1],dimRoundingMode:a,bias:o,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(by(W.state.gradientDepth,l)===!1){let w=wu(n,e,t,s,i,r,a);return o!=null&&(w=de(w,o)),yy(w,l,c,u)}const h=N(n,"x","depthwiseConv2d","float32"),d=N(e,"filter","depthwiseConv2d","float32");let p=h,f=!1;h.rank===3&&(f=!0,p=K(h,[1,h.shape[0],h.shape[1],h.shape[2]])),E(p.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${p.rank}.`),E(d.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${d.rank}.`),E(p.shape[3]===d.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${p.shape[3]}) must match the inChannels dimension in filter ${d.shape[2]}.`),r==null&&(r=[1,1]),E(Qn(t,r),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${t} and dilations '${r}'`),ms("fused depthwiseConv2d",s,a);const y=zn(p.shape,d.shape,t,r,s,a,!0);let m;o!=null&&(m=N(o,"bias","fused conv2d"),[m]=cn(m,h),st(y.outShape,m.shape));let g;c!=null&&(g=N(c,"prelu weights","fused depthwiseConv2d"));const b=(w,_)=>{E(Pa(r),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${r}'`);const[I,C,S,M]=_,A=my(w,S,l),D=KC(C.shape,A,I,t,s,r,a),F=HC(C,A,I.shape,t,s,r,a);if(M!=null){const k=gy(m,A);return[D,F,k]}return[D,F]},x={x:p,filter:d,bias:m,preluActivationWeights:g},v={strides:t,pad:s,dataFormat:i,dilations:r,dimRoundingMode:a,activation:l,leakyreluAlpha:u};return o==null?mr((w,_,I)=>{let C=W.runKernel(Mh,x,v);return I([_,w,C]),f&&(C=K(C,[C.shape[1],C.shape[2],C.shape[3]])),{value:C,gradFunc:b}})(p,d):mr((w,_,I,C)=>{let S=W.runKernel(Mh,x,v);return C([_,w,S,I]),f&&(S=K(S,[S.shape[1],S.shape[2],S.shape[3]])),{value:S,gradFunc:b}})(p,d,m)}const yde=U({fusedDepthwiseConv2d_:gde});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qA=Object.freeze(Object.defineProperty({__proto__:null,conv2d:XC,depthwiseConv2d:yde,matMul:ax},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bde="model",xde=".json",vde=".weights.bin";function XM(n){return new Promise(e=>setTimeout(e)).then(n)}class Ho{constructor(e){if(!ee().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Ho.URL_SCHEME)&&(e=e.slice(Ho.URL_SCHEME.length)),(e==null||e.length===0)&&(e=bde),this.modelJsonFileName=e+xde,this.weightDataFileName=e+vde}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const s=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=_C(e,s),r=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),a=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(a.download=this.modelJsonFileName,a.href=r,await XM(()=>a.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const o=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;o.download=this.weightDataFileName,o.href=t,await XM(()=>o.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:Hd(e)}}}}Ho.URL_SCHEME="downloads://";class wde{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,t)=>{const s=new FileReader;s.onload=i=>{const r=JSON.parse(i.target.result),a=r.modelTopology;if(a==null){t(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(r.weightsManifest==null){t(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:a});return}const o=w1(r,l=>this.loadWeights(l));e(o)},s.onerror=i=>t(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),s.readAsText(this.jsonFile)})}loadWeights(e){const t=[],s=[];for(const a of e)t.push(...a.weights),s.push(...a.paths);const i=this.checkManifestAndWeightFiles(e),r=s.map(a=>this.loadWeightsFile(a,i[a]));return Promise.all(r).then(a=>[t,Wg(a)])}loadWeightsFile(e,t){return new Promise((s,i)=>{const r=new FileReader;r.onload=a=>{const o=a.target.result;s(o)},r.onerror=a=>i(`Failed to weights data from file of path '${e}'.`),r.readAsArrayBuffer(t)})}checkManifestAndWeightFiles(e){const t=[],s=this.weightsFiles.map(r=>bI(r.name)),i={};for(const r of e)r.paths.forEach(a=>{const o=bI(a);if(t.indexOf(o)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${o}'`);if(t.push(o),s.indexOf(o)===-1)throw new Error(`Weight file with basename '${o}' is not provided.`);i[a]=this.weightsFiles[s.indexOf(o)]});if(t.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${t.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const Sde=n=>ee().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Ho.URL_SCHEME)?Tde(n.slice(Ho.URL_SCHEME.length)):null;rn.registerSaveRouter(Sde);function Tde(n="model"){return new Ho(n)}function _de(n){return new wde(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class I0{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class eL{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class Ide{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function Mde(n,e,t,s){const i=arguments;return new Ide(Tm(...i))}function Tm(n,e,t,s){return arguments.length===1?n.modelTopology!=null||n.weightSpecs!=null?new I0(n):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new I0({modelTopology:n})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new I0({modelTopology:n,weightSpecs:e,weightData:t,trainingConfig:s}))}function Cde(n){return new eL(n)}function Ede(n){return new eL(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eT=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:_de,browserHTTPRequest:oE,concatenateArrayBuffers:Wg,copyModel:SW,decodeWeights:b1,encodeWeights:tx,fromMemory:Mde,fromMemorySync:Tm,getLoadHandlers:MC,getModelArtifactsForJSON:w1,getModelArtifactsForJSONSync:v1,getModelArtifactsInfoForJSON:Hd,getSaveHandlers:IC,getWeightSpecs:S1,http:Dv,isHTTPScheme:ox,listModels:vW,loadWeights:iE,moveModel:TW,registerLoadRouter:lW,registerSaveRouter:oW,removeModel:wW,weightsLoaderFactory:rE,withSaveHandler:Cde,withSaveHandlerSync:Ede},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kde(n,e,t){const s=N(n,"labels","confusionMatrix"),i=N(e,"predictions","confusionMatrix");E(t==null||t>0&&Number.isInteger(t),()=>`If provided, numClasses must be a positive integer, but got ${t}`),E(s.rank===1,()=>`Expected the rank of labels to be 1, but got ${s.rank}`),E(i.rank===1,()=>`Expected the rank of predictions to be 1, but got ${i.rank}`),E(s.shape[0]===i.shape[0],()=>`Mismatch in the number of examples: ${s.shape[0]} vs. ${i.shape[0]}. Labels and predictions should have the same number of elements.`),E(t>0&&Number.isInteger(t),()=>`numClasses is required to be a positive integer, but got ${t}`);const r=lc(Se(s,"int32"),t),a=lc(Se(i,"int32"),t),o=xt(r),l=ft(o,a);return Se(l,"int32")}const Nde=U({confusionMatrix_:kde});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rde=Object.freeze(Object.defineProperty({__proto__:null,confusionMatrix:Nde},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const tL="4.2.0";/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ade=Object.freeze(Object.defineProperty({__proto__:null,nonMaxSuppressionV3Impl:xy,nonMaxSuppressionV4Impl:vy,nonMaxSuppressionV5Impl:wy,whereImpl:py},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Lde(n){return new xw(n)}function Pde(n){return new vw(n)}function Dde(){return new ww}function Fde(n){return new Sw(n)}const Ode=Object.freeze(Object.defineProperty({__proto__:null,maxNorm:Lde,minMaxNorm:Fde,nonNeg:Dde,unitNorm:Pde},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Gde(){return new uw}function zde(){return new Ny}function Vde(n){return new hw(n)}function Wde(n){return new dw(n)}function Ude(n){return new pw(n)}function Bde(n){return new fw(n)}function $de(n){return new mw(n)}function Xde(n){return new Ns(n)}function Hde(n){return new Ry(n)}function Kde(n){return new Ay(n)}function Zde(n){return new Ly(n)}function Yde(n){return new Py(n)}function jde(n){return new Dy(n)}function Qde(n){return new Fy(n)}function Jde(n){return new gw(n)}const qde=Object.freeze(Object.defineProperty({__proto__:null,constant:Vde,glorotNormal:Kde,glorotUniform:Hde,heNormal:Zde,heUniform:Yde,identity:$de,leCunNormal:jde,leCunUniform:Qde,ones:zde,orthogonal:Jde,randomNormal:Ude,randomUniform:Wde,truncatedNormal:Bde,varianceScaling:Xde,zeros:Gde},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function epe(n){return new Vr(n)}function tpe(n){return new Wy(n)}function nL(n){return lk(n)}function npe(n,e){Tw.registerCallbackConstructor(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function spe(n){return new Ru(n)}function ipe(n){return new Lw(n)}function rpe(n){return new Nw(n)}function ape(n){return new Rw(n)}function ope(n){return new Aw(n)}function lpe(n){return new Dw(n)}function cpe(n){return new Pw(n)}function upe(n){return new vp(n)}function hpe(n){return new Pu(n)}function dpe(n){return new Ow(n)}function ppe(n){return new Du(n)}function fpe(n){return new Gw(n)}function mpe(n){return new zw(n)}function gpe(n){return new Vw(n)}function ype(n){return new Ww(n)}function bpe(n){return new Uw(n)}function xpe(n){return new jw(n)}function vpe(n){return new Zw(n)}function wpe(n){return new Ky(n)}function Spe(n){return new Kw(n)}function Tpe(n){return new Yw(n)}function _pe(n){return new Qw(n)}function Ipe(n){return new Jw(n)}function Mpe(n){return new qw(n)}function Cpe(n){return new tS(n)}function Epe(n){return new nS(n)}function kpe(n){return new iS(n)}function Npe(n){return new oS(n)}function Rpe(n){return new rS(n)}function Ape(n){return new aS(n)}function Lpe(n){return new sS(n)}function Ppe(n){return new lS(n)}function Dpe(n){return new dS(n)}function Fpe(n){return new pS(n)}function Ope(n){return new fS(n)}function tT(n){return new gS(n)}function Gpe(n){return tT(n)}function zpe(n){return tT(n)}function nT(n){return new bS(n)}function Vpe(n){return nT(n)}function Wpe(n){return nT(n)}function sT(n){return new vS(n)}function Upe(n){return sT(n)}function Bpe(n){return sT(n)}function $pe(n){return new wS(n)}function Xpe(n){return new TS(n)}function sL(n){return new SS(n)}function iL(n){return new _S(n)}function rL(n){return new mS(n)}function aL(n){return new yS(n)}function Hpe(n){return new xS(n)}function Kpe(n){return new $w(n)}function Zpe(n){return new $y(n)}function Ype(n){return new Xw(n)}function jpe(n){return new Sp(n)}function Qpe(n){return new Bw(n)}function Jpe(n){return new By(n)}function qpe(n){return new Hw(n)}function efe(n){return new Hy(n)}function tfe(n){return new Ki(n)}function nfe(n){return new Xy(n)}function sfe(n){return new MS(n)}function ife(n){return new IS(n)}const rfe=sL,afe=iL,ofe=rL,lfe=aL;function cfe(n){return new cS(n)}function ufe(n){return new uS(n)}function hfe(n){return new hS(n)}function dfe(n){return new eS(n)}function pfe(n){return new CS(n)}function ffe(n){return new ES(n)}function mfe(n){return new NS(n)}function gfe(n){return new kS(n)}const yfe=Object.freeze(Object.defineProperty({__proto__:null,Layer:yt,RNN:Ki,RNNCell:wp,activation:xpe,add:Epe,alphaDropout:hfe,average:kpe,averagePooling1d:tT,averagePooling2d:nT,averagePooling3d:sT,avgPool1d:Gpe,avgPool2d:Vpe,avgPool3d:Upe,avgPooling1d:zpe,avgPooling2d:Wpe,avgPooling3d:Bpe,batchNormalization:Dpe,bidirectional:sfe,categoryEncoding:gfe,centerCrop:ffe,concatenate:Npe,conv1d:upe,conv2d:hpe,conv2dTranspose:dpe,conv3d:ppe,conv3dTranspose:fpe,convLstm2d:qpe,convLstm2dCell:efe,cropping2D:gpe,dense:vpe,depthwiseConv2d:bpe,dot:Ppe,dropout:wpe,elu:ipe,embedding:Cpe,flatten:Tpe,gaussianDropout:ufe,gaussianNoise:cfe,globalAveragePooling1d:$pe,globalAveragePooling2d:Xpe,globalMaxPool1d:rfe,globalMaxPool2d:afe,globalMaxPooling1d:sL,globalMaxPooling2d:iL,gru:Kpe,gruCell:Zpe,input:nL,inputLayer:spe,layerNormalization:Fpe,leakyReLU:ape,lstm:Ype,lstmCell:jpe,masking:dfe,maxPool1d:ofe,maxPool2d:lfe,maxPooling1d:rL,maxPooling2d:aL,maxPooling3d:Hpe,maximum:Rpe,minimum:Ape,multiply:Lpe,permute:Mpe,prelu:ope,reLU:rpe,repeatVector:_pe,rescaling:pfe,reshape:Ipe,resizing:mfe,rnn:tfe,separableConv2d:mpe,simpleRNN:Qpe,simpleRNNCell:Jpe,softmax:lpe,spatialDropout1d:Spe,stackedRNNCells:nfe,thresholdedReLU:cpe,timeDistributed:ife,upSampling2d:ype,zeroPadding2d:Ope},Symbol.toStringTag,{value:"Module"}));function bfe(n,e){return Iw(n,e)}function xfe(n,e){return yk(n,e)}function vfe(n,e){return bk(n,e)}function wfe(n,e){return Mw(n,e)}function Sfe(n,e){return Cw(n,e)}function Tfe(n,e){return gk(n,e)}function _fe(n,e){return i5(n,e)}function Ife(n,e){return _w(n,e)}function Mfe(n,e){return Gy(n,e)}function Cfe(n,e){return Au(n,e)}function Efe(n,e){return Au(n,e)}function kfe(n,e){return Au(n,e)}function Nfe(n,e){return ol(n,e)}function Rfe(n,e){return ol(n,e)}function Afe(n,e){return ol(n,e)}const Lfe=Object.freeze(Object.defineProperty({__proto__:null,MAPE:Efe,MSE:Rfe,binaryAccuracy:bfe,binaryCrossentropy:xfe,categoricalAccuracy:wfe,categoricalCrossentropy:Sfe,cosineProximity:Ife,mape:kfe,meanAbsoluteError:Mfe,meanAbsolutePercentageError:Cfe,meanSquaredError:Nfe,mse:Afe,precision:Tfe,recall:_fe,sparseCategoricalAccuracy:vfe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const Pfe=Object.freeze(Object.defineProperty({__proto__:null,modelFromJSON:L5},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Dfe(n){return new xp(n)}function Ffe(n){return O5(n)}function Ofe(n){return G5(n)}const Gfe=Object.freeze(Object.defineProperty({__proto__:null,l1:Ffe,l1l2:Dfe,l2:Ofe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class oL extends pc{constructor(){super(...arguments),this.model=null}setModel(e){if(!(e instanceof Vr))throw new Error("model must be a LayersModel, not some other Container");this.model=e}}function Cf(n,e){return n<e}function HM(n,e){return n>e}class lL extends oL{constructor(e){if(super(),e==null&&(e={}),e.restoreBestWeights)throw new ct("restoreBestWeights = True is not implemented in EarlyStopping yet.");this.monitor=e.monitor||"val_loss",this.minDelta=Math.abs(e.minDelta||0),this.patience=e.patience||0,this.verbose=e.verbose||0,this.mode=e.mode||"auto",this.baseline=e.baseline,["auto","min","max"].indexOf(this.mode)===-1&&(console.warn(`EarlyStopping mode '${this.mode}' is invalid. Falling back to mode 'auto'.`),this.mode="auto"),this.mode==="min"?this.monitorFunc=Cf:this.mode==="max"?this.monitorFunc=HM:this.monitor.indexOf("acc")!==-1?this.monitorFunc=HM:this.monitorFunc=Cf,this.monitorFunc===Cf&&(this.minDelta*=-1)}async onTrainBegin(e){this.wait=0,this.stoppedEpoch=0,this.baseline!=null?this.best=this.baseline:this.best=this.monitorFunc===Cf?1/0:-1/0}async onEpochEnd(e,t){await da(t);const s=this.getMonitorValue(t);s!=null&&(this.monitorFunc(s-this.minDelta,this.best)?(this.best=s,this.wait=0):(this.wait++,this.wait>=this.patience&&(this.stoppedEpoch=e,this.model.stopTraining=!0)))}async onTrainEnd(e){this.stoppedEpoch>0&&this.verbose&&console.log(`Epoch ${this.stoppedEpoch}: early stopping.`)}getMonitorValue(e){e==null&&(e={});const t=e[this.monitor];return t==null&&console.warn(`Metric for EarlyStopping ${this.monitor} is not available. Available metrics are: ${Object.keys(e)}`),t}}function zfe(n){return new lL(n)}const Vfe={earlyStopping:zfe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iT={};function Wfe(n,e){const t={tfOpName:n,category:"custom",inputs:[],attrs:[],customExecutor:e};iT[n]=t}function cL(n){return iT[n]}function Ufe(n){delete iT[n]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T(n,e,t,s,i){const r=e.inputParams[n];if(r&&r.inputIndexStart!==void 0){const o=r.inputIndexStart,l=r.inputIndexEnd===0?void 0:r.inputIndexEnd===void 0?o+1:r.inputIndexEnd;if(r.type==="tensor")return ds(e.inputNames[r.inputIndexStart],t,s,i);if(r.type==="tensors")return e.inputNames.slice(o,l).map(h=>ds(h,t,s,i));const c=ds(e.inputNames.slice(o)[0],t,s,i),u=c.dataSync();return r.type==="number"?u[0]:ni(c.shape,u)}const a=e.attrParams[n];return a&&a.value}function ds(n,e,t,s){const[i,r]=Fs(n);if(s!=null){const o=s.getHashTableHandleByName(i);if(o!=null)return o}const a=t.currentContextIds.find(o=>!!e[_m(i,o)]);return a!==void 0?e[_m(i,a)][r]:void 0}function Bfe(n,e,t){return e[_m(n,t.currentContextId)]}function Nr(n,e){const[t,s,i]=Fs(n);return[_m(t,e&&e.currentContextId),s,i]}function _m(n,e){return e?`${n}-${e}`:n}function Fs(n){const e=n.split(":");if(e.length===1)return[n,0,void 0];const t=e[0],s=e.length===3?e[1]:void 0,i=Number(e[e.length-1]);return[t,i,s]}function Df(n,e,t){let s=T("pad",n,e,t);if(s==="explicit"){s=T("explicitPaddings",n,e,t);const i=[[0,0],[0,0],[0,0],[0,0]];for(let r=0;r<4;r++)i[r][0]=s[r*2],i[r][1]=s[r*2+1];return i}return s}function Rr(n){return n.kept?n:ur(n)}/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $fe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Xfe=Object.freeze(Object.defineProperty({__proto__:null,json:$fe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hfe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Kfe=Object.freeze(Object.defineProperty({__proto__:null,json:Hfe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zfe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Yfe=Object.freeze(Object.defineProperty({__proto__:null,json:Zfe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jfe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Qfe=Object.freeze(Object.defineProperty({__proto__:null,json:jfe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jfe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],qfe=Object.freeze(Object.defineProperty({__proto__:null,json:Jfe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eme=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],tme=Object.freeze(Object.defineProperty({__proto__:null,json:eme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nme=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],sme=Object.freeze(Object.defineProperty({__proto__:null,json:nme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ime=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],rme=Object.freeze(Object.defineProperty({__proto__:null,json:ime},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ame=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"InitializeTable",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]},{tfOpName:"InitializeTableV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}]}],ome=Object.freeze(Object.defineProperty({__proto__:null,json:ame},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lme=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],cme=Object.freeze(Object.defineProperty({__proto__:null,json:lme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ume=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],hme=Object.freeze(Object.defineProperty({__proto__:null,json:ume},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dme=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],pme=Object.freeze(Object.defineProperty({__proto__:null,json:dme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fme=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],mme=Object.freeze(Object.defineProperty({__proto__:null,json:fme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gme=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],yme=Object.freeze(Object.defineProperty({__proto__:null,json:gme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bme=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],xme=Object.freeze(Object.defineProperty({__proto__:null,json:bme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vme=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],wme=Object.freeze(Object.defineProperty({__proto__:null,json:vme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Sme=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],Tme=Object.freeze(Object.defineProperty({__proto__:null,json:Sme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _me=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],Ime=Object.freeze(Object.defineProperty({__proto__:null,json:_me},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2023 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mme=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],Cme=Object.freeze(Object.defineProperty({__proto__:null,json:Mme},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KM{constructor(){const e=[Xfe,Kfe,Yfe,Qfe,qfe,tme,sme,rme,ome,cme,hme,pme,mme,yme,xme,wme,Tme,Ime,Cme],t=[].concat(...e.map(s=>s.json));this.opMappers=t.reduce((s,i)=>(s[i.tfOpName]=i,s),{})}static get Instance(){return this._instance||(this._instance=new this)}transformGraph(e,t={}){const s=e.node,i=[],r=[],a=[],o=s.reduce((y,m)=>(y[m.name]=this.mapNode(m),m.op.startsWith("Placeholder")?i.push(y[m.name]):m.op==="Const"?r.push(y[m.name]):(m.input==null||m.input.length===0)&&a.push(y[m.name]),y),{});let l=[];const c=[];let u={},h={};t!=null&&(u=this.mapSignatureEntries(t.inputs),h=this.mapSignatureEntries(t.outputs));const d=Object.keys(o);d.forEach(y=>{const m=o[y];m.inputNames.forEach((g,b)=>{const[x,,v]=Nr(g),w=o[x];if(w.outputs!=null){const _=w.outputs.indexOf(v);if(_!==-1){const I=`${x}:${_}`;m.inputNames[b]=I}}m.inputs.push(w),w.children.push(m)})}),Object.keys(h).length===0?d.forEach(y=>{const m=o[y];m.children.length===0&&c.push(m)}):Object.keys(h).forEach(y=>{const[m]=Nr(y),g=o[m];g!=null&&(g.signatureKey=h[y],c.push(g))}),Object.keys(u).length>0?Object.keys(u).forEach(y=>{const[m]=Nr(y),g=o[m];g&&(g.signatureKey=u[y],l.push(g))}):l=i;let p={};e.library!=null&&e.library.function!=null&&(p=e.library.function.reduce((y,m)=>(y[m.signature.name]=this.mapFunction(m),y),{}));const f={nodes:o,inputs:l,outputs:c,weights:r,placeholders:i,signature:t,functions:p};return a.length>0&&(f.initNodes=a),f}mapSignatureEntries(e){return Object.keys(e||{}).reduce((t,s)=>(t[e[s].name]=s,t),{})}mapNode(e){const t=cL(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const s={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return t.inputs!=null&&(s.inputParams=t.inputs.reduce((i,r)=>(i[r.name]={type:r.type,inputIndexStart:r.start,inputIndexEnd:r.end},i),{})),t.attrs!=null&&(s.attrParams=t.attrs.reduce((i,r)=>{const a=r.type;let o;switch(r.type){case"string":o=kx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=kx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"string[]":o=Fx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Fx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number":o=Rx(e.attr,r.tfName,r.defaultValue||0),o===void 0&&r.tfDeprecatedName&&(o=Rx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"number[]":o=Dx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Dx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool":o=Nx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Nx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"bool[]":o=Gx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Gx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape":o=Px(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Px(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"shape[]":o=Ox(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Ox(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype":o=Ax(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Ax(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"dtype[]":o=Lx(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=Lx(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"func":o=ZM(e.attr,r.tfName,r.defaultValue),o===void 0&&r.tfDeprecatedName&&(o=ZM(e.attr,r.tfDeprecatedName,r.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${r.type} for op: ${e.op}`)}return i[r.name]={value:o,type:a},i},{})),s}mapFunction(e){const t=e.nodeDef,s=[],i=[];let r={};t!=null&&(r=t.reduce((u,h)=>(u[h.name]=this.mapNode(h),h.op==="Const"&&i.push(u[h.name]),u),{}));const a=[],o=[];e.signature.inputArg.forEach(u=>{const[h]=Nr(u.name),d={name:h,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:rT(u.type),type:"dtype"}},children:[]};d.signatureKey=u.name,a.push(d),r[h]=d}),Object.keys(r).forEach(u=>{const h=r[u];h.inputNames.forEach((d,p)=>{const[f,,y]=Nr(d),m=r[f];if(m.outputs!=null){const g=m.outputs.indexOf(y);if(g!==-1){const b=`${f}:${g}`;h.inputNames[p]=b}}h.inputs.push(m),m.children.push(h)})});const l=e.ret;e.signature.outputArg.forEach(u=>{const[h,d]=Nr(l[u.name]),p=r[h];p!=null&&(p.defaultOutput=d,o.push(p))});const c=this.mapArgsToSignature(e);return{nodes:r,inputs:a,outputs:o,weights:i,placeholders:s,signature:c}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s),t),{}),outputs:e.signature.outputArg.reduce((t,s)=>(t[s.name]=this.mapArgToTensorInfo(s,e.ret),t),{})}}mapArgToTensorInfo(e,t){let s=e.name;return t!=null&&(s=t[s]),{name:s,dtype:e.type}}}function Eme(n){const e=ee().global;if(typeof e.atob<"u")return e.atob(n);if(typeof Buffer<"u")return new Buffer(n,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function uL(n,e){const t=Array.isArray(n)?String.fromCharCode.apply(null,n):Eme(n);return e?t:t.toLowerCase()}function kx(n,e,t,s=!1){const i=n[e];return i!=null?uL(i.s,s):t}function Nx(n,e,t){const s=n[e];return s?s.b:t}function Rx(n,e,t){const s=n[e]||{},i=s.i!=null?s.i:s.f!=null?s.f:t;return typeof i=="number"?i:parseInt(i,10)}function rT(n){switch(typeof n=="string"&&(n=di[n]),n){case di.DT_FLOAT:case di.DT_HALF:return"float32";case di.DT_INT32:case di.DT_INT64:case di.DT_INT8:case di.DT_UINT8:return"int32";case di.DT_BOOL:return"bool";case di.DT_DOUBLE:return"float32";case di.DT_STRING:return"string";default:return null}}function ZM(n,e,t){const s=n[e];return s&&s.func?s.func.name:t}function Ax(n,e,t){const s=n[e];return s&&s.type?rT(s.type):t}function Lx(n,e,t){const s=n[e];return s&&s.list&&s.list.type?s.list.type.map(i=>rT(i)):t}function hL(n){if(!n.unknownRank)return n.dim!=null?n.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function Px(n,e,t){const s=n[e];return s&&s.shape?hL(s.shape):t}function Dx(n,e,t){const s=n[e];return s?((s.list.f&&s.list.f.length?s.list.f:s.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):t}function Fx(n,e,t,s=!1){const i=n[e];return i&&i.list&&i.list.s?i.list.s.map(r=>uL(r,s)):t}function Ox(n,e,t){const s=n[e];return s&&s.list&&s.list.shape?s.list.shape.map(i=>hL(i)):t}function Gx(n,e,t){const s=n[e];return s&&s.list&&s.list.b?s.list.b:t}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kme{constructor(e,t,s){this.node=e,this.tensorMap=t,this.context=s,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,r)=>(i[r]=this.getAttr(r),i),{}))}getInput(e){return ds(e,this.tensorMap,this.context)}getAttr(e,t){const s=this.node.rawAttrs[e];if(s.tensor!=null)return ds(e,this.tensorMap,this.context);if(s.i!=null||s.f!=null)return Rx(this.node.rawAttrs,e,t);if(s.s!=null)return kx(this.node.rawAttrs,e,t);if(s.b!=null)return Nx(this.node.rawAttrs,e,t);if(s.shape!=null)return Px(this.node.rawAttrs,e,t);if(s.type!=null)return Ax(this.node.rawAttrs,e,t);if(s.list!=null){if(s.list.i!=null||s.list.f!=null)return Dx(this.node.rawAttrs,e,t);if(s.list.s!=null)return Fx(this.node.rawAttrs,e,t);if(s.list.shape!=null)return Ox(this.node.rawAttrs,e,t);if(s.list.b!=null)return Gx(this.node.rawAttrs,e,t);if(s.list.type!=null)return Lx(this.node.rawAttrs,e,t)}return t}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const es=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:y1,abs:xn,acos:I1,acosh:M1,add:de,addN:fA,all:Bg,any:Rh,argMax:Do,argMin:C1,asin:E1,asinh:k1,atan:N1,atan2:R1,atanh:A1,avgPool:Zd,avgPool3d:P1,basicLSTMCell:mA,batchNorm:vu,batchNorm2d:D1,batchNorm3d:F1,batchNorm4d:O1,batchToSpaceND:Yd,bincount:G1,booleanMaskAsync:KA,broadcastArgs:gA,broadcastTo:Mo,buffer:ut,cast:Se,ceil:z1,clipByValue:ks,clone:ur,complex:Xr,concat:fn,concat1d:V1,concat2d:W1,concat3d:U1,concat4d:B1,conv1d:$g,conv2d:Hr,conv2dTranspose:Xg,conv3d:X1,conv3dTranspose:H1,cos:jd,cosh:Hg,cosineWindow:fy,cumprod:Ph,cumsum:Kg,denseBincount:tm,depthToSpace:K1,depthwiseConv2d:wu,diag:yA,dilation2d:Z1,div:Ue,divNoNan:Y1,dot:j1,dropout:Tv,einsum:bA,elu:Su,enclosingPowerOfTwo:_v,equal:Us,erf:Q1,euclideanNorm:q1,exp:Bs,expandDims:ns,expm1:ev,eye:Zg,fft:lp,fill:el,floor:_u,floorDiv:Ug,fused:qA,gather:Iu,gatherND:QA,greater:gs,greaterEqual:ta,ifft:hc,imag:Qd,image:rr,inTopKAsync:JA,irfft:cy,isFinite:tv,isInf:nv,isNaN:sv,leakyRelu:Jd,less:Yg,lessEqual:Ha,linalg:Cv,linspace:xA,localResponseNormalization:iv,log:$s,log1p:qd,logSigmoid:rv,logSoftmax:Qg,logSumExp:Jg,logicalAnd:Ti,logicalNot:ep,logicalOr:qg,logicalXor:av,losses:eE,lowerBound:vA,matMul:ft,max:si,maxPool:tp,maxPool3d:ov,maxPoolWithArgmax:wA,maximum:vr,mean:on,meshgrid:SA,min:oc,minimum:Mu,mirrorPad:lv,mod:cv,moments:np,movingAverage:ZA,mul:X,multiRNNCell:TA,multinomial:_A,neg:Jt,norm:Tu,notEqual:zo,oneHot:lc,ones:Vs,onesLike:Xs,op:U,outerProduct:IA,pad:na,pad1d:MA,pad2d:CA,pad3d:EA,pad4d:kA,pool:uv,pow:Kr,prelu:ip,print:T1,prod:hv,raggedGather:NA,raggedRange:RA,raggedTensorToTensor:AA,rand:LA,randomGamma:FA,randomNormal:ey,randomStandardNormal:OA,randomUniform:Eu,range:Vo,real:cc,reciprocal:pv,relu:Xi,relu6:ty,reshape:K,reverse:ri,reverse1d:GA,reverse2d:zA,reverse3d:VA,reverse4d:WA,rfft:cp,round:ny,rsqrt:sy,scalar:Ke,scatterND:YA,searchSorted:ib,selu:iy,separableConv2d:ry,setdiff1dAsync:UA,sigmoid:Gi,sign:fv,signal:qC,sin:ay,sinh:oy,slice:Tt,slice1d:rp,slice2d:ly,slice3d:ap,slice4d:uc,softmax:op,softplus:tl,spaceToBatchND:sp,sparse:tE,sparseToDense:jA,spectral:JC,split:Cs,sqrt:Yn,square:zt,squaredDifference:uy,squeeze:Ka,stack:ps,step:sl,stridedSlice:mv,string:nE,sub:Fe,sum:ze,tan:gv,tanh:Oo,tensor:en,tensor1d:ss,tensor2d:Ca,tensor3d:yv,tensor4d:BA,tensor5d:$A,tensor6d:XA,tile:ei,topk:bv,transpose:xt,truncatedNormal:hy,unique:xv,unsortedSegmentSum:dy,unstack:ai,upperBound:HA,variable:vv,where:rs,whereAsync:qS,zeros:vn,zerosLike:_t},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nme=(n,e,t,s=es)=>{switch(n.op){case"BiasAdd":case"AddV2":case"Add":return[s.add(T("a",n,e,t),T("b",n,e,t))];case"AddN":return[s.addN(T("tensors",n,e,t))];case"FloorMod":case"Mod":return[s.mod(T("a",n,e,t),T("b",n,e,t))];case"Mul":return[s.mul(T("a",n,e,t),T("b",n,e,t))];case"RealDiv":case"Div":return[s.div(T("a",n,e,t),T("b",n,e,t))];case"DivNoNan":return[s.divNoNan(T("a",n,e,t),T("b",n,e,t))];case"FloorDiv":return[s.floorDiv(T("a",n,e,t),T("b",n,e,t))];case"Sub":return[s.sub(T("a",n,e,t),T("b",n,e,t))];case"Minimum":return[s.minimum(T("a",n,e,t),T("b",n,e,t))];case"Maximum":return[s.maximum(T("a",n,e,t),T("b",n,e,t))];case"Pow":return[s.pow(T("a",n,e,t),T("b",n,e,t))];case"SquaredDifference":return[s.squaredDifference(T("a",n,e,t),T("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rme=(n,e,t,s=es)=>{switch(n.op){case"Abs":case"ComplexAbs":return[s.abs(T("x",n,e,t))];case"Acos":return[s.acos(T("x",n,e,t))];case"Acosh":return[s.acosh(T("x",n,e,t))];case"Asin":return[s.asin(T("x",n,e,t))];case"Asinh":return[s.asinh(T("x",n,e,t))];case"Atan":return[s.atan(T("x",n,e,t))];case"Atan2":return[s.atan2(T("x",n,e,t),T("y",n,e,t))];case"Atanh":return[s.atanh(T("x",n,e,t))];case"Ceil":return[s.ceil(T("x",n,e,t))];case"Complex":return[s.complex(T("real",n,e,t),T("imag",n,e,t))];case"Cos":return[s.cos(T("x",n,e,t))];case"Cosh":return[s.cosh(T("x",n,e,t))];case"Elu":return[s.elu(T("x",n,e,t))];case"Erf":return[s.erf(T("x",n,e,t))];case"Exp":return[s.exp(T("x",n,e,t))];case"Expm1":return[s.expm1(T("x",n,e,t))];case"Floor":return[s.floor(T("x",n,e,t))];case"Log":return[s.log(T("x",n,e,t))];case"Log1p":return[s.log1p(T("x",n,e,t))];case"Imag":return[s.imag(T("x",n,e,t))];case"Neg":return[s.neg(T("x",n,e,t))];case"Reciprocal":return[s.reciprocal(T("x",n,e,t))];case"Real":return[s.real(T("x",n,e,t))];case"Relu":return[s.relu(T("x",n,e,t))];case"Round":return[s.round(T("x",n,e,t))];case"Selu":return[s.selu(T("x",n,e,t))];case"Sigmoid":return[s.sigmoid(T("x",n,e,t))];case"Sin":return[s.sin(T("x",n,e,t))];case"Sign":return[s.sign(T("x",n,e,t))];case"Sinh":return[s.sinh(T("x",n,e,t))];case"Softplus":return[s.softplus(T("x",n,e,t))];case"Sqrt":return[s.sqrt(T("x",n,e,t))];case"Square":return[s.square(T("x",n,e,t))];case"Tanh":return[s.tanh(T("x",n,e,t))];case"Tan":return[s.tan(T("x",n,e,t))];case"ClipByValue":return[s.clipByValue(T("x",n,e,t),T("clipValueMin",n,e,t),T("clipValueMax",n,e,t))];case"Relu6":return[s.relu6(T("x",n,e,t))];case"Rsqrt":return[s.rsqrt(ds(n.inputNames[0],e,t))];case"Prod":return[s.prod(T("x",n,e,t),T("axes",n,e,t))];case"LeakyRelu":return[s.leakyRelu(T("x",n,e,t),T("alpha",n,e,t))];case"Prelu":return[s.prelu(T("x",n,e,t),T("alpha",n,e,t))];case"IsNan":return[s.isNaN(ds(n.inputNames[0],e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fi(n,e,t=""){if(!(typeof n=="number"||typeof e=="number")){E(n.length===e.length,()=>t+` Shapes ${n} and ${e} must match`);for(let s=0;s<n.length;s++){const i=n[s],r=e[s];E(i<0||r<0||i===r,()=>t+` Shapes ${n} and ${e} must match`)}}}function YM(n){return!(typeof n=="number"||n.some(e=>e<0))}function ah(n,e,t){let s=zx(n,t);const i=!YM(s);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${s}`);if(i&&e.forEach(r=>{s=zx(r.shape,s)}),!YM(s))throw new Error(`Non-fully-defined elementShape: ${s}`);return s}function zx(n,e){if(typeof n=="number")return e;if(typeof e=="number")return n;if(n.length!==e.length)throw new Error(`Incompatible ranks during merge: ${n} vs. ${e}`);const t=[];for(let s=0;s<n.length;++s){const i=n[s],r=e[s];if(i>=0&&r>=0&&i!==r)throw new Error(`Incompatible shape during merge: ${n} vs. ${e}`);t[s]=i>=0?i:r}return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ame{constructor(e,t,s,i,r,a,o){this.name=e,this.dtype=t,this.maxSize=s,this.elementShape=i,this.identicalElementShapes=r,this.dynamicSize=a,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=Ke(0),hn(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.tensor.id))&&t.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const t=this.tensors[e];if(t.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map(t=>this.read(t))}write(e,t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const s=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${t.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=t.shape),fi(this.elementShape,t.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),s.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(s.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);s.tensor=t,hn(t),s.written=!0,this.tensors[e]=s}writeMany(e,t){if(e.length!==t.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${t.length}.`);e.forEach((s,i)=>this.write(s,t[i]))}gather(e,t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${t}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return en([],[0].concat(this.elementShape));const s=this.readMany(e);return fi(this.elementShape,s[0].shape,"TensorArray shape mismatch: "),ps(s,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return en([],[0].concat(this.elementShape));const t=[];for(let i=0;i<this.size();i++)t.push(i);const s=this.readMany(t);return fi(this.elementShape,s[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${s[0].shape})`),fn(s,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(!this.dynamicSize&&s>=this.maxSize)throw new Error(`Max index must be < array size (${s}  vs. ${this.maxSize})`);this.writeMany(e,ai(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${t.dtype}`);let s=0;const i=e.map(l=>(s+=l,s));if(s!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${t.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const r=s===0?0:t.size/s,a=[];j(()=>{t=K(t,[1,s,r]);for(let l=0;l<e.length;++l){const c=[0,l===0?0:i[l-1],0],u=[1,e[l],r];a[l]=K(Tt(t,c,u),this.elementShape)}return a});const o=[];for(let l=0;l<e.length;l++)o[l]=l;this.writeMany(o,a)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ko{constructor(e,t,s,i=-1){this.tensors=e,this.elementShape=t,this.elementDtype=s,e!=null&&e.forEach(r=>{if(s!==r.dtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${r.dtype}`);fi(t,r.shape,"TensorList shape mismatch: "),hn(r)}),this.idTensor=Ke(0),this.maxNumElements=i,hn(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Ko([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(t=>{(e==null||!e.has(t.id))&&t.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t,s=-1){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(s!==-1&&this.tensors.length!==s)throw new Error(`Operation expected a list with ${s} elements but got a list with ${this.tensors.length} elements.`);fi(e,this.elementShape,"TensorList shape mismatch: ");const i=ah(this.elementShape,this.tensors,e);return j(()=>{const r=this.tensors.map(a=>K(a,i));return ps(r,0)})}popBack(e,t){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const s=ah(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,fi(i.shape,e,"TensorList shape mismatch: "),K(i,s)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(fi(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");hn(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const t=new Ko([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let s=0;s<Math.min(this.tensors.length,e);++s)t.tensors[s]=this.tensors[s];return t}getItem(e,t,s){if(s!==this.elementDtype)throw new Error(`Invalid data types; op elements ${s}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);fi(this.tensors[e].shape,t,"TensorList shape mismatch: ");const i=ah(this.elementShape,this.tensors,t);return K(this.tensors[e],i)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);fi(this.elementShape,t.shape,"TensorList shape mismatch: "),hn(t),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,s){if(t!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t}, but list elements ${this.elementDtype}`);fi(this.elementShape,s,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=ah(this.elementShape,this.tensors,s);return e.length===0?en([],[0].concat(i)):j(()=>{const r=e.map(a=>K(this.tensors[a],i));return ps(r,0)})}concat(e,t){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);fi(this.elementShape,t,"TensorList shape mismatch: ");const s=ah(this.elementShape,this.tensors,t);return this.size()===0?en([],[0].concat(s)):j(()=>{const i=this.tensors.map(r=>K(r,s));return fn(i,0)})}}function Lme(n,e,t){const s=n.dtype;if(n.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${n.shape}`);if(n.dtype!==t)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${t}`);const i=n.shape.slice(1);fi(i,e,"TensorList shape mismatch: ");const r=ai(n);return new Ko(r,e,s)}function Pme(n,e,t,s){return new Ko([],n,e,s)}function Dme(n,e,t,s){if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const i=Math.max(...e);if(s!=null&&s!==-1&&i>=s)throw new Error(`Max index must be < array size (${i}  vs. ${s})`);const r=new Ko([],t,n.dtype,s),a=ai(n,0);return e.forEach((o,l)=>{r.setItem(o,a[l])}),r}function Fme(n,e,t){let s=0;const i=e.map(u=>(s+=u,s));if(s!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${s}, and tensor's shape is: ${n.shape}`);const r=n.shape.slice(1),a=zx(r,t),o=s===0?0:n.size/s,l=j(()=>{const u=[];n=K(n,[1,s,o]);for(let h=0;h<e.length;++h){const d=[0,h===0?0:i[h-1],0],p=[1,e[h],o];u[h]=K(Tt(n,d,p),a)}return n.dispose(),u}),c=new Ko([],t,n.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ome=async(n,e,t)=>{switch(n.op){case"If":case"StatelessIf":{const s=T("thenBranch",n,e,t),i=T("elseBranch",n,e,t),r=T("cond",n,e,t),a=T("args",n,e,t);return(await r.data())[0]?t.functionMap[s].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap):t.functionMap[i].executeFunctionAsync(a,t.tensorArrayMap,t.tensorListMap)}case"While":case"StatelessWhile":{const s=T("body",n,e,t),i=T("cond",n,e,t),r=T("args",n,e,t),a=await t.functionMap[i].executeFunctionAsync(r,t.tensorArrayMap,t.tensorListMap),o=r.map(u=>u.id);let l=await a[0].data();a.forEach(u=>{!u.kept&&o.indexOf(u.id)===-1&&u.dispose()});let c=r;for(;l[0];){const u=c;c=await t.functionMap[s].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);const h=c.map(p=>p.id);u.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()});const d=await t.functionMap[i].executeFunctionAsync(c,t.tensorArrayMap,t.tensorListMap);l=await d[0].data(),d.forEach(p=>{!p.kept&&o.indexOf(p.id)===-1&&h.indexOf(p.id)===-1&&p.dispose()})}return c}case"LoopCond":{const s=T("pred",n,e,t);return[Rr(s)]}case"Switch":{const s=T("pred",n,e,t);let i=T("data",n,e,t);return i.kept||(i=Rr(i)),(await s.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const s=n.inputNames.find(i=>ds(i,e,t)!==void 0);if(s){const i=ds(s,e,t);return[Rr(i)]}return}case"Enter":{const s=T("frameName",n,e,t),i=T("tensor",n,e,t);return t.enterFrame(s),[Rr(i)]}case"Exit":{const s=T("tensor",n,e,t);return t.exitFrame(),[Rr(s)]}case"NextIteration":{const s=T("tensor",n,e,t);return t.nextIteration(),[Rr(s)]}case"TensorArrayV3":{const s=T("size",n,e,t),i=T("dtype",n,e,t),r=T("elementShape",n,e,t),a=T("dynamicSize",n,e,t),o=T("clearAfterRead",n,e,t),l=T("identicalElementShapes",n,e,t),c=T("name",n,e,t),u=new Ame(c,i,s,r,l,a,o);return t.addTensorArray(u),[u.idTensor,Ke(1)]}case"TensorArrayWriteV3":{const s=T("tensorArrayId",n,e,t),i=T("index",n,e,t),r=T("tensor",n,e,t),a=t.getTensorArray(s.id);return a.write(i,r),[a.idTensor]}case"TensorArrayReadV3":{const s=T("tensorArrayId",n,e,t),i=T("index",n,e,t);return[t.getTensorArray(s.id).read(i)]}case"TensorArrayGatherV3":{const s=T("tensorArrayId",n,e,t),i=T("indices",n,e,t),r=T("dtype",n,e,t);return[t.getTensorArray(s.id).gather(i,r)]}case"TensorArrayScatterV3":{const s=T("tensorArrayId",n,e,t),i=T("indices",n,e,t),r=T("tensor",n,e,t),a=t.getTensorArray(s.id);return a.scatter(i,r),[a.idTensor]}case"TensorArrayConcatV3":{const s=T("tensorArrayId",n,e,t),i=t.getTensorArray(s.id),r=T("dtype",n,e,t);return[i.concat(r)]}case"TensorArraySplitV3":{const s=T("tensorArrayId",n,e,t),i=T("tensor",n,e,t),r=T("lengths",n,e,t),a=t.getTensorArray(s.id);return a.split(r,i),[a.idTensor]}case"TensorArraySizeV3":{const s=T("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return[Ke(i.size(),"int32")]}case"TensorArrayCloseV3":{const s=T("tensorArrayId",n,e,t),i=t.getTensorArray(s.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const s=T("tensorListId",n,e,t),i=T("index",n,e,t),r=T("tensor",n,e,t),a=t.getTensorList(s.id);return a.setItem(i,r),[a.idTensor]}case"TensorListGetItem":{const s=T("tensorListId",n,e,t),i=T("index",n,e,t),r=T("elementShape",n,e,t),a=T("elementDType",n,e,t);return[t.getTensorList(s.id).getItem(i,r,a)]}case"TensorListScatterV2":case"TensorListScatter":{const s=T("indices",n,e,t),i=T("tensor",n,e,t),r=T("elementShape",n,e,t),a=T("numElements",n,e,t),o=Dme(i,s,r,a);return t.addTensorList(o),[o.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const s=T("elementShape",n,e,t),i=T("elementDType",n,e,t);let r;n.op==="TensorListReserve"?r="numElements":r="maxNumElements";const a=T(r,n,e,t),o=n.op==="TensorListReserve"?-1:a,l=Pme(s,i,a,o);return t.addTensorList(l),[l.idTensor]}case"TensorListGather":{const s=T("tensorListId",n,e,t),i=T("indices",n,e,t),r=T("elementShape",n,e,t),a=T("elementDType",n,e,t);return[t.getTensorList(s.id).gather(i,a,r)]}case"TensorListStack":{const s=T("tensorListId",n,e,t),i=T("elementShape",n,e,t),r=T("elementDType",n,e,t),a=T("numElements",n,e,t);return[t.getTensorList(s.id).stack(i,r,a)]}case"TensorListFromTensor":{const s=T("tensor",n,e,t),i=T("elementShape",n,e,t),r=T("elementDType",n,e,t),a=Lme(s,i,r);return t.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const s=T("tensorListId",n,e,t),i=t.getTensorList(s.id),r=T("dtype",n,e,t),a=T("elementShape",n,e,t);return[i.concat(r,a)]}case"TensorListPushBack":{const s=T("tensorListId",n,e,t),i=T("tensor",n,e,t),r=t.getTensorList(s.id);return r.pushBack(i),[r.idTensor]}case"TensorListPopBack":{const s=T("tensorListId",n,e,t),i=T("elementShape",n,e,t),r=T("elementDType",n,e,t);return[t.getTensorList(s.id).popBack(i,r)]}case"TensorListSplit":{const s=T("tensor",n,e,t),i=T("elementShape",n,e,t),r=T("lengths",n,e,t),a=Fme(s,r,i);return t.addTensorList(a),[a.idTensor]}case"TensorListLength":{const s=T("tensorListId",n,e,t),i=t.getTensorList(s.id);return[Ke(i.size(),"int32")]}case"TensorListResize":{const s=T("tensorListId",n,e,t),i=T("size",n,e,t),r=t.getTensorList(s.id).resize(i);return t.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jM(n,e,t){const[s,i]=T("fusedOps",n,e,t),r=s==="biasadd",a=!r,o=i==="prelu",l=s==="fusedbatchnorm",c=T("numArgs",n,e,t);if(r){if(o&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&r&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=T("strides",n,e,t),h=Df(n,e,t),d=T("dataFormat",n,e,t).toUpperCase(),p=T("dilations",n,e,t);let[f,y]=T("args",n,e,t);a&&(y=f,f=void 0);const m=T("leakyreluAlpha",n,e,t);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:y,activationFunc:i,leakyreluAlpha:m}}const Gme=(n,e,t,s=es)=>{switch(n.op){case"Conv1D":{const i=T("stride",n,e,t),r=T("pad",n,e,t),a=T("dataFormat",n,e,t).toUpperCase(),o=T("dilation",n,e,t);return[s.conv1d(T("x",n,e,t),T("filter",n,e,t),i,r,a,o)]}case"Conv2D":{const i=T("strides",n,e,t),r=Df(n,e,t),a=T("dataFormat",n,e,t).toUpperCase(),o=T("dilations",n,e,t);return[s.conv2d(T("x",n,e,t),T("filter",n,e,t),[i[1],i[2]],r,a,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=jM(n,e,t);return[s.fused.conv2d({x:T("x",n,e,t),filter:T("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:r,dataFormat:a,dilations:o,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:h}=jM(n,e,t);return[s.fused.depthwiseConv2d({x:T("x",n,e,t),filter:T("filter",n,e,t),strides:[i[1],i[2]],pad:r,dataFormat:a,dilations:[o[1],o[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=T("outputShape",n,e,t),r=T("strides",n,e,t),a=Df(n,e,t);return[s.conv2dTranspose(T("x",n,e,t),T("filter",n,e,t),i,[r[1],r[2]],a)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=T("strides",n,e,t),r=Df(n,e,t),a=T("dilations",n,e,t),o=T("dataFormat",n,e,t).toUpperCase();return[s.depthwiseConv2d(T("input",n,e,t),T("filter",n,e,t),[i[1],i[2]],r,o,[a[1],a[2]])]}case"Conv3D":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("dataFormat",n,e,t).toUpperCase(),o=T("dilations",n,e,t);return[s.conv3d(T("x",n,e,t),T("filter",n,e,t),[i[1],i[2],i[3]],r,a,[o[1],o[2],o[3]])]}case"AvgPool":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("kernelSize",n,e,t);return[s.avgPool(T("x",n,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPool":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("kernelSize",n,e,t);return[s.maxPool(T("x",n,e,t),[a[1],a[2]],[i[1],i[2]],r)]}case"MaxPoolWithArgmax":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("kernelSize",n,e,t),o=T("includeBatchInIndex",n,e,t),{result:l,indexes:c}=s.maxPoolWithArgmax(T("x",n,e,t),[a[1],a[2]],[i[1],i[2]],r,o);return[l,c]}case"AvgPool3D":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("kernelSize",n,e,t);return[s.avgPool3d(T("x",n,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"MaxPool3D":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("kernelSize",n,e,t);return[s.maxPool3d(T("x",n,e,t),[a[1],a[2],a[3]],[i[1],i[2],i[3]],r)]}case"Dilation2D":{const i=T("strides",n,e,t),r=T("pad",n,e,t),a=T("dilations",n,e,t),o=i[1],l=i[2],c=a[1],u=a[2];return[s.dilation2d(T("x",n,e,t),T("filter",n,e,t),[o,l],r,[c,u],"NHWC")]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zme=(n,e,t,s=es)=>{switch(n.op){case"Fill":{const i=T("shape",n,e,t),r=T("dtype",n,e,t),a=T("value",n,e,t);return[s.fill(i,a,r)]}case"LinSpace":{const i=T("start",n,e,t),r=T("stop",n,e,t),a=T("num",n,e,t);return[s.linspace(i,r,a)]}case"Multinomial":{const i=T("logits",n,e,t),r=T("numSamples",n,e,t),a=T("seed",n,e,t);return[s.multinomial(i,r,a)]}case"OneHot":{const i=T("indices",n,e,t),r=T("depth",n,e,t),a=T("onValue",n,e,t),o=T("offValue",n,e,t),l=T("dtype",n,e,t);return[s.oneHot(i,r,a,o,l)]}case"Ones":return[s.ones(T("shape",n,e,t),T("dtype",n,e,t))];case"OnesLike":return[s.onesLike(T("x",n,e,t))];case"RandomStandardNormal":return[s.randomStandardNormal(T("shape",n,e,t),T("dtype",n,e,t),T("seed",n,e,t))];case"RandomUniform":return[s.randomUniform(T("shape",n,e,t),T("minval",n,e,t),T("maxval",n,e,t),T("dtype",n,e,t))];case"Range":{const i=T("start",n,e,t),r=T("stop",n,e,t),a=T("step",n,e,t);return[s.range(i,r,a,T("dtype",n,e,t))]}case"TruncatedNormal":{const i=T("shape",n,e,t),r=T("mean",n,e,t),a=T("stdDev",n,e,t),o=T("seed",n,e,t);return[s.truncatedNormal(i,r,a,T("dtype",n,e,t),o)]}case"Zeros":return[s.zeros(T("shape",n,e,t),T("dtype",n,e,t))];case"ZerosLike":return[s.zerosLike(T("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M0(n,e,t){const s=T("boxes",n,e,t),i=T("scores",n,e,t),r=T("maxOutputSize",n,e,t),a=T("iouThreshold",n,e,t),o=T("scoreThreshold",n,e,t),l=T("softNmsSigma",n,e,t);return{boxes:s,scores:i,maxOutputSize:r,iouThreshold:a,scoreThreshold:o,softNmsSigma:l}}const Vme=async(n,e,t,s,i=es)=>{switch(n.op){case"NonMaxSuppressionV5":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=M0(n,e,t),h=await i.image.nonMaxSuppressionWithScoreAsync(r,a,o,l,c,u);return[h.selectedIndices,h.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=M0(n,e,t),u=T("padToMaxOutputSize",n,e,t),h=await i.image.nonMaxSuppressionPaddedAsync(r,a,o,l,c,u);return[h.selectedIndices,h.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:r,scores:a,maxOutputSize:o,iouThreshold:l,scoreThreshold:c}=M0(n,e,t);return[await i.image.nonMaxSuppressionAsync(r,a,o,l,c)]}case"Where":{const r=i.cast(T("condition",n,e,t),"bool"),a=[await i.whereAsync(r)];return r.dispose(),a}case"ListDiff":return i.setdiff1dAsync(T("x",n,e,t),T("y",n,e,t));default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Wme=(n,e,t,s=es)=>{switch(n.op){case"LowerBound":{const i=T("sortedSequence",n,e,t),r=T("values",n,e,t);return[s.lowerBound(i,r)]}case"TopKV2":{const i=T("x",n,e,t),r=T("k",n,e,t),a=T("sorted",n,e,t),o=s.topk(i,r,a);return[o.values,o.indices]}case"UpperBound":{const i=T("sortedSequence",n,e,t),r=T("values",n,e,t);return[s.upperBound(i,r)]}case"Unique":{const i=T("x",n,e,t),r=s.unique(i);return[r.values,r.indices]}case"UniqueV2":{const i=T("x",n,e,t),r=T("axis",n,e,t),a=s.unique(i,r);return[a.values,a.indices]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ume=(n,e,t,s=es)=>{switch(n.op){case"Const":return e[n.name];case"PlaceholderWithDefault":const i=T("default",n,e,t);return[ds(n.name,e,t)||i];case"Placeholder":return[ds(n.name,e,t)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=T("x",n,e,t);return[Rr(u)]}case"IdentityN":return T("x",n,e,t).map(u=>Rr(u));case"Snapshot":const r=T("x",n,e,t);return[Rr(r)];case"Shape":return[s.tensor1d(T("x",n,e,t).shape,"int32")];case"ShapeN":return T("x",n,e,t).map(u=>s.tensor1d(u.shape));case"Size":return[s.scalar(T("x",n,e,t).size,"int32")];case"Rank":return[s.scalar(T("x",n,e,t).rank,"int32")];case"NoOp":return[s.scalar(1)];case"Print":const a=T("x",n,e,t),o=T("data",n,e,t),l=T("message",n,e,t),c=T("summarize",n,e,t);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<o.length;u++)console.log(Array.prototype.slice.call(o[u].dataSync()).slice(0,c));return[a];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bme{constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=Ke(0),this.tensorMap=new Map,hn(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return Ke(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),j(()=>{const i=ai(t),r=s.length,a=i.length;E(r===a,()=>`The number of elements doesn't match, keys has ${r} elements, the values has ${a} elements.`);for(let o=0;o<r;o++){const l=s[o],c=i[o];hn(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,t){this.checkKeyAndValueTensor(e,t);const s=await e.data();return j(()=>{const i=[];for(let r=0;r<s.length;r++){const a=s[r],o=this.findWithDefault(a,t);i.push(o)}return ps(i)})}findWithDefault(e,t){return this.tensorMap.get(e)??t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(t.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${t.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $me=async(n,e,t,s)=>{switch(n.op){case"HashTable":case"HashTableV2":{const i=s.getHashTableHandleByName(n.name);if(i!=null)return[i];{const r=T("keyDType",n,e,t),a=T("valueDType",n,e,t),o=new Bme(r,a);return s.addHashTable(n.name,o),[o.handle]}}case"InitializeTable":case"InitializeTableV2":case"LookupTableImport":case"LookupTableImportV2":{const i=T("tableHandle",n,e,t,s),r=T("keys",n,e,t),a=T("values",n,e,t);return[await s.getHashTableById(i.id).import(r,a)]}case"LookupTableFind":case"LookupTableFindV2":{const i=T("tableHandle",n,e,t,s),r=T("keys",n,e,t),a=T("defaultValue",n,e,t);return[await s.getHashTableById(i.id).find(r,a)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=T("tableHandle",n,e,t,s);return[s.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xme=(n,e,t,s=es)=>{switch(n.op){case"ResizeBilinear":{const i=T("images",n,e,t),r=T("size",n,e,t),a=T("alignCorners",n,e,t),o=T("halfPixelCenters",n,e,t);return[s.image.resizeBilinear(i,[r[0],r[1]],a,o)]}case"ResizeNearestNeighbor":{const i=T("images",n,e,t),r=T("size",n,e,t),a=T("alignCorners",n,e,t),o=T("halfPixelCenters",n,e,t);return[s.image.resizeNearestNeighbor(i,[r[0],r[1]],a,o)]}case"CropAndResize":{const i=T("image",n,e,t),r=T("boxes",n,e,t),a=T("boxInd",n,e,t),o=T("cropSize",n,e,t),l=T("method",n,e,t),c=T("extrapolationValue",n,e,t);return[s.image.cropAndResize(i,r,a,o,l,c)]}case"ImageProjectiveTransformV3":{const i=T("images",n,e,t),r=T("transforms",n,e,t),a=T("outputShape",n,e,t),o=T("fillValue",n,e,t),l=T("interpolation",n,e,t),c=T("fillMode",n,e,t);return[s.image.transform(i,r,l.toLowerCase(),c.toLowerCase(),o,a)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hme=(n,e,t,s=es)=>{switch(n.op){case"Equal":return[s.equal(T("a",n,e,t),T("b",n,e,t))];case"NotEqual":return[s.notEqual(T("a",n,e,t),T("b",n,e,t))];case"Greater":return[s.greater(T("a",n,e,t),T("b",n,e,t))];case"GreaterEqual":return[s.greaterEqual(T("a",n,e,t),T("b",n,e,t))];case"Less":return[s.less(T("a",n,e,t),T("b",n,e,t))];case"LessEqual":return[s.lessEqual(T("a",n,e,t),T("b",n,e,t))];case"LogicalAnd":return[s.logicalAnd(T("a",n,e,t),T("b",n,e,t))];case"LogicalNot":return[s.logicalNot(T("a",n,e,t))];case"LogicalOr":return[s.logicalOr(T("a",n,e,t),T("b",n,e,t))];case"Select":case"SelectV2":return[s.where(T("condition",n,e,t),T("a",n,e,t),T("b",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kme=(n,e,t,s=es)=>{switch(n.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[s.matMul(T("a",n,e,t),T("b",n,e,t),T("transposeA",n,e,t),T("transposeB",n,e,t))];case"Einsum":return[s.einsum(T("equation",n,e,t),...T("tensors",n,e,t))];case"Transpose":return[s.transpose(T("x",n,e,t),T("perm",n,e,t))];case"_FusedMatMul":const[i,r]=T("fusedOps",n,e,t),a=i==="biasadd",o=r==="prelu",l=T("numArgs",n,e,t),c=T("leakyreluAlpha",n,e,t);if(a){if(o&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=T("args",n,e,t);return[s.fused.matMul({a:T("a",n,e,t),b:T("b",n,e,t),transposeA:T("transposeA",n,e,t),transposeB:T("transposeB",n,e,t),bias:u,activation:r,preluActivationWeights:h,leakyreluAlpha:c})];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Zme=(n,e,t,s=es)=>{switch(n.op){case"EuclideanNorm":return[s.euclideanNorm(T("x",n,e,t),T("axis",n,e,t),T("keepDims",n,e,t))];case"FusedBatchNorm":case"FusedBatchNormV2":return[s.batchNorm(T("x",n,e,t),T("mean",n,e,t),T("variance",n,e,t),T("offset",n,e,t),T("scale",n,e,t),T("epsilon",n,e,t))];case"FusedBatchNormV3":return[s.batchNorm(T("x",n,e,t),T("mean",n,e,t),T("variance",n,e,t),T("offset",n,e,t),T("scale",n,e,t),T("epsilon",n,e,t))];case"LRN":return[s.localResponseNormalization(T("x",n,e,t),T("radius",n,e,t),T("bias",n,e,t),T("alpha",n,e,t),T("beta",n,e,t))];case"Softmax":return[s.softmax(T("x",n,e,t))];case"LogSoftmax":return[s.logSoftmax(T("x",n,e,t))];case"SparseToDense":return[s.sparseToDense(T("sparseIndices",n,e,t),T("outputShape",n,e,t),T("sparseValues",n,e,t),T("defaultValue",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yme=(n,e,t,s=es)=>{switch(n.op){case"RaggedGather":{const{outputNestedSplits:i,outputDenseValues:r}=s.raggedGather(T("paramsNestedSplits",n,e,t),T("paramsDenseValues",n,e,t),T("indices",n,e,t),T("outputRaggedRank",n,e,t));return i.concat(r)}case"RaggedRange":{const{rtNestedSplits:i,rtDenseValues:r}=s.raggedRange(T("starts",n,e,t),T("limits",n,e,t),T("splits",n,e,t));return[i,r]}case"RaggedTensorToTensor":return[s.raggedTensorToTensor(T("shape",n,e,t),T("values",n,e,t),T("defaultValue",n,e,t),T("rowPartitionTensors",n,e,t),T("rowPartitionTypes",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jme=(n,e,t,s=es)=>{switch(n.op){case"Max":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.max(T("x",n,e,t),o,l)]}case"Mean":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.mean(T("x",n,e,t),o,l)]}case"Min":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.min(T("x",n,e,t),o,l)]}case"Sum":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.sum(T("x",n,e,t),o,l)]}case"All":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.all(T("x",n,e,t),o,l)]}case"Any":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.any(T("x",n,e,t),o,l)]}case"ArgMax":{const o=T("axis",n,e,t);return[s.argMax(T("x",n,e,t),o)]}case"ArgMin":{const o=T("axis",n,e,t);return[s.argMin(T("x",n,e,t),o)]}case"Prod":{const o=T("axis",n,e,t),l=T("keepDims",n,e,t);return[s.prod(T("x",n,e,t),o,l)]}case"Cumprod":{const o=T("axis",n,e,t),l=T("exclusive",n,e,t),c=T("reverse",n,e,t);return[s.cumprod(T("x",n,e,t),o,l,c)]}case"Cumsum":{const o=T("axis",n,e,t),l=T("exclusive",n,e,t),c=T("reverse",n,e,t);return[s.cumsum(T("x",n,e,t),o,l,c)]}case"Bincount":const i=T("x",n,e,t),r=T("weights",n,e,t),a=T("size",n,e,t);return[s.bincount(i,r,a)];case"DenseBincount":{const o=T("x",n,e,t),l=T("weights",n,e,t),c=T("size",n,e,t),u=T("binaryOutput",n,e,t);return[s.denseBincount(o,l,c,u)]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qme=(n,e,t,s=es)=>{switch(n.op){case"ConcatV2":case"Concat":{const i=T("n",n,e,t),r=T("axis",n,e,t);let a=T("tensors",n,e,t);return a=a.slice(0,i),[s.concat(a,r)]}case"Gather":{const i=T("x",n,e,t),r=T("indices",n,e,t);return[s.gather(i,s.cast(r,"int32"),0)]}case"GatherV2":{const i=T("axis",n,e,t),r=T("batchDims",n,e,t),a=T("x",n,e,t),o=T("indices",n,e,t);return[s.gather(a,s.cast(o,"int32"),i,r)]}case"Reverse":{const i=T("dims",n,e,t),r=[];for(let o=0;o<i.length;o++)i[o]&&r.push(o);const a=T("x",n,e,t);return[s.reverse(a,r)]}case"ReverseV2":{const i=T("axis",n,e,t),r=T("x",n,e,t);return[s.reverse(r,i)]}case"Slice":{const i=T("begin",n,e,t),r=T("size",n,e,t);return[s.slice(T("x",n,e,t),i,r)]}case"StridedSlice":{const i=T("begin",n,e,t),r=T("end",n,e,t),a=T("strides",n,e,t),o=T("beginMask",n,e,t),l=T("endMask",n,e,t),c=T("ellipsisMask",n,e,t),u=T("newAxisMask",n,e,t),h=T("shrinkAxisMask",n,e,t),d=T("x",n,e,t);return[s.stridedSlice(d,i,r,a,o,l,c,u,h)]}case"Pack":return j(()=>{const i=T("axis",n,e,t),r=T("tensors",n,e,t),a=r[0].shape,o=s.squeeze(r[0]).shape,l=r.map(c=>{const u=St(c.shape,a);if(!u&&!St(s.squeeze(c).shape,o))throw new Error("the input tensors shape does not match");return u?c:s.reshape(c,a)});return[s.stack(l,i)]});case"Unpack":{const i=T("axis",n,e,t),r=T("tensor",n,e,t);return s.unstack(r,i)}case"Tile":{const i=T("reps",n,e,t);return[s.tile(T("x",n,e,t),i)]}case"Split":case"SplitV":{const i=T("axis",n,e,t),r=T("numOrSizeSplits",n,e,t),a=T("x",n,e,t);return s.split(a,r,i)}case"ScatterNd":{const i=T("indices",n,e,t),r=T("values",n,e,t),a=T("shape",n,e,t);return[s.scatterND(i,r,a)]}case"GatherNd":{const i=T("x",n,e,t),r=T("indices",n,e,t);return[s.gatherND(i,r)]}case"SparseToDense":{const i=T("sparseIndices",n,e,t),r=T("outputShape",n,e,t),a=T("sparseValues",n,e,t),o=T("defaultValue",n,e,t);return[s.sparseToDense(i,a,r,a.dtype===o.dtype?o:s.cast(o,a.dtype))]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jme=(n,e,t,s=es)=>{switch(n.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:r,emptyRowIndicator:a,reverseIndexMap:o}=s.sparse.sparseFillEmptyRows(T("indices",n,e,t),T("values",n,e,t),T("denseShape",n,e,t),T("defaultValue",n,e,t));return[i,r,a,o]}case"SparseReshape":{const{outputIndices:i,outputShape:r}=s.sparse.sparseReshape(T("inputIndices",n,e,t),T("inputShape",n,e,t),T("newShape",n,e,t));return[i,r]}case"SparseSegmentMean":return[s.sparse.sparseSegmentMean(T("data",n,e,t),T("indices",n,e,t),T("segmentIds",n,e,t))];case"SparseSegmentSum":return[s.sparse.sparseSegmentSum(T("data",n,e,t),T("indices",n,e,t),T("segmentIds",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qme=(n,e,t,s=es)=>{switch(n.op){case"FFT":return[s.fft(T("x",n,e,t))];case"IFFT":return[s.ifft(T("x",n,e,t))];case"RFFT":return[s.rfft(T("x",n,e,t))];case"IRFFT":return[s.irfft(T("x",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ege=(n,e,t,s=es)=>{switch(n.op){case"StringNGrams":{const{nGrams:i,nGramsSplits:r}=s.string.stringNGrams(T("data",n,e,t),T("dataSplits",n,e,t),T("separator",n,e,t),T("nGramWidths",n,e,t),T("leftPad",n,e,t),T("rightPad",n,e,t),T("padWidth",n,e,t),T("preserveShortSequences",n,e,t));return[i,r]}case"StringSplit":{const{indices:i,values:r,shape:a}=s.string.stringSplit(T("input",n,e,t),T("delimiter",n,e,t),T("skipEmpty",n,e,t));return[i,r,a]}case"StringToHashBucketFast":return[s.string.stringToHashBucketFast(T("input",n,e,t),T("numBuckets",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tge=(n,e,t,s=es)=>{switch(n.op){case"Cast":return[s.cast(T("x",n,e,t),T("dtype",n,e,t))];case"ExpandDims":{const i=T("axis",n,e,t);return[s.expandDims(T("x",n,e,t),i)]}case"Squeeze":{const i=T("axis",n,e,t);return[s.squeeze(T("x",n,e,t),i)]}case"Reshape":return[s.reshape(T("x",n,e,t),T("shape",n,e,t))];case"MirrorPad":return[s.mirrorPad(T("x",n,e,t),T("padding",n,e,t),T("mode",n,e,t))];case"PadV2":case"Pad":return[s.pad(T("x",n,e,t),T("padding",n,e,t),T("constantValue",n,e,t))];case"SpaceToBatchND":{const i=T("blockShape",n,e,t),r=T("paddings",n,e,t);return[s.spaceToBatchND(T("x",n,e,t),i,r)]}case"BatchToSpaceND":{const i=T("blockShape",n,e,t),r=T("crops",n,e,t);return[s.batchToSpaceND(T("x",n,e,t),i,r)]}case"DepthToSpace":{const i=T("blockSize",n,e,t),r=T("dataFormat",n,e,t).toUpperCase();return[s.depthToSpace(T("x",n,e,t),i,r)]}case"BroadcastTo":return[s.broadcastTo(T("x",n,e,t),T("shape",n,e,t))];case"BroadcastArgs":return[s.broadcastArgs(T("s0",n,e,t),T("s1",n,e,t))];default:throw TypeError(`Node type ${n.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QM(n,e,t,s,i=j){const r=((a,o,l)=>{switch(a.category){case"arithmetic":return i(()=>Nme(a,o,l));case"basic_math":return i(()=>Rme(a,o,l));case"control":return Ome(a,o,l);case"convolution":return i(()=>Gme(a,o,l));case"creation":return i(()=>zme(a,o,l));case"dynamic":return Vme(a,o,l);case"evaluation":return i(()=>Wme(a,o,l));case"image":return i(()=>Xme(a,o,l));case"graph":return i(()=>Ume(a,o,l));case"logical":return i(()=>Hme(a,o,l));case"matrices":return i(()=>Kme(a,o,l));case"normalization":return i(()=>Zme(a,o,l));case"ragged":return i(()=>Yme(a,o,l));case"reduction":return i(()=>jme(a,o,l));case"slice_join":return i(()=>Qme(a,o,l));case"sparse":return i(()=>Jme(a,o,l));case"spectral":return i(()=>qme(a,o,l));case"string":return i(()=>ege(a,o,l));case"transformation":return i(()=>tge(a,o,l));case"hash_table":return $me(a,o,l,s);case"custom":const c=cL(a.op);if(c&&c.customExecutor)return c.customExecutor(new kme(a,o,l));throw TypeError(`Custom op ${a.op} is not registered.`);default:throw TypeError(`Unknown op '${a.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(n,e,t);return Ur(r)?r.then(a=>[].concat(a)):[].concat(r)}class JM{constructor(e={},t={},s={},i={}){this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=s,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const s=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(s))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(t=>t.id===0&&t.iterationId===0?"":`${t.frameName}-${t.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qM(n,e,t,s){const i=new Set,r=[];let a=null,o=null;const l=new Set,c=Object.keys(n).map(d=>Fs(d)[0]);let u=[];s!=null&&(u=s.map(d=>Fs(d.name)[0]));const h=[...e];for(;h.length>0;){const d=h.pop();if((dL(d)||age(d)||oge(d))&&a==null&&(a=d,o=a.children.map(p=>p.name).filter(p=>i.has(p))),i.add(d.name),t[d.name]==null&&c.indexOf(d.name)===-1&&u.indexOf(d.name)===-1){if(d.inputs.length===0){r.push(d.name);continue}d.inputs.forEach(p=>{l.has(p.name)||(l.add(p.name),h.push(p))})}}return{inputs:n,outputs:e,usedNodes:i,missingInputs:r,dynamicNode:a,syncInputs:o}}function nge(n,e,t){const{usedNodes:s,inputs:i}=t,r=[],a=Object.keys(i).map(u=>Fs(u)[0]).map(u=>n.nodes[u]),o=n.initNodes;a.forEach(u=>{s.has(u.name)&&r.push(u)}),n.weights.forEach(u=>{s.has(u.name)&&r.push(u)}),o!=null&&o.forEach(u=>{s.has(u.name)&&r.push(u)});const l=new Set,c=[];for(;r.length>0;){const u=r.pop();l.add(u.name),e[u.name]||c.push(u),u.children.forEach(h=>{!l.has(h.name)&&s.has(h.name)&&h.inputs.every(d=>l.has(d.name))&&r.push(h)})}return c}const sge=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],ige=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],rge=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function dL(n){return sge.indexOf(n.op)>=0}function age(n){return ige.indexOf(n.op)>=0}function oge(n){return rge.indexOf(n.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Im{constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.keepIntermediateTensors=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(s=>{this._functionExecutorMap[s]=new Im(e.functions[s],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map(s=>e[s].map(i=>i.id));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const t=e.signatureKey||e.name;return e.defaultOutput?`${t}:${e.defaultOutput}`:t})}get functions(){return Object.keys(this._functions).reduce((e,t)=>(e[t]=this._functions[t].signature,e),{})}getCompilationKey(e,t){const s=e.map(r=>r.name).sort(),i=t.map(r=>r.name).sort();return s.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,t){const s=qM(e,t,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:r,syncInputs:a}=s;if(r!=null)throw new Error(`This execution contains the node '${r.name}', which has the dynamic op '${r.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${a}]`);if(i.length>0){const o=t.map(c=>c.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${o}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return nge(this.graph,this.weightMap,s)}cloneAndKeepTensor(e){if(e==null)return null;const t=e.clone();return hn(t),t}cloneTensorList(e){return e?e.map(t=>this.cloneAndKeepTensor(t)):null}cloneTensorMap(e){return Object.fromEntries(Object.entries(e).map(([t,s])=>[t,this.cloneTensorList(s)]))}execute(e,t){this.disposeIntermediateTensors(),e=this.mapInputs(e);const s=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const i=s.map(h=>this.graph.nodes[Fs(h)[0]]),r=t.map(h=>Fs(h)[0]);let a=r.map(h=>this.graph.nodes[h]);a.length===0&&(a=this._outputs);const o=this.getCompilationKey(i,a);let l=this.compiledMap.get(o);l==null&&(l=this.compile(e,a),this.compiledMap.set(o,l));try{this.keepIntermediateTensors=ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(h){this.keepIntermediateTensors=!1,console.warn(h.message)}const c={},u={};return j(()=>{const h=new JM(this.weightMap,c,u,this.functionExecutorMap),d=Object.assign({},this.weightMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap)),Object.keys(e).forEach(y=>{const[m,g]=Fs(y),b=[];b[g]=e[y],d[m]=b,this.keepIntermediateTensors&&(this.clonedTensorsMap[m]=this.cloneTensorList(b))});const p=this.getFrozenTensorIds(d),f={};for(let y=0;y<l.length;y++){const m=l[y];if(!d[m.name]){const g=QM(m,d,h,this._resourceManager);if(Ur(g))throw new Error(`The execution of the op '${m.op}' returned a promise. Please use model.executeAsync() instead.`);d[m.name]=g,this.keepIntermediateTensors&&(this.clonedTensorsMap[m.name]=this.cloneTensorList(g)),this.checkTensorForDisposal(m.name,m,d,h,p,r,f)}}return this.parent==null&&h.dispose(p),t.map(y=>ds(y,d,h))})}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map(s=>e[s]).map(s=>s.map(i=>i.id)));return new Set(t)}checkTensorForDisposal(e,t,s,i,r,a,o){t.category==="control"||a.indexOf(e)!==-1||(s[e].forEach(l=>{l!=null&&(o[l.id]=(o[l.id]||0)+t.children.length)}),t.inputs.forEach(l=>{if(l.category!=="control"){const c=Bfe(l.name,s,i);c!=null&&c.forEach(u=>{if(u&&!u.kept&&!r.has(u.id)){const h=o[u.id];h===1?(u.dispose(),delete o[u.id]):h!=null&&o[u.id]--}})}}))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.clonedTensorsMap&&(Object.values(this.clonedTensorsMap).forEach(e=>{for(const t of e)t&&!t.isDisposed&&t.dispose()}),this.clonedTensorsMap=null)}getIntermediateTensors(){return this.clonedTensorsMap}async _executeAsync(e,t,s=!1,i={},r={}){this.disposeIntermediateTensors(),s||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepIntermediateTensors=ee().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(d){this.keepIntermediateTensors=!1,console.warn(d.message)}const a=new JM(this.weightMap,i,r,this.functionExecutorMap);this.keepIntermediateTensors&&(this.clonedTensorsMap=this.cloneTensorMap(this.weightMap));const o=await this.executeWithControlFlow(e,a,t,s),l=t.map(d=>ds(d,o,a)),c=l.map(d=>d.id),u=Object.keys(e).map(d=>e[d].id),h=new Set([...c,...u,...this.weightIds]);return Object.values(o).forEach(d=>{d.forEach(p=>{p&&!p.isDisposed&&!h.has(p.id)&&p.dispose()})}),this.parent==null&&a.dispose(h),l}async executeFunctionAsync(e,t,s){const i=e.reduce((r,a,o)=>(r[this.inputs[o].name]=a,r),{});return this._executeAsync(i,this.outputNodes,!0,t,s)}async executeWithControlFlow(e,t,s,i){const r=Object.keys(e),a=r.map(x=>this.graph.nodes[Fs(x)[0]]),o=s.map(x=>Fs(x)[0]);let l=o.map(x=>this.graph.nodes[x]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:h,syncInputs:d}=qM(e,l,this.weightMap,this._initNodes),p=[...a,...this.graph.weights,...this._initNodes||[]].map(x=>({node:x,contexts:t.currentContext})),f=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[v,w]=Fs(x),_=[];_[w]=e[x],f[v]=_});const y={},m=this.getFrozenTensorIds(f),g={};for(;p.length>0;){const x=this.processStack(a,p,t,f,g,m,o,y,c);await Promise.all(x)}h==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter(x=>!dL(x)&&!ds(x.name,f,t)).map(x=>x.name);if(b.length>0){let x="";throw h!=null&&(x=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${d}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${r}]. Consider providing the following inputs: [${u}]. ${x}`)}return f}processStack(e,t,s,i,r,a,o,l,c){const u=[];for(;t.length>0;){const h=t.pop();s.currentContext=h.contexts;let d="";if(h.node.op==="Enter"&&T("isConstant",h.node,i,s)&&([d]=Nr(h.node.name,s)),i[h.node.name]==null){const p=QM(h.node,i,s,this._resourceManager);d||([d]=Nr(h.node.name,s));const f=s.currentContext;Ur(p)?u.push(p.then(y=>(i[d]=y,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(y)),s.currentContext=f,this.checkTensorForDisposal(d,h.node,i,s,a,o,l),this.processChildNodes(h.node,t,s,i,r,c),y))):(i[d]=p,this.keepIntermediateTensors&&(this.clonedTensorsMap[d]=this.cloneTensorList(p)),this.checkTensorForDisposal(d,h.node,i,s,a,o,l),this.processChildNodes(h.node,t,s,i,r,c))}else this.processChildNodes(h.node,t,s,i,r,c)}return u}processChildNodes(e,t,s,i,r,a){e.children.forEach(o=>{const[l]=Nr(o.name,s);r[l]||!a.has(o.name)||(o.op==="Merge"?o.inputNames.some(c=>!!ds(c,i,s))&&(r[l]=!0,t.push({contexts:s.currentContext,node:o})):o.inputNames.every(c=>!!ds(c,i,s))&&(r[l]=!0,t.push({contexts:s.currentContext,node:o})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(t=>t.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(t=>{const s=e[t],[i]=Fs(t),r=this.graph.nodes[i];if(r.attrParams.shape&&r.attrParams.shape.value){const a=r.attrParams.shape.value,o=a.length===s.shape.length&&s.shape.every((l,c)=>a[c]===-1||a[c]===l);E(o,()=>`The shape of dict['${r.name}'] provided in model.execute(dict) must be [${a}], but was [${s.shape}]`)}r.attrParams.dtype&&r.attrParams.dtype.value&&E(s.dtype===r.attrParams.dtype.value,()=>`The dtype of dict['${r.name}'] provided in model.execute(dict) must be ${r.attrParams.dtype.value}, but was ${s.dtype}`)})}mapInputs(e){var t,s;const i={};for(const r in e){const a=(s=(t=this._signature)===null||t===void 0?void 0:t.inputs)===null||s===void 0?void 0:s[r];a!=null?i[a.name]=e[r]:i[r]=e[r]}return i}checkInputs(e){const t=Object.keys(e).filter(s=>{const[i]=Fs(s);return this.graph.nodes[i]==null});if(t.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${t}] that are not part of graph`)}mapOutputs(e){return e.map(t=>{var s,i;const r=(i=(s=this._signature)===null||s===void 0?void 0:s.outputs)===null||i===void 0?void 0:i[t];return r!=null?r.name:t},{})}checkOutputs(e){e.forEach(t=>{const[s]=Fs(t);if(!this.graph.nodes[s])throw new Error(`The output '${t}' is not found in the graph`)})}}class lge{constructor(e={},t={}){this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cge="?tfjs-format=file",uge="model.json";class aT{constructor(e,t={},s=eT){this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=s,t==null&&(this.loadOptions={}),this.resourceManager=new lge}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(t.length===0)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error(`Found more than one (${t.length}) load handlers for URL '${[e]}'`);this.handler=t[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Ur(e)?e.then(t=>this.loadSync(t)):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let s=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const r=this.artifacts.userDefinedMetadata;r.signature!=null&&(s=r.signature),r.structuredOutputKeys!=null&&(this.structuredOutputKeys=r.structuredOutputKeys)}this.signature=s,this.version=`${t.versions.producer}.${t.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Im(KM.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const r=KM.Instance.transformGraph(e.modelInitializer);this.initializer=new Im(r),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializerSignature=e.initializerSignature}return!0}async save(e,t){if(typeof e=="string"){const s=this.io.getSaveHandlers(e);if(s.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(s.length>1)throw new Error(`Found more than one (${s.length}) save handlers for URL '${e}'`);e=s[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}addStructuredOutputNames(e){if(this.structuredOutputKeys){const t=e instanceof Et?[e]:e,s={};return t.forEach((i,r)=>s[this.structuredOutputKeys[r]]=i),s}return e}predict(e,t){const s=this.execute(e,this.outputNodes);return this.addStructuredOutputNames(s)}async predictAsync(e,t){const s=await this.executeAsync(e,this.outputNodes);return this.addStructuredOutputNames(s)}normalizeInputs(e){var t;if(!(e instanceof Et)&&!Array.isArray(e)){const r=(t=this.signature)===null||t===void 0?void 0:t.inputs;if(r!=null)for(const a in r){const o=r[a];o.resourceId!=null&&(e[a]=this.resourceIdToCapturedInput[o.resourceId])}return e}e=Array.isArray(e)?e:[e];const s=Object.keys(this.resourceIdToCapturedInput).length;if(e.length+s!==this.inputNodes.length)throw new Error(`Input tensor count mismatch, the graph model has ${this.inputNodes.length-s} non-resource placeholders, while there are ${e.length} input tensors provided.`);let i=0;return this.inputNodes.reduce((r,a)=>{var o,l,c;const u=(c=(l=(o=this.signature)===null||o===void 0?void 0:o.inputs)===null||l===void 0?void 0:l[a])===null||c===void 0?void 0:c.resourceId;return u!=null?r[a]=this.resourceIdToCapturedInput[u]:r[a]=e[i++],r},{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}executeInitializerGraph(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.execute({},[]):this.initializer.execute({},Object.keys(this.initializerSignature.outputs))}async executeInitializerGraphAsync(){return this.initializer==null?[]:this.initializerSignature==null?this.initializer.executeAsync({},[]):this.initializer.executeAsync({},Object.keys(this.initializerSignature.outputs))}setResourceIdToCapturedInput(e){if(this.resourceIdToCapturedInput={},this.initializerSignature){const t=this.initializerSignature.outputs,s=Object.keys(t);for(let i=0;i<s.length;i++){const r=s[i],a=t[r];this.resourceIdToCapturedInput[a.resourceId]=e[i]}}}execute(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(this.executeInitializerGraph()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=this.executor.execute(e,t);return s.length>1?s:s[0]}async executeAsync(e,t){this.resourceIdToCapturedInput==null&&this.setResourceIdToCapturedInput(await this.executeInitializerGraphAsync()),e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const s=await this.executor.executeAsync(e,t);return s.length>1?s:s[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((t,s)=>(t[s]=[e[s]],t),{})}dispose(){this.executor.dispose(),this.initializer&&(this.initializer.dispose(),this.resourceIdToCapturedInput&&nt(this.resourceIdToCapturedInput)),this.resourceManager.dispose()}}async function hge(n,e={},t=eT){if(n==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof n=="string"&&(n=pge(n));const s=new aT(n,e,t);return await s.load(),s}function dge(n){if(n==null)throw new Error("modelUrl in loadGraphModelSync() cannot be null. Please provide model artifacts or an IOHandler that loads the model");let e;if(n instanceof Array){const[s,i]=n;if(!s)throw new Error("modelJSON must be the first element of the array");if(!i||!(i instanceof ArrayBuffer))throw new Error("An ArrayBuffer of weights must be the second element of the array");if(!("modelTopology"in s))throw new Error("Model JSON is missing 'modelTopology'");if(!("weightsManifest"in s))throw new Error("Model JSON is missing 'weightsManifest'");const r=S1(s.weightsManifest),a=v1(s,r,i);e=Tm(a)}else if("load"in n)e=n;else if("modelTopology"in n&&"weightSpecs"in n&&"weightData"in n)e=Tm(n);else throw new Error("Unknown model format");const t=new aT(e);return t.load(),t}function pge(n){return n.endsWith("/")||(n=n+"/"),`${n}${uge}${cge}`}/** @license See the LICENSE file. */const pL="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class fL extends Fu{constructor(e){super(),this.input=e}async iterator(){return(await this.input.iterator()).decodeUTF8().split(`
`).map(e=>(e.endsWith("\r")&&(e=e.slice(0,-1)),e))}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */const Ef='"',oh=Symbol("out"),e2=Symbol("field"),kf=Symbol("quote"),C0=Symbol("quoteafterquote"),t2=Symbol("quoteinquote");class mL extends Fu{constructor(e,t){super(),this.input=e,this.hasHeader=!0,this.fullColumnNames=null,this.columnNamesValidated=!1,this.columnConfigs=null,this.configuredColumnsOnly=!1,this.delimiter=",",this.delimWhitespace=!1,this.base=new fL(e),t||(t={}),this.hasHeader=t.hasHeader!==!1,this.fullColumnNames=t.columnNames,this.columnConfigs=t.columnConfigs,this.configuredColumnsOnly=t.configuredColumnsOnly,t.delimWhitespace?(E(t.delimiter==null,()=>"Delimiter should not be provided when delimWhitespace is true."),this.delimWhitespace=!0,this.delimiter=" "):this.delimiter=t.delimiter?t.delimiter:","}async columnNames(){return this.columnNamesValidated||await this.setColumnNames(),this.configuredColumnsOnly?Object.keys(this.columnConfigs):this.fullColumnNames}async setColumnNames(){const e=await this.maybeReadHeaderLine();if(!this.fullColumnNames&&!e)throw new Error("Column names must be provided if there is no header line.");this.fullColumnNames&&e&&E(e.length===this.fullColumnNames.length,()=>"The length of provided columnNames ("+this.fullColumnNames.length.toString()+") does not match the length of the header line read from file ("+e.length.toString()+")."),this.fullColumnNames||(this.fullColumnNames=e);const t=this.fullColumnNames.reduce((i,r)=>(i[r]=i[r]+1||1,i),{}),s=Object.keys(t).filter(i=>t[i]>1);if(E(s.length===0,()=>"Duplicate column names found: "+s.toString()),this.columnConfigs){for(const i of Object.keys(this.columnConfigs))if(this.fullColumnNames.indexOf(i)===-1)throw new Error('The key "'+i+'" provided in columnConfigs does not match any of the column names ('+this.fullColumnNames.toString()+").")}this.columnNamesValidated=!0}async maybeReadHeaderLine(){if(this.hasHeader){const e=await(await this.base.iterator()).next();if(e.done)throw new Error("No data was found for CSV parsing.");const t=e.value;return this.parseRow(t,!1)}else return null}async iterator(){this.columnNamesValidated||await this.setColumnNames();let e=await this.base.iterator();return this.hasHeader&&(e=e.skip(1)),e.map(t=>this.makeDataElement(t))}makeDataElement(e){const t=this.parseRow(e),s={},i={};for(let r=0;r<this.fullColumnNames.length;r++){const a=this.fullColumnNames[r],o=this.columnConfigs?this.columnConfigs[a]:null;if(!(this.configuredColumnsOnly&&!o)){const l=t[r];let c=null;if(l==="")if(o&&o.default!==void 0)c=o.default;else{if(o&&(o.required||o.isLabel))throw new Error(`Required column ${a} is empty in this line: ${e}`);c=void 0}else{const u=Number(l);if(isNaN(u))o&&o.dtype==="bool"?c=this.getBoolean(l):c=l;else if(!o||!o.dtype)c=u;else switch(o.dtype){case"float32":c=u;break;case"int32":c=Math.floor(u);break;case"bool":c=this.getBoolean(l);break;default:c=u}}o&&o.isLabel?i[a]=c:s[a]=c}}return Object.keys(i).length===0?s:{xs:s,ys:i}}getBoolean(e){return e==="1"||e.toLowerCase()==="true"?1:0}parseRow(e,t=!0){const s=[];let i=0;const r=e.length;let a=oh;for(let o=0;o<r;o++)switch(a){case oh:switch(e.charAt(o)){case Ef:i=o+1,a=kf;break;case this.delimiter:if(i=o+1,this.delimiter===" "&&this.delimWhitespace)break;s.push(""),a=oh;break;default:a=e2,i=o;break}break;case e2:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(i,o)),a=oh,i=o+1;break}break;case kf:switch(e.charAt(o)){case Ef:a=C0;break}break;case C0:switch(e.charAt(o)){case this.delimiter:s.push(e.substring(i,o-1)),a=oh,i=o+1;break;case Ef:a=kf;break;default:a=t2;break}break;case t2:switch(e.charAt(o)){case Ef:a=kf;break}break}if(a===C0?s.push(e.substring(i,r-1)):s.push(e.substring(i)),t&&s.length!==this.fullColumnNames.length)throw new Error(`Invalid row in csv file. Should have ${this.fullColumnNames.length} elements in a row, but got ${s}`);return s}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class oT extends Gn{constructor(e){super(),this.microphoneConfig=e,this.isClosed=!1,this.fftSize=e.fftSize||1024;const t=Math.log2(this.fftSize);if(this.fftSize<0||t<4||t>14||!Number.isInteger(t))throw new Error(`Invalid fftSize: it must be a power of 2 between 2 to 4 and 2 to 14, but got ${this.fftSize}`);if(this.numFrames=e.numFramesPerSpectrogram||43,this.sampleRateHz=e.sampleRateHz,this.columnTruncateLength=e.columnTruncateLength||this.fftSize,this.audioTrackConstraints=e.audioTrackConstraints,this.smoothingTimeConstant=e.smoothingTimeConstant||0,this.includeSpectrogram=e.includeSpectrogram!==!1,this.includeWaveform=e.includeWaveform===!0,!this.includeSpectrogram&&!this.includeWaveform)throw new Error("Both includeSpectrogram and includeWaveform are false. At least one type of data should be returned.")}summary(){return"microphone"}static async create(e={}){if(!ee().get("IS_BROWSER"))throw new Error("microphone API is only supported in browser environment.");const t=new oT(e);return await t.start(),t}async start(){try{this.stream=await navigator.mediaDevices.getUserMedia({audio:this.audioTrackConstraints==null?!0:this.audioTrackConstraints,video:!1})}catch(s){throw new Error(`Error thrown while initializing video stream: ${s.message}`)}if(!this.stream)throw new Error("Could not obtain audio from microphone.");const e=window.AudioContext||window.webkitAudioContext;if(this.audioContext=new e,!this.sampleRateHz)this.sampleRateHz=this.audioContext.sampleRate;else if(this.audioContext.sampleRate!==this.sampleRateHz)throw new Error(`Mismatch in sampling rate: Expected: ${this.sampleRateHz}; Actual: ${this.audioContext.sampleRate}`);const t=this.audioContext.createMediaStreamSource(this.stream);this.analyser=this.audioContext.createAnalyser(),this.analyser.fftSize=this.fftSize*2,this.analyser.smoothingTimeConstant=this.smoothingTimeConstant,t.connect(this.analyser),this.freqData=new Float32Array(this.fftSize),this.timeData=new Float32Array(this.fftSize)}async next(){if(this.isClosed)return{value:null,done:!0};let e,t;const s=await this.getAudioData();if(this.includeSpectrogram){const i=this.flattenQueue(s.freqDataQueue);e=this.getTensorFromAudioDataArray(i,[this.numFrames,this.columnTruncateLength,1])}if(this.includeWaveform){const i=this.flattenQueue(s.timeDataQueue);t=this.getTensorFromAudioDataArray(i,[this.numFrames*this.fftSize,1])}return{value:{spectrogram:e,waveform:t},done:!1}}async capture(){return(await this.next()).value}async getAudioData(){const e=[],t=[];let s=0;return new Promise(i=>{const r=setInterval(()=>{this.includeSpectrogram&&(this.analyser.getFloatFrequencyData(this.freqData),this.freqData[0]===-1/0&&i({freqDataQueue:e,timeDataQueue:t}),e.push(this.freqData.slice(0,this.columnTruncateLength))),this.includeWaveform&&(this.analyser.getFloatTimeDomainData(this.timeData),t.push(this.timeData.slice())),++s===this.numFrames&&(clearInterval(r),i({freqDataQueue:e,timeDataQueue:t}))},this.fftSize/this.sampleRateHz*1e3)})}stop(){this.isClosed||(this.isClosed=!0,this.analyser.disconnect(),this.audioContext.close(),this.stream!=null&&this.stream.getTracks().length>0&&this.stream.getTracks()[0].stop())}toArray(){throw new Error("Can not convert infinite audio stream to array.")}getSampleRate(){return this.sampleRateHz}flattenQueue(e){const t=e[0].length,s=new Float32Array(e.length*t);return e.forEach((i,r)=>s.set(i,r*t)),s}getTensorFromAudioDataArray(e,t){const s=new Float32Array(re(t));return s.set(e,s.length-e.length),en(s,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class lT extends Gn{constructor(e,t){if(super(),this.webcamVideoElement=e,this.webcamConfig=t,this.isClosed=!0,this.resize=!1,this.needToResize())if(this.resize=!0,this.cropSize=[this.webcamConfig.resizeHeight,this.webcamConfig.resizeWidth],this.cropBoxInd=ss([0],"int32"),this.webcamConfig.centerCrop){const s=this.webcamConfig.resizeWidth*1/this.webcamVideoElement.width,i=this.webcamConfig.resizeHeight*1/this.webcamVideoElement.height,r=(1-s)/2,a=(1-i)/2,o=r+s,l=i+a;this.cropBox=Ca([a,r,l,o],[1,4])}else this.cropBox=Ca([0,0,1,1],[1,4])}summary(){return"webcam"}static async create(e,t={}){if(!ee().get("IS_BROWSER"))throw new Error("tf.data.webcam is only supported in browser environment.");if(!e){if(e=document.createElement("video"),!t.resizeWidth||!t.resizeHeight)throw new Error("Please provide webcam video element, or resizeWidth and resizeHeight to create a hidden video element.");e.width=t.resizeWidth,e.height=t.resizeHeight}const s=new lT(e,t);return await s.start(),s}async start(){this.webcamConfig.facingMode&&E(this.webcamConfig.facingMode==="user"||this.webcamConfig.facingMode==="environment",()=>`Invalid webcam facing mode: ${this.webcamConfig.facingMode}. Please provide 'user' or 'environment'`);try{this.stream=await navigator.mediaDevices.getUserMedia({video:{deviceId:this.webcamConfig.deviceId,facingMode:this.webcamConfig.facingMode?this.webcamConfig.facingMode:"user",width:this.webcamVideoElement.width,height:this.webcamVideoElement.height}})}catch(e){throw e.message=`Error thrown while initializing video stream: ${e.message}`,e}if(!this.stream)throw new Error("Could not obtain video from webcam.");try{this.webcamVideoElement.srcObject=this.stream}catch(e){console.log(e),this.webcamVideoElement.src=window.URL.createObjectURL(this.stream)}return this.webcamVideoElement.play(),this.isClosed=!1,new Promise(e=>{this.webcamVideoElement.onloadedmetadata=()=>{e()}})}async next(){if(this.isClosed)return{value:null,done:!0};let e;try{e=Fv(this.webcamVideoElement)}catch(t){throw new Error(`Error thrown converting video to pixels: ${JSON.stringify(t)}`)}if(this.resize)try{return{value:this.cropAndResizeFrame(e),done:!1}}catch(t){throw new Error(`Error thrown cropping the video: ${t.message}`)}finally{e.dispose()}else return{value:e,done:!1}}needToResize(){return!!(this.webcamConfig.resizeWidth&&this.webcamConfig.resizeHeight&&(this.webcamVideoElement.width!==this.webcamConfig.resizeWidth||this.webcamVideoElement.height!==this.webcamConfig.resizeHeight))}cropAndResizeFrame(e){return j(()=>{const t=ns(Se(e,"float32"),0);let s;s=rr.cropAndResize(t,this.cropBox,this.cropBoxInd,this.cropSize,"bilinear");const i=s.shape;return K(s,i.slice(1))})}async capture(){return(await this.next()).value}stop(){this.stream.getTracks().forEach(e=>e.stop());try{this.webcamVideoElement.srcObject=null}catch(e){console.log(e),this.webcamVideoElement.src=null}this.isClosed=!0}toArray(){throw new Error("Can not convert infinite video stream to array.")}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class gL{}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class yL extends Gn{split(e){return new fge(this,e)}}class fge extends yL{constructor(e,t){super(),this.upstream=e,this.impl=new mge(e,t)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class mge extends AS{constructor(e,t){super(),this.upstream=e,this.separator=t,this.carryover=""}summary(){return`${this.upstream.summary()} -> Split('${this.separator}')`}async pump(){const e=await this.upstream.next();if(e.done)return this.carryover===""?!1:(this.outputQueue.push(this.carryover),this.carryover="",!0);const t=e.value.split(this.separator);t[0]=this.carryover+t[0];for(const s of t.slice(0,-1))this.outputQueue.push(s);return this.carryover=t[t.length-1],!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class gge extends Gn{decodeUTF8(){return new yge(this)}}class yge extends yL{constructor(e){super(),this.upstream=e,this.impl=new bge(e)}summary(){return this.impl.summary()}async next(){return this.impl.next()}}class bge extends AS{constructor(e){if(super(),this.upstream=e,ee().get("IS_BROWSER"))this.decoder=new TextDecoder("utf-8");else{const{StringDecoder:t}=require("string_decoder");this.decoder=new t("utf8")}}summary(){return`${this.upstream.summary()} -> Utf8`}async pump(){const e=await this.upstream.next();let t;if(e.done)return!1;t=e.value;let s;return ee().get("IS_BROWSER")?s=this.decoder.decode(t,{stream:!0}):s=this.decoder.write(Buffer.from(t.buffer)),this.outputQueue.push(s),!0}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class bL extends gge{constructor(e,t={}){super(),this.file=e,this.options=t,E(e instanceof Uint8Array||(ee().get("IS_BROWSER")?e instanceof File||e instanceof Blob:!1),()=>"FileChunkIterator only supports File, Blob and Uint8Array right now."),this.offset=t.offset||0,this.chunkSize=t.chunkSize||1024*1024}summary(){return`FileChunks ${this.file}`}async next(){return this.offset>=(this.file instanceof Uint8Array?this.file.byteLength:this.file.size)?{value:null,done:!0}:{value:await new Promise((e,t)=>{const s=this.offset+this.chunkSize;if(this.file instanceof Uint8Array)e(new Uint8Array(this.file.slice(this.offset,s)));else{const i=new FileReader;i.onload=a=>{let o=i.result;if(o instanceof ArrayBuffer&&(o=new Uint8Array(o)),!(o instanceof Uint8Array))return t(new TypeError("FileReader returned unknown type."));e(o)},i.onabort=a=>t(new Error("Aborted")),i.onerror=a=>t(new Error(a.type));const r=this.file.slice(this.offset,s);i.readAsArrayBuffer(r)}this.offset=s}),done:!1}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */async function xge(n,e={},t){let s,i;typeof n=="string"?s=n:(s=n.url,i=vge(n));const r=await(t||bC)(s,i);if(r.ok){const a=new Uint8Array(await r.arrayBuffer());return new bL(a,e)}else throw new Error(r.statusText)}const vge=n=>({method:n.method,headers:n.headers,body:n.body,mode:n.mode,credentials:n.credentials,cache:n.cache,redirect:n.redirect,referrer:n.referrer,integrity:n.integrity});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function xL(n){return typeof n=="string"&&n.slice(0,7)==="file://"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class vL extends gL{constructor(e,t={}){super(),this.input=e,this.options=t}async iterator(){if(xL(this.input)&&ee().get("IS_NODE")){const e=require("fs");this.input=e.readFileSync(this.input.slice(7))}return new bL(this.input,this.options)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */class wL extends gL{constructor(e,t={}){super(),this.url=e,this.fileOptions=t}async iterator(){return xL(this.url)?new vL(this.url,this.fileOptions).iterator():xge(this.url,this.fileOptions)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */function wge(n,e={}){return new mL(new wL(n),e)}function Sge(n){const e=RS(n);return Ds(async()=>e)}function Tge(n){return Ds(async()=>{const e=await n();return RS(()=>e.next())})}async function _ge(n,e){return lT.create(n,e)}async function Ige(n){return oT.create(n)}/** @license See the LICENSE file. */const SL="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mge=Object.freeze(Object.defineProperty({__proto__:null,CSVDataset:mL,Dataset:Fu,FileDataSource:vL,TextLineDataset:fL,URLDataSource:wL,array:w9,csv:wge,func:Sge,generator:Tge,microphone:Ige,version_data:SL,webcam:_ge,zip:S9},Symbol.toStringTag,{value:"Module"}));/** @license See the LICENSE file. */const Cge="4.2.0";/** @license See the LICENSE file. */const Ege="4.2.0";/** @license See the LICENSE file. */const kge="4.2.0";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nge={"tfjs-core":tL,"tfjs-backend-cpu":Cge,"tfjs-backend-webgl":Ege,"tfjs-data":SL,"tfjs-layers":Vy,"tfjs-converter":pL,tfjs:kge},Rge=Object.freeze(Object.defineProperty({__proto__:null,Abs:$h,Acos:Ic,Acosh:Mc,AdadeltaOptimizer:Ev,AdagradOptimizer:kv,AdamOptimizer:Nv,AdamaxOptimizer:Rv,Add:Jo,AddN:Xh,All:Fm,Any:Om,ArgMax:Hh,ArgMin:Kh,Asin:Cc,Asinh:Ec,Atan:kc,Atan2:Rc,Atanh:Nc,AvgPool:Zh,AvgPool3D:Yh,AvgPool3DGrad:zm,AvgPoolGrad:Gm,BatchMatMul:jh,BatchToSpaceND:Qh,Bincount:Vm,BroadcastArgs:Wm,BroadcastTo:aC,Callback:oL,CallbackList:uk,Cast:Ac,Ceil:Lc,ClipByValue:Pc,Complex:Um,ComplexAbs:Jh,Concat:qh,Conv2D:ed,Conv2DBackpropFilter:Bm,Conv2DBackpropInput:td,Conv3D:nd,Conv3DBackpropFilterV2:$m,Conv3DBackpropInputV2:Xm,Cos:Dc,Cosh:Fc,CropAndResize:Km,Cumprod:Hm,Cumsum:sd,CustomCallback:dk,DataStorage:a1,DenseBincount:Zm,DepthToSpace:Ym,DepthwiseConv2dNative:id,DepthwiseConv2dNativeBackpropFilter:jm,DepthwiseConv2dNativeBackpropInput:Qm,Diag:Jm,Dilation2D:rd,Dilation2DBackpropFilter:Yf,Dilation2DBackpropInput:Zf,get ENV(){return h1},EarlyStopping:lL,Einsum:qm,Elu:Gc,EluGrad:eg,Environment:iC,Equal:ad,Erf:zc,Exp:Vc,ExpandDims:od,Expm1:Wc,FFT:tg,Fill:ng,FlipLeftRight:sg,Floor:Uc,FloorDiv:Bc,FromPixels:jf,FusedBatchNorm:ld,FusedConv2D:Ih,FusedDepthwiseConv2D:Mh,GatherNd:ig,GatherV2:cd,GraphModel:aT,Greater:ud,GreaterEqual:$c,History:hk,IFFT:rg,Identity:Xc,Imag:ag,InputSpec:wn,IsFinite:Hc,IsInf:Kc,IsNan:Zc,KernelBackend:Lm,LRN:yd,LRNGrad:lg,LayerVariable:ak,LayersModel:Vr,LeakyRelu:hd,Less:dd,LessEqual:pd,LinSpace:og,Log:Yc,Log1p:jc,LogSoftmax:oC,LogicalAnd:fd,LogicalNot:md,LogicalOr:gd,LogicalXor:vV,LowerBound:wV,Max:bd,MaxPool:xd,MaxPool3D:vd,MaxPool3DGrad:ug,MaxPoolGrad:cg,MaxPoolWithArgmax:hg,Maximum:Qc,Mean:wd,Min:Sd,Minimum:Jc,MirrorPad:Td,Mod:qc,MomentumOptimizer:Av,Multinomial:dg,Multiply:eu,Neg:_d,NonMaxSuppressionV3:pg,NonMaxSuppressionV4:fg,NonMaxSuppressionV5:mg,NotEqual:Id,OP_SCOPE_SUFFIX:y1,OneHot:Cd,OnesLike:Md,Optimizer:ia,OptimizerConstructors:bE,Pack:Ed,PadV2:kd,Pool:SV,Pow:tu,Prelu:Nd,Prod:Rd,RMSPropOptimizer:Lv,RNN:Ki,RaggedGather:gg,RaggedRange:yg,RaggedTensorToTensor:bg,Range:xg,get Rank(){return Z0},Real:vg,RealDiv:Oc,Reciprocal:nu,get Reduction(){return us},Relu:su,Relu6:iu,Reshape:Ad,ResizeBilinear:Pd,ResizeBilinearGrad:Sg,ResizeNearestNeighbor:Ld,ResizeNearestNeighborGrad:wg,Reverse:Dd,RotateWithOffset:Gg,Round:ru,Rsqrt:au,SGDOptimizer:Sy,ScatterNd:Tg,SearchSorted:_g,Select:Fd,Selu:ou,Sequential:Wy,Sigmoid:hu,Sign:uu,Sin:lu,Sinh:cu,Slice:Od,Softmax:Wd,Softplus:du,SpaceToBatchND:zd,SparseFillEmptyRows:Ig,SparseReshape:Mg,SparseSegmentMean:Cg,SparseSegmentSum:Eg,SparseToDense:kg,SplitV:Vd,Sqrt:pu,Square:Ng,SquaredDifference:fu,Step:xu,StridedSlice:Rg,StringNGrams:Ag,StringSplit:Lg,StringToHashBucketFast:Pg,Sub:mu,Sum:Gd,SymbolicTensor:Di,Tan:gu,Tanh:yu,Tensor:Et,TensorBuffer:En,Tile:bu,TopK:Dg,Transform:Fg,Transpose:Io,Unique:Og,Unpack:Ud,UnsortedSegmentSum:Bd,UpperBound:TV,Variable:Eh,ZerosLike:$d,_FusedMatMul:_h,abs:xn,acos:I1,acosh:M1,add:de,addN:fA,all:Bg,any:Rh,argMax:Do,argMin:C1,asin:E1,asinh:k1,atan:N1,atan2:R1,atanh:A1,avgPool:Zd,avgPool3d:P1,backend:Gr,backend_util:BE,basicLSTMCell:mA,batchNorm:vu,batchNorm2d:D1,batchNorm3d:F1,batchNorm4d:O1,batchToSpaceND:Yd,bincount:G1,booleanMaskAsync:KA,broadcastArgs:gA,broadcastTo:Mo,broadcast_util:KU,browser:jH,buffer:ut,callbacks:Vfe,cast:Se,ceil:z1,clipByValue:ks,clone:ur,complex:Xr,concat:fn,concat1d:V1,concat2d:W1,concat3d:U1,concat4d:B1,constraints:Ode,conv1d:$g,conv2d:Hr,conv2dTranspose:Xg,conv3d:X1,conv3dTranspose:H1,copyRegisteredKernels:CV,cos:jd,cosh:Hg,cosineWindow:fy,cumprod:Ph,cumsum:Kg,customGrad:mr,data:Mge,denseBincount:tm,deprecationWarn:LW,depthToSpace:K1,depthwiseConv2d:wu,deregisterOp:Ufe,device_util:JV,diag:yA,dilation2d:Z1,disableDeprecationWarnings:AW,dispose:nt,disposeVariables:PW,div:Ue,divNoNan:Y1,dot:j1,dropout:Tv,einsum:bA,elu:Su,enableDebugMode:RW,enableProdMode:NW,enclosingPowerOfTwo:_v,engine:Ut,env:ee,equal:Us,erf:Q1,euclideanNorm:q1,exp:Bs,expandDims:ns,expm1:ev,eye:Zg,fft:lp,fill:el,findBackend:WW,findBackendFactory:UW,floor:_u,floorDiv:Ug,fused:qA,gather:Iu,gatherND:QA,gather_util:QH,getBackend:zW,getGradient:X0,getKernel:Qf,getKernelsForBackend:Jf,grad:EB,grads:kB,greater:gs,greaterEqual:ta,ifft:hc,imag:Qd,image:rr,inTopKAsync:JA,initializers:qde,input:nL,io:eT,irfft:cy,isFinite:tv,isInf:nv,isNaN:sv,keep:hn,kernel_impls:Ade,layers:yfe,leakyRelu:Jd,less:Yg,lessEqual:Ha,linalg:Cv,linspace:xA,loadGraphModel:hge,loadGraphModelSync:dge,loadLayersModel:P5,localResponseNormalization:iv,log:$s,log1p:qd,logSigmoid:rv,logSoftmax:Qg,logSumExp:Jg,logicalAnd:Ti,logicalNot:ep,logicalOr:qg,logicalXor:av,losses:eE,lowerBound:vA,matMul:ft,math:Rde,max:si,maxPool:tp,maxPool3d:ov,maxPoolWithArgmax:wA,maximum:vr,mean:on,memory:Nh,meshgrid:SA,metrics:Lfe,min:oc,minimum:Mu,mirrorPad:lv,mod:cv,model:epe,models:Pfe,moments:np,movingAverage:ZA,mul:X,multiRNNCell:TA,multinomial:_A,neg:Jt,nextFrame:up,norm:Tu,notEqual:zo,oneHot:lc,ones:Vs,onesLike:Xs,op:U,outerProduct:IA,pad:na,pad1d:MA,pad2d:CA,pad3d:EA,pad4d:kA,pool:uv,pow:Kr,prelu:ip,print:T1,prod:hv,profile:DW,raggedGather:NA,raggedRange:RA,raggedTensorToTensor:AA,rand:LA,randomGamma:FA,randomNormal:ey,randomStandardNormal:OA,randomUniform:Eu,range:Vo,ready:GW,real:cc,reciprocal:pv,registerBackend:_1,registerCallbackConstructor:npe,registerGradient:lC,registerKernel:As,registerOp:Wfe,regularizers:Gfe,relu:Xi,relu6:ty,removeBackend:VW,reshape:K,reverse:ri,reverse1d:GA,reverse2d:zA,reverse3d:VA,reverse4d:WA,rfft:cp,round:ny,rsqrt:sy,scalar:Ke,scatterND:YA,scatter_util:aX,searchSorted:ib,selu:iy,separableConv2d:ry,sequential:tpe,serialization:GH,setBackend:OW,setPlatform:BW,setdiff1dAsync:UA,sigmoid:Gi,sign:fv,signal:qC,sin:ay,sinh:oy,slice:Tt,slice1d:rp,slice2d:ly,slice3d:ap,slice4d:uc,slice_util:yE,softmax:op,softplus:tl,spaceToBatchND:sp,sparse:tE,sparseToDense:jA,spectral:JC,split:Cs,sqrt:Yn,square:zt,squaredDifference:uy,squeeze:Ka,stack:ps,step:sl,stridedSlice:mv,string:nE,sub:Fe,sum:ze,sumOutType:zg,tan:gv,tanh:Oo,tensor:en,tensor1d:ss,tensor2d:Ca,tensor3d:yv,tensor4d:BA,tensor5d:$A,tensor6d:XA,tensor_util:KV,test_util:ede,tidy:j,tile:ei,time:FW,topk:bv,train:po,transpose:xt,truncatedNormal:hy,unique:xv,unregisterGradient:MV,unregisterKernel:IV,unsortedSegmentSum:dy,unstack:ai,upcastType:Es,upperBound:HA,util:DV,valueAndGrad:NB,valueAndGrads:RB,variable:vv,variableGrads:OC,version:Nge,version_converter:pL,version_core:tL,version_layers:Vy,where:rs,whereAsync:qS,zeros:vn,zerosLike:_t},Symbol.toStringTag,{value:"Module"})),TL=new ot;TL.compose(new J,new Is,new J(.001,.001,.001));const Age=new ot().set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1);class _L{constructor({container:e,imageTargetSrc:t,maxTrack:s,uiLoading:i="yes",uiScanning:r="yes",uiError:a="yes",filterMinCF:o=null,filterBeta:l=null,warmupTolerance:c=null,missTolerance:u=null,userDeviceId:h=null,environmentDeviceId:d=null}){this.container=e,this.imageTargetSrc=t,this.maxTrack=s,this.filterMinCF=o,this.filterBeta=l,this.warmupTolerance=c,this.missTolerance=u,this.ui=new rV({uiLoading:i,uiScanning:r,uiError:a}),this.userDeviceId=h,this.environmentDeviceId=d,this.shouldFaceUser=!1,this.scene=new O_,this.cssScene=new O_,this.renderer=new G2({antialias:!0,alpha:!0}),this.cssRenderer=new Mhe({antialias:!0}),this.renderer.outputEncoding=Ia,this.renderer.setPixelRatio(window.devicePixelRatio),this.camera=new Ts,this.anchors=[],this.renderer.domElement.style.position="absolute",this.cssRenderer.domElement.style.position="absolute",this.container.appendChild(this.renderer.domElement),this.container.appendChild(this.cssRenderer.domElement),window.addEventListener("resize",this.resize.bind(this))}async start(){this.ui.showLoading(),await this._startVideo(),await this._startAR()}stop(){this.controller.stopProcessVideo(),this.video.srcObject.getTracks().forEach(function(e){e.stop()}),this.video.remove()}switchCamera(){this.shouldFaceUser=!this.shouldFaceUser,this.stop(),this.start()}addAnchor(e){const t=new Or;t.visible=!1,t.matrixAutoUpdate=!1;const s={group:t,targetIndex:e,onTargetFound:null,onTargetLost:null,onTargetUpdate:null,css:!1,visible:!1};return this.anchors.push(s),this.scene.add(t),s}addCSSAnchor(e){const t=new Or;t.visible=!1,t.matrixAutoUpdate=!1;const s={group:t,targetIndex:e,onTargetFound:null,onTargetLost:null,onTargetUpdate:null,css:!0,visible:!1};return this.anchors.push(s),this.cssScene.add(t),s}_startVideo(){return new Promise((e,t)=>{if(this.video=document.createElement("video"),this.video.setAttribute("autoplay",""),this.video.setAttribute("muted",""),this.video.setAttribute("playsinline",""),this.video.style.position="absolute",this.video.style.top="0px",this.video.style.left="0px",this.video.style.zIndex="-2",this.container.appendChild(this.video),!navigator.mediaDevices||!navigator.mediaDevices.getUserMedia){this.ui.showCompatibility(),t();return}const s={audio:!1,video:{}};this.shouldFaceUser?this.userDeviceId?s.video.deviceId={exact:this.userDeviceId}:s.video.facingMode="user":this.environmentDeviceId?s.video.deviceId={exact:this.environmentDeviceId}:s.video.facingMode="environment",navigator.mediaDevices.getUserMedia(s).then(i=>{this.video.addEventListener("loadedmetadata",()=>{this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight),e()}),this.video.srcObject=i}).catch(i=>{console.log("getUserMedia error",i),t()})})}_startAR(){return new Promise(async(e,t)=>{const s=this.video;this.container,this.controller=new The({inputWidth:s.videoWidth,inputHeight:s.videoHeight,filterMinCF:this.filterMinCF,filterBeta:this.filterBeta,warmupTolerance:this.warmupTolerance,missTolerance:this.missTolerance,maxTrack:this.maxTrack,onUpdate:r=>{if(r.type==="updateMatrix"){const{targetIndex:a,worldMatrix:o}=r;for(let l=0;l<this.anchors.length;l++)if(this.anchors[l].targetIndex===a){if(this.anchors[l].css?this.anchors[l].group.children.forEach(c=>{c.element.style.visibility=o===null?"hidden":"visible"}):this.anchors[l].group.visible=o!==null,o!==null){let c=new ot;c.elements=[...o],c.multiply(this.postMatrixs[a]),this.anchors[l].css&&c.multiply(TL),this.anchors[l].group.matrix=c}else this.anchors[l].group.matrix=Age;this.anchors[l].visible&&o===null&&(this.anchors[l].visible=!1,this.anchors[l].onTargetLost&&this.anchors[l].onTargetLost()),!this.anchors[l].visible&&o!==null&&(this.anchors[l].visible=!0,this.anchors[l].onTargetFound&&this.anchors[l].onTargetFound()),this.anchors[l].onTargetUpdate&&this.anchors[l].onTargetUpdate()}this.anchors.reduce((l,c)=>l||c.visible,!1)?this.ui.hideScanning():this.ui.showScanning()}}}),this.resize();const{dimensions:i}=await this.controller.addImageTargets(this.imageTargetSrc);this.postMatrixs=[];for(let r=0;r<i.length;r++){const a=new J,o=new Is,l=new J,[c,u]=i[r];a.x=c/2,a.y=c/2+(u-c)/2,l.x=c,l.y=c,l.z=c;const h=new ot;h.compose(a,o,l),this.postMatrixs.push(h)}await this.controller.dummyRun(this.video),this.ui.hideLoading(),this.ui.showScanning(),this.controller.processVideo(this.video),e()})}resize(){const{renderer:e,cssRenderer:t,camera:s,container:i,video:r}=this;if(!r)return;this.video.setAttribute("width",this.video.videoWidth),this.video.setAttribute("height",this.video.videoHeight);let a,o;const l=r.videoWidth/r.videoHeight,c=i.clientWidth/i.clientHeight;l>c?(o=i.clientHeight,a=o*l):(a=i.clientWidth,o=a/l);const u=this.controller.getProjectionMatrix(),h=this.controller.inputWidth/this.controller.inputHeight;let d;h>c?d=this.video.width/this.controller.inputWidth:d=this.video.height/this.controller.inputHeight;let p,f;h>c?(p=i.clientHeight,p*=d):(f=i.clientWidth,p=f/this.controller.inputWidth*this.controller.inputHeight,p*=d);let y=i.clientHeight/p;const m=2*Math.atan(1/u[5]*y)*180/Math.PI,g=u[14]/(u[10]-1),b=u[14]/(u[10]+1);u[5]/u[0],s.fov=m,s.near=g,s.far=b,s.aspect=i.clientWidth/i.clientHeight,s.updateProjectionMatrix(),r.style.top=-(o-i.clientHeight)/2+"px",r.style.left=-(a-i.clientWidth)/2+"px",r.style.width=a+"px",r.style.height=o+"px";const x=e.domElement,v=t.domElement;x.style.position="absolute",x.style.left=0,x.style.top=0,x.style.width=i.clientWidth+"px",x.style.height=i.clientHeight+"px",v.style.position="absolute",v.style.left=0,v.style.top=0,v.style.width=i.clientWidth+"px",v.style.height=i.clientHeight+"px",e.setSize(i.clientWidth,i.clientHeight),t.setSize(i.clientWidth,i.clientHeight)}}window.MINDAR||(window.MINDAR={});window.MINDAR.IMAGE||(window.MINDAR.IMAGE={});window.MINDAR.IMAGE.MindARThree=_L;window.MINDAR.IMAGE.tf=Rge;function n2(n,e){if(e===N3)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===D0||e===b2){let t=n.getIndex();if(t===null){const a=[],o=n.getAttribute("position");if(o!==void 0){for(let l=0;l<o.count;l++)a.push(l);n.setIndex(a),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const s=t.count-2,i=[];if(e===D0)for(let a=1;a<=s;a++)i.push(t.getX(0)),i.push(t.getX(a)),i.push(t.getX(a+1));else for(let a=0;a<s;a++)a%2===0?(i.push(t.getX(a)),i.push(t.getX(a+1)),i.push(t.getX(a+2))):(i.push(t.getX(a+2)),i.push(t.getX(a+1)),i.push(t.getX(a)));i.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const r=n.clone();return r.setIndex(i),r.clearGroups(),r}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}class Lge extends Wa{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Gge(t)}),this.register(function(t){return new Hge(t)}),this.register(function(t){return new Kge(t)}),this.register(function(t){return new Zge(t)}),this.register(function(t){return new Vge(t)}),this.register(function(t){return new Wge(t)}),this.register(function(t){return new Uge(t)}),this.register(function(t){return new Bge(t)}),this.register(function(t){return new Oge(t)}),this.register(function(t){return new $ge(t)}),this.register(function(t){return new zge(t)}),this.register(function(t){return new Xge(t)}),this.register(function(t){return new Dge(t)}),this.register(function(t){return new Yge(t)}),this.register(function(t){return new jge(t)})}load(e,t,s,i){const r=this;let a;this.resourcePath!==""?a=this.resourcePath:this.path!==""?a=this.path:a=B0.extractUrlBase(e),this.manager.itemStart(e);const o=function(c){i?i(c):console.error(c),r.manager.itemError(e),r.manager.itemEnd(e)},l=new Am(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{r.parse(c,a,function(u){t(u),r.manager.itemEnd(e)},o)}catch(u){o(u)}},s,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,i){let r;const a={},o={},l=new TextDecoder;if(typeof e=="string")r=JSON.parse(e);else if(e instanceof ArrayBuffer)if(l.decode(new Uint8Array(e,0,4))===IL){try{a[Ct.KHR_BINARY_GLTF]=new Qge(e)}catch(h){i&&i(h);return}r=JSON.parse(a[Ct.KHR_BINARY_GLTF].content)}else r=JSON.parse(l.decode(e));else r=e;if(r.asset===void 0||r.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new uye(r,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const h=this.pluginCallbacks[u](c);h.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[h.name]=h,a[h.name]=!0}if(r.extensionsUsed)for(let u=0;u<r.extensionsUsed.length;++u){const h=r.extensionsUsed[u],d=r.extensionsRequired||[];switch(h){case Ct.KHR_MATERIALS_UNLIT:a[h]=new Fge;break;case Ct.KHR_DRACO_MESH_COMPRESSION:a[h]=new Jge(r,this.dracoLoader);break;case Ct.KHR_TEXTURE_TRANSFORM:a[h]=new qge;break;case Ct.KHR_MESH_QUANTIZATION:a[h]=new eye;break;default:d.indexOf(h)>=0&&o[h]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+h+'".')}}c.setExtensions(a),c.setPlugins(o),c.parse(s,i)}parseAsync(e,t){const s=this;return new Promise(function(i,r){s.parse(e,t,i,r)})}}function Pge(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const Ct={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Dge{constructor(e){this.parser=e,this.name=Ct.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,i=t.length;s<i;s++){const r=t[s];r.extensions&&r.extensions[this.name]&&r.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,r.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let i=t.cache.get(s);if(i)return i;const r=t.json,l=((r.extensions&&r.extensions[this.name]||{}).lights||[])[e];let c;const u=new lt(16777215);l.color!==void 0&&u.setRGB(l.color[0],l.color[1],l.color[2],Kn);const h=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new Pz(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new Az(u),c.distance=h;break;case"spot":c=new Nz(u),c.distance=h,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,ma(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=t.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),t.cache.add(s,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,r=s.json.nodes[e],o=(r.extensions&&r.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(l){return s._getNodeRef(t.cache,o,l)})}}class Fge{constructor(){this.name=Ct.KHR_MATERIALS_UNLIT}getMaterialType(){return ya}extendParams(e,t,s){const i=[];e.color=new lt(1,1,1),e.opacity=1;const r=t.pbrMetallicRoughness;if(r){if(Array.isArray(r.baseColorFactor)){const a=r.baseColorFactor;e.color.setRGB(a[0],a[1],a[2],Kn),e.opacity=a[3]}r.baseColorTexture!==void 0&&i.push(s.assignTexture(e,"map",r.baseColorTexture,an))}return Promise.all(i)}}class Oge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name].emissiveStrength;return r!==void 0&&(t.emissiveIntensity=r),Promise.resolve()}}class Gge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(r.push(s.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Rt(o,o)}return Promise.all(r)}}class zge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(t.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(t.iridescenceIOR=a.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&r.push(s.assignTexture(t,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(r)}}class Vge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[];t.sheenColor=new lt(0,0,0),t.sheenRoughness=0,t.sheen=1;const a=i.extensions[this.name];if(a.sheenColorFactor!==void 0){const o=a.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],Kn)}return a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&r.push(s.assignTexture(t,"sheenColorMap",a.sheenColorTexture,an)),a.sheenRoughnessTexture!==void 0&&r.push(s.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(r)}}class Wge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&r.push(s.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(r)}}class Uge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&r.push(s.assignTexture(t,"thicknessMap",a.thicknessTexture)),t.attenuationDistance=a.attenuationDistance||1/0;const o=a.attenuationColor||[1,1,1];return t.attenuationColor=new lt().setRGB(o[0],o[1],o[2],Kn),Promise.all(r)}}class Bge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=i.extensions[this.name];return t.ior=r.ior!==void 0?r.ior:1.5,Promise.resolve()}}class $ge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&r.push(s.assignTexture(t,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return t.specularColor=new lt().setRGB(o[0],o[1],o[2],Kn),a.specularColorTexture!==void 0&&r.push(s.assignTexture(t,"specularColorMap",a.specularColorTexture,an)),Promise.all(r)}}class Xge{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Va}extendMaterialParams(e,t){const s=this.parser,i=s.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const r=[],a=i.extensions[this.name];return a.anisotropyStrength!==void 0&&(t.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(t.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&r.push(s.assignTexture(t,"anisotropyMap",a.anisotropyTexture)),Promise.all(r)}}class Hge{constructor(e){this.parser=e,this.name=Ct.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,i=s.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const r=i.extensions[this.name],a=t.options.ktx2Loader;if(!a){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,r.source,a)}}class Kge{constructor(e){this.parser=e,this.name=Ct.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],o=i.images[a.source];let l=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Zge{constructor(e){this.parser=e,this.name=Ct.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,i=s.json,r=i.textures[e];if(!r.extensions||!r.extensions[t])return null;const a=r.extensions[t],o=i.images[a.source];let l=s.textureLoader;if(o.uri){const c=s.options.manager.getHandler(o.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,a.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Yge{constructor(e){this.name=Ct.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const i=s.extensions[this.name],r=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return r.then(function(o){const l=i.byteOffset||0,c=i.byteLength||0,u=i.count,h=i.byteStride,d=new Uint8Array(o,l,c);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(u,h,d,i.mode,i.filter).then(function(p){return p.buffer}):a.ready.then(function(){const p=new ArrayBuffer(u*h);return a.decodeGltfBuffer(new Uint8Array(p),u,h,d,i.mode,i.filter),p})})}else return null}}class jge{constructor(e){this.name=Ct.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const i=t.meshes[s.mesh];for(const c of i.primitives)if(c.mode!==pi.TRIANGLES&&c.mode!==pi.TRIANGLE_STRIP&&c.mode!==pi.TRIANGLE_FAN&&c.mode!==void 0)return null;const a=s.extensions[this.name].attributes,o=[],l={};for(const c in a)o.push(this.parser.getDependency("accessor",a[c]).then(u=>(l[c]=u,l[c])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(c=>{const u=c.pop(),h=u.isGroup?u.children:[u],d=c[0].count,p=[];for(const f of h){const y=new ot,m=new J,g=new Is,b=new J(1,1,1),x=new fz(f.geometry,f.material,d);for(let v=0;v<d;v++)l.TRANSLATION&&m.fromBufferAttribute(l.TRANSLATION,v),l.ROTATION&&g.fromBufferAttribute(l.ROTATION,v),l.SCALE&&b.fromBufferAttribute(l.SCALE,v),x.setMatrixAt(v,y.compose(m,g,b));for(const v in l)if(v==="_COLOR_0"){const w=l[v];x.instanceColor=new V0(w.array,w.itemSize,w.normalized)}else v!=="TRANSLATION"&&v!=="ROTATION"&&v!=="SCALE"&&f.geometry.setAttribute(v,l[v]);nn.prototype.copy.call(x,f),this.parser.assignFinalMaterial(x),p.push(x)}return u.isGroup?(u.clear(),u.add(...p),u):p[0]}))}}const IL="glTF",lh=12,s2={JSON:1313821514,BIN:5130562};class Qge{constructor(e){this.name=Ct.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,lh),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==IL)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-lh,r=new DataView(e,lh);let a=0;for(;a<i;){const o=r.getUint32(a,!0);a+=4;const l=r.getUint32(a,!0);if(a+=4,l===s2.JSON){const c=new Uint8Array(e,lh+a,o);this.content=s.decode(c)}else if(l===s2.BIN){const c=lh+a;this.body=e.slice(c,c+o)}a+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Jge{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Ct.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,i=this.dracoLoader,r=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},l={},c={};for(const u in a){const h=Vx[u]||u.toLowerCase();o[h]=a[u]}for(const u in e.attributes){const h=Vx[u]||u.toLowerCase();if(a[u]!==void 0){const d=s.accessors[e.attributes[u]],p=Hl[d.componentType];c[h]=p.name,l[h]=d.normalized===!0}}return t.getDependency("bufferView",r).then(function(u){return new Promise(function(h){i.decodeDracoFile(u,function(d){for(const p in d.attributes){const f=d.attributes[p],y=l[p];y!==void 0&&(f.normalized=y)}h(d)},o,c)})})}}class qge{constructor(){this.name=Ct.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class eye{constructor(){this.name=Ct.KHR_MESH_QUANTIZATION}}class ML extends Bh{constructor(e,t,s,i){super(e,t,s,i)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,i=this.valueSize,r=e*i*3+i;for(let a=0;a!==i;a++)t[a]=s[r+a];return t}interpolate_(e,t,s,i){const r=this.resultBuffer,a=this.sampleValues,o=this.valueSize,l=o*2,c=o*3,u=i-t,h=(s-t)/u,d=h*h,p=d*h,f=e*c,y=f-c,m=-2*p+3*d,g=p-d,b=1-m,x=g-d+h;for(let v=0;v!==o;v++){const w=a[y+v+o],_=a[y+v+l]*u,I=a[f+v+o],C=a[f+v]*u;r[v]=b*w+x*_+m*I+g*C}return r}}const tye=new Is;class nye extends ML{interpolate_(e,t,s,i){const r=super.interpolate_(e,t,s,i);return tye.fromArray(r).normalize().toArray(r),r}}const pi={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Hl={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},i2={9728:$n,9729:An,9984:P0,9985:u2,9986:Nf,9987:Ra},r2={33071:Os,33648:Gf,10497:Na},E0={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Vx={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ha={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},sye={CUBICSPLINE:void 0,LINEAR:Jl,STEP:wh},k0={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function iye(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new t1({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Wr})),n.DefaultMaterial}function oo(n,e,t){for(const s in t.extensions)n[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function ma(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function rye(n,e,t){let s=!1,i=!1,r=!1;for(let c=0,u=e.length;c<u;c++){const h=e[c];if(h.POSITION!==void 0&&(s=!0),h.NORMAL!==void 0&&(i=!0),h.COLOR_0!==void 0&&(r=!0),s&&i&&r)break}if(!s&&!i&&!r)return Promise.resolve(n);const a=[],o=[],l=[];for(let c=0,u=e.length;c<u;c++){const h=e[c];if(s){const d=h.POSITION!==void 0?t.getDependency("accessor",h.POSITION):n.attributes.position;a.push(d)}if(i){const d=h.NORMAL!==void 0?t.getDependency("accessor",h.NORMAL):n.attributes.normal;o.push(d)}if(r){const d=h.COLOR_0!==void 0?t.getDependency("accessor",h.COLOR_0):n.attributes.color;l.push(d)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l)]).then(function(c){const u=c[0],h=c[1],d=c[2];return s&&(n.morphAttributes.position=u),i&&(n.morphAttributes.normal=h),r&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}function aye(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let s=0,i=t.length;s<i;s++)n.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function oye(n){let e;const t=n.extensions&&n.extensions[Ct.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+N0(t.attributes):e=n.indices+":"+N0(n.attributes)+":"+n.mode,n.targets!==void 0)for(let s=0,i=n.targets.length;s<i;s++)e+=":"+N0(n.targets[s]);return e}function N0(n){let e="";const t=Object.keys(n).sort();for(let s=0,i=t.length;s<i;s++)e+=t[s]+":"+n[t[s]]+";";return e}function Wx(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function lye(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const cye=new ot;class uye{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Pge,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,i=!1,r=-1;typeof navigator<"u"&&(s=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,r=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||s||i&&r<98?this.textureLoader=new K2(this.options.manager):this.textureLoader=new Dz(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Am(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,i=this.json,r=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:s,userData:{}};return oo(r,o,i),ma(o,i),Promise.all(s._invokeAll(function(l){return l.afterRoot&&l.afterRoot(o)})).then(function(){e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let i=0,r=t.length;i<r;i++){const a=t[i].joints;for(let o=0,l=a.length;o<l;o++)e[a[o]].isBone=!0}for(let i=0,r=e.length;i<r;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(s[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const i=s.clone(),r=(a,o)=>{const l=this.associations.get(a);l!=null&&this.associations.set(o,l);for(const[c,u]of a.children.entries())r(u,o.children[c])};return r(s,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const i=e(t[s]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let i=0;i<t.length;i++){const r=e(t[i]);r&&s.push(r)}return s}getDependency(e,t){const s=e+":"+t;let i=this.cache.get(s);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(r){return r.loadNode&&r.loadNode(t)});break;case"mesh":i=this._invokeOne(function(r){return r.loadMesh&&r.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(r){return r.loadBufferView&&r.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(r){return r.loadMaterial&&r.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(r){return r.loadTexture&&r.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(r){return r.loadAnimation&&r.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(r){return r!=this&&r.getDependency&&r.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(s,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(r,a){return s.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Ct.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(r,a){s.load(B0.resolveURL(t.uri,i.path),r,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const i=t.byteLength||0,r=t.byteOffset||0;return s.slice(r,r+i)})}loadAccessor(e){const t=this,s=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=E0[i.type],o=Hl[i.componentType],l=i.normalized===!0,c=new o(i.count*a);return Promise.resolve(new Ms(c,a,l))}const r=[];return i.bufferView!==void 0?r.push(this.getDependency("bufferView",i.bufferView)):r.push(null),i.sparse!==void 0&&(r.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),r.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(r).then(function(a){const o=a[0],l=E0[i.type],c=Hl[i.componentType],u=c.BYTES_PER_ELEMENT,h=u*l,d=i.byteOffset||0,p=i.bufferView!==void 0?s.bufferViews[i.bufferView].byteStride:void 0,f=i.normalized===!0;let y,m;if(p&&p!==h){const g=Math.floor(d/p),b="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+g+":"+i.count;let x=t.cache.get(b);x||(y=new c(o,g*p,i.count*p/u),x=new cz(y,p/u),t.cache.add(b,x)),m=new Jx(x,l,d%p/u,f)}else o===null?y=new c(i.count*l):y=new c(o,d,i.count*l),m=new Ms(y,l,f);if(i.sparse!==void 0){const g=E0.SCALAR,b=Hl[i.sparse.indices.componentType],x=i.sparse.indices.byteOffset||0,v=i.sparse.values.byteOffset||0,w=new b(a[1],x,i.sparse.count*g),_=new c(a[2],v,i.sparse.count*l);o!==null&&(m=new Ms(m.array.slice(),m.itemSize,m.normalized));for(let I=0,C=w.length;I<C;I++){const S=w[I];if(m.setX(S,_[I*l]),l>=2&&m.setY(S,_[I*l+1]),l>=3&&m.setZ(S,_[I*l+2]),l>=4&&m.setW(S,_[I*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return m})}loadTexture(e){const t=this.json,s=this.options,r=t.textures[e].source,a=t.images[r];let o=this.textureLoader;if(a.uri){const l=s.manager.getHandler(a.uri);l!==null&&(o=l)}return this.loadTextureImage(e,r,o)}loadTextureImage(e,t,s){const i=this,r=this.json,a=r.textures[e],o=r.images[t],l=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(t,s).then(function(u){u.flipY=!1,u.name=a.name||o.name||"",u.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(u.name=o.uri);const d=(r.samplers||{})[a.sampler]||{};return u.magFilter=i2[d.magFilter]||An,u.minFilter=i2[d.minFilter]||Ra,u.wrapS=r2[d.wrapS]||Na,u.wrapT=r2[d.wrapT]||Na,i.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,t){const s=this,i=this.json,r=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(h=>h.clone());const a=i.images[e],o=self.URL||self.webkitURL;let l=a.uri||"",c=!1;if(a.bufferView!==void 0)l=s.getDependency("bufferView",a.bufferView).then(function(h){c=!0;const d=new Blob([h],{type:a.mimeType});return l=o.createObjectURL(d),l});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(l).then(function(h){return new Promise(function(d,p){let f=d;t.isImageBitmapLoader===!0&&(f=function(y){const m=new is(y);m.needsUpdate=!0,d(m)}),t.load(B0.resolveURL(h,r.path),f,void 0,p)})}).then(function(h){return c===!0&&o.revokeObjectURL(l),h.userData.mimeType=a.mimeType||lye(a.uri),h}).catch(function(h){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),h});return this.sourceCache[e]=u,u}assignTexture(e,t,s,i){const r=this;return this.getDependency("texture",s.index).then(function(a){if(!a)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(a=a.clone(),a.channel=s.texCoord),r.extensions[Ct.KHR_TEXTURE_TRANSFORM]){const o=s.extensions!==void 0?s.extensions[Ct.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const l=r.associations.get(a);a=r.extensions[Ct.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),r.associations.set(a,l)}}return i!==void 0&&(a.colorSpace=i),e[t]=a,a})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const i=t.attributes.tangent===void 0,r=t.attributes.color!==void 0,a=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+s.uuid;let l=this.cache.get(o);l||(l=new U2,lr.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,l.sizeAttenuation=!1,this.cache.add(o,l)),s=l}else if(e.isLine){const o="LineBasicMaterial:"+s.uuid;let l=this.cache.get(o);l||(l=new W2,lr.prototype.copy.call(l,s),l.color.copy(s.color),l.map=s.map,this.cache.add(o,l)),s=l}if(i||r||a){let o="ClonedMaterial:"+s.uuid+":";i&&(o+="derivative-tangents:"),r&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let l=this.cache.get(o);l||(l=s.clone(),r&&(l.vertexColors=!0),a&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(o,l),this.associations.set(l,this.associations.get(s))),s=l}e.material=s}getMaterialType(){return t1}loadMaterial(e){const t=this,s=this.json,i=this.extensions,r=s.materials[e];let a;const o={},l=r.extensions||{},c=[];if(l[Ct.KHR_MATERIALS_UNLIT]){const h=i[Ct.KHR_MATERIALS_UNLIT];a=h.getMaterialType(),c.push(h.extendParams(o,r,t))}else{const h=r.pbrMetallicRoughness||{};if(o.color=new lt(1,1,1),o.opacity=1,Array.isArray(h.baseColorFactor)){const d=h.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],Kn),o.opacity=d[3]}h.baseColorTexture!==void 0&&c.push(t.assignTexture(o,"map",h.baseColorTexture,an)),o.metalness=h.metallicFactor!==void 0?h.metallicFactor:1,o.roughness=h.roughnessFactor!==void 0?h.roughnessFactor:1,h.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(o,"metalnessMap",h.metallicRoughnessTexture)),c.push(t.assignTexture(o,"roughnessMap",h.metallicRoughnessTexture))),a=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}r.doubleSided===!0&&(o.side=Pi);const u=r.alphaMode||k0.OPAQUE;if(u===k0.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,u===k0.MASK&&(o.alphaTest=r.alphaCutoff!==void 0?r.alphaCutoff:.5)),r.normalTexture!==void 0&&a!==ya&&(c.push(t.assignTexture(o,"normalMap",r.normalTexture)),o.normalScale=new Rt(1,1),r.normalTexture.scale!==void 0)){const h=r.normalTexture.scale;o.normalScale.set(h,h)}if(r.occlusionTexture!==void 0&&a!==ya&&(c.push(t.assignTexture(o,"aoMap",r.occlusionTexture)),r.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=r.occlusionTexture.strength)),r.emissiveFactor!==void 0&&a!==ya){const h=r.emissiveFactor;o.emissive=new lt().setRGB(h[0],h[1],h[2],Kn)}return r.emissiveTexture!==void 0&&a!==ya&&c.push(t.assignTexture(o,"emissiveMap",r.emissiveTexture,an)),Promise.all(c).then(function(){const h=new a(o);return r.name&&(h.name=r.name),ma(h,r),t.associations.set(h,{materials:e}),r.extensions&&oo(i,h,r),h})}createUniqueName(e){const t=Ot.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,i=this.primitiveCache;function r(o){return s[Ct.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(l){return a2(l,o,t)})}const a=[];for(let o=0,l=e.length;o<l;o++){const c=e[o],u=oye(c),h=i[u];if(h)a.push(h.promise);else{let d;c.extensions&&c.extensions[Ct.KHR_DRACO_MESH_COMPRESSION]?d=r(c):d=a2(new br,c,t),i[u]={primitive:c,promise:d},a.push(d)}}return Promise.all(a)}loadMesh(e){const t=this,s=this.json,i=this.extensions,r=s.meshes[e],a=r.primitives,o=[];for(let l=0,c=a.length;l<c;l++){const u=a[l].material===void 0?iye(this.cache):this.getDependency("material",a[l].material);o.push(u)}return o.push(t.loadGeometries(a)),Promise.all(o).then(function(l){const c=l.slice(0,l.length-1),u=l[l.length-1],h=[];for(let p=0,f=u.length;p<f;p++){const y=u[p],m=a[p];let g;const b=c[p];if(m.mode===pi.TRIANGLES||m.mode===pi.TRIANGLE_STRIP||m.mode===pi.TRIANGLE_FAN||m.mode===void 0)g=r.isSkinnedMesh===!0?new hz(y,b):new bi(y,b),g.isSkinnedMesh===!0&&g.normalizeSkinWeights(),m.mode===pi.TRIANGLE_STRIP?g.geometry=n2(g.geometry,b2):m.mode===pi.TRIANGLE_FAN&&(g.geometry=n2(g.geometry,D0));else if(m.mode===pi.LINES)g=new mz(y,b);else if(m.mode===pi.LINE_STRIP)g=new e1(y,b);else if(m.mode===pi.LINE_LOOP)g=new gz(y,b);else if(m.mode===pi.POINTS)g=new yz(y,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(g.geometry.morphAttributes).length>0&&aye(g,r),g.name=t.createUniqueName(r.name||"mesh_"+e),ma(g,r),m.extensions&&oo(i,g,m),t.assignFinalMaterial(g),h.push(g)}for(let p=0,f=h.length;p<f;p++)t.associations.set(h[p],{meshes:e,primitives:p});if(h.length===1)return r.extensions&&oo(i,h[0],r),h[0];const d=new Or;r.extensions&&oo(i,d,r),t.associations.set(d,{meshes:e});for(let p=0,f=h.length;p<f;p++)d.add(h[p]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],i=s[s.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new Ts(tP.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):s.type==="orthographic"&&(t=new jx(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),ma(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let i=0,r=t.joints.length;i<r;i++)s.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(i){const r=i.pop(),a=i,o=[],l=[];for(let c=0,u=a.length;c<u;c++){const h=a[c];if(h){o.push(h);const d=new ot;r!==null&&d.fromArray(r.array,c*16),l.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new qx(o,l)})}loadAnimation(e){const t=this.json,s=this,i=t.animations[e],r=i.name?i.name:"animation_"+e,a=[],o=[],l=[],c=[],u=[];for(let h=0,d=i.channels.length;h<d;h++){const p=i.channels[h],f=i.samplers[p.sampler],y=p.target,m=y.node,g=i.parameters!==void 0?i.parameters[f.input]:f.input,b=i.parameters!==void 0?i.parameters[f.output]:f.output;y.node!==void 0&&(a.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",g)),l.push(this.getDependency("accessor",b)),c.push(f),u.push(y))}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(l),Promise.all(c),Promise.all(u)]).then(function(h){const d=h[0],p=h[1],f=h[2],y=h[3],m=h[4],g=[];for(let b=0,x=d.length;b<x;b++){const v=d[b],w=p[b],_=f[b],I=y[b],C=m[b];if(v===void 0)continue;v.updateMatrix&&v.updateMatrix();const S=s._createAnimationTracks(v,w,_,I,C);if(S)for(let M=0;M<S.length;M++)g.push(S[M])}return new U0(r,void 0,g)})}createNodeMesh(e){const t=this.json,s=this,i=t.nodes[e];return i.mesh===void 0?null:s.getDependency("mesh",i.mesh).then(function(r){const a=s._getNodeRef(s.meshCache,i.mesh,r);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let l=0,c=i.weights.length;l<c;l++)o.morphTargetInfluences[l]=i.weights[l]}),a})}loadNode(e){const t=this.json,s=this,i=t.nodes[e],r=s._loadNodeShallow(e),a=[],o=i.children||[];for(let c=0,u=o.length;c<u;c++)a.push(s.getDependency("node",o[c]));const l=i.skin===void 0?Promise.resolve(null):s.getDependency("skin",i.skin);return Promise.all([r,Promise.all(a),l]).then(function(c){const u=c[0],h=c[1],d=c[2];d!==null&&u.traverse(function(p){p.isSkinnedMesh&&p.bind(d,cye)});for(let p=0,f=h.length;p<f;p++)u.add(h[p]);return u})}_loadNodeShallow(e){const t=this.json,s=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const r=t.nodes[e],a=r.name?i.createUniqueName(r.name):"",o=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&o.push(l),r.camera!==void 0&&o.push(i.getDependency("camera",r.camera).then(function(c){return i._getNodeRef(i.cameraCache,r.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){o.push(c)}),this.nodeCache[e]=Promise.all(o).then(function(c){let u;if(r.isBone===!0?u=new z2:c.length>1?u=new Or:c.length===1?u=c[0]:u=new nn,u!==c[0])for(let h=0,d=c.length;h<d;h++)u.add(c[h]);if(r.name&&(u.userData.name=r.name,u.name=a),ma(u,r),r.extensions&&oo(s,u,r),r.matrix!==void 0){const h=new ot;h.fromArray(r.matrix),u.applyMatrix4(h)}else r.translation!==void 0&&u.position.fromArray(r.translation),r.rotation!==void 0&&u.quaternion.fromArray(r.rotation),r.scale!==void 0&&u.scale.fromArray(r.scale);return i.associations.has(u)||i.associations.set(u,{}),i.associations.get(u).nodes=e,u}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],i=this,r=new Or;s.name&&(r.name=i.createUniqueName(s.name)),ma(r,s),s.extensions&&oo(t,r,s);const a=s.nodes||[],o=[];for(let l=0,c=a.length;l<c;l++)o.push(i.getDependency("node",a[l]));return Promise.all(o).then(function(l){for(let u=0,h=l.length;u<h;u++)r.add(l[u]);const c=u=>{const h=new Map;for(const[d,p]of i.associations)(d instanceof lr||d instanceof is)&&h.set(d,p);return u.traverse(d=>{const p=i.associations.get(d);p!=null&&h.set(d,p)}),h};return i.associations=c(r),r})}_createAnimationTracks(e,t,s,i,r){const a=[],o=e.name?e.name:e.uuid,l=[];ha[r.path]===ha.weights?e.traverse(function(d){d.morphTargetInfluences&&l.push(d.name?d.name:d.uuid)}):l.push(o);let c;switch(ha[r.path]){case ha.weights:c=tc;break;case ha.rotation:c=Ro;break;case ha.position:case ha.scale:c=nc;break;default:switch(s.itemSize){case 1:c=tc;break;case 2:case 3:default:c=nc;break}break}const u=i.interpolation!==void 0?sye[i.interpolation]:Jl,h=this._getArrayFromAccessor(s);for(let d=0,p=l.length;d<p;d++){const f=new c(l[d]+"."+ha[r.path],t.array,h,u);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(f),a.push(f)}return a}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=Wx(t.constructor),i=new Float32Array(t.length);for(let r=0,a=t.length;r<a;r++)i[r]=t[r]*s;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const i=this instanceof Ro?nye:ML;return new i(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function hye(n,e,t){const s=e.attributes,i=new jr;if(s.POSITION!==void 0){const o=t.json.accessors[s.POSITION],l=o.min,c=o.max;if(l!==void 0&&c!==void 0){if(i.set(new J(l[0],l[1],l[2]),new J(c[0],c[1],c[2])),o.normalized){const u=Wx(Hl[o.componentType]);i.min.multiplyScalar(u),i.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const r=e.targets;if(r!==void 0){const o=new J,l=new J;for(let c=0,u=r.length;c<u;c++){const h=r[c];if(h.POSITION!==void 0){const d=t.json.accessors[h.POSITION],p=d.min,f=d.max;if(p!==void 0&&f!==void 0){if(l.setX(Math.max(Math.abs(p[0]),Math.abs(f[0]))),l.setY(Math.max(Math.abs(p[1]),Math.abs(f[1]))),l.setZ(Math.max(Math.abs(p[2]),Math.abs(f[2]))),d.normalized){const y=Wx(Hl[d.componentType]);l.multiplyScalar(y)}o.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}n.boundingBox=i;const a=new yr;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,n.boundingSphere=a}function a2(n,e,t){const s=e.attributes,i=[];function r(a,o){return t.getDependency("accessor",a).then(function(l){n.setAttribute(o,l)})}for(const a in s){const o=Vx[a]||a.toLowerCase();o in n.attributes||i.push(r(s[a],o))}if(e.indices!==void 0&&!n.index){const a=t.getDependency("accessor",e.indices).then(function(o){n.setIndex(o)});i.push(a)}return Pt.workingColorSpace!==Kn&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Pt.workingColorSpace}" not supported.`),ma(n,e),hye(n,e,t),Promise.all(i).then(function(){return e.targets!==void 0?rye(n,e.targets,t):n})}class dye extends Ez{constructor(e){super(e),this.type=Dr}parse(e){const a=function(C,S){switch(C){case 1:throw new Error("THREE.RGBELoader: Read Error: "+(S||""));case 2:throw new Error("THREE.RGBELoader: Write Error: "+(S||""));case 3:throw new Error("THREE.RGBELoader: Bad File Format: "+(S||""));default:case 4:throw new Error("THREE.RGBELoader: Memory Error: "+(S||""))}},u=`
`,h=function(C,S,M){S=S||1024;let D=C.pos,F=-1,k=0,P="",O=String.fromCharCode.apply(null,new Uint16Array(C.subarray(D,D+128)));for(;0>(F=O.indexOf(u))&&k<S&&D<C.byteLength;)P+=O,k+=O.length,D+=128,O+=String.fromCharCode.apply(null,new Uint16Array(C.subarray(D,D+128)));return-1<F?(M!==!1&&(C.pos+=k+F+1),P+O.slice(0,F)):!1},d=function(C){const S=/^#\?(\S+)/,M=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,A=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,D=/^\s*FORMAT=(\S+)\s*$/,F=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,k={valid:0,string:"",comments:"",programtype:"RGBE",format:"",gamma:1,exposure:1,width:0,height:0};let P,O;for((C.pos>=C.byteLength||!(P=h(C)))&&a(1,"no header found"),(O=P.match(S))||a(3,"bad initial token"),k.valid|=1,k.programtype=O[1],k.string+=P+`
`;P=h(C),P!==!1;){if(k.string+=P+`
`,P.charAt(0)==="#"){k.comments+=P+`
`;continue}if((O=P.match(M))&&(k.gamma=parseFloat(O[1])),(O=P.match(A))&&(k.exposure=parseFloat(O[1])),(O=P.match(D))&&(k.valid|=2,k.format=O[1]),(O=P.match(F))&&(k.valid|=4,k.height=parseInt(O[1],10),k.width=parseInt(O[2],10)),k.valid&2&&k.valid&4)break}return k.valid&2||a(3,"missing format specifier"),k.valid&4||a(3,"missing image size specifier"),k},p=function(C,S,M){const A=S;if(A<8||A>32767||C[0]!==2||C[1]!==2||C[2]&128)return new Uint8Array(C);A!==(C[2]<<8|C[3])&&a(3,"wrong scanline width");const D=new Uint8Array(4*S*M);D.length||a(4,"unable to allocate buffer space");let F=0,k=0;const P=4*A,O=new Uint8Array(4),V=new Uint8Array(P);let $=M;for(;$>0&&k<C.byteLength;){k+4>C.byteLength&&a(1),O[0]=C[k++],O[1]=C[k++],O[2]=C[k++],O[3]=C[k++],(O[0]!=2||O[1]!=2||(O[2]<<8|O[3])!=A)&&a(3,"bad rgbe scanline format");let H=0,Y;for(;H<P&&k<C.byteLength;){Y=C[k++];const B=Y>128;if(B&&(Y-=128),(Y===0||H+Y>P)&&a(3,"bad scanline data"),B){const te=C[k++];for(let se=0;se<Y;se++)V[H++]=te}else V.set(C.subarray(k,k+Y),H),H+=Y,k+=Y}const G=A;for(let B=0;B<G;B++){let te=0;D[F]=V[B+te],te+=A,D[F+1]=V[B+te],te+=A,D[F+2]=V[B+te],te+=A,D[F+3]=V[B+te],F+=4}$--}return D},f=function(C,S,M,A){const D=C[S+3],F=Math.pow(2,D-128)/255;M[A+0]=C[S+0]*F,M[A+1]=C[S+1]*F,M[A+2]=C[S+2]*F,M[A+3]=1},y=function(C,S,M,A){const D=C[S+3],F=Math.pow(2,D-128)/255;M[A+0]=Bp.toHalfFloat(Math.min(C[S+0]*F,65504)),M[A+1]=Bp.toHalfFloat(Math.min(C[S+1]*F,65504)),M[A+2]=Bp.toHalfFloat(Math.min(C[S+2]*F,65504)),M[A+3]=Bp.toHalfFloat(1)},m=new Uint8Array(e);m.pos=0;const g=d(m),b=g.width,x=g.height,v=p(m.subarray(m.pos),b,x);let w,_,I;switch(this.type){case yi:I=v.length/4;const C=new Float32Array(I*4);for(let M=0;M<I;M++)f(v,M*4,C,M*4);w=C,_=yi;break;case Dr:I=v.length/4;const S=new Uint16Array(I*4);for(let M=0;M<I;M++)y(v,M*4,S,M*4);w=S,_=Dr;break;default:throw new Error("THREE.RGBELoader: Unsupported type: "+this.type)}return{width:b,height:x,data:w,header:g.string,gamma:g.gamma,exposure:g.exposure,type:_}}setDataType(e){return this.type=e,this}load(e,t,s,i){function r(a,o){switch(a.type){case yi:case Dr:a.colorSpace=Kn,a.minFilter=An,a.magFilter=An,a.generateMipmaps=!1,a.flipY=!0;break}t&&t(a,o)}return super.load(e,r,s,i)}}var vh=function(){var n=0,e=document.createElement("div");e.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",e.addEventListener("click",function(u){u.preventDefault(),s(++n%e.children.length)},!1);function t(u){return e.appendChild(u.dom),u}function s(u){for(var h=0;h<e.children.length;h++)e.children[h].style.display=h===u?"block":"none";n=u}var i=(performance||Date).now(),r=i,a=0,o=t(new vh.Panel("FPS","#0ff","#002")),l=t(new vh.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var c=t(new vh.Panel("MB","#f08","#201"));return s(0),{REVISION:16,dom:e,addPanel:t,showPanel:s,begin:function(){i=(performance||Date).now()},end:function(){a++;var u=(performance||Date).now();if(l.update(u-i,200),u>=r+1e3&&(o.update(a*1e3/(u-r),100),r=u,a=0,c)){var h=performance.memory;c.update(h.usedJSHeapSize/1048576,h.jsHeapSizeLimit/1048576)}return u},update:function(){i=this.end()},domElement:e,setMode:s}};vh.Panel=function(n,e,t){var s=1/0,i=0,r=Math.round,a=r(window.devicePixelRatio||1),o=80*a,l=48*a,c=3*a,u=2*a,h=3*a,d=15*a,p=74*a,f=30*a,y=document.createElement("canvas");y.width=o,y.height=l,y.style.cssText="width:80px;height:48px";var m=y.getContext("2d");return m.font="bold "+9*a+"px Helvetica,Arial,sans-serif",m.textBaseline="top",m.fillStyle=t,m.fillRect(0,0,o,l),m.fillStyle=e,m.fillText(n,c,u),m.fillRect(h,d,p,f),m.fillStyle=t,m.globalAlpha=.9,m.fillRect(h,d,p,f),{dom:y,update:function(g,b){s=Math.min(s,g),i=Math.max(i,g),m.fillStyle=t,m.globalAlpha=1,m.fillRect(0,0,o,d),m.fillStyle=e,m.fillText(r(g)+" "+n+" ("+r(s)+"-"+r(i)+")",c,u),m.drawImage(y,h+a,d,p-a,f,h,d,p-a,f),m.fillRect(h+p-a,d,a,f),m.fillStyle=t,m.globalAlpha=.9,m.fillRect(h+p-a,d,a,r((1-g/b)*f))}}};const pye=vh,CL=new pye;document.body.appendChild(CL.dom);var fye=".",Xu=fye,mye=document.getElementById("loadingtext"),gye=document.getElementById("loader"),yye=document.getElementById("startexperience"),bye=document.getElementById("loadingbar");const xye=document.querySelector("#startButton"),ja=new H2;ja.onStart=function(n,e,t){};ja.onLoad=function(){gye.style.display="none",yye.style.opacity="1"};ja.onProgress=function(n,e,t){mye.innerHTML="Gearing up for your AR adventure! <br> We're fetching the ingredients "+Math.floor(e/t*100)+"%",bye.style.width=Math.floor(e/t*100)+"%"};ja.onError=function(n){console.log("There was an error loading "+n)};const cT=new _L({container:document.querySelector("#container"),imageTargetSrc:Xu+"/roadtrip.mind",filterMinCF:.001,filterBeta:.001});Pt.enabled=!0;const vye=new K2(ja),wye=new Lge(ja),Sye=new Y2,{renderer:Ux,scene:EL,camera:kL}=cT,NL=cT.addAnchor(0);Ux.outputColorSpace=an;var RL;const uT=new Gz;kL.add(uT);const Kl=new j2(uT),Zl=new j2(uT),AL=new Fz(ja);AL.load(Xu+"/gltf/roadtrip/audio/birds-chirp-ambiance.m4a",function(n){Kl.setBuffer(n),Kl.setLoop(!0),Kl.setVolume(1)});AL.load(Xu+"/gltf/roadtrip/audio/FUXB9SL-car-driving-ambience-1_R.m4a",function(n){Zl.setBuffer(n),Zl.setLoop(!0),Zl.setVolume(.1)});new dye(ja).setPath("/").load(Xu+"/photo_studio_loft_hall_1k.hdr",function(n){n.mapping=Of,EL.environment=n,RL=n});var hT=vye.load(Xu+"/gltf/roadtrip/textures/parava_fly.png");hT.colorSpace=an;new Iye(hT,6,3,9);const Tye=new ya({color:255,colorWrite:!1});let lo,Mm;wye.load(Xu+"/gltf/roadtrip/RoadTrip.gltf",function(n){lo=n.scene,lo.traverse(t=>{t.isMesh&&(t.material.envMap=RL,t.material.depthWrite=!1,t.material.side=Pi,t.material.name==="skyMat"&&(t.renderOrder=21),t.material.name==="paravaMat"&&(t.material.map=hT,t.renderOrder=1),t.material.name==="hill_1_Mat"&&(t.renderOrder=2),t.material.name==="hill_2_Mat"&&(t.renderOrder=3),t.material.name==="vegitation_last_Mat"&&(t.renderOrder=4),t.material.name==="electric_post_mat"&&(t.renderOrder=5),t.material.name==="vegitation_front_mat"&&(t.renderOrder=6),t.material.name==="houses_Mat"&&(t.renderOrder=7),t.material.name==="roadside_vegetation_bg_mat"&&(t.renderOrder=8),t.material.name==="road_sign_mat"&&(t.renderOrder=9),t.material.name==="backTireMat"&&(t.renderOrder=10),t.material.name==="carBodyMat"&&(t.renderOrder=11),t.material.name==="tireMat"&&(t.renderOrder=12),t.material.name==="roadside_vegetation_mat"&&(t.renderOrder=13),t.material.name==="treeMat"&&(t.renderOrder=14),t.material.name==="maskMat"&&(t.material=Tye,t.renderOrder=20),t.material.needsUpdate=!0)}),Mm=new Qz(lo),n.animations.forEach(t=>{const s=Mm.clipAction(t);s.reset(),s.timeScale=1.5,s.setLoop(y2),s.play()});var e=.55;lo.scale.set(e,e,e),lo.rotation.setFromVector3(new J(Math.PI/2,0,0)),lo.castShadow=!0,NL.group.add(lo)},function(n){},function(n){console.log("An error happened"+n)});const _ye=async()=>{document.querySelector("#control").style.display="none",await cT.start(),Ux.setAnimationLoop(()=>{CL.update(),NL.visible?(Mm&&Mm.update(Sye.getDelta()),Kl.isPlaying||Kl.play(),Zl.isPlaying||Zl.play()):(Kl.pause(),Zl.pause()),Ux.render(EL,kL)})};xye.addEventListener("click",()=>{_ye()});function Iye(n,e,t,s){let i={};return i.texture=n,i.tilesHorizontal=e,i.tilesVertical=t,i.tileDisplayDuration=s,i.numberOfTiles=e*t,i.texture.wrapS=Na,i.texture.wrapT=Na,i.texture.repeat.set(1/e,1/t),i.currentTile=0,i.nextFrame=function(){i.currentTile++,i.currentTile==i.numberOfTiles&&(i.currentTile=0);let r=i.currentTile%i.tilesHorizontal;i.texture.offset.x=r/i.tilesHorizontal;let a=Math.floor(i.currentTile/i.tilesHorizontal);i.texture.offset.y=i.tilesVertical-a/i.tilesVertical},i.start=function(){i.intervalID=setInterval(i.nextFrame,i.tileDisplayDuration)},i.stop=function(){clearInterval(i.intervalID)},i.start(),i}
